{
  "image": "vulhub/couchdb:3.2.1",
  "total_vulnerabilities": 2007,
  "scanners_used": [
    "trivy",
    "grype"
  ],
  "vulnerabilities": [
    {
      "cve_id": "CVE-2022-3715",
      "package_name": "bash",
      "installed_version": "5.1-2+deb11u1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bash: a heap-buffer-overflow in valid_parameter_transform",
      "description": "A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1304",
      "package_name": "e2fsprogs",
      "installed_version": "1.46.2-2",
      "fixed_version": "1.46.2-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "e2fsprogs: out-of-bounds read/write via crafted filesystem",
      "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-37026",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang/otp: Client Authentication Bypass",
      "description": "In Erlang/OTP before 23.3.4.15, 24.x before 24.3.4.2, and 25.x before 25.0.2, there is a Client Authentication Bypass in certain client-certification situations for SSL, TLS, and DTLS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30211",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "erlang: KEX init error results with excessive memory usage",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.1, 26.2.5.10, and 25.3.2.19, a maliciously formed KEX init message can result with high memory usage. Implementation does not verify RFC specified limits on algorithm names (64 characters) provided in KEX init message. Big KEX init packet may lead to inefficient processing of the error data. As a result, large amount of memory will be allocated for processing malicious data. Versions OTP-27.3.1, OTP-26.2.5.10, and OTP-25.3.2.19 fix the issue. Some workarounds are available. One may set option `parallel_login` to `false` and/or reduce the `max_sessions` option.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32433",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Erlang/OTP is a set of libraries for the Erlang programming language.  ...",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting a flaw in SSH protocol message handling, a malicious actor could gain unauthorized access to affected systems and execute arbitrary commands without valid credentials. This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20. A temporary workaround involves disabling the SSH server or to prevent access via firewall rules.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-6655",
      "package_name": "gtk-update-icon-cache",
      "installed_version": "3.24.24-4+deb11u2",
      "fixed_version": "3.24.24-4+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gtk3: gtk2: Library injection from CWD",
      "description": "A flaw was found in the GTK library. Under certain conditions, it is possible for a library to be injected into a GTK application from the current working directory.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-5222",
      "package_name": "icu-devtools",
      "installed_version": "67.1-7",
      "fixed_version": "67.1-7+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "icu: Stack buffer overflow in the SRBRoot::addTag function",
      "description": "A stack buffer overflow was found in Internationl components for unicode (ICU ). While running the genrb binary, the 'subtag' struct overflowed at the SRBRoot::addTag function. This issue may lead to memory corruption and local arbitrary code execution.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4911",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: buffer overflow in ld.so leading to privilege escalation",
      "description": "A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2961",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u9",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: Out of bounds write in iconv may lead to remote code execution",
      "description": "The iconv() function in the GNU C Library versions 2.39 and older may overflow the output buffer passed to it by up to 4 bytes when converting strings to the ISO-2022-CN-EXT character set, which may be used to crash an application or overwrite a neighbouring variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33599",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: stack-based buffer overflow in netgroup cache",
      "description": "nscd: Stack-based buffer overflow in netgroup cache\n\nIf the Name Service Cache Daemon's (nscd) fixed size cache is exhausted\nby client requests then a subsequent client request for netgroup data\nmay result in a stack-based buffer overflow.  This flaw was introduced\nin glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4802",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u13",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: static setuid binary dlopen may incorrectly search LD_LIBRARY_PATH",
      "description": "Untrusted LD_LIBRARY_PATH environment variable vulnerability in the GNU C Library version 2.27 to 2.38 allows attacker controlled loading of dynamically shared library in statically compiled setuid binaries that call dlopen (including internal dlopen calls after setlocale or calls to NSS functions such as getaddrinfo).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4911",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: buffer overflow in ld.so leading to privilege escalation",
      "description": "A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2961",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u9",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: Out of bounds write in iconv may lead to remote code execution",
      "description": "The iconv() function in the GNU C Library versions 2.39 and older may overflow the output buffer passed to it by up to 4 bytes when converting strings to the ISO-2022-CN-EXT character set, which may be used to crash an application or overwrite a neighbouring variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33599",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: stack-based buffer overflow in netgroup cache",
      "description": "nscd: Stack-based buffer overflow in netgroup cache\n\nIf the Name Service Cache Daemon's (nscd) fixed size cache is exhausted\nby client requests then a subsequent client request for netgroup data\nmay result in a stack-based buffer overflow.  This flaw was introduced\nin glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4802",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u13",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: static setuid binary dlopen may incorrectly search LD_LIBRARY_PATH",
      "description": "Untrusted LD_LIBRARY_PATH environment variable vulnerability in the GNU C Library version 2.27 to 2.38 allows attacker controlled loading of dynamically shared library in statically compiled setuid binaries that call dlopen (including internal dlopen calls after setlocale or calls to NSS functions such as getaddrinfo).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4911",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: buffer overflow in ld.so leading to privilege escalation",
      "description": "A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2961",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u9",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: Out of bounds write in iconv may lead to remote code execution",
      "description": "The iconv() function in the GNU C Library versions 2.39 and older may overflow the output buffer passed to it by up to 4 bytes when converting strings to the ISO-2022-CN-EXT character set, which may be used to crash an application or overwrite a neighbouring variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33599",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: stack-based buffer overflow in netgroup cache",
      "description": "nscd: Stack-based buffer overflow in netgroup cache\n\nIf the Name Service Cache Daemon's (nscd) fixed size cache is exhausted\nby client requests then a subsequent client request for netgroup data\nmay result in a stack-based buffer overflow.  This flaw was introduced\nin glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4802",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u13",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: static setuid binary dlopen may incorrectly search LD_LIBRARY_PATH",
      "description": "Untrusted LD_LIBRARY_PATH environment variable vulnerability in the GNU C Library version 2.27 to 2.38 allows attacker controlled loading of dynamically shared library in statically compiled setuid binaries that call dlopen (including internal dlopen calls after setlocale or calls to NSS functions such as getaddrinfo).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4911",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: buffer overflow in ld.so leading to privilege escalation",
      "description": "A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2961",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u9",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: Out of bounds write in iconv may lead to remote code execution",
      "description": "The iconv() function in the GNU C Library versions 2.39 and older may overflow the output buffer passed to it by up to 4 bytes when converting strings to the ISO-2022-CN-EXT character set, which may be used to crash an application or overwrite a neighbouring variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33599",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: stack-based buffer overflow in netgroup cache",
      "description": "nscd: Stack-based buffer overflow in netgroup cache\n\nIf the Name Service Cache Daemon's (nscd) fixed size cache is exhausted\nby client requests then a subsequent client request for netgroup data\nmay result in a stack-based buffer overflow.  This flaw was introduced\nin glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4802",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u13",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glibc: static setuid binary dlopen may incorrectly search LD_LIBRARY_PATH",
      "description": "Untrusted LD_LIBRARY_PATH environment variable vulnerability in the GNU C Library version 2.27 to 2.38 allows attacker controlled loading of dynamically shared library in statically compiled setuid binaries that call dlopen (including internal dlopen calls after setlocale or calls to NSS functions such as getaddrinfo).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-2603",
      "package_name": "libcap2",
      "installed_version": "1:2.44-1",
      "fixed_version": "1:2.44-1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libcap: Integer Overflow in _libcap_strdup()",
      "description": "A vulnerability was found in libcap. This issue occurs in the _libcap_strdup() function and can lead to an integer overflow if the input string is close to 4GiB.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1304",
      "package_name": "libcom-err2",
      "installed_version": "1.46.2-2",
      "fixed_version": "1.46.2-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "e2fsprogs: out-of-bounds read/write via crafted filesystem",
      "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-47175",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u9",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "cups: libppd: remote command injection via attacker controlled data in PPD file",
      "description": "CUPS is a standards-based, open-source printing system, and `libppd` can be used for legacy PPD file support. The `libppd` function `ppdCreatePPDFromIPP2` does not sanitize IPP attributes when creating the PPD buffer. When used in combination with other functions such as `cfGetPrinterAttributes5`, can result in user controlled input and ultimately code execution via Foomatic. This vulnerability can be part of an exploit chain leading to remote code execution (RCE), as described in CVE-2024-47176.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-34241",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "cups: use-after-free in cupsdAcceptClient() in scheduler/client.c",
      "description": "OpenPrinting CUPS is a standards-based, open source printing system for Linux and other Unix-like operating systems. Starting in version 2.0.0 and prior to version 2.4.6, CUPS logs data of free memory to the logging service AFTER the connection has been closed, when it should have logged the data right before. This is a use-after-free bug that impacts the entire cupsd process.\n\nThe exact cause of this issue is the function `httpClose(con->http)` being called in `scheduler/client.c`. The problem is that httpClose always, provided its argument is not null, frees the pointer at the end of the call, only for cupsdLogClient to pass the pointer to httpGetHostname. This issue happens in function `cupsdAcceptClient` if LogLevel is warn or higher and in two scenarios: there is a double-lookup for the IP Address (HostNameLookups Double is set in `cupsd.conf`) which fails to resolve, or if CUPS is compiled with TCP wrappers and the connection is refused by rules from `/etc/hosts.allow` and `/etc/hosts.deny`.\n\nVersion 2.4.6 has a patch for this issue.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4504",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libppd: Postscript Parsing Heap Overflow",
      "description": "Due to failure in validating the length provided by an attacker-crafted PPD PostScript document, CUPS and libppd are susceptible to a heap-based buffer overflow and possibly code execution. This issue has been fixed in CUPS version 2.4.7, released in September of 2023.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-58060",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "cups: Authentication Bypass in CUPS Authorization Handling",
      "description": "OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. In versions 2.4.12 and earlier, when the `AuthType` is set to anything but `Basic`, if the request contains an `Authorization: Basic ...` header, the password is not checked. This results in authentication bypass. Any configuration that allows an `AuthType` that is not `Basic` is affected. Version 2.4.13 fixes the issue.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-32221",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: POST following PUT confusion",
      "description": "When doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously was used to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the subsequent `POST` request. The problem exists in the logic for a reused handle when it is changed from a PUT to a POST.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-23914",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HSTS ignored on multiple requests",
      "description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38545",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u10",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: heap based buffer overflow in the SOCKS5 proxy handshake",
      "description": "This flaw makes curl overflow a heap based buffer in the SOCKS5 proxy\nhandshake.\n\nWhen curl is asked to pass along the host name to the SOCKS5 proxy to allow\nthat to resolve the address instead of it getting done by curl itself, the\nmaximum length that host name can be is 255 bytes.\n\nIf the host name is detected to be longer, curl switches to local name\nresolving and instead passes on the resolved address only. Due to this bug,\nthe local variable that means \"let the host resolve the name\" could get the\nwrong value during a slow SOCKS5 handshake, and contrary to the intention,\ncopy the too long host name to the target buffer instead of copying just the\nresolved address there.\n\nThe target buffer being a heap based buffer, and the host name coming from the\nURL that curl has been told to operate with.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-42916",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HSTS bypass via IDN",
      "description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-43551",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HSTS bypass via IDN",
      "description": "A vulnerability exists in curl <7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27533",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: TELNET option IAC injection",
      "description": "A vulnerability in input validation exists in curl <8.0 during communication using the TELNET protocol may allow an attacker to pass on maliciously crafted user name and \"telnet options\" during server negotiation. The lack of proper input scrubbing allows an attacker to send content or perform option negotiation without the application's intent. This vulnerability could be exploited if an application allows user input, thereby enabling attackers to execute arbitrary code on the system.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27534",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: SFTP path ~ resolving discrepancy",
      "description": "A path traversal vulnerability exists in curl <8.0.0 SFTP implementation causes the tilde (~) character to be wrongly replaced when used as a prefix in the first path element, in addition to its intended use as the first element to indicate a path relative to the user's home directory. Attackers can exploit this flaw to bypass filtering or execute arbitrary code by crafting a path like /~2/foo while accessing a server with a specific user.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2398",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u12",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HTTP/2 push headers memory-leak",
      "description": "When an application tells libcurl it wants to allow HTTP/2 server push, and the amount of received headers for the push surpasses the maximum allowed limit (1000), libcurl aborts the server push. When aborting, libcurl inadvertently does not free all the previously allocated headers and instead leaks the memory.  Further, this error condition fails silently and is therefore not easily detected by an application.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-32221",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: POST following PUT confusion",
      "description": "When doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously was used to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the subsequent `POST` request. The problem exists in the logic for a reused handle when it is changed from a PUT to a POST.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-23914",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HSTS ignored on multiple requests",
      "description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38545",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u10",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: heap based buffer overflow in the SOCKS5 proxy handshake",
      "description": "This flaw makes curl overflow a heap based buffer in the SOCKS5 proxy\nhandshake.\n\nWhen curl is asked to pass along the host name to the SOCKS5 proxy to allow\nthat to resolve the address instead of it getting done by curl itself, the\nmaximum length that host name can be is 255 bytes.\n\nIf the host name is detected to be longer, curl switches to local name\nresolving and instead passes on the resolved address only. Due to this bug,\nthe local variable that means \"let the host resolve the name\" could get the\nwrong value during a slow SOCKS5 handshake, and contrary to the intention,\ncopy the too long host name to the target buffer instead of copying just the\nresolved address there.\n\nThe target buffer being a heap based buffer, and the host name coming from the\nURL that curl has been told to operate with.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-42916",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HSTS bypass via IDN",
      "description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-43551",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HSTS bypass via IDN",
      "description": "A vulnerability exists in curl <7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27533",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: TELNET option IAC injection",
      "description": "A vulnerability in input validation exists in curl <8.0 during communication using the TELNET protocol may allow an attacker to pass on maliciously crafted user name and \"telnet options\" during server negotiation. The lack of proper input scrubbing allows an attacker to send content or perform option negotiation without the application's intent. This vulnerability could be exploited if an application allows user input, thereby enabling attackers to execute arbitrary code on the system.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27534",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: SFTP path ~ resolving discrepancy",
      "description": "A path traversal vulnerability exists in curl <8.0.0 SFTP implementation causes the tilde (~) character to be wrongly replaced when used as a prefix in the first path element, in addition to its intended use as the first element to indicate a path relative to the user's home directory. Attackers can exploit this flaw to bypass filtering or execute arbitrary code by crafting a path like /~2/foo while accessing a server with a specific user.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2398",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u12",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "curl: HTTP/2 push headers memory-leak",
      "description": "When an application tells libcurl it wants to allow HTTP/2 server push, and the amount of received headers for the push surpasses the maximum allowed limit (1000), libcurl aborts the server push. When aborting, libcurl inadvertently does not free all the previously allocated headers and instead leaks the memory.  Further, this error condition fails silently and is therefore not easily detected by an application.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-8457",
      "package_name": "libdb5.3",
      "installed_version": "5.3.28+dfsg1-0.8",
      "fixed_version": "No fix available",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "sqlite: heap out-of-bound read in function rtreenode()",
      "description": "SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-45491",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "2.2.10-2+deb11u6",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libexpat: Integer Overflow or Wraparound",
      "description": "An issue was discovered in libexpat before 2.6.3. dtdCopy in xmlparse.c can have an integer overflow for nDefaultAtts on 32-bit platforms (where UINT_MAX equals SIZE_MAX).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-45492",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "2.2.10-2+deb11u6",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libexpat: integer overflow",
      "description": "An issue was discovered in libexpat before 2.6.3. nextScaffoldPart in xmlparse.c can have an integer overflow for m_groupSize on 32-bit platforms (where UINT_MAX equals SIZE_MAX).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-52425",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "2.2.10-2+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "expat: parsing large tokens can trigger a denial of service",
      "description": "libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-45490",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "2.2.10-2+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libexpat: Negative Length Parsing Vulnerability in libexpat",
      "description": "An issue was discovered in libexpat before 2.6.3. xmlparse.c does not reject a negative length for XML_ParseBuffer.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-8176",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libexpat: expat: Improper Restriction of XML Entity Expansion Depth in libexpat",
      "description": "A stack overflow vulnerability exists in the libexpat library due to the way it handles recursive entity expansion in XML documents. When parsing an XML document with deeply nested entity references, libexpat can be forced to recurse indefinitely, exhausting the stack space and causing a crash. This issue could lead to denial of service (DoS) or, in some cases, exploitable memory corruption, depending on the environment and library usage.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1304",
      "package_name": "libext2fs2",
      "installed_version": "1.46.2-2",
      "fixed_version": "1.46.2-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "e2fsprogs: out-of-bounds read/write via crafted filesystem",
      "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-27363",
      "package_name": "libfreetype6",
      "installed_version": "2.10.4+dfsg-1+deb11u1",
      "fixed_version": "2.10.4+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "freetype: OOB write when attempting to parse font subglyph structures related to TrueType GX and variable font files",
      "description": "An out of bounds write exists in FreeType versions 2.13.0 and below (newer versions of FreeType are not vulnerable) when attempting to parse font subglyph structures related to TrueType GX and variable font files. The vulnerable code assigns a signed short value to an unsigned long and then adds a static value causing it to wrap around and allocate too small of a heap buffer. The code then writes up to 6 signed long integers out of bounds relative to this buffer. This may result in arbitrary code execution. This vulnerability may have been exploited in the wild.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-33560",
      "package_name": "libgcrypt20",
      "installed_version": "1.8.7-6",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libgcrypt: mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm",
      "description": "Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm, and the window size is not chosen appropriately. This, for example, affects use of ElGamal in OpenPGP.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-48622",
      "package_name": "libgdk-pixbuf-2.0-0",
      "installed_version": "2.42.2+dfsg-1+deb11u1",
      "fixed_version": "2.42.2+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnome: heap memory corruption on gdk-pixbuf",
      "description": "In GNOME GdkPixbuf (aka gdk-pixbuf) through 2.42.10, the ANI (Windows animated cursor) decoder encounters heap memory corruption (in ani_load_chunk in io-ani.c) when parsing chunks in a crafted .ani file. A crafted file could allow an attacker to overwrite heap metadata, leading to a denial of service or code execution attack. This occurs in gdk_pixbuf_set_option() in gdk-pixbuf.c.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-7345",
      "package_name": "libgdk-pixbuf-2.0-0",
      "installed_version": "2.42.2+dfsg-1+deb11u1",
      "fixed_version": "2.42.2+dfsg-1+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gdk\u2011pixbuf: Heap\u2011buffer\u2011overflow in gdk\u2011pixbuf",
      "description": "A flaw exists in gdk\u2011pixbuf within the gdk_pixbuf__jpeg_image_load_increment function (io-jpeg.c) and in glib\u2019s g_base64_encode_step (glib/gbase64.c). When processing maliciously crafted JPEG images, a heap buffer overflow can occur during Base64 encoding, allowing out-of-bounds reads from heap memory, potentially causing application crashes or arbitrary code execution.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-48622",
      "package_name": "libgdk-pixbuf2.0-common",
      "installed_version": "2.42.2+dfsg-1+deb11u1",
      "fixed_version": "2.42.2+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnome: heap memory corruption on gdk-pixbuf",
      "description": "In GNOME GdkPixbuf (aka gdk-pixbuf) through 2.42.10, the ANI (Windows animated cursor) decoder encounters heap memory corruption (in ani_load_chunk in io-ani.c) when parsing chunks in a crafted .ani file. A crafted file could allow an attacker to overwrite heap metadata, leading to a denial of service or code execution attack. This occurs in gdk_pixbuf_set_option() in gdk-pixbuf.c.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-7345",
      "package_name": "libgdk-pixbuf2.0-common",
      "installed_version": "2.42.2+dfsg-1+deb11u1",
      "fixed_version": "2.42.2+dfsg-1+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gdk\u2011pixbuf: Heap\u2011buffer\u2011overflow in gdk\u2011pixbuf",
      "description": "A flaw exists in gdk\u2011pixbuf within the gdk_pixbuf__jpeg_image_load_increment function (io-jpeg.c) and in glib\u2019s g_base64_encode_step (glib/gbase64.c). When processing maliciously crafted JPEG images, a heap buffer overflow can occur during Base64 encoding, allowing out-of-bounds reads from heap memory, potentially causing application crashes or arbitrary code execution.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29499",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "2.66.8-1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glib: GVariant offset table entry size is not checked in is_normal()",
      "description": "A flaw was found in GLib. GVariant deserialization fails to validate that the input conforms to the expected format, leading to denial of service.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52533",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "2.66.8-1+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "glib: buffer overflow in set_connect_msg()",
      "description": "gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\\0' character.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0361",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnutls: timing side-channel in the TLS RSA key exchange code",
      "description": "A timing side-channel in the handling of RSA ClientKeyExchange messages was discovered in GnuTLS. This side-channel can be sufficient to recover the key encrypted in the RSA ciphertext across a network in a Bleichenbacher style attack. To achieve a successful decryption the attacker would need to send a large amount of specially crafted messages to the vulnerable server. By recovering the secret from the ClientKeyExchange message, the attacker would be able to decrypt the application data exchanged over that connection.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-0553",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnutls: incomplete fix for CVE-2023-5981",
      "description": "A vulnerability was found in GnuTLS. The response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from the response times of ciphertexts with correct PKCS#1 v1.5 padding. This issue may allow a remote attacker to perform a timing side-channel attack in the RSA-PSK key exchange, potentially leading to the leakage of sensitive data. CVE-2024-0553 is designated as an incomplete resolution for CVE-2023-5981.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-0567",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnutls: rejects certificate chain with distributed trust",
      "description": "A vulnerability was found in GnuTLS, where a cockpit (which uses gnuTLS) rejects a certificate chain with distributed trust. This issue occurs when validating a certificate chain with cockpit-certificate-ensure. This flaw allows an unauthenticated, remote client or attacker to initiate a denial of service attack.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32988",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnutls: Vulnerability in GnuTLS otherName SAN export",
      "description": "A flaw was found in GnuTLS. A double-free vulnerability exists in GnuTLS due to incorrect ownership handling in the export logic of Subject Alternative Name (SAN) entries containing an otherName. If the type-id OID is invalid or malformed, GnuTLS will call asn1_delete_structure() on an ASN.1 node it does not own, leading to a double-free condition when the parent function or caller later attempts to free the same structure.\n\nThis vulnerability can be triggered using only public GnuTLS APIs and may result in denial of service or memory corruption, depending on allocator behavior.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32990",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gnutls: Vulnerability in GnuTLS certtool template parsing",
      "description": "A heap-buffer-overflow (off-by-one) flaw was found in the GnuTLS software in the template parsing logic within the certtool utility. When it reads certain settings from a template file, it allows an attacker to cause an out-of-bounds (OOB) NULL pointer write, resulting in memory corruption and a denial-of-service (DoS) that could potentially crash the system.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37371",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can cause invalid memory reads during GSS message token handling by sending message tokens with invalid length fields.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-42898",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: integer overflow vulnerabilities in PAC parsing",
      "description": "PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37370",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can modify the plaintext Extra Count field of a confidential GSS krb5 wrap token, causing the unwrapped token to appear truncated to the application.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-6655",
      "package_name": "libgtk-3-0",
      "installed_version": "3.24.24-4+deb11u2",
      "fixed_version": "3.24.24-4+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gtk3: gtk2: Library injection from CWD",
      "description": "A flaw was found in the GTK library. Under certain conditions, it is possible for a library to be injected into a GTK application from the current working directory.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-6655",
      "package_name": "libgtk-3-common",
      "installed_version": "3.24.24-4+deb11u2",
      "fixed_version": "3.24.24-4+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "gtk3: gtk2: Library injection from CWD",
      "description": "A flaw was found in the GTK library. Under certain conditions, it is possible for a library to be injected into a GTK application from the current working directory.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-25193",
      "package_name": "libharfbuzz0b",
      "installed_version": "2.7.4-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "harfbuzz: allows attackers to trigger O(n^2) growth via consecutive marks",
      "description": "hb-ot-layout-gsubgpos.hh in HarfBuzz through 6.0.0 allows attackers to trigger O(n^2) growth via consecutive marks during the process of looking back for base glyphs when attaching marks.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-5222",
      "package_name": "libicu-dev",
      "installed_version": "67.1-7",
      "fixed_version": "67.1-7+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "icu: Stack buffer overflow in the SRBRoot::addTag function",
      "description": "A stack buffer overflow was found in Internationl components for unicode (ICU ). While running the genrb binary, the 'subtag' struct overflowed at the SRBRoot::addTag function. This issue may lead to memory corruption and local arbitrary code execution.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-5222",
      "package_name": "libicu67",
      "installed_version": "67.1-7",
      "fixed_version": "67.1-7+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "icu: Stack buffer overflow in the SRBRoot::addTag function",
      "description": "A stack buffer overflow was found in Internationl components for unicode (ICU ). While running the genrb binary, the 'subtag' struct overflowed at the SRBRoot::addTag function. This issue may lead to memory corruption and local arbitrary code execution.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-32292",
      "package_name": "libjson-c5",
      "installed_version": "0.15-2",
      "fixed_version": "0.15-2+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "json-c: stack-buffer-overflow in parseit() in json_parse.c",
      "description": "An issue was discovered in json-c from 20200420 (post 0.14 unreleased code) through 0.15-20200726. A stack-buffer-overflow exists in the auxiliary sample program json_parse which is located in the function parseit.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37371",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can cause invalid memory reads during GSS message token handling by sending message tokens with invalid length fields.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-42898",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: integer overflow vulnerabilities in PAC parsing",
      "description": "PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37370",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can modify the plaintext Extra Count field of a confidential GSS krb5 wrap token, causing the unwrapped token to appear truncated to the application.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37371",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can cause invalid memory reads during GSS message token handling by sending message tokens with invalid length fields.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-42898",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: integer overflow vulnerabilities in PAC parsing",
      "description": "PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37370",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can modify the plaintext Extra Count field of a confidential GSS krb5 wrap token, causing the unwrapped token to appear truncated to the application.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37371",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can cause invalid memory reads during GSS message token handling by sending message tokens with invalid length fields.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-42898",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: integer overflow vulnerabilities in PAC parsing",
      "description": "PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-37370",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "krb5: GSS message token handling",
      "description": "In MIT Kerberos 5 (aka krb5) before 1.21.3, an attacker can modify the plaintext Extra Count field of a confidential GSS krb5 wrap token, causing the unwrapped token to appear truncated to the application.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-2953",
      "package_name": "libldap-2.4-2",
      "installed_version": "2.4.57+dfsg-3+deb11u1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "openldap: null pointer dereference in  ber_memalloc_x  function",
      "description": "A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-29458",
      "package_name": "libncurses6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: segfaulting OOB read",
      "description": "ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29491",
      "package_name": "libncurses6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: Local users can trigger security-relevant memory corruption via malformed data",
      "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-29458",
      "package_name": "libncursesw6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: segfaulting OOB read",
      "description": "ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29491",
      "package_name": "libncursesw6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: Local users can trigger security-relevant memory corruption via malformed data",
      "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-44487",
      "package_name": "libnghttp2-14",
      "installed_version": "1.43.0-1",
      "fixed_version": "1.43.0-1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "HTTP/2: Multiple HTTP/2 enabled web servers are vulnerable to a DDoS attack (Rapid Reset Attack)",
      "description": "The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6020",
      "package_name": "libpam-modules",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "linux-pam: Linux-pam directory Traversal",
      "description": "A flaw was found in linux-pam. The module pam_namespace may use access user-controlled paths without proper protection, allowing local users to elevate their privileges to root via multiple symlink attacks and race conditions.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6020",
      "package_name": "libpam-modules-bin",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "linux-pam: Linux-pam directory Traversal",
      "description": "A flaw was found in linux-pam. The module pam_namespace may use access user-controlled paths without proper protection, allowing local users to elevate their privileges to root via multiple symlink attacks and race conditions.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6020",
      "package_name": "libpam-runtime",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "linux-pam: Linux-pam directory Traversal",
      "description": "A flaw was found in linux-pam. The module pam_namespace may use access user-controlled paths without proper protection, allowing local users to elevate their privileges to root via multiple symlink attacks and race conditions.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50387",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator",
      "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50868",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources",
      "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6020",
      "package_name": "libpam0g",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "linux-pam: Linux-pam directory Traversal",
      "description": "A flaw was found in linux-pam. The module pam_namespace may use access user-controlled paths without proper protection, allowing local users to elevate their privileges to root via multiple symlink attacks and race conditions.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52531",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: buffer overflow via UTF-8 conversion in soup_header_parse_param_list_strict",
      "description": "GNOME libsoup before 3.6.1 allows a buffer overflow in applications that perform conversion to UTF-8 in soup_header_parse_param_list_strict. There is a plausible way to reach this remotely via soup_message_headers_get_content_type (e.g., an application may want to retrieve the content type of a request or response).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32911",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Double free on  soup_message_headers_get_content_disposition() through  \"soup-message-headers.c\" via \"params\" GHashTable value",
      "description": "A use-after-free type vulnerability was found in libsoup, in the soup_message_headers_get_content_disposition() function. This flaw allows a malicious HTTP client to cause memory corruption in the libsoup server.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52530",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: HTTP request smuggling via stripping null bytes from the ends of header names",
      "description": "GNOME libsoup before 3.6.0 allows HTTP request smuggling in some configurations because '\\0' characters at the end of header names are ignored, i.e., a \"Transfer-Encoding\\0: chunked\" header is treated the same as a \"Transfer-Encoding: chunked\" header.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52532",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: infinite loop while reading websocket data",
      "description": "GNOME libsoup before 3.6.1 has an infinite loop, and memory consumption. during the reading of certain patterns of WebSocket data from clients.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32049",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Denial of Service attack to websocket server",
      "description": "A flaw was found in libsoup. The SoupWebsocketConnection may accept a large WebSocket message, which may cause libsoup to allocate memory and lead to a denial of service (DoS).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32906",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Out of bounds reads in soup_headers_parse_request()",
      "description": "A flaw was found in libsoup, where the soup_headers_parse_request() function may be vulnerable to an out-of-bound read. This flaw allows a malicious user to use a specially crafted HTTP request to crash the HTTP server.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32913",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: NULL pointer dereference in  soup_message_headers_get_content_disposition when \"filename\" parameter  is present, but has no value in Content-Disposition header",
      "description": "A flaw was found in libsoup, where the soup_message_headers_get_content_disposition() function is vulnerable to a NULL pointer dereference. This flaw allows a malicious HTTP peer to crash a libsoup client or server that uses this function.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32914",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: OOB Read on libsoup through function  \"soup_multipart_new_from_message\" in soup-multipart.c leads to crash or  exit of process",
      "description": "A flaw was found in libsoup, where the soup_multipart_new_from_message() function is vulnerable to an out-of-bounds read. This flaw allows a malicious HTTP client to induce the libsoup server to read out of bounds.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4948",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Integer Underflow in soup_multipart_new_from_message() Leading to Denial of Service in libsoup",
      "description": "A flaw was found in the soup_multipart_new_from_message() function of the libsoup HTTP library, which is commonly used by GNOME and other applications to handle web communications. The issue occurs when the library processes specially crafted multipart messages. Due to improper validation, an internal calculation can go wrong, leading to an integer underflow. This can cause the program to access invalid memory and crash. As a result, any application or server using libsoup could be forced to exit unexpectedly, creating a denial-of-service (DoS) risk.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52531",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: buffer overflow via UTF-8 conversion in soup_header_parse_param_list_strict",
      "description": "GNOME libsoup before 3.6.1 allows a buffer overflow in applications that perform conversion to UTF-8 in soup_header_parse_param_list_strict. There is a plausible way to reach this remotely via soup_message_headers_get_content_type (e.g., an application may want to retrieve the content type of a request or response).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32911",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Double free on  soup_message_headers_get_content_disposition() through  \"soup-message-headers.c\" via \"params\" GHashTable value",
      "description": "A use-after-free type vulnerability was found in libsoup, in the soup_message_headers_get_content_disposition() function. This flaw allows a malicious HTTP client to cause memory corruption in the libsoup server.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52530",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: HTTP request smuggling via stripping null bytes from the ends of header names",
      "description": "GNOME libsoup before 3.6.0 allows HTTP request smuggling in some configurations because '\\0' characters at the end of header names are ignored, i.e., a \"Transfer-Encoding\\0: chunked\" header is treated the same as a \"Transfer-Encoding: chunked\" header.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52532",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: infinite loop while reading websocket data",
      "description": "GNOME libsoup before 3.6.1 has an infinite loop, and memory consumption. during the reading of certain patterns of WebSocket data from clients.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32049",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Denial of Service attack to websocket server",
      "description": "A flaw was found in libsoup. The SoupWebsocketConnection may accept a large WebSocket message, which may cause libsoup to allocate memory and lead to a denial of service (DoS).",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32906",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Out of bounds reads in soup_headers_parse_request()",
      "description": "A flaw was found in libsoup, where the soup_headers_parse_request() function may be vulnerable to an out-of-bound read. This flaw allows a malicious user to use a specially crafted HTTP request to crash the HTTP server.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32913",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: NULL pointer dereference in  soup_message_headers_get_content_disposition when \"filename\" parameter  is present, but has no value in Content-Disposition header",
      "description": "A flaw was found in libsoup, where the soup_message_headers_get_content_disposition() function is vulnerable to a NULL pointer dereference. This flaw allows a malicious HTTP peer to crash a libsoup client or server that uses this function.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32914",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: OOB Read on libsoup through function  \"soup_multipart_new_from_message\" in soup-multipart.c leads to crash or  exit of process",
      "description": "A flaw was found in libsoup, where the soup_multipart_new_from_message() function is vulnerable to an out-of-bounds read. This flaw allows a malicious HTTP client to induce the libsoup server to read out of bounds.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4948",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libsoup: Integer Underflow in soup_multipart_new_from_message() Leading to Denial of Service in libsoup",
      "description": "A flaw was found in the soup_multipart_new_from_message() function of the libsoup HTTP library, which is commonly used by GNOME and other applications to handle web communications. The issue occurs when the library processes specially crafted multipart messages. Due to improper validation, an internal calculation can go wrong, leading to an integer underflow. This can cause the program to access invalid memory and crash. As a result, any application or server using libsoup could be forced to exit unexpectedly, creating a denial-of-service (DoS) risk.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6965",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "No fix available",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "sqlite: Integer Truncation in SQLite",
      "description": "There exists a vulnerability in SQLite versions before 3.50.2 where the number of aggregate terms could exceed the number of columns available. This could lead to a memory corruption issue. We recommend upgrading to version 3.50.2 or above.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-36690",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "3.34.1-3+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "A segmentation fault can occur in the sqlite3.exe command-line compone ...",
      "description": "A segmentation fault can occur in the sqlite3.exe command-line component of SQLite 3.36.0 via the idxGetTableInfo function when there is a crafted SQL query. NOTE: the vendor disputes the relevance of this report because a sqlite3.exe user already has full privileges (e.g., is intentionally allowed to execute commands). This report does NOT imply any problem in the SQLite library.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-7104",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "3.34.1-3+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "sqlite: heap-buffer-overflow at sessionfuzz",
      "description": "A vulnerability was found in SQLite SQLite3 up to 3.43.0 and classified as critical. This issue affects the function sessionReadRecord of the file ext/session/sqlite3session.c of the component make alltest Handler. The manipulation leads to heap-based buffer overflow. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-248999.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1304",
      "package_name": "libss2",
      "installed_version": "1.46.2-2",
      "fixed_version": "1.46.2-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "e2fsprogs: out-of-bounds read/write via crafted filesystem",
      "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-22218",
      "package_name": "libssh2-1",
      "installed_version": "1.9.0-2",
      "fixed_version": "1.9.0-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libssh2: use-of-uninitialized-value in _libssh2_transport_read",
      "description": "An issue was discovered in function _libssh2_packet_add in libssh2 1.10.0 allows attackers to access out of bounds memory.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4450",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "openssl: double free after calling PEM_read_bio_ex",
      "description": "The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data.\nIf the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0215",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "openssl: use-after-free following BIO_new_NDEF",
      "description": "The public API function BIO_new_NDEF is a helper function used for streaming\nASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a BIO from the caller, prepends a new BIO_f_asn1 filter\nBIO onto the front of it to form a BIO chain, and then returns the new head of\nthe BIO chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter BIO is freed and the function\nreturns a NULL result indicating a failure. However, in this case, the BIO chain\nis not properly cleaned up and the BIO passed by the caller still retains\ninternal pointers to the previously freed filter BIO. If the caller then goes on\nto call BIO_pop() on the BIO then a use-after-free will occur. This will most\nlikely result in a crash.\n\n\n\nThis scenario occurs directly in the internal function B64_write_ASN1() which\nmay cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on\nthe BIO. This internal function is in turn called by the public API functions\nPEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,\nSMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.\n\nOther public API functions that may be impacted by this include\ni2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and\ni2d_PKCS7_bio_stream.\n\nThe OpenSSL cms and smime command line applications are similarly affected.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0286",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "openssl: X.400 address type confusion in X.509 GeneralName",
      "description": "There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0464",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "openssl: Denial of service by excessive resource usage in verifying X509 policy constraints",
      "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50387",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator",
      "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50868",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources",
      "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-46848",
      "package_name": "libtasn1-6",
      "installed_version": "4.16.0-2",
      "fixed_version": "4.16.0-2+deb11u1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtasn1: Out-of-bound access in ETYPE_OK",
      "description": "GNU Libtasn1 before 4.19.0 has an ETYPE_OK off-by-one array size check that affects asn1_encode_simple_der.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3970",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtiff: integer overflow in function TIFFReadRGBATileExt of the file",
      "description": "A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-25434",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtiff: heap-buffer overflow via extractContigSamplesBytes() at /libtiff/tools/tiffcrop.c",
      "description": "libtiff 4.5.0 is vulnerable to Buffer Overflow via extractContigSamplesBytes() at /libtiff/tools/tiffcrop.c:3215.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-52355",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtiff: TIFFRasterScanlineSize64 produce too-big size and could cause OOM",
      "description": "An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-52356",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtiff: Segment fault in libtiff  in TIFFReadRGBATileExt() leading to denial of service",
      "description": "A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-7006",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtiff: NULL pointer dereference in tif_dirinfo.c",
      "description": "A null pointer dereference flaw was found in Libtiff via `tif_dirinfo.c`. This issue may allow an attacker to trigger memory allocation failures through certain means, such as restricting the heap space size or injecting faults, causing a segmentation fault. This can cause an application crash, eventually leading to a denial of service.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9900",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libtiff: Libtiff Write-What-Where",
      "description": "A flaw was found in Libtiff. This vulnerability is a \"write-what-where\" condition, triggered when the library processes a specially crafted TIFF image file.\n\nBy providing an abnormally large image height value in the file's metadata, an attacker can trick the library into writing attacker-controlled color data to an arbitrary memory location. This memory corruption can be exploited to cause a denial of service (application crash) or to achieve arbitrary code execution with the permissions of the user.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-29458",
      "package_name": "libtinfo6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: segfaulting OOB read",
      "description": "ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29491",
      "package_name": "libtinfo6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: Local users can trigger security-relevant memory corruption via malformed data",
      "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50387",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator",
      "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50868",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources",
      "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-1999",
      "package_name": "libwebp6",
      "installed_version": "0.6.1-2.1",
      "fixed_version": "0.6.1-2.1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Mozilla: libwebp: Double-free in libwebp",
      "description": "There exists a use after free/double free in libwebp. An attacker can use the\u00a0ApplyFiltersAndEncode() function and loop through to free best.bw and assign best = trial pointer. The second loop will then return 0 because of an Out of memory error in VP8 encoder, the pointer is still assigned to trial and the AddressSanitizer will attempt a double free.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4863",
      "package_name": "libwebp6",
      "installed_version": "0.6.1-2.1",
      "fixed_version": "0.6.1-2.1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libwebp: Heap buffer overflow in WebP Codec",
      "description": "Heap buffer overflow in libwebp in Google Chrome prior to 116.0.5845.187 and libwebp 1.3.2 allowed a remote attacker to perform an out of bounds memory write via a crafted HTML page. (Chromium security severity: Critical)",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3138",
      "package_name": "libx11-6",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libX11: InitExt.c can overwrite unintended portions of the Display structure if the extension request leads to a buffer overflow",
      "description": "A vulnerability was found in libX11. The security flaw occurs because the functions in src/InitExt.c in libX11 do not check that the values provided for the Request, Event, or Error IDs are within the bounds of the arrays that those functions write to, using those IDs as array indexes. They trust that they were called with values provided by an Xserver adhering to the bounds specified in the X11 protocol, as all X servers provided by X.Org do. As the protocol only specifies a single byte for these values, an out-of-bounds value provided by a malicious server (or a malicious proxy-in-the-middle) can only overwrite other portions of the Display structure and not write outside the bounds of the Display structure itself, possibly causing the client to crash with this memory corruption.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43787",
      "package_name": "libx11-6",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libX11: integer overflow in XCreateImage() leading to a heap overflow",
      "description": "A vulnerability was found in libX11 due to an integer overflow within the XCreateImage() function. This flaw allows a local user to trigger an integer overflow and execute arbitrary code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3138",
      "package_name": "libx11-data",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libX11: InitExt.c can overwrite unintended portions of the Display structure if the extension request leads to a buffer overflow",
      "description": "A vulnerability was found in libX11. The security flaw occurs because the functions in src/InitExt.c in libX11 do not check that the values provided for the Request, Event, or Error IDs are within the bounds of the arrays that those functions write to, using those IDs as array indexes. They trust that they were called with values provided by an Xserver adhering to the bounds specified in the X11 protocol, as all X servers provided by X.Org do. As the protocol only specifies a single byte for these values, an out-of-bounds value provided by a malicious server (or a malicious proxy-in-the-middle) can only overwrite other portions of the Display structure and not write outside the bounds of the Display structure itself, possibly causing the client to crash with this memory corruption.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43787",
      "package_name": "libx11-data",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libX11: integer overflow in XCreateImage() leading to a heap overflow",
      "description": "A vulnerability was found in libX11 due to an integer overflow within the XCreateImage() function. This flaw allows a local user to trigger an integer overflow and execute arbitrary code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3138",
      "package_name": "libx11-xcb1",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libX11: InitExt.c can overwrite unintended portions of the Display structure if the extension request leads to a buffer overflow",
      "description": "A vulnerability was found in libX11. The security flaw occurs because the functions in src/InitExt.c in libX11 do not check that the values provided for the Request, Event, or Error IDs are within the bounds of the arrays that those functions write to, using those IDs as array indexes. They trust that they were called with values provided by an Xserver adhering to the bounds specified in the X11 protocol, as all X servers provided by X.Org do. As the protocol only specifies a single byte for these values, an out-of-bounds value provided by a malicious server (or a malicious proxy-in-the-middle) can only overwrite other portions of the Display structure and not write outside the bounds of the Display structure itself, possibly causing the client to crash with this memory corruption.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43787",
      "package_name": "libx11-xcb1",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libX11: integer overflow in XCreateImage() leading to a heap overflow",
      "description": "A vulnerability was found in libX11 due to an integer overflow within the XCreateImage() function. This flaw allows a local user to trigger an integer overflow and execute arbitrary code with elevated privileges.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-56171",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: Use-After-Free in libxml2",
      "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a use-after-free in xmlSchemaIDCFillNodeTables and xmlSchemaBubbleIDCNodeTables in xmlschemas.c. To exploit this, a crafted XML document must be validated against an XML schema with certain identity constraints, or a crafted XML schema must be used.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-49794",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u8",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml: Heap use after free (UAF) leads to Denial of service (DoS)",
      "description": "A use-after-free vulnerability was found in libxml2. This issue occurs when parsing XPath elements under certain circumstances when the XML schematron has the <sch:name path=\"...\"/> schema elements. This flaw allows a malicious actor to craft a malicious XML document used as input for libxml, resulting in the program's crash using libxml or other possible undefined behaviors.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-49796",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u8",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml: Type confusion leads to Denial of service (DoS)",
      "description": "A vulnerability was found in libxml2. Processing certain sch:name elements from the input XML file can trigger a memory corruption issue. This flaw allows an attacker to craft a malicious XML input file that can lead libxml to crash, resulting in a denial of service or other possible undefined behavior due to sensitive data being corrupted in memory.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2309",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u5",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "lxml: NULL Pointer Dereference in lxml",
      "description": "NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-49043",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml: use-after-free in xmlXIncludeAddNode",
      "description": "xmlXIncludeAddNode in xinclude.c in libxml2 before 2.11.0 has a use-after-free.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-25062",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: use-after-free in XMLReader",
      "description": "An issue was discovered in libxml2 before 2.11.7 and 2.12.x before 2.12.5. When using the XML Reader interface with DTD validation and XInclude expansion enabled, processing crafted XML documents can lead to an xmlValidatePopElement use-after-free.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-24928",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: Stack-based buffer overflow in xmlSnprintfElements of libxml2",
      "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a stack-based buffer overflow in xmlSnprintfElements in valid.c. To exploit this, DTD validation must occur for an untrusted document or untrusted DTD. NOTE: this is similar to CVE-2017-9047.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-27113",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: NULL Pointer Dereference in libxml2 xmlPatMatch",
      "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a NULL pointer dereference in xmlPatMatch in pattern.c.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32414",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: Out-of-Bounds Read in libxml2",
      "description": "In libxml2 before 2.13.8 and 2.14.x before 2.14.2, out-of-bounds memory access can occur in the Python API (Python bindings) because of an incorrect return value. This occurs in xmlPythonFileRead and xmlPythonFileReadRaw because of a difference between bytes and characters.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32415",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u7",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: Out-of-bounds Read in xmlSchemaIDCFillNodeTables",
      "description": "In libxml2 before 2.13.8 and 2.14.x before 2.14.2, xmlSchemaIDCFillNodeTables in xmlschemas.c has a heap-based buffer under-read. To exploit this, a crafted XML document must be validated against an XML schema with certain identity constraints, or a crafted XML schema must be used.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6021",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "libxml2: Integer Overflow in xmlBuildQName() Leads to Stack Buffer Overflow in libxml2",
      "description": "A flaw was found in libxml2's xmlBuildQName function, where integer overflows in buffer size calculations can lead to a stack-based buffer overflow. This issue can result in memory corruption or a denial of service when processing crafted input.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4899",
      "package_name": "libzstd1",
      "installed_version": "1.4.8+dfsg-2.1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "zstd: mysql: buffer overrun in util.c",
      "description": "A vulnerability was found in zstd v1.4.10, where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-25775",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: irdma: Improper access control",
      "description": "Improper access control in the Intel(R) Ethernet Controller RDMA driver for linux before version 1.9.30 may allow an unauthenticated user to potentially enable escalation of privilege via network access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47685",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put()\n\nsyzbot reported that nf_reject_ip6_tcphdr_put() was possibly sending\ngarbage on the four reserved tcp bits (th->res1)\n\nUse skb_put_zero() to clear the whole TCP header,\nas done in nf_reject_ip_tcphdr_put()\n\nBUG: KMSAN: uninit-value in nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1da/0xa00 net/core/dev.c:5775\n  process_backlog+0x4ad/0xa50 net/core/dev.c:6108\n  __napi_poll+0xe7/0x980 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0xa5a/0x19b0 net/core/dev.c:6963\n  handle_softirqs+0x1ce/0x800 kernel/softirq.c:554\n  __do_softirq+0x14/0x1a kernel/softirq.c:588\n  do_softirq+0x9a/0x100 kernel/softirq.c:455\n  __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:382\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:908 [inline]\n  __dev_queue_xmit+0x2692/0x5610 net/core/dev.c:4450\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  neigh_resolve_output+0x9ca/0xae0 net/core/neighbour.c:1565\n  neigh_output include/net/neighbour.h:542 [inline]\n  ip6_finish_output2+0x2347/0x2ba0 net/ipv6/ip6_output.c:141\n  __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]\n  ip6_finish_output+0xbb8/0x14b0 net/ipv6/ip6_output.c:226\n  NF_HOOK_COND include/linux/netfilter.h:303 [inline]\n  ip6_output+0x356/0x620 net/ipv6/ip6_output.c:247\n  dst_output include/net/dst.h:450 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_xmit+0x1ba6/0x25d0 net/ipv6/ip6_output.c:366\n  inet6_csk_xmit+0x442/0x530 net/ipv6/inet6_connection_sock.c:135\n  __tcp_transmit_skb+0x3b07/0x4880 net/ipv4/tcp_output.c:1466\n  tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n  tcp_connect+0x35b6/0x7130 net/ipv4/tcp_output.c:4143\n  tcp_v6_connect+0x1bcc/0x1e40 net/ipv6/tcp_ipv6.c:333\n  __inet_stream_connect+0x2ef/0x1730 net/ipv4/af_inet.c:679\n  inet_stream_connect+0x6a/0xd0 net/ipv4/af_inet.c:750\n  __sys_connect_file net/socket.c:2061 [inline]\n  __sys_connect+0x606/0x690 net/socket.c:2078\n  __do_sys_connect net/socket.c:2088 [inline]\n  __se_sys_connect net/socket.c:2085 [inline]\n  __x64_sys_connect+0x91/0xe0 net/socket.c:2085\n  x64_sys_call+0x27a5/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:43\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was stored to memory at:\n  nf_reject_ip6_tcphdr_put+0x60c/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:249\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2013-7445",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: memory exhaustion via crafted Graphics Execution Manager (GEM) objects",
      "description": "The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2019-19449",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c",
      "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c, related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2019-19814",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: out-of-bounds write in __remove_dirty_segment in fs/f2fs/segment.c",
      "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2020-12362",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Integer overflow in Intel(R) Graphics Drivers",
      "description": "Integer overflow in the firmware for some Intel(R) Graphics Drivers for Windows * before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable an escalation of privilege via local access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-33631",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: kernel bug in ext4_write_inline_data_end()",
      "description": "Integer Overflow or Wraparound vulnerability in openEuler kernel on Linux (filesystem modules) allows Forced Integer Overflow.This issue affects openEuler kernel: from 4.19.90 before 4.19.90-2401.3, from 5.10.0-60.18.0 before 5.10.0-183.0.0.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-3847",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: low-privileged user privileges escalation",
      "description": "An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-3864",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: descendant's dumpable setting with certain SUID binaries",
      "description": "A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-39686",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: race condition in the Android binder driver could lead to incorrect security checks",
      "description": "In several functions of binder.c, there is a possible way to represent the wrong domain to SELinux due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-200688826References: Upstream kernel",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-4204",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: improper input validation may lead to privilege escalation",
      "description": "An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47014",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: act_ct: fix wild memory access when clearing fragments",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_ct: fix wild memory access when clearing fragments\n\nwhile testing re-assembly/re-fragmentation using act_ct, it's possible to\nobserve a crash like the following one:\n\n KASAN: maybe wild-memory-access in range [0x0001000000000448-0x000100000000044f]\n CPU: 50 PID: 0 Comm: swapper/50 Tainted: G S                5.12.0-rc7+ #424\n Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017\n RIP: 0010:inet_frag_rbtree_purge+0x50/0xc0\n Code: 00 fc ff df 48 89 c3 31 ed 48 89 df e8 a9 7a 38 ff 4c 89 fe 48 89 df 49 89 c6 e8 5b 3a 38 ff 48 8d 7b 40 48 89 f8 48 c1 e8 03 <42> 80 3c 20 00 75 59 48 8d bb d0 00 00 00 4c 8b 6b 40 48 89 f8 48\n RSP: 0018:ffff888c31449db8 EFLAGS: 00010203\n RAX: 0000200000000089 RBX: 000100000000040e RCX: ffffffff989eb960\n RDX: 0000000000000140 RSI: ffffffff97cfb977 RDI: 000100000000044e\n RBP: 0000000000000900 R08: 0000000000000000 R09: ffffed1186289350\n R10: 0000000000000003 R11: ffffed1186289350 R12: dffffc0000000000\n R13: 000100000000040e R14: 0000000000000000 R15: ffff888155e02160\n FS:  0000000000000000(0000) GS:ffff888c31440000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00005600cb70a5b8 CR3: 0000000a2c014005 CR4: 00000000003706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <IRQ>\n  inet_frag_destroy+0xa9/0x150\n  call_timer_fn+0x2d/0x180\n  run_timer_softirq+0x4fe/0xe70\n  __do_softirq+0x197/0x5a0\n  irq_exit_rcu+0x1de/0x200\n  sysvec_apic_timer_interrupt+0x6b/0x80\n  </IRQ>\n\nwhen act_ct temporarily stores an IP fragment, restoring the skb qdisc cb\nresults in putting random data in FRAG_CB(), and this causes those \"wild\"\nmemory accesses later, when the rbtree is purged. Never overwrite the skb\ncb in case tcf_ct_handle_fragments() returns -EINPROGRESS.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47028",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mt76: mt7915: fix txrate reporting",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: mt7915: fix txrate reporting\n\nProperly check rate_info to fix unexpected reporting.\n\n[ 1215.161863] Call trace:\n[ 1215.164307]  cfg80211_calculate_bitrate+0x124/0x200 [cfg80211]\n[ 1215.170139]  ieee80211s_update_metric+0x80/0xc0 [mac80211]\n[ 1215.175624]  ieee80211_tx_status_ext+0x508/0x838 [mac80211]\n[ 1215.181190]  mt7915_mcu_get_rx_rate+0x28c/0x8d0 [mt7915e]\n[ 1215.186580]  mt7915_mac_tx_free+0x324/0x7c0 [mt7915e]\n[ 1215.191623]  mt7915_queue_rx_skb+0xa8/0xd0 [mt7915e]\n[ 1215.196582]  mt76_dma_cleanup+0x7b0/0x11d0 [mt76]\n[ 1215.201276]  __napi_poll+0x38/0xf8\n[ 1215.204668]  napi_workfn+0x40/0x80\n[ 1215.208062]  process_one_work+0x1fc/0x390\n[ 1215.212062]  worker_thread+0x48/0x4d0\n[ 1215.215715]  kthread+0x120/0x128\n[ 1215.218935]  ret_from_fork+0x10/0x1c",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47094",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: x86/mmu: Don&#39;t advance iterator after restart due to yielding",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/mmu: Don't advance iterator after restart due to yielding\n\nAfter dropping mmu_lock in the TDP MMU, restart the iterator during\ntdp_iter_next() and do not advance the iterator.  Advancing the iterator\nresults in skipping the top-level SPTE and all its children, which is\nfatal if any of the skipped SPTEs were not visited before yielding.\n\nWhen zapping all SPTEs, i.e. when min_level == root_level, restarting the\niter and then invoking tdp_iter_next() is always fatal if the current gfn\nhas as a valid SPTE, as advancing the iterator results in try_step_side()\nskipping the current gfn, which wasn't visited before yielding.\n\nSprinkle WARNs on iter->yielded being true in various helpers that are\noften used in conjunction with yielding, and tag the helper with\n__must_check to reduce the probabily of improper usage.\n\nFailing to zap a top-level SPTE manifests in one of two ways.  If a valid\nSPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(),\nthe shadow page will be leaked and KVM will WARN accordingly.\n\n  WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm]\n  RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_arch_destroy_vm+0x130/0x1b0 [kvm]\n   kvm_destroy_vm+0x162/0x2a0 [kvm]\n   kvm_vcpu_release+0x34/0x60 [kvm]\n   __fput+0x82/0x240\n   task_work_run+0x5c/0x90\n   do_exit+0x364/0xa10\n   ? futex_unqueue+0x38/0x60\n   do_group_exit+0x33/0xa0\n   get_signal+0x155/0x850\n   arch_do_signal_or_restart+0xed/0x750\n   exit_to_user_mode_prepare+0xc5/0x120\n   syscall_exit_to_user_mode+0x1d/0x40\n   do_syscall_64+0x48/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nIf kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped by\nkvm_tdp_mmu_put_root(), KVM triggers a use-after-free in the form of\nmarking a struct page as dirty/accessed after it has been put back on the\nfree list.  This directly triggers a WARN due to encountering a page with\npage_count() == 0, but it can also lead to data corruption and additional\nerrors in the kernel.\n\n  WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171\n  RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_set_pfn_dirty+0x120/0x1d0 [kvm]\n   __handle_changed_spte+0x92e/0xca0 [kvm]\n   __handle_changed_spte+0x63c/0xca0 [kvm]\n   __handle_changed_spte+0x63c/0xca0 [kvm]\n   __handle_changed_spte+0x63c/0xca0 [kvm]\n   zap_gfn_range+0x549/0x620 [kvm]\n   kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm]\n   mmu_free_root_page+0x219/0x2c0 [kvm]\n   kvm_mmu_free_roots+0x1b4/0x4e0 [kvm]\n   kvm_mmu_unload+0x1c/0xa0 [kvm]\n   kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm]\n   kvm_put_kvm+0x3b1/0x8b0 [kvm]\n   kvm_vcpu_release+0x4e/0x70 [kvm]\n   __fput+0x1f7/0x8c0\n   task_work_run+0xf8/0x1a0\n   do_exit+0x97b/0x2230\n   do_group_exit+0xda/0x2a0\n   get_signal+0x3be/0x1e50\n   arch_do_signal_or_restart+0x244/0x17f0\n   exit_to_user_mode_prepare+0xcb/0x120\n   syscall_exit_to_user_mode+0x1d/0x40\n   do_syscall_64+0x4d/0x90\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nNote, the underlying bug existed even before commit 1af4a96025b3 (\"KVM:\nx86/mmu: Yield in TDU MMU iter even if no SPTES changed\") moved calls to\ntdp_mmu_iter_cond_resched() to the beginning of loops, as KVM could still\nincorrectly advance past a top-level entry when yielding on a lower-level\nentry.  But with respect to leaking shadow pages, the bug was introduced\nby yielding before processing the current gfn.\n\nAlternatively, tdp_mmu_iter_cond_resched() could simply fall through, or\ncallers could jump to their \"retry\" label.  The downside of that approach\nis that tdp_mmu_iter_cond_resched() _must_ be called before anything else\nin the loop, and there's no easy way to enfornce that requirement.\n\nIdeally, KVM would handling the cond_resched() fully within the iterator\nmacro (the code is actually quite clean) and avoid this entire class of\nbugs, but that is extremely difficult do wh\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47101",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: asix: fix uninit-value in asix_mdio_read()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nasix: fix uninit-value in asix_mdio_read()\n\nasix_read_cmd() may read less than sizeof(smsr) bytes and in this case\nsmsr will be uninitialized.\n\nFail log:\nBUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]\nBUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497\nBUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497\n asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]\n asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497\n asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47103",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: inet: fully convert sk->sk_rx_dst to RCU rules",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ninet: fully convert sk->sk_rx_dst to RCU rules\n\nsyzbot reported various issues around early demux,\none being included in this changelog [1]\n\nsk->sk_rx_dst is using RCU protection without clearly\ndocumenting it.\n\nAnd following sequences in tcp_v4_do_rcv()/tcp_v6_do_rcv()\nare not following standard RCU rules.\n\n[a]    dst_release(dst);\n[b]    sk->sk_rx_dst = NULL;\n\nThey look wrong because a delete operation of RCU protected\npointer is supposed to clear the pointer before\nthe call_rcu()/synchronize_rcu() guarding actual memory freeing.\n\nIn some cases indeed, dst could be freed before [b] is done.\n\nWe could cheat by clearing sk_rx_dst before calling\ndst_release(), but this seems the right time to stick\nto standard RCU annotations and debugging facilities.\n\n[1]\nBUG: KASAN: use-after-free in dst_check include/net/dst.h:470 [inline]\nBUG: KASAN: use-after-free in tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792\nRead of size 2 at addr ffff88807f1cb73a by task syz-executor.5/9204\n\nCPU: 0 PID: 9204 Comm: syz-executor.5 Not tainted 5.16.0-rc5-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c:247\n __kasan_report mm/kasan/report.c:433 [inline]\n kasan_report.cold+0x83/0xdf mm/kasan/report.c:450\n dst_check include/net/dst.h:470 [inline]\n tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792\n ip_rcv_finish_core.constprop.0+0x15de/0x1e80 net/ipv4/ip_input.c:340\n ip_list_rcv_finish.constprop.0+0x1b2/0x6e0 net/ipv4/ip_input.c:583\n ip_sublist_rcv net/ipv4/ip_input.c:609 [inline]\n ip_list_rcv+0x34e/0x490 net/ipv4/ip_input.c:644\n __netif_receive_skb_list_ptype net/core/dev.c:5508 [inline]\n __netif_receive_skb_list_core+0x549/0x8e0 net/core/dev.c:5556\n __netif_receive_skb_list net/core/dev.c:5608 [inline]\n netif_receive_skb_list_internal+0x75e/0xd80 net/core/dev.c:5699\n gro_normal_list net/core/dev.c:5853 [inline]\n gro_normal_list net/core/dev.c:5849 [inline]\n napi_complete_done+0x1f1/0x880 net/core/dev.c:6590\n virtqueue_napi_complete drivers/net/virtio_net.c:339 [inline]\n virtnet_poll+0xca2/0x11b0 drivers/net/virtio_net.c:1557\n __napi_poll+0xaf/0x440 net/core/dev.c:7023\n napi_poll net/core/dev.c:7090 [inline]\n net_rx_action+0x801/0xb40 net/core/dev.c:7177\n __do_softirq+0x29b/0x9c2 kernel/softirq.c:558\n invoke_softirq kernel/softirq.c:432 [inline]\n __irq_exit_rcu+0x123/0x180 kernel/softirq.c:637\n irq_exit_rcu+0x5/0x20 kernel/softirq.c:649\n common_interrupt+0x52/0xc0 arch/x86/kernel/irq.c:240\n asm_common_interrupt+0x1e/0x40 arch/x86/include/asm/idtentry.h:629\nRIP: 0033:0x7f5e972bfd57\nCode: 39 d1 73 14 0f 1f 80 00 00 00 00 48 8b 50 f8 48 83 e8 08 48 39 ca 77 f3 48 39 c3 73 3e 48 89 13 48 8b 50 f8 48 89 38 49 8b 0e <48> 8b 3e 48 83 c3 08 48 83 c6 08 eb bc 48 39 d1 72 9e 48 39 d0 73\nRSP: 002b:00007fff8a413210 EFLAGS: 00000283\nRAX: 00007f5e97108990 RBX: 00007f5e97108338 RCX: ffffffff81d3aa45\nRDX: ffffffff81d3aa45 RSI: 00007f5e97108340 RDI: ffffffff81d3aa45\nRBP: 00007f5e97107eb8 R08: 00007f5e97108d88 R09: 0000000093c2e8d9\nR10: 0000000000000000 R11: 0000000000000000 R12: 00007f5e97107eb0\nR13: 00007f5e97108338 R14: 00007f5e97107ea8 R15: 0000000000000019\n </TASK>\n\nAllocated by task 13:\n kasan_save_stack+0x1e/0x50 mm/kasan/common.c:38\n kasan_set_track mm/kasan/common.c:46 [inline]\n set_alloc_info mm/kasan/common.c:434 [inline]\n __kasan_slab_alloc+0x90/0xc0 mm/kasan/common.c:467\n kasan_slab_alloc include/linux/kasan.h:259 [inline]\n slab_post_alloc_hook mm/slab.h:519 [inline]\n slab_alloc_node mm/slub.c:3234 [inline]\n slab_alloc mm/slub.c:3242 [inline]\n kmem_cache_alloc+0x202/0x3a0 mm/slub.c:3247\n dst_alloc+0x146/0x1f0 net/core/dst.c:92\n rt_dst_alloc+0x73/0x430 net/ipv4/route.c:1613\n ip_route_input_slow+0x1817/0x3a20 net/ipv4/route.c:234\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47198",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: lpfc: Fix use-after-free in lpfc_unreg_rpi() routine",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix use-after-free in lpfc_unreg_rpi() routine\n\nAn error is detected with the following report when unloading the driver:\n  \"KASAN: use-after-free in lpfc_unreg_rpi+0x1b1b\"\n\nThe NLP_REG_LOGIN_SEND nlp_flag is set in lpfc_reg_fab_ctrl_node(), but the\nflag is not cleared upon completion of the login.\n\nThis allows a second call to lpfc_unreg_rpi() to proceed with nlp_rpi set\nto LPFC_RPI_ALLOW_ERROR.  This results in a use after free access when used\nas an rpi_ids array index.\n\nFix by clearing the NLP_REG_LOGIN_SEND nlp_flag in\nlpfc_mbx_cmpl_fc_reg_login().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47200",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/prime: Fix use after free in mmap with drm_gem_ttm_mmap",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/prime: Fix use after free in mmap with drm_gem_ttm_mmap\n\ndrm_gem_ttm_mmap() drops a reference to the gem object on success. If\nthe gem object's refcount == 1 on entry to drm_gem_prime_mmap(), that\ndrop will free the gem object, and the subsequent drm_gem_object_get()\nwill be a UAF. Fix by grabbing a reference before calling the mmap\nhelper.\n\nThis issue was forseen when the reference dropping was adding in\ncommit 9786b65bc61ac (\"drm/ttm: fix mmap refcounting\"):\n  \"For that to work properly the drm_gem_object_get() call in\n  drm_gem_ttm_mmap() must be moved so it happens before calling\n  obj->funcs->mmap(), otherwise the gem refcount would go down\n  to zero.\"",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47247",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5e: Fix use-after-free of encap entry in neigh update handler",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix use-after-free of encap entry in neigh update handler\n\nFunction mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl lock\nremoval from TC filter update path and properly handle concurrent encap\nentry insertion/deletion which can lead to following use-after-free:\n\n [23827.464923] ==================================================================\n [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker/u20:6/21635\n [23827.472251]\n [23827.472615] CPU: 9 PID: 21635 Comm: kworker/u20:6 Not tainted 5.13.0-rc3+ #5\n [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core]\n [23827.476731] Call Trace:\n [23827.477260]  dump_stack+0xbb/0x107\n [23827.477906]  print_address_description.constprop.0+0x18/0x140\n [23827.478896]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.479879]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.480905]  kasan_report.cold+0x7c/0xd8\n [23827.481701]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.482744]  kasan_check_range+0x145/0x1a0\n [23827.493112]  mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.494054]  ? mlx5e_tc_tun_encap_info_equal_generic+0x140/0x140 [mlx5_core]\n [23827.495296]  mlx5e_rep_neigh_update+0x41e/0x5e0 [mlx5_core]\n [23827.496338]  ? mlx5e_rep_neigh_entry_release+0xb80/0xb80 [mlx5_core]\n [23827.497486]  ? read_word_at_a_time+0xe/0x20\n [23827.498250]  ? strscpy+0xa0/0x2a0\n [23827.498889]  process_one_work+0x8ac/0x14e0\n [23827.499638]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n [23827.500537]  ? pwq_dec_nr_in_flight+0x2c0/0x2c0\n [23827.501359]  ? rwlock_bug.part.0+0x90/0x90\n [23827.502116]  worker_thread+0x53b/0x1220\n [23827.502831]  ? process_one_work+0x14e0/0x14e0\n [23827.503627]  kthread+0x328/0x3f0\n [23827.504254]  ? _raw_spin_unlock_irq+0x24/0x40\n [23827.505065]  ? __kthread_bind_mask+0x90/0x90\n [23827.505912]  ret_from_fork+0x1f/0x30\n [23827.506621]\n [23827.506987] Allocated by task 28248:\n [23827.507694]  kasan_save_stack+0x1b/0x40\n [23827.508476]  __kasan_kmalloc+0x7c/0x90\n [23827.509197]  mlx5e_attach_encap+0xde1/0x1d40 [mlx5_core]\n [23827.510194]  mlx5e_tc_add_fdb_flow+0x397/0xc40 [mlx5_core]\n [23827.511218]  __mlx5e_add_fdb_flow+0x519/0xb30 [mlx5_core]\n [23827.512234]  mlx5e_configure_flower+0x191c/0x4870 [mlx5_core]\n [23827.513298]  tc_setup_cb_add+0x1d5/0x420\n [23827.514023]  fl_hw_replace_filter+0x382/0x6a0 [cls_flower]\n [23827.514975]  fl_change+0x2ceb/0x4a51 [cls_flower]\n [23827.515821]  tc_new_tfilter+0x89a/0x2070\n [23827.516548]  rtnetlink_rcv_msg+0x644/0x8c0\n [23827.517300]  netlink_rcv_skb+0x11d/0x340\n [23827.518021]  netlink_unicast+0x42b/0x700\n [23827.518742]  netlink_sendmsg+0x743/0xc20\n [23827.519467]  sock_sendmsg+0xb2/0xe0\n [23827.520131]  ____sys_sendmsg+0x590/0x770\n [23827.520851]  ___sys_sendmsg+0xd8/0x160\n [23827.521552]  __sys_sendmsg+0xb7/0x140\n [23827.522238]  do_syscall_64+0x3a/0x70\n [23827.522907]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n [23827.523797]\n [23827.524163] Freed by task 25948:\n [23827.524780]  kasan_save_stack+0x1b/0x40\n [23827.525488]  kasan_set_track+0x1c/0x30\n [23827.526187]  kasan_set_free_info+0x20/0x30\n [23827.526968]  __kasan_slab_free+0xed/0x130\n [23827.527709]  slab_free_freelist_hook+0xcf/0x1d0\n [23827.528528]  kmem_cache_free_bulk+0x33a/0x6e0\n [23827.529317]  kfree_rcu_work+0x55f/0xb70\n [23827.530024]  process_one_work+0x8ac/0x14e0\n [23827.530770]  worker_thread+0x53b/0x1220\n [23827.531480]  kthread+0x328/0x3f0\n [23827.532114]  ret_from_fork+0x1f/0x30\n [23827.532785]\n [23827.533147] Last potentially related work creation:\n [23827.534007]  kasan_save_stack+0x1b/0x40\n [23827.534710]  kasan_record_aux_stack+0xab/0xc0\n [23827.535492]  kvfree_call_rcu+0x31/0x7b0\n [23827.536206]  mlx5e_tc_del\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47391",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/cma: Ensure rdma_addr_cancel() happens before issuing more requests",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/cma: Ensure rdma_addr_cancel() happens before issuing more requests\n\nThe FSM can run in a circle allowing rdma_resolve_ip() to be called twice\non the same id_priv. While this cannot happen without going through the\nwork, it violates the invariant that the same address resolution\nbackground request cannot be active twice.\n\n       CPU 1                                  CPU 2\n\nrdma_resolve_addr():\n  RDMA_CM_IDLE -> RDMA_CM_ADDR_QUERY\n  rdma_resolve_ip(addr_handler)  #1\n\n\t\t\t process_one_req(): for #1\n                          addr_handler():\n                            RDMA_CM_ADDR_QUERY -> RDMA_CM_ADDR_BOUND\n                            mutex_unlock(&id_priv->handler_mutex);\n                            [.. handler still running ..]\n\nrdma_resolve_addr():\n  RDMA_CM_ADDR_BOUND -> RDMA_CM_ADDR_QUERY\n  rdma_resolve_ip(addr_handler)\n    !! two requests are now on the req_list\n\nrdma_destroy_id():\n destroy_id_handler_unlock():\n  _destroy_id():\n   cma_cancel_operation():\n    rdma_addr_cancel()\n\n                          // process_one_req() self removes it\n\t\t          spin_lock_bh(&lock);\n                           cancel_delayed_work(&req->work);\n\t                   if (!list_empty(&req->list)) == true\n\n      ! rdma_addr_cancel() returns after process_on_req #1 is done\n\n   kfree(id_priv)\n\n\t\t\t process_one_req(): for #2\n                          addr_handler():\n\t                    mutex_lock(&id_priv->handler_mutex);\n                            !! Use after free on id_priv\n\nrdma_addr_cancel() expects there to be one req on the list and only\ncancels the first one. The self-removal behavior of the work only happens\nafter the handler has returned. This yields a situations where the\nreq_list can have two reqs for the same \"handle\" but rdma_addr_cancel()\nonly cancels the first one.\n\nThe second req remains active beyond rdma_destroy_id() and will\nuse-after-free id_priv once it inevitably triggers.\n\nFix this by remembering if the id_priv has called rdma_resolve_ip() and\nalways cancel before calling it again. This ensures the req_list never\ngets more than one item in it and doesn't cost anything in the normal flow\nthat never uses this strange error path.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47489",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: Fix even more out of bound writes from debugfs",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix even more out of bound writes from debugfs\n\nCVE-2021-42327 was fixed by:\n\ncommit f23750b5b3d98653b31d4469592935ef6364ad67\nAuthor: Thelford Williams <tdwilliamsiv@gmail.com>\nDate:   Wed Oct 13 16:04:13 2021 -0400\n\n    drm/amdgpu: fix out of bounds write\n\nbut amdgpu_dm_debugfs.c contains more of the same issue so fix the\nremaining ones.\n\nv2:\n\t* Add missing fix in dp_max_bpc_write (Harry Wentland)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2021-47653",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: davinci: vpif: fix use-after-free on driver unbind",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: davinci: vpif: fix use-after-free on driver unbind\n\nThe driver allocates and registers two platform device structures during\nprobe, but the devices were never deregistered on driver unbind.\n\nThis results in a use-after-free on driver unbind as the device\nstructures were allocated using devres and would be freed by driver\ncore when remove() returns.\n\nFix this by adding the missing deregistration calls to the remove()\ncallback and failing probe on registration errors.\n\nNote that the platform device structures must be freed using a proper\nrelease callback to avoid leaking associated resources like device\nnames.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-0500",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Linux ebpf logic vulnerability leads to critical memory read and write gaining root privileges",
      "description": "A flaw was found in unrestricted eBPF usage by the BPF_BTF_LOAD, leading to a possible out-of-bounds memory write in the Linux kernel\u2019s BPF subsystem due to the way a user loads BTF. This flaw allows a local user to crash or escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-2196",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: nVMX: missing IBPB when exiting from nested guest can lead to Spectre v2 attacks",
      "description": "A regression exists in the Linux Kernel within KVM: nVMX that allowed for speculative execution attacks.\u00a0L2 can carry out Spectre v2 attacks on L1 due to L1 thinking it doesn't need retpolines or IBPB\u00a0after running L2 due to KVM (L0) advertising eIBRS support to L1. An attacker at L2 with code execution can execute code on an indirect branch on the host machine. We recommend upgrading to Kernel 6.2 or past commit\u00a02e7eab81425a",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-3545",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfp: use-after-free in area_cache_get()",
      "description": "A vulnerability has been found in Linux Kernel and classified as critical. Affected by this vulnerability is the function area_cache_get of the file drivers/net/ethernet/netronome/nfp/nfpcore/nfp_cppcore.c of the component IPsec. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier VDB-211045 was assigned to this vulnerability.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-3564",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free caused by l2cap_reassemble_sdu() in net/bluetooth/l2cap_core.c",
      "description": "A vulnerability classified as critical was found in Linux Kernel. Affected by this vulnerability is the function l2cap_reassemble_sdu of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211087.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-3565",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in l1oip timer handlers",
      "description": "A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function del_timer of the file drivers/isdn/mISDN/l1oip_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211088.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-3566",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: data races around icsk->icsk_af_ops in do_ipv6_setsockopt",
      "description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-3623",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: denial of service in follow_page_pte in mm/gup.c due to poisoned pte entry",
      "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function follow_page_pte of the file mm/gup.c of the component BPF. The manipulation leads to race condition. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211921 was assigned to this vulnerability.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-3640",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use after free flaw in l2cap_conn_del in net/bluetooth/l2cap_core.c",
      "description": "A vulnerability, which was classified as critical, was found in Linux Kernel. Affected is the function l2cap_conn_del of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211944.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-39189",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED leading to guest malfunctioning",
      "description": "An issue was discovered the x86 KVM subsystem in the Linux kernel before 5.18.17. Unprivileged guest users can compromise the guest kernel because TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-4139",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i915: Incorrect GPU TLB flush can lead to random memory access",
      "description": "An incorrect TLB flush issue was found in the Linux kernel\u2019s GPU i915 kernel driver, potentially leading to random memory corruption or data leaks. This flaw could allow a local user to crash the system or escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-42896",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in l2cap_connect and l2cap_le_connect_req in net/bluetooth/l2cap_core.c",
      "description": "There are use-after-free vulnerabilities in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_connect and l2cap_le_connect_req functions which may allow code execution and leaking kernel memory (respectively) remotely via Bluetooth.\u00a0A remote attacker could execute code leaking kernel memory via Bluetooth if within proximity of the victim.\n\nWe recommend upgrading past commit\u00a0  https://www.google.com/url  https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4 https://www.google.com/url \n\n",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-4378",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: stack overflow in do_proc_dointvec and proc_skip_spaces",
      "description": "A stack overflow flaw was found in the Linux kernel's SYSCTL subsystem in how a user changes certain kernel parameters and variables. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-4379",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in __nfs42_ssc_open() in fs/nfs/nfs4file.c leading to remote Denial of Service attack",
      "description": "A use-after-free vulnerability was found in __nfs42_ssc_open() in fs/nfs/nfs4file.c in the Linux kernel. This flaw allows an attacker to conduct a remote denial",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-43945",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfsd buffer overflow by RPC message over TCP with garbage data",
      "description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-45934",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: integer overflow in l2cap_config_req() in net/bluetooth/l2cap_core.c",
      "description": "An issue was discovered in the Linux kernel through 6.0.10. l2cap_config_req in net/bluetooth/l2cap_core.c has an integer wraparound via L2CAP_CONF_REQ packets.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-4696",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: user-after-free during IORING_OP_SPLICE operation",
      "description": "There exists a use-after-free vulnerability in the Linux kernel through io_uring and the\u00a0IORING_OP_SPLICE operation. If\u00a0IORING_OP_SPLICE is\u00a0missing the IO_WQ_WORK_FILES flag, which signals that the operation won't use current->nsproxy, so its reference counter is not increased. This assumption is not always true as calling io_splice on specific files will call the get_uts function which will use current->nsproxy leading to invalidly decreasing its reference counter later causing the use-after-free vulnerability. We recommend upgrading to version 5.10.160 or above\n",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-47518",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: a heap-based buffer overflow in drivers/net/wireless/microchip/wilc1000/cfg80211.c",
      "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when copying the list of operating channels from Wi-Fi management frames.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-47519",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: an out-of-bounds write in drivers/net/wireless/microchip/wilc1000/cfg80211.c",
      "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing the channel list attribute from Wi-Fi management frames.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-47520",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: an out-of-bounds read in drivers/net/wireless/microchip/wilc1000/hif.c",
      "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-47521",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: a heap-based buffer overflow in drivers/net/wireless/microchip/wilc1000/cfg80211.c",
      "description": "An issue was discovered in the Linux kernel before 6.0.11. Missing validation of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c in the WILC1000 wireless driver can trigger a heap-based buffer overflow when parsing the operating channel attribute from Wi-Fi management frames.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48626",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: moxart: fix potential use-after-free on remove path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmoxart: fix potential use-after-free on remove path\n\nIt was reported that the mmc host structure could be accessed after it\nwas freed in moxart_remove(), so fix this by saving the base register of\nthe device and using it instead of the pointer dereference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48655",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: firmware: arm_scmi: Harden accesses to the reset domains",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: arm_scmi: Harden accesses to the reset domains\n\nAccessing reset domains descriptors by the index upon the SCMI drivers\nrequests through the SCMI reset operations interface can potentially\nlead to out-of-bound violations if the SCMI driver misbehave.\n\nAdd an internal consistency check before any such domains descriptors\naccesses.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48657",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arm64: topology: fix possible overflow in amu_fie_setup()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: topology: fix possible overflow in amu_fie_setup()\n\ncpufreq_get_hw_max_freq() returns max frequency in kHz as *unsigned int*,\nwhile freq_inv_set_max_ratio() gets passed this frequency in Hz as 'u64'.\nMultiplying max frequency by 1000 can potentially result in overflow --\nmultiplying by 1000ULL instead should avoid that...\n\nFound by Linux Verification Center (linuxtesting.org) with the SVACE static\nanalysis tool.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48674",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: erofs: fix pcluster use-after-free on UP platforms",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nerofs: fix pcluster use-after-free on UP platforms\n\nDuring stress testing with CONFIG_SMP disabled, KASAN reports as below:\n\n==================================================================\nBUG: KASAN: use-after-free in __mutex_lock+0xe5/0xc30\nRead of size 8 at addr ffff8881094223f8 by task stress/7789\n\nCPU: 0 PID: 7789 Comm: stress Not tainted 6.0.0-rc1-00002-g0d53d2e882f9 #3\nHardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\nCall Trace:\n <TASK>\n..\n __mutex_lock+0xe5/0xc30\n..\n z_erofs_do_read_page+0x8ce/0x1560\n..\n z_erofs_readahead+0x31c/0x580\n..\nFreed by task 7787\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x20/0x30\n kasan_set_free_info+0x20/0x40\n __kasan_slab_free+0x10c/0x190\n kmem_cache_free+0xed/0x380\n rcu_core+0x3d5/0xc90\n __do_softirq+0x12d/0x389\n\nLast potentially related work creation:\n kasan_save_stack+0x1e/0x40\n __kasan_record_aux_stack+0x97/0xb0\n call_rcu+0x3d/0x3f0\n erofs_shrink_workstation+0x11f/0x210\n erofs_shrink_scan+0xdc/0x170\n shrink_slab.constprop.0+0x296/0x530\n drop_slab+0x1c/0x70\n drop_caches_sysctl_handler+0x70/0x80\n proc_sys_call_handler+0x20a/0x2f0\n vfs_write+0x555/0x6c0\n ksys_write+0xbe/0x160\n do_syscall_64+0x3b/0x90\n\nThe root cause is that erofs_workgroup_unfreeze() doesn't reset to\norig_val thus it causes a race that the pcluster reuses unexpectedly\nbefore freeing.\n\nSince UP platforms are quite rare now, such path becomes unnecessary.\nLet's drop such specific-designed path directly instead.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48733",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: fix use-after-free after failure to create a snapshot",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix use-after-free after failure to create a snapshot\n\nAt ioctl.c:create_snapshot(), we allocate a pending snapshot structure and\nthen attach it to the transaction's list of pending snapshots. After that\nwe call btrfs_commit_transaction(), and if that returns an error we jump\nto 'fail' label, where we kfree() the pending snapshot structure. This can\nresult in a later use-after-free of the pending snapshot:\n\n1) We allocated the pending snapshot and added it to the transaction's\n   list of pending snapshots;\n\n2) We call btrfs_commit_transaction(), and it fails either at the first\n   call to btrfs_run_delayed_refs() or btrfs_start_dirty_block_groups().\n   In both cases, we don't abort the transaction and we release our\n   transaction handle. We jump to the 'fail' label and free the pending\n   snapshot structure. We return with the pending snapshot still in the\n   transaction's list;\n\n3) Another task commits the transaction. This time there's no error at\n   all, and then during the transaction commit it accesses a pointer\n   to the pending snapshot structure that the snapshot creation task\n   has already freed, resulting in a user-after-free.\n\nThis issue could actually be detected by smatch, which produced the\nfollowing warning:\n\n  fs/btrfs/ioctl.c:843 create_snapshot() warn: '&pending_snapshot->list' not removed from list\n\nSo fix this by not having the snapshot creation ioctl directly add the\npending snapshot to the transaction's list. Instead add the pending\nsnapshot to the transaction handle, and then at btrfs_commit_transaction()\nwe add the snapshot to the list only when we can guarantee that any error\nreturned after that point will result in a transaction abort, in which\ncase the ioctl code can safely free the pending snapshot and no one can\naccess it anymore.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48744",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5e: Avoid field-overflowing memcpy()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Avoid field-overflowing memcpy()\n\nIn preparation for FORTIFY_SOURCE performing compile-time and run-time\nfield bounds checking for memcpy(), memmove(), and memset(), avoid\nintentionally writing across neighboring fields.\n\nUse flexible arrays instead of zero-element arrays (which look like they\nare always overflowing) and split the cross-field memcpy() into two halves\nthat can be appropriately bounds-checked by the compiler.\n\nWe were doing:\n\n\t#define ETH_HLEN  14\n\t#define VLAN_HLEN  4\n\t...\n\t#define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN)\n\t...\n        struct mlx5e_tx_wqe      *wqe  = mlx5_wq_cyc_get_wqe(wq, pi);\n\t...\n        struct mlx5_wqe_eth_seg  *eseg = &wqe->eth;\n        struct mlx5_wqe_data_seg *dseg = wqe->data;\n\t...\n\tmemcpy(eseg->inline_hdr.start, xdptxd->data, MLX5E_XDP_MIN_INLINE);\n\ntarget is wqe->eth.inline_hdr.start (which the compiler sees as being\n2 bytes in size), but copying 18, intending to write across start\n(really vlan_tci, 2 bytes). The remaining 16 bytes get written into\nwqe->data[0], covering byte_count (4 bytes), lkey (4 bytes), and addr\n(8 bytes).\n\nstruct mlx5e_tx_wqe {\n        struct mlx5_wqe_ctrl_seg   ctrl;                 /*     0    16 */\n        struct mlx5_wqe_eth_seg    eth;                  /*    16    16 */\n        struct mlx5_wqe_data_seg   data[];               /*    32     0 */\n\n        /* size: 32, cachelines: 1, members: 3 */\n        /* last cacheline: 32 bytes */\n};\n\nstruct mlx5_wqe_eth_seg {\n        u8                         swp_outer_l4_offset;  /*     0     1 */\n        u8                         swp_outer_l3_offset;  /*     1     1 */\n        u8                         swp_inner_l4_offset;  /*     2     1 */\n        u8                         swp_inner_l3_offset;  /*     3     1 */\n        u8                         cs_flags;             /*     4     1 */\n        u8                         swp_flags;            /*     5     1 */\n        __be16                     mss;                  /*     6     2 */\n        __be32                     flow_table_metadata;  /*     8     4 */\n        union {\n                struct {\n                        __be16     sz;                   /*    12     2 */\n                        u8         start[2];             /*    14     2 */\n                } inline_hdr;                            /*    12     4 */\n                struct {\n                        __be16     type;                 /*    12     2 */\n                        __be16     vlan_tci;             /*    14     2 */\n                } insert;                                /*    12     4 */\n                __be32             trailer;              /*    12     4 */\n        };                                               /*    12     4 */\n\n        /* size: 16, cachelines: 1, members: 9 */\n        /* last cacheline: 16 bytes */\n};\n\nstruct mlx5_wqe_data_seg {\n        __be32                     byte_count;           /*     0     4 */\n        __be32                     lkey;                 /*     4     4 */\n        __be64                     addr;                 /*     8     8 */\n\n        /* size: 16, cachelines: 1, members: 3 */\n        /* last cacheline: 16 bytes */\n};\n\nSo, split the memcpy() so the compiler can reason about the buffer\nsizes.\n\n\"pahole\" shows no size nor member offset changes to struct mlx5e_tx_wqe\nnor struct mlx5e_umr_wqe. \"objdump -d\" shows no meaningful object\ncode changes (i.e. only source line number induced differences and\noptimizations).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48827",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFSD: Fix the behavior of READ near OFFSET_MAX",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix the behavior of READ near OFFSET_MAX\n\nDan Aloni reports:\n> Due to commit 8cfb9015280d (\"NFS: Always provide aligned buffers to\n> the RPC read layers\") on the client, a read of 0xfff is aligned up\n> to server rsize of 0x1000.\n>\n> As a result, in a test where the server has a file of size\n> 0x7fffffffffffffff, and the client tries to read from the offset\n> 0x7ffffffffffff000, the read causes loff_t overflow in the server\n> and it returns an NFS code of EINVAL to the client. The client as\n> a result indefinitely retries the request.\n\nThe Linux NFS client does not handle NFS?ERR_INVAL, even though all\nNFS specifications permit servers to return that status code for a\nREAD.\n\nInstead of NFS?ERR_INVAL, have out-of-range READ requests succeed\nand return a short result. Set the EOF flag in the result to prevent\nthe client from retrying the READ request. This behavior appears to\nbe consistent with Solaris NFS servers.\n\nNote that NFSv3 and NFSv4 use u64 offset values on the wire. These\nmust be converted to loff_t internally before use -- an implicit\ntype cast is not adequate for this purpose. Otherwise VFS checks\nagainst sb->s_maxbytes do not work properly.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48871",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tty: serial: qcom-geni-serial: fix slab-out-of-bounds on RX FIFO buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: serial: qcom-geni-serial: fix slab-out-of-bounds on RX FIFO buffer\n\nDriver's probe allocates memory for RX FIFO (port->rx_fifo) based on\ndefault RX FIFO depth, e.g. 16.  Later during serial startup the\nqcom_geni_serial_port_setup() updates the RX FIFO depth\n(port->rx_fifo_depth) to match real device capabilities, e.g. to 32.\n\nThe RX UART handle code will read \"port->rx_fifo_depth\" number of words\ninto \"port->rx_fifo\" buffer, thus exceeding the bounds.  This can be\nobserved in certain configurations with Qualcomm Bluetooth HCI UART\ndevice and KASAN:\n\n  Bluetooth: hci0: QCA Product ID   :0x00000010\n  Bluetooth: hci0: QCA SOC Version  :0x400a0200\n  Bluetooth: hci0: QCA ROM Version  :0x00000200\n  Bluetooth: hci0: QCA Patch Version:0x00000d2b\n  Bluetooth: hci0: QCA controller version 0x02000200\n  Bluetooth: hci0: QCA Downloading qca/htbtfw20.tlv\n  bluetooth hci0: Direct firmware load for qca/htbtfw20.tlv failed with error -2\n  Bluetooth: hci0: QCA Failed to request file: qca/htbtfw20.tlv (-2)\n  Bluetooth: hci0: QCA Failed to download patch (-2)\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in handle_rx_uart+0xa8/0x18c\n  Write of size 4 at addr ffff279347d578c0 by task swapper/0/0\n\n  CPU: 0 PID: 0 Comm: swapper/0 Not tainted 6.1.0-rt5-00350-gb2450b7e00be-dirty #26\n  Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n  Call trace:\n   dump_backtrace.part.0+0xe0/0xf0\n   show_stack+0x18/0x40\n   dump_stack_lvl+0x8c/0xb8\n   print_report+0x188/0x488\n   kasan_report+0xb4/0x100\n   __asan_store4+0x80/0xa4\n   handle_rx_uart+0xa8/0x18c\n   qcom_geni_serial_handle_rx+0x84/0x9c\n   qcom_geni_serial_isr+0x24c/0x760\n   __handle_irq_event_percpu+0x108/0x500\n   handle_irq_event+0x6c/0x110\n   handle_fasteoi_irq+0x138/0x2cc\n   generic_handle_domain_irq+0x48/0x64\n\nIf the RX FIFO depth changes after probe, be sure to resize the buffer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48872",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: misc: fastrpc: Fix use-after-free race condition for maps",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: fastrpc: Fix use-after-free race condition for maps\n\nIt is possible that in between calling fastrpc_map_get() until\nmap->fl->lock is taken in fastrpc_free_map(), another thread can call\nfastrpc_map_lookup() and get a reference to a map that is about to be\ndeleted.\n\nRewrite fastrpc_map_get() to only increase the reference count of a map\nif it's non-zero. Propagate this to callers so they can know if a map is\nabout to be deleted.\n\nFixes this warning:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 5 PID: 10100 at lib/refcount.c:25 refcount_warn_saturate\n...\nCall trace:\n refcount_warn_saturate\n [fastrpc_map_get inlined]\n [fastrpc_map_lookup inlined]\n fastrpc_map_create\n fastrpc_internal_invoke\n fastrpc_device_ioctl\n __arm64_sys_ioctl\n invoke_syscall",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48873",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: misc: fastrpc: Don't remove map on creater_process and device_release",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: fastrpc: Don't remove map on creater_process and device_release\n\nDo not remove the map from the list on error path in\nfastrpc_init_create_process, instead call fastrpc_map_put, to avoid\nuse-after-free. Do not remove it on fastrpc_device_release either,\ncall fastrpc_map_put instead.\n\nThe fastrpc_free_map is the only proper place to remove the map.\nThis is called only after the reference count is 0.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48878",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: hci_qca: Fix driver shutdown on closed serdev",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_qca: Fix driver shutdown on closed serdev\n\nThe driver shutdown callback (which sends EDL_SOC_RESET to the device\nover serdev) should not be invoked when HCI device is not open (e.g. if\nhci_dev_open_sync() failed), because the serdev and its TTY are not open\neither.  Also skip this step if device is powered off\n(qca_power_shutdown()).\n\nThe shutdown callback causes use-after-free during system reboot with\nQualcomm Atheros Bluetooth:\n\n  Unable to handle kernel paging request at virtual address\n  0072662f67726fd7\n  ...\n  CPU: 6 PID: 1 Comm: systemd-shutdow Tainted: G        W\n  6.1.0-rt5-00325-g8a5f56bcfcca #8\n  Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n  Call trace:\n   tty_driver_flush_buffer+0x4/0x30\n   serdev_device_write_flush+0x24/0x34\n   qca_serdev_shutdown+0x80/0x130 [hci_uart]\n   device_shutdown+0x15c/0x260\n   kernel_restart+0x48/0xac\n\nKASAN report:\n\n  BUG: KASAN: use-after-free in tty_driver_flush_buffer+0x1c/0x50\n  Read of size 8 at addr ffff16270c2e0018 by task systemd-shutdow/1\n\n  CPU: 7 PID: 1 Comm: systemd-shutdow Not tainted\n  6.1.0-next-20221220-00014-gb85aaf97fb01-dirty #28\n  Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n  Call trace:\n   dump_backtrace.part.0+0xdc/0xf0\n   show_stack+0x18/0x30\n   dump_stack_lvl+0x68/0x84\n   print_report+0x188/0x488\n   kasan_report+0xa4/0xf0\n   __asan_load8+0x80/0xac\n   tty_driver_flush_buffer+0x1c/0x50\n   ttyport_write_flush+0x34/0x44\n   serdev_device_write_flush+0x48/0x60\n   qca_serdev_shutdown+0x124/0x274\n   device_shutdown+0x1e8/0x350\n   kernel_restart+0x48/0xb0\n   __do_sys_reboot+0x244/0x2d0\n   __arm64_sys_reboot+0x54/0x70\n   invoke_syscall+0x60/0x190\n   el0_svc_common.constprop.0+0x7c/0x160\n   do_el0_svc+0x44/0xf0\n   el0_svc+0x2c/0x6c\n   el0t_64_sync_handler+0xbc/0x140\n   el0t_64_sync+0x190/0x194",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48948",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: gadget: uvc: Prevent buffer overflow in setup handler",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: uvc: Prevent buffer overflow in setup handler\n\nSetup function uvc_function_setup permits control transfer\nrequests with up to 64 bytes of payload (UVC_MAX_REQUEST_SIZE),\ndata stage handler for OUT transfer uses memcpy to copy req->actual\nbytes to uvc_event->data.data array of size 60. This may result\nin an overflow of 4 bytes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48950",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf: Fix perf_pending_task() UaF",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix perf_pending_task() UaF\n\nPer syzbot it is possible for perf_pending_task() to run after the\nevent is free()'d. There are two related but distinct cases:\n\n - the task_work was already queued before destroying the event;\n - destroying the event itself queues the task_work.\n\nThe first cannot be solved using task_work_cancel() since\nperf_release() itself might be called from a task_work (____fput),\nwhich means the current->task_works list is already empty and\ntask_work_cancel() won't be able to find the perf_pending_task()\nentry.\n\nThe simplest alternative is extending the perf_event lifetime to cover\nthe task_work.\n\nThe second is just silly, queueing a task_work while you know the\nevent is going away makes no sense and is easily avoided by\nre-arranging how the event is marked STATE_DEAD and ensuring it goes\nthrough STATE_OFF on the way down.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48951",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: ops: Check bounds for second channel in snd_soc_put_volsw_sx()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: ops: Check bounds for second channel in snd_soc_put_volsw_sx()\n\nThe bounds checks in snd_soc_put_volsw_sx() are only being applied to the\nfirst channel, meaning it is possible to write out of bounds values to the\nsecond channel in stereo controls. Add appropriate checks.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48956",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv6: avoid use-after-free in ip6_fragment()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: avoid use-after-free in ip6_fragment()\n\nBlamed commit claimed rcu_read_lock() was held by ip6_fragment() callers.\n\nIt seems to not be always true, at least for UDP stack.\n\nsyzbot reported:\n\nBUG: KASAN: use-after-free in ip6_dst_idev include/net/ip6_fib.h:245 [inline]\nBUG: KASAN: use-after-free in ip6_fragment+0x2724/0x2770 net/ipv6/ip6_output.c:951\nRead of size 8 at addr ffff88801d403e80 by task syz-executor.3/7618\n\nCPU: 1 PID: 7618 Comm: syz-executor.3 Not tainted 6.1.0-rc6-syzkaller-00012-g4312098baf37 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:284 [inline]\n print_report+0x15e/0x45d mm/kasan/report.c:395\n kasan_report+0xbf/0x1f0 mm/kasan/report.c:495\n ip6_dst_idev include/net/ip6_fib.h:245 [inline]\n ip6_fragment+0x2724/0x2770 net/ipv6/ip6_output.c:951\n __ip6_finish_output net/ipv6/ip6_output.c:193 [inline]\n ip6_finish_output+0x9a3/0x1170 net/ipv6/ip6_output.c:206\n NF_HOOK_COND include/linux/netfilter.h:291 [inline]\n ip6_output+0x1f1/0x540 net/ipv6/ip6_output.c:227\n dst_output include/net/dst.h:445 [inline]\n ip6_local_out+0xb3/0x1a0 net/ipv6/output_core.c:161\n ip6_send_skb+0xbb/0x340 net/ipv6/ip6_output.c:1966\n udp_v6_send_skb+0x82a/0x18a0 net/ipv6/udp.c:1286\n udp_v6_push_pending_frames+0x140/0x200 net/ipv6/udp.c:1313\n udpv6_sendmsg+0x18da/0x2c80 net/ipv6/udp.c:1606\n inet6_sendmsg+0x9d/0xe0 net/ipv6/af_inet6.c:665\n sock_sendmsg_nosec net/socket.c:714 [inline]\n sock_sendmsg+0xd3/0x120 net/socket.c:734\n sock_write_iter+0x295/0x3d0 net/socket.c:1108\n call_write_iter include/linux/fs.h:2191 [inline]\n new_sync_write fs/read_write.c:491 [inline]\n vfs_write+0x9ed/0xdd0 fs/read_write.c:584\n ksys_write+0x1ec/0x250 fs/read_write.c:637\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7fde3588c0d9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fde365b6168 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 00007fde359ac050 RCX: 00007fde3588c0d9\nRDX: 000000000000ffdc RSI: 00000000200000c0 RDI: 000000000000000a\nRBP: 00007fde358e7ae9 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fde35acfb1f R14: 00007fde365b6300 R15: 0000000000022000\n </TASK>\n\nAllocated by task 7618:\n kasan_save_stack+0x22/0x40 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n __kasan_slab_alloc+0x82/0x90 mm/kasan/common.c:325\n kasan_slab_alloc include/linux/kasan.h:201 [inline]\n slab_post_alloc_hook mm/slab.h:737 [inline]\n slab_alloc_node mm/slub.c:3398 [inline]\n slab_alloc mm/slub.c:3406 [inline]\n __kmem_cache_alloc_lru mm/slub.c:3413 [inline]\n kmem_cache_alloc+0x2b4/0x3d0 mm/slub.c:3422\n dst_alloc+0x14a/0x1f0 net/core/dst.c:92\n ip6_dst_alloc+0x32/0xa0 net/ipv6/route.c:344\n ip6_rt_pcpu_alloc net/ipv6/route.c:1369 [inline]\n rt6_make_pcpu_route net/ipv6/route.c:1417 [inline]\n ip6_pol_route+0x901/0x1190 net/ipv6/route.c:2254\n pol_lookup_func include/net/ip6_fib.h:582 [inline]\n fib6_rule_lookup+0x52e/0x6f0 net/ipv6/fib6_rules.c:121\n ip6_route_output_flags_noref+0x2e6/0x380 net/ipv6/route.c:2625\n ip6_route_output_flags+0x76/0x320 net/ipv6/route.c:2638\n ip6_route_output include/net/ip6_route.h:98 [inline]\n ip6_dst_lookup_tail+0x5ab/0x1620 net/ipv6/ip6_output.c:1092\n ip6_dst_lookup_flow+0x90/0x1d0 net/ipv6/ip6_output.c:1222\n ip6_sk_dst_lookup_flow+0x553/0x980 net/ipv6/ip6_output.c:1260\n udpv6_sendmsg+0x151d/0x2c80 net/ipv6/udp.c:1554\n inet6_sendmsg+0x9d/0xe0 net/ipv6/af_inet6.c:665\n sock_sendmsg_nosec n\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48960",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: hisilicon: Fix potential use-after-free in hix5hd2_rx()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hisilicon: Fix potential use-after-free in hix5hd2_rx()\n\nThe skb is delivered to napi_gro_receive() which may free it, after\ncalling this, dereferencing skb may trigger use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48962",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: hisilicon: Fix potential use-after-free in hisi_femac_rx()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hisilicon: Fix potential use-after-free in hisi_femac_rx()\n\nThe skb is delivered to napi_gro_receive() which may free it, after\ncalling this, dereferencing skb may trigger use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48966",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: mvneta: Prevent out of bounds read in mvneta_config_rss()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mvneta: Prevent out of bounds read in mvneta_config_rss()\n\nThe pp->indir[0] value comes from the user.  It is passed to:\n\n\tif (cpu_online(pp->rxq_def))\n\ninside the mvneta_percpu_elect() function.  It needs bounds checkeding\nto ensure that it is not beyond the end of the cpu bitmap.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48967",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFC: nci: Bounds check struct nfc_target arrays",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFC: nci: Bounds check struct nfc_target arrays\n\nWhile running under CONFIG_FORTIFY_SOURCE=y, syzkaller reported:\n\n  memcpy: detected field-spanning write (size 129) of single field \"target->sensf_res\" at net/nfc/nci/ntf.c:260 (size 18)\n\nThis appears to be a legitimate lack of bounds checking in\nnci_add_new_protocol(). Add the missing checks.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48981",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/shmem-helper: Remove errant put in error path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/shmem-helper: Remove errant put in error path\n\ndrm_gem_shmem_mmap() doesn't own this reference, resulting in the GEM\nobject getting prematurely freed leading to a later use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48988",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: memcg: fix possible use-after-free in memcg_write_event_control()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemcg: fix possible use-after-free in memcg_write_event_control()\n\nmemcg_write_event_control() accesses the dentry->d_name of the specified\ncontrol fd to route the write call.  As a cgroup interface file can't be\nrenamed, it's safe to access d_name as long as the specified file is a\nregular cgroup file.  Also, as these cgroup interface files can't be\nremoved before the directory, it's safe to access the parent too.\n\nPrior to 347c4a874710 (\"memcg: remove cgroup_event->cft\"), there was a\ncall to __file_cft() which verified that the specified file is a regular\ncgroupfs file before further accesses.  The cftype pointer returned from\n__file_cft() was no longer necessary and the commit inadvertently dropped\nthe file type check with it allowing any file to slip through.  With the\ninvarients broken, the d_name and parent accesses can now race against\nrenames and removals of arbitrary files and cause use-after-free's.\n\nFix the bug by resurrecting the file type check in __file_cft().  Now that\ncgroupfs is implemented through kernfs, checking the file operations needs\nto go through a layer of indirection.  Instead, let's check the superblock\nand dentry type.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48991",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm/khugepaged: invoke MMU notifiers in shmem/file collapse paths",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/khugepaged: invoke MMU notifiers in shmem/file collapse paths\n\nAny codepath that zaps page table entries must invoke MMU notifiers to\nensure that secondary MMUs (like KVM) don't keep accessing pages which\naren't mapped anymore.  Secondary MMUs don't hold their own references to\npages that are mirrored over, so failing to notify them can lead to page\nuse-after-free.\n\nI'm marking this as addressing an issue introduced in commit f3f0e1d2150b\n(\"khugepaged: add support of collapse for tmpfs/shmem pages\"), but most of\nthe security impact of this only came in commit 27e1f8273113 (\"khugepaged:\nenable collapse pmd for pte-mapped THP\"), which actually omitted flushes\nfor the removal of present PTEs, not just for the removal of empty page\ntables.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-48999",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv4: Handle attempt to delete multipath route when fib_info contains an nh reference",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv4: Handle attempt to delete multipath route when fib_info contains an nh reference\n\nGwangun Jung reported a slab-out-of-bounds access in fib_nh_match:\n    fib_nh_match+0xf98/0x1130 linux-6.0-rc7/net/ipv4/fib_semantics.c:961\n    fib_table_delete+0x5f3/0xa40 linux-6.0-rc7/net/ipv4/fib_trie.c:1753\n    inet_rtm_delroute+0x2b3/0x380 linux-6.0-rc7/net/ipv4/fib_frontend.c:874\n\nSeparate nexthop objects are mutually exclusive with the legacy\nmultipath spec. Fix fib_nh_match to return if the config for the\nto be deleted route contains a multipath spec while the fib_info\nis using a nexthop object.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49006",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tracing: Free buffers when a used dynamic event is removed",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Free buffers when a used dynamic event is removed\n\nAfter 65536 dynamic events have been added and removed, the \"type\" field\nof the event then uses the first type number that is available (not\ncurrently used by other events). A type number is the identifier of the\nbinary blobs in the tracing ring buffer (known as events) to map them to\nlogic that can parse the binary blob.\n\nThe issue is that if a dynamic event (like a kprobe event) is traced and\nis in the ring buffer, and then that event is removed (because it is\ndynamic, which means it can be created and destroyed), if another dynamic\nevent is created that has the same number that new event's logic on\nparsing the binary blob will be used.\n\nTo show how this can be an issue, the following can crash the kernel:\n\n # cd /sys/kernel/tracing\n # for i in `seq 65536`; do\n     echo 'p:kprobes/foo do_sys_openat2 $arg1:u32' > kprobe_events\n # done\n\nFor every iteration of the above, the writing to the kprobe_events will\nremove the old event and create a new one (with the same format) and\nincrease the type number to the next available on until the type number\nreaches over 65535 which is the max number for the 16 bit type. After it\nreaches that number, the logic to allocate a new number simply looks for\nthe next available number. When an dynamic event is removed, that number\nis then available to be reused by the next dynamic event created. That is,\nonce the above reaches the max number, the number assigned to the event in\nthat loop will remain the same.\n\nNow that means deleting one dynamic event and created another will reuse\nthe previous events type number. This is where bad things can happen.\nAfter the above loop finishes, the kprobes/foo event which reads the\ndo_sys_openat2 function call's first parameter as an integer.\n\n # echo 1 > kprobes/foo/enable\n # cat /etc/passwd > /dev/null\n # cat trace\n             cat-2211    [005] ....  2007.849603: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849620: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849838: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849880: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n # echo 0 > kprobes/foo/enable\n\nNow if we delete the kprobe and create a new one that reads a string:\n\n # echo 'p:kprobes/foo do_sys_openat2 +0($arg2):string' > kprobe_events\n\nAnd now we can the trace:\n\n # cat trace\n        sendmail-1942    [002] .....   530.136320: foo: (do_sys_openat2+0x0/0x240) arg1=             cat-2046    [004] .....   530.930817: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\"\n             cat-2046    [004] .....   530.930961: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\"\n             cat-2046    [004] .....   530.934278: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\"\n             cat-2046    [004] .....   530.934563: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49014",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: tun: Fix use-after-free in tun_detach()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: tun: Fix use-after-free in tun_detach()\n\nsyzbot reported use-after-free in tun_detach() [1].  This causes call\ntrace like below:\n\n==================================================================\nBUG: KASAN: use-after-free in notifier_call_chain+0x1ee/0x200 kernel/notifier.c:75\nRead of size 8 at addr ffff88807324e2a8 by task syz-executor.0/3673\n\nCPU: 0 PID: 3673 Comm: syz-executor.0 Not tainted 6.1.0-rc5-syzkaller-00044-gcc675d22e422 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:284 [inline]\n print_report+0x15e/0x461 mm/kasan/report.c:395\n kasan_report+0xbf/0x1f0 mm/kasan/report.c:495\n notifier_call_chain+0x1ee/0x200 kernel/notifier.c:75\n call_netdevice_notifiers_info+0x86/0x130 net/core/dev.c:1942\n call_netdevice_notifiers_extack net/core/dev.c:1983 [inline]\n call_netdevice_notifiers net/core/dev.c:1997 [inline]\n netdev_wait_allrefs_any net/core/dev.c:10237 [inline]\n netdev_run_todo+0xbc6/0x1100 net/core/dev.c:10351\n tun_detach drivers/net/tun.c:704 [inline]\n tun_chr_close+0xe4/0x190 drivers/net/tun.c:3467\n __fput+0x27c/0xa90 fs/file_table.c:320\n task_work_run+0x16f/0x270 kernel/task_work.c:179\n exit_task_work include/linux/task_work.h:38 [inline]\n do_exit+0xb3d/0x2a30 kernel/exit.c:820\n do_group_exit+0xd4/0x2a0 kernel/exit.c:950\n get_signal+0x21b1/0x2440 kernel/signal.c:2858\n arch_do_signal_or_restart+0x86/0x2300 arch/x86/kernel/signal.c:869\n exit_to_user_mode_loop kernel/entry/common.c:168 [inline]\n exit_to_user_mode_prepare+0x15f/0x250 kernel/entry/common.c:203\n __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]\n syscall_exit_to_user_mode+0x1d/0x50 kernel/entry/common.c:296\n do_syscall_64+0x46/0xb0 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe cause of the issue is that sock_put() from __tun_detach() drops\nlast reference count for struct net, and then notifier_call_chain()\nfrom netdev_state_change() accesses that struct net.\n\nThis patch fixes the issue by calling sock_put() from tun_detach()\nafter all necessary accesses for the struct net has done.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49015",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: hsr: Fix potential use-after-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hsr: Fix potential use-after-free\n\nThe skb is delivered to netif_rx() which may free it, after calling this,\ndereferencing skb may trigger use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49017",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tipc: re-fetch skb cb after tipc_msg_validate",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: re-fetch skb cb after tipc_msg_validate\n\nAs the call trace shows, the original skb was freed in tipc_msg_validate(),\nand dereferencing the old skb cb would cause an use-after-free crash.\n\n  BUG: KASAN: use-after-free in tipc_crypto_rcv_complete+0x1835/0x2240 [tipc]\n  Call Trace:\n   <IRQ>\n   tipc_crypto_rcv_complete+0x1835/0x2240 [tipc]\n   tipc_crypto_rcv+0xd32/0x1ec0 [tipc]\n   tipc_rcv+0x744/0x1150 [tipc]\n  ...\n  Allocated by task 47078:\n   kmem_cache_alloc_node+0x158/0x4d0\n   __alloc_skb+0x1c1/0x270\n   tipc_buf_acquire+0x1e/0xe0 [tipc]\n   tipc_msg_create+0x33/0x1c0 [tipc]\n   tipc_link_build_proto_msg+0x38a/0x2100 [tipc]\n   tipc_link_timeout+0x8b8/0xef0 [tipc]\n   tipc_node_timeout+0x2a1/0x960 [tipc]\n   call_timer_fn+0x2d/0x1c0\n  ...\n  Freed by task 47078:\n   tipc_msg_validate+0x7b/0x440 [tipc]\n   tipc_crypto_rcv_complete+0x4b5/0x2240 [tipc]\n   tipc_crypto_rcv+0xd32/0x1ec0 [tipc]\n   tipc_rcv+0x744/0x1150 [tipc]\n\nThis patch fixes it by re-fetching the skb cb from the new allocated skb\nafter calling tipc_msg_validate().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49022",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mac8021: fix possible oob access in ieee80211_get_rate_duration",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac8021: fix possible oob access in ieee80211_get_rate_duration\n\nFix possible out-of-bound access in ieee80211_get_rate_duration routine\nas reported by the following UBSAN report:\n\nUBSAN: array-index-out-of-bounds in net/mac80211/airtime.c:455:47\nindex 15 is out of range for type 'u16 [12]'\nCPU: 2 PID: 217 Comm: kworker/u32:10 Not tainted 6.1.0-060100rc3-generic\nHardware name: Acer Aspire TC-281/Aspire TC-281, BIOS R01-A2 07/18/2017\nWorkqueue: mt76 mt76u_tx_status_data [mt76_usb]\nCall Trace:\n <TASK>\n show_stack+0x4e/0x61\n dump_stack_lvl+0x4a/0x6f\n dump_stack+0x10/0x18\n ubsan_epilogue+0x9/0x43\n __ubsan_handle_out_of_bounds.cold+0x42/0x47\nieee80211_get_rate_duration.constprop.0+0x22f/0x2a0 [mac80211]\n ? ieee80211_tx_status_ext+0x32e/0x640 [mac80211]\n ieee80211_calc_rx_airtime+0xda/0x120 [mac80211]\n ieee80211_calc_tx_airtime+0xb4/0x100 [mac80211]\n mt76x02_send_tx_status+0x266/0x480 [mt76x02_lib]\n mt76x02_tx_status_data+0x52/0x80 [mt76x02_lib]\n mt76u_tx_status_data+0x67/0xd0 [mt76_usb]\n process_one_work+0x225/0x400\n worker_thread+0x50/0x3e0\n ? process_one_work+0x400/0x400\n kthread+0xe9/0x110\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x22/0x30",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49023",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: cfg80211: fix buffer overflow in elem comparison",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: fix buffer overflow in elem comparison\n\nFor vendor elements, the code here assumes that 5 octets\nare present without checking. Since the element itself is\nalready checked to fit, we only need to check the length.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49025",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5e: Fix use-after-free when reverting termination table",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix use-after-free when reverting termination table\n\nWhen having multiple dests with termination tables and second one\nor afterwards fails the driver reverts usage of term tables but\ndoesn't reset the assignment in attr->dests[num_vport_dests].termtbl\nwhich case a use-after-free when releasing the rule.\nFix by resetting the assignment of termtbl to null.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49026",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: e100: Fix possible use after free in e100_xmit_prepare",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ne100: Fix possible use after free in e100_xmit_prepare\n\nIn e100_xmit_prepare(), if we can't map the skb, then return -ENOMEM, so\ne100_xmit_frame() will return NETDEV_TX_BUSY and the upper layer will\nresend the skb. But the skb is already freed, which will cause UAF bug\nwhen the upper layer resends the skb.\n\nRemove the harmful free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49029",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hwmon: (ibmpex) Fix possible UAF when ibmpex_register_bmc() fails",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (ibmpex) Fix possible UAF when ibmpex_register_bmc() fails\n\nSmatch report warning as follows:\n\ndrivers/hwmon/ibmpex.c:509 ibmpex_register_bmc() warn:\n  '&data->list' not removed from list\n\nIf ibmpex_find_sensors() fails in ibmpex_register_bmc(), data will\nbe freed, but data->list will not be removed from driver_data.bmc_data,\nthen list traversal may cause UAF.\n\nFix by removeing it from driver_data.bmc_data before free().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49030",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: libbpf: Handle size overflow for ringbuf mmap",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibbpf: Handle size overflow for ringbuf mmap\n\nThe maximum size of ringbuf is 2GB on x86-64 host, so 2 * max_entries\nwill overflow u32 when mapping producer page and data pages. Only\ncasting max_entries to size_t is not enough, because for 32-bits\napplication on 64-bits kernel the size of read-only mmap region\nalso could overflow size_t.\n\nSo fixing it by casting the size of read-only mmap region into a __u64\nand checking whether or not there will be overflow during mmap.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49031",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: health: afe4403: Fix oob read in afe4403_read_raw",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: health: afe4403: Fix oob read in afe4403_read_raw\n\nKASAN report out-of-bounds read as follows:\n\nBUG: KASAN: global-out-of-bounds in afe4403_read_raw+0x42e/0x4c0\nRead of size 4 at addr ffffffffc02ac638 by task cat/279\n\nCall Trace:\n afe4403_read_raw\n iio_read_channel_info\n dev_attr_show\n\nThe buggy address belongs to the variable:\n afe4403_channel_leds+0x18/0xffffffffffffe9e0\n\nThis issue can be reproduced by singe command:\n\n $ cat /sys/bus/spi/devices/spi0.0/iio\\:device0/in_intensity6_raw\n\nThe array size of afe4403_channel_leds is less than channels, so access\nwith chan->address cause OOB read in afe4403_read_raw. Fix it by moving\naccess before use it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49032",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: health: afe4404: Fix oob read in afe4404_[read|write]_raw",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: health: afe4404: Fix oob read in afe4404_[read|write]_raw\n\nKASAN report out-of-bounds read as follows:\n\nBUG: KASAN: global-out-of-bounds in afe4404_read_raw+0x2ce/0x380\nRead of size 4 at addr ffffffffc00e4658 by task cat/278\n\nCall Trace:\n afe4404_read_raw\n iio_read_channel_info\n dev_attr_show\n\nThe buggy address belongs to the variable:\n afe4404_channel_leds+0x18/0xffffffffffffe9c0\n\nThis issue can be reproduce by singe command:\n\n $ cat /sys/bus/i2c/devices/0-0058/iio\\:device0/in_intensity6_raw\n\nThe array size of afe4404_channel_leds and afe4404_channel_offdacs\nare less than channels, so access with chan->address cause OOB read\nin afe4404_[read|write]_raw. Fix it by moving access before use them.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49172",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: parisc: Fix non-access data TLB cache flush faults",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Fix non-access data TLB cache flush faults\n\nWhen a page is not present, we get non-access data TLB faults from\nthe fdc and fic instructions in flush_user_dcache_range_asm and\nflush_user_icache_range_asm. When these occur, the cache line is\nnot invalidated and potentially we get memory corruption. The\nproblem was hidden by the nullification of the flush instructions.\n\nThese faults also affect performance. With pa8800/pa8900 processors,\nthere will be 32 faults per 4 KB page since the cache line is 128\nbytes.  There will be more faults with earlier processors.\n\nThe problem is fixed by using flush_cache_pages(). It does the flush\nusing a tmp alias mapping.\n\nThe flush_cache_pages() call in flush_cache_range() flushed too\nlarge a range.\n\nV2: Remove unnecessary preempt_disable() and preempt_enable() calls.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49218",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/dp: Fix OOB read when handling Post Cursor2 register",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/dp: Fix OOB read when handling Post Cursor2 register\n\nThe link_status array was not large enough to read the Adjust Request\nPost Cursor2 register, so remove the common helper function to avoid\nan OOB read, found with a -Warray-bounds build:\n\ndrivers/gpu/drm/drm_dp_helper.c: In function 'drm_dp_get_adjust_request_post_cursor':\ndrivers/gpu/drm/drm_dp_helper.c:59:27: error: array subscript 10 is outside array bounds of 'const u8[6]' {aka 'const unsigned char[6]'} [-Werror=array-bounds]\n   59 |         return link_status[r - DP_LANE0_1_STATUS];\n      |                ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\ndrivers/gpu/drm/drm_dp_helper.c:147:51: note: while referencing 'link_status'\n  147 | u8 drm_dp_get_adjust_request_post_cursor(const u8 link_status[DP_LINK_STATUS_SIZE],\n      |                                          ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReplace the only user of the helper with an open-coded fetch and decode,\nsimilar to drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49234",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: dsa: Avoid cross-chip syncing of VLAN filtering",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: Avoid cross-chip syncing of VLAN filtering\n\nChanges to VLAN filtering are not applicable to cross-chip\nnotifications.\n\nOn a system like this:\n\n.-----.   .-----.   .-----.\n| sw1 +---+ sw2 +---+ sw3 |\n'-1-2-'   '-1-2-'   '-1-2-'\n\nBefore this change, upon sw1p1 leaving a bridge, a call to\ndsa_port_vlan_filtering would also be made to sw2p1 and sw3p1.\n\nIn this scenario:\n\n.---------.   .-----.   .-----.\n|   sw1   +---+ sw2 +---+ sw3 |\n'-1-2-3-4-'   '-1-2-'   '-1-2-'\n\nWhen sw1p4 would leave a bridge, dsa_port_vlan_filtering would be\ncalled for sw2 and sw3 with a non-existing port - leading to array\nout-of-bounds accesses and crashes on mv88e6xxx.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49267",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mmc: core: use sysfs_emit() instead of sprintf()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmmc: core: use sysfs_emit() instead of sprintf()\n\nsprintf() (still used in the MMC core for the sysfs output) is vulnerable\nto the buffer overflow.  Use the new-fangled sysfs_emit() instead.\n\nFound by Linux Verification Center (linuxtesting.org) with the SVACE static\nanalysis tool.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49289",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: uaccess: fix integer overflow on access_ok()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuaccess: fix integer overflow on access_ok()\n\nThree architectures check the end of a user access against the\naddress limit without taking a possible overflow into account.\nPassing a negative length or another overflow in here returns\nsuccess when it should not.\n\nUse the most common correct implementation here, which optimizes\nfor a constant 'size' argument, and turns the common case into a\nsingle comparison.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49328",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mt76: fix use-after-free by removing a non-RCU wcid pointer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: fix use-after-free by removing a non-RCU wcid pointer\n\nFixes an issue caught by KASAN about use-after-free in mt76_txq_schedule\nby protecting mtxq->wcid with rcu_lock between mt76_txq_schedule and\nsta_info_[alloc, free].\n\n[18853.876689] ==================================================================\n[18853.876751] BUG: KASAN: use-after-free in mt76_txq_schedule+0x204/0xaf8 [mt76]\n[18853.876773] Read of size 8 at addr ffffffaf989a2138 by task mt76-tx phy0/883\n[18853.876786]\n[18853.876810] CPU: 5 PID: 883 Comm: mt76-tx phy0 Not tainted 5.10.100-fix-510-56778d365941-kasan #5 0b01fbbcf41a530f52043508fec2e31a4215\n\n[18853.876840] Call trace:\n[18853.876861]  dump_backtrace+0x0/0x3ec\n[18853.876878]  show_stack+0x20/0x2c\n[18853.876899]  dump_stack+0x11c/0x1ac\n[18853.876918]  print_address_description+0x74/0x514\n[18853.876934]  kasan_report+0x134/0x174\n[18853.876948]  __asan_report_load8_noabort+0x44/0x50\n[18853.876976]  mt76_txq_schedule+0x204/0xaf8 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]\n[18853.877002]  mt76_txq_schedule_all+0x2c/0x48 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]\n[18853.877030]  mt7921_tx_worker+0xa0/0x1cc [mt7921_common f0875ebac9d7b4754e1010549e7db50fbd90a047]\n[18853.877054]  __mt76_worker_fn+0x190/0x22c [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]\n[18853.877071]  kthread+0x2f8/0x3b8\n[18853.877087]  ret_from_fork+0x10/0x30\n[18853.877098]\n[18853.877112] Allocated by task 941:\n[18853.877131]  kasan_save_stack+0x38/0x68\n[18853.877147]  __kasan_kmalloc+0xd4/0xfc\n[18853.877163]  kasan_kmalloc+0x10/0x1c\n[18853.877177]  __kmalloc+0x264/0x3c4\n[18853.877294]  sta_info_alloc+0x460/0xf88 [mac80211]\n[18853.877410]  ieee80211_prep_connection+0x204/0x1ee0 [mac80211]\n[18853.877523]  ieee80211_mgd_auth+0x6c4/0xa4c [mac80211]\n[18853.877635]  ieee80211_auth+0x20/0x2c [mac80211]\n[18853.877733]  rdev_auth+0x7c/0x438 [cfg80211]\n[18853.877826]  cfg80211_mlme_auth+0x26c/0x390 [cfg80211]\n[18853.877919]  nl80211_authenticate+0x6d4/0x904 [cfg80211]\n[18853.877938]  genl_rcv_msg+0x748/0x93c\n[18853.877954]  netlink_rcv_skb+0x160/0x2a8\n[18853.877969]  genl_rcv+0x3c/0x54\n[18853.877985]  netlink_unicast_kernel+0x104/0x1ec\n[18853.877999]  netlink_unicast+0x178/0x268\n[18853.878015]  netlink_sendmsg+0x3cc/0x5f0\n[18853.878030]  sock_sendmsg+0xb4/0xd8\n[18853.878043]  ____sys_sendmsg+0x2f8/0x53c\n[18853.878058]  ___sys_sendmsg+0xe8/0x150\n[18853.878071]  __sys_sendmsg+0xc4/0x1f4\n[18853.878087]  __arm64_compat_sys_sendmsg+0x88/0x9c\n[18853.878101]  el0_svc_common+0x1b4/0x390\n[18853.878115]  do_el0_svc_compat+0x8c/0xdc\n[18853.878131]  el0_svc_compat+0x10/0x1c\n[18853.878146]  el0_sync_compat_handler+0xa8/0xcc\n[18853.878161]  el0_sync_compat+0x188/0x1c0\n[18853.878171]\n[18853.878183] Freed by task 10927:\n[18853.878200]  kasan_save_stack+0x38/0x68\n[18853.878215]  kasan_set_track+0x28/0x3c\n[18853.878228]  kasan_set_free_info+0x24/0x48\n[18853.878244]  __kasan_slab_free+0x11c/0x154\n[18853.878259]  kasan_slab_free+0x14/0x24\n[18853.878273]  slab_free_freelist_hook+0xac/0x1b0\n[18853.878287]  kfree+0x104/0x390\n[18853.878402]  sta_info_free+0x198/0x210 [mac80211]\n[18853.878515]  __sta_info_destroy_part2+0x230/0x2d4 [mac80211]\n[18853.878628]  __sta_info_flush+0x300/0x37c [mac80211]\n[18853.878740]  ieee80211_set_disassoc+0x2cc/0xa7c [mac80211]\n[18853.878851]  ieee80211_mgd_deauth+0x4a4/0x10a0 [mac80211]\n[18853.878962]  ieee80211_deauth+0x20/0x2c [mac80211]\n[18853.879057]  rdev_deauth+0x7c/0x438 [cfg80211]\n[18853.879150]  cfg80211_mlme_deauth+0x274/0x414 [cfg80211]\n[18853.879243]  cfg80211_mlme_down+0xe4/0x118 [cfg80211]\n[18853.879335]  cfg80211_disconnect+0x218/0x2d8 [cfg80211]\n[18853.879427]  __cfg80211_leave+0x17c/0x240 [cfg80211]\n[18853.879519]  cfg80211_leave+0x3c/0x58 [cfg80211]\n[18853.879611]  wiphy_suspend+0xdc/0x200 [cfg80211]\n[18853.879628]  dpm_run_callback+0x58/0x408\n[18853.879642]  __device_suspend+0x4cc/0x864\n[18853.879658]  async_suspend+0x34/0xf4\n[18\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49359",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/panfrost: Job should reference MMU not file_priv",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/panfrost: Job should reference MMU not file_priv\n\nFor a while now it's been allowed for a MMU context to outlive it's\ncorresponding panfrost_priv, however the job structure still references\npanfrost_priv to get hold of the MMU context. If panfrost_priv has been\nfreed this is a use-after-free which I've been able to trigger resulting\nin a splat.\n\nTo fix this, drop the reference to panfrost_priv in the job structure\nand add a direct reference to the MMU structure which is what's actually\nneeded.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49362",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFSD: Fix potential use-after-free in nfsd_file_put()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix potential use-after-free in nfsd_file_put()\n\nnfsd_file_put_noref() can free @nf, so don't dereference @nf\nimmediately upon return from nfsd_file_put_noref().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49444",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: module: fix [e_shstrndx].sh_size=0 OOB access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmodule: fix [e_shstrndx].sh_size=0 OOB access\n\nIt is trivial to craft a module to trigger OOB access in this line:\n\n\tif (info->secstrings[strhdr->sh_size - 1] != '\\0') {\n\nBUG: unable to handle page fault for address: ffffc90000aa0fff\nPGD 100000067 P4D 100000067 PUD 100066067 PMD 10436f067 PTE 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 7 PID: 1215 Comm: insmod Not tainted 5.18.0-rc5-00007-g9bf578647087-dirty #10\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04/01/2014\nRIP: 0010:load_module+0x19b/0x2391\n\n[rebased patch onto modules-next]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49470",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: btmtksdio: fix use-after-free at btmtksdio_recv_event",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btmtksdio: fix use-after-free at btmtksdio_recv_event\n\nWe should not access skb buffer data anymore after hci_recv_frame was\ncalled.\n\n[   39.634809] BUG: KASAN: use-after-free in btmtksdio_recv_event+0x1b0\n[   39.634855] Read of size 1 at addr ffffff80cf28a60d by task kworker\n[   39.634962] Call trace:\n[   39.634974]  dump_backtrace+0x0/0x3b8\n[   39.634999]  show_stack+0x20/0x2c\n[   39.635016]  dump_stack_lvl+0x60/0x78\n[   39.635040]  print_address_description+0x70/0x2f0\n[   39.635062]  kasan_report+0x154/0x194\n[   39.635079]  __asan_report_load1_noabort+0x44/0x50\n[   39.635099]  btmtksdio_recv_event+0x1b0/0x1c4\n[   39.635129]  btmtksdio_txrx_work+0x6cc/0xac4\n[   39.635157]  process_one_work+0x560/0xc5c\n[   39.635177]  worker_thread+0x7ec/0xcc0\n[   39.635195]  kthread+0x2d0/0x3d0\n[   39.635215]  ret_from_fork+0x10/0x20\n[   39.635247] Allocated by task 0:\n[   39.635260] (stack is not available)\n[   39.635281] Freed by task 2392:\n[   39.635295]  kasan_save_stack+0x38/0x68\n[   39.635319]  kasan_set_track+0x28/0x3c\n[   39.635338]  kasan_set_free_info+0x28/0x4c\n[   39.635357]  ____kasan_slab_free+0x104/0x150\n[   39.635374]  __kasan_slab_free+0x18/0x28\n[   39.635391]  slab_free_freelist_hook+0x114/0x248\n[   39.635410]  kfree+0xf8/0x2b4\n[   39.635427]  skb_free_head+0x58/0x98\n[   39.635447]  skb_release_data+0x2f4/0x410\n[   39.635464]  skb_release_all+0x50/0x60\n[   39.635481]  kfree_skb+0xc8/0x25c\n[   39.635498]  hci_event_packet+0x894/0xca4 [bluetooth]\n[   39.635721]  hci_rx_work+0x1c8/0x68c [bluetooth]\n[   39.635925]  process_one_work+0x560/0xc5c\n[   39.635951]  worker_thread+0x7ec/0xcc0\n[   39.635970]  kthread+0x2d0/0x3d0\n[   39.635990]  ret_from_fork+0x10/0x20\n[   39.636021] The buggy address belongs to the object at ffffff80cf28a600\n                which belongs to the cache kmalloc-512 of size 512\n[   39.636039] The buggy address is located 13 bytes inside of\n                512-byte region [ffffff80cf28a600, ffffff80cf28a800)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49541",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cifs: fix potential double free during failed mount",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix potential double free during failed mount\n\nRHBZ: https://bugzilla.redhat.com/show_bug.cgi?id=2088799",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49623",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: powerpc/xive/spapr: correct bitmap allocation size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/xive/spapr: correct bitmap allocation size\n\nkasan detects access beyond the end of the xibm->bitmap allocation:\n\nBUG: KASAN: slab-out-of-bounds in _find_first_zero_bit+0x40/0x140\nRead of size 8 at addr c00000001d1d0118 by task swapper/0/1\n\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-rc2-00001-g90df023b36dd #28\nCall Trace:\n[c00000001d98f770] [c0000000012baab8] dump_stack_lvl+0xac/0x108 (unreliable)\n[c00000001d98f7b0] [c00000000068faac] print_report+0x37c/0x710\n[c00000001d98f880] [c0000000006902c0] kasan_report+0x110/0x354\n[c00000001d98f950] [c000000000692324] __asan_load8+0xa4/0xe0\n[c00000001d98f970] [c0000000011c6ed0] _find_first_zero_bit+0x40/0x140\n[c00000001d98f9b0] [c0000000000dbfbc] xive_spapr_get_ipi+0xcc/0x260\n[c00000001d98fa70] [c0000000000d6d28] xive_setup_cpu_ipi+0x1e8/0x450\n[c00000001d98fb30] [c000000004032a20] pSeries_smp_probe+0x5c/0x118\n[c00000001d98fb60] [c000000004018b44] smp_prepare_cpus+0x944/0x9ac\n[c00000001d98fc90] [c000000004009f9c] kernel_init_freeable+0x2d4/0x640\n[c00000001d98fd90] [c0000000000131e8] kernel_init+0x28/0x1d0\n[c00000001d98fe10] [c00000000000cd54] ret_from_kernel_thread+0x5c/0x64\n\nAllocated by task 0:\n kasan_save_stack+0x34/0x70\n __kasan_kmalloc+0xb4/0xf0\n __kmalloc+0x268/0x540\n xive_spapr_init+0x4d0/0x77c\n pseries_init_irq+0x40/0x27c\n init_IRQ+0x44/0x84\n start_kernel+0x2a4/0x538\n start_here_common+0x1c/0x20\n\nThe buggy address belongs to the object at c00000001d1d0118\n which belongs to the cache kmalloc-8 of size 8\nThe buggy address is located 0 bytes inside of\n 8-byte region [c00000001d1d0118, c00000001d1d0120)\n\nThe buggy address belongs to the physical page:\npage:c00c000000074740 refcount:1 mapcount:0 mapping:0000000000000000 index:0xc00000001d1d0558 pfn:0x1d1d\nflags: 0x7ffff000000200(slab|node=0|zone=0|lastcpupid=0x7ffff)\nraw: 007ffff000000200 c00000001d0003c8 c00000001d0003c8 c00000001d010480\nraw: c00000001d1d0558 0000000001e1000a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n c00000001d1d0000: fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n c00000001d1d0080: fc fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc\n>c00000001d1d0100: fc fc fc 02 fc fc fc fc fc fc fc fc fc fc fc fc\n                            ^\n c00000001d1d0180: fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc fc\n c00000001d1d0200: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc\n\nThis happens because the allocation uses the wrong unit (bits) when it\nshould pass (BITS_TO_LONGS(count) * sizeof(long)) or equivalent. With small\nnumbers of bits, the allocated object can be smaller than sizeof(long),\nwhich results in invalid accesses.\n\nUse bitmap_zalloc() to allocate and initialize the irq bitmap, paired with\nbitmap_free() for consistency.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49635",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/i915/selftests: fix subtraction overflow bug",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/selftests: fix subtraction overflow bug\n\nOn some machines hole_end can be small enough to cause subtraction\noverflow. On the other side (addr + 2 * min_alignment) can overflow\nin case of mock tests. This patch should handle both cases.\n\n(cherry picked from commit ab3edc679c552a466e4bf0b11af3666008bd65a2)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49711",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bus: fsl-mc-bus: fix KASAN use-after-free in fsl_mc_bus_remove()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: fsl-mc-bus: fix KASAN use-after-free in fsl_mc_bus_remove()\n\nIn fsl_mc_bus_remove(), mc->root_mc_bus_dev->mc_io is passed to\nfsl_destroy_mc_io(). However, mc->root_mc_bus_dev is already freed in\nfsl_mc_device_remove(). Then reference to mc->root_mc_bus_dev->mc_io\ntriggers KASAN use-after-free. To avoid the use-after-free, keep the\nreference to mc->root_mc_bus_dev->mc_io in a local variable and pass to\nfsl_destroy_mc_io().\n\nThis patch needs rework to apply to kernels older than v5.15.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49722",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ice: Fix memory corruption in VF driver",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: Fix memory corruption in VF driver\n\nDisable VF's RX/TX queues, when it's disabled. VF can have queues enabled,\nwhen it requests a reset. If PF driver assumes that VF is disabled,\nwhile VF still has queues configured, VF may unmap DMA resources.\nIn such scenario device still can map packets to memory, which ends up\nsilently corrupting it.\nPreviously, VF driver could experience memory corruption, which lead to\ncrash:\n[ 5119.170157] BUG: unable to handle kernel paging request at 00001b9780003237\n[ 5119.170166] PGD 0 P4D 0\n[ 5119.170173] Oops: 0002 [#1] PREEMPT_RT SMP PTI\n[ 5119.170181] CPU: 30 PID: 427592 Comm: kworker/u96:2 Kdump: loaded Tainted: G        W I      --------- -  - 4.18.0-372.9.1.rt7.166.el8.x86_64 #1\n[ 5119.170189] Hardware name: Dell Inc. PowerEdge R740/014X06, BIOS 2.3.10 08/15/2019\n[ 5119.170193] Workqueue: iavf iavf_adminq_task [iavf]\n[ 5119.170219] RIP: 0010:__page_frag_cache_drain+0x5/0x30\n[ 5119.170238] Code: 0f 0f b6 77 51 85 f6 74 07 31 d2 e9 05 df ff ff e9 90 fe ff ff 48 8b 05 49 db 33 01 eb b4 0f 1f 80 00 00 00 00 0f 1f 44 00 00 <f0> 29 77 34 74 01 c3 48 8b 07 f6 c4 80 74 0f 0f b6 77 51 85 f6 74\n[ 5119.170244] RSP: 0018:ffffa43b0bdcfd78 EFLAGS: 00010282\n[ 5119.170250] RAX: ffffffff896b3e40 RBX: ffff8fb282524000 RCX: 0000000000000002\n[ 5119.170254] RDX: 0000000049000000 RSI: 0000000000000000 RDI: 00001b9780003203\n[ 5119.170259] RBP: ffff8fb248217b00 R08: 0000000000000022 R09: 0000000000000009\n[ 5119.170262] R10: 2b849d6300000000 R11: 0000000000000020 R12: 0000000000000000\n[ 5119.170265] R13: 0000000000001000 R14: 0000000000000009 R15: 0000000000000000\n[ 5119.170269] FS:  0000000000000000(0000) GS:ffff8fb1201c0000(0000) knlGS:0000000000000000\n[ 5119.170274] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 5119.170279] CR2: 00001b9780003237 CR3: 00000008f3e1a003 CR4: 00000000007726e0\n[ 5119.170283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 5119.170286] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 5119.170290] PKRU: 55555554\n[ 5119.170292] Call Trace:\n[ 5119.170298]  iavf_clean_rx_ring+0xad/0x110 [iavf]\n[ 5119.170324]  iavf_free_rx_resources+0xe/0x50 [iavf]\n[ 5119.170342]  iavf_free_all_rx_resources.part.51+0x30/0x40 [iavf]\n[ 5119.170358]  iavf_virtchnl_completion+0xd8a/0x15b0 [iavf]\n[ 5119.170377]  ? iavf_clean_arq_element+0x210/0x280 [iavf]\n[ 5119.170397]  iavf_adminq_task+0x126/0x2e0 [iavf]\n[ 5119.170416]  process_one_work+0x18f/0x420\n[ 5119.170429]  worker_thread+0x30/0x370\n[ 5119.170437]  ? process_one_work+0x420/0x420\n[ 5119.170445]  kthread+0x151/0x170\n[ 5119.170452]  ? set_kthread_struct+0x40/0x40\n[ 5119.170460]  ret_from_fork+0x35/0x40\n[ 5119.170477] Modules linked in: iavf sctp ip6_udp_tunnel udp_tunnel mlx4_en mlx4_core nfp tls vhost_net vhost vhost_iotlb tap tun xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache sunrpc intel_rapl_msr iTCO_wdt iTCO_vendor_support dell_smbios wmi_bmof dell_wmi_descriptor dcdbas kvm_intel kvm irqbypass intel_rapl_common isst_if_common skx_edac irdma nfit libnvdimm x86_pkg_temp_thermal i40e intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ib_uverbs rapl ipmi_ssif intel_cstate intel_uncore mei_me pcspkr acpi_ipmi ib_core mei lpc_ich i2c_i801 ipmi_si ipmi_devintf wmi ipmi_msghandler acpi_power_meter xfs libcrc32c sd_mod t10_pi sg mgag200 drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops ice ahci drm libahci crc32c_intel libata tg3 megaraid_sas\n[ 5119.170613]  i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod fuse [last unloaded: iavf]\n[ 5119.170627] CR2: 00001b9780003237",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49738",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to do sanity check on i_extra_isize in is_alive()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to do sanity check on i_extra_isize in is_alive()\n\nsyzbot found a f2fs bug:\n\nBUG: KASAN: slab-out-of-bounds in data_blkaddr fs/f2fs/f2fs.h:2891 [inline]\nBUG: KASAN: slab-out-of-bounds in is_alive fs/f2fs/gc.c:1117 [inline]\nBUG: KASAN: slab-out-of-bounds in gc_data_segment fs/f2fs/gc.c:1520 [inline]\nBUG: KASAN: slab-out-of-bounds in do_garbage_collect+0x386a/0x3df0 fs/f2fs/gc.c:1734\nRead of size 4 at addr ffff888076557568 by task kworker/u4:3/52\n\nCPU: 1 PID: 52 Comm: kworker/u4:3 Not tainted 6.1.0-rc4-syzkaller-00362-gfef7fd48922d #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nWorkqueue: writeback wb_workfn (flush-7:0)\nCall Trace:\n<TASK>\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\nprint_address_description mm/kasan/report.c:284 [inline]\nprint_report+0x15e/0x45d mm/kasan/report.c:395\nkasan_report+0xbb/0x1f0 mm/kasan/report.c:495\ndata_blkaddr fs/f2fs/f2fs.h:2891 [inline]\nis_alive fs/f2fs/gc.c:1117 [inline]\ngc_data_segment fs/f2fs/gc.c:1520 [inline]\ndo_garbage_collect+0x386a/0x3df0 fs/f2fs/gc.c:1734\nf2fs_gc+0x88c/0x20a0 fs/f2fs/gc.c:1831\nf2fs_balance_fs+0x544/0x6b0 fs/f2fs/segment.c:410\nf2fs_write_inode+0x57e/0xe20 fs/f2fs/inode.c:753\nwrite_inode fs/fs-writeback.c:1440 [inline]\n__writeback_single_inode+0xcfc/0x1440 fs/fs-writeback.c:1652\nwriteback_sb_inodes+0x54d/0xf90 fs/fs-writeback.c:1870\nwb_writeback+0x2c5/0xd70 fs/fs-writeback.c:2044\nwb_do_writeback fs/fs-writeback.c:2187 [inline]\nwb_workfn+0x2dc/0x12f0 fs/fs-writeback.c:2227\nprocess_one_work+0x9bf/0x1710 kernel/workqueue.c:2289\nworker_thread+0x665/0x1080 kernel/workqueue.c:2436\nkthread+0x2e4/0x3a0 kernel/kthread.c:376\nret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n\nThe root cause is that we forgot to do sanity check on .i_extra_isize\nin below path, result in accessing invalid address later, fix it.\n- gc_data_segment\n - is_alive\n  - data_blkaddr\n   - offset_in_addr",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49740",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: brcmfmac: Check the count value of channel spec to prevent out-of-bounds reads",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: Check the count value of channel spec to prevent out-of-bounds reads\n\nThis patch fixes slab-out-of-bounds reads in brcmfmac that occur in\nbrcmf_construct_chaninfo() and brcmf_enable_bw40_2g() when the count\nvalue of channel specifications provided by the device is greater than\nthe length of 'list->element[]', decided by the size of the 'list'\nallocated with kzalloc(). The patch adds checks that make the functions\nfree the buffer and return -EINVAL if that is the case. Note that the\nnegative return is handled by the caller, brcmf_setup_wiphybands() or\nbrcmf_cfg80211_attach().\n\nFound by a modified version of syzkaller.\n\nCrash Report from brcmf_construct_chaninfo():\n==================================================================\nBUG: KASAN: slab-out-of-bounds in brcmf_setup_wiphybands+0x1238/0x1430\nRead of size 4 at addr ffff888115f24600 by task kworker/0:2/1896\n\nCPU: 0 PID: 1896 Comm: kworker/0:2 Tainted: G        W  O      5.14.0+ #132\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n dump_stack_lvl+0x57/0x7d\n print_address_description.constprop.0.cold+0x93/0x334\n kasan_report.cold+0x83/0xdf\n brcmf_setup_wiphybands+0x1238/0x1430\n brcmf_cfg80211_attach+0x2118/0x3fd0\n brcmf_attach+0x389/0xd40\n brcmf_usb_probe+0x12de/0x1690\n usb_probe_interface+0x25f/0x710\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_set_configuration+0x984/0x1770\n usb_generic_driver_probe+0x69/0x90\n usb_probe_device+0x9c/0x220\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_new_device.cold+0x463/0xf66\n hub_event+0x10d5/0x3330\n process_one_work+0x873/0x13e0\n worker_thread+0x8b/0xd10\n kthread+0x379/0x450\n ret_from_fork+0x1f/0x30\n\nAllocated by task 1896:\n kasan_save_stack+0x1b/0x40\n __kasan_kmalloc+0x7c/0x90\n kmem_cache_alloc_trace+0x19e/0x330\n brcmf_setup_wiphybands+0x290/0x1430\n brcmf_cfg80211_attach+0x2118/0x3fd0\n brcmf_attach+0x389/0xd40\n brcmf_usb_probe+0x12de/0x1690\n usb_probe_interface+0x25f/0x710\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_set_configuration+0x984/0x1770\n usb_generic_driver_probe+0x69/0x90\n usb_probe_device+0x9c/0x220\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_new_device.cold+0x463/0xf66\n hub_event+0x10d5/0x3330\n process_one_work+0x873/0x13e0\n worker_thread+0x8b/0xd10\n kthread+0x379/0x450\n ret_from_fork+0x1f/0x30\n\nThe buggy address belongs to the object at ffff888115f24000\n which belongs to the cache kmalloc-2k of size 2048\nThe buggy address is located 1536 bytes inside of\n 2048-byte region [ffff888115f24000, ffff888115f24800)\n\nMemory state around the buggy address:\n ffff888115f24500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff888115f24580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff888115f24600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                   ^\n ffff888115f24680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888115f24700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n==================================================================\n\nCrash Report from brcmf_enable_bw40_2g():\n==========\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49755",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: gadget: f_fs: Prevent race during ffs_ep0_queue_wait",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_fs: Prevent race during ffs_ep0_queue_wait\n\nWhile performing fast composition switch, there is a possibility that the\nprocess of ffs_ep0_write/ffs_ep0_read get into a race condition\ndue to ep0req being freed up from functionfs_unbind.\n\nConsider the scenario that the ffs_ep0_write calls the ffs_ep0_queue_wait\nby taking a lock &ffs->ev.waitq.lock. However, the functionfs_unbind isn't\nbounded so it can go ahead and mark the ep0req to NULL, and since there\nis no NULL check in ffs_ep0_queue_wait we will end up in use-after-free.\n\nFix this by making a serialized execution between the two functions using\na mutex_lock(ffs->mutex).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49763",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ntfs: fix use-after-free in ntfs_attr_find()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nntfs: fix use-after-free in ntfs_attr_find()\n\nPatch series \"ntfs: fix bugs about Attribute\", v2.\n\nThis patchset fixes three bugs relative to Attribute in record:\n\nPatch 1 adds a sanity check to ensure that, attrs_offset field in first\nmft record loading from disk is within bounds.\n\nPatch 2 moves the ATTR_RECORD's bounds checking earlier, to avoid\ndereferencing ATTR_RECORD before checking this ATTR_RECORD is within\nbounds.\n\nPatch 3 adds an overflow checking to avoid possible forever loop in\nntfs_attr_find().\n\nWithout patch 1 and patch 2, the kernel triggersa KASAN use-after-free\ndetection as reported by Syzkaller.\n\nAlthough one of patch 1 or patch 2 can fix this, we still need both of\nthem.  Because patch 1 fixes the root cause, and patch 2 not only fixes\nthe direct cause, but also fixes the potential out-of-bounds bug.\n\n\nThis patch (of 3):\n\nSyzkaller reported use-after-free read as follows:\n==================================================================\nBUG: KASAN: use-after-free in ntfs_attr_find+0xc02/0xce0 fs/ntfs/attrib.c:597\nRead of size 2 at addr ffff88807e352009 by task syz-executor153/3607\n\n[...]\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:317 [inline]\n print_report.cold+0x2ba/0x719 mm/kasan/report.c:433\n kasan_report+0xb1/0x1e0 mm/kasan/report.c:495\n ntfs_attr_find+0xc02/0xce0 fs/ntfs/attrib.c:597\n ntfs_attr_lookup+0x1056/0x2070 fs/ntfs/attrib.c:1193\n ntfs_read_inode_mount+0x89a/0x2580 fs/ntfs/inode.c:1845\n ntfs_fill_super+0x1799/0x9320 fs/ntfs/super.c:2854\n mount_bdev+0x34d/0x410 fs/super.c:1400\n legacy_get_tree+0x105/0x220 fs/fs_context.c:610\n vfs_get_tree+0x89/0x2f0 fs/super.c:1530\n do_new_mount fs/namespace.c:3040 [inline]\n path_mount+0x1326/0x1e20 fs/namespace.c:3370\n do_mount fs/namespace.c:3383 [inline]\n __do_sys_mount fs/namespace.c:3591 [inline]\n __se_sys_mount fs/namespace.c:3568 [inline]\n __x64_sys_mount+0x27f/0x300 fs/namespace.c:3568\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n [...]\n </TASK>\n\nThe buggy address belongs to the physical page:\npage:ffffea0001f8d400 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x7e350\nhead:ffffea0001f8d400 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000010200 0000000000000000 dead000000000122 ffff888011842140\nraw: 0000000000000000 0000000000040004 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\nMemory state around the buggy address:\n ffff88807e351f00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88807e351f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff88807e352000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff88807e352080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff88807e352100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\nKernel will loads $MFT/$DATA's first mft record in\nntfs_read_inode_mount().\n\nYet the problem is that after loading, kernel doesn't check whether\nattrs_offset field is a valid value.\n\nTo be more specific, if attrs_offset field is larger than bytes_allocated\nfield, then it may trigger the out-of-bounds read bug(reported as\nuse-after-free bug) in ntfs_attr_find(), when kernel tries to access the\ncorresponding mft record's attribute.\n\nThis patch solves it by adding the sanity check between attrs_offset field\nand bytes_allocated field, after loading the first mft record.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49770",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ceph: avoid putting the realm twice when decoding snaps fails",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: avoid putting the realm twice when decoding snaps fails\n\nWhen decoding the snaps fails it maybe leaving the 'first_realm'\nand 'realm' pointing to the same snaprealm memory. And then it'll\nput it twice and could cause random use-after-free, BUG_ON, etc\nissues.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49788",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: misc/vmw_vmci: fix an infoleak in vmci_host_do_receive_datagram()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc/vmw_vmci: fix an infoleak in vmci_host_do_receive_datagram()\n\n`struct vmci_event_qp` allocated by qp_notify_peer() contains padding,\nwhich may carry uninitialized data to the userspace, as observed by\nKMSAN:\n\n  BUG: KMSAN: kernel-infoleak in instrument_copy_to_user ./include/linux/instrumented.h:121\n   instrument_copy_to_user ./include/linux/instrumented.h:121\n   _copy_to_user+0x5f/0xb0 lib/usercopy.c:33\n   copy_to_user ./include/linux/uaccess.h:169\n   vmci_host_do_receive_datagram drivers/misc/vmw_vmci/vmci_host.c:431\n   vmci_host_unlocked_ioctl+0x33d/0x43d0 drivers/misc/vmw_vmci/vmci_host.c:925\n   vfs_ioctl fs/ioctl.c:51\n  ...\n\n  Uninit was stored to memory at:\n   kmemdup+0x74/0xb0 mm/util.c:131\n   dg_dispatch_as_host drivers/misc/vmw_vmci/vmci_datagram.c:271\n   vmci_datagram_dispatch+0x4f8/0xfc0 drivers/misc/vmw_vmci/vmci_datagram.c:339\n   qp_notify_peer+0x19a/0x290 drivers/misc/vmw_vmci/vmci_queue_pair.c:1479\n   qp_broker_attach drivers/misc/vmw_vmci/vmci_queue_pair.c:1662\n   qp_broker_alloc+0x2977/0x2f30 drivers/misc/vmw_vmci/vmci_queue_pair.c:1750\n   vmci_qp_broker_alloc+0x96/0xd0 drivers/misc/vmw_vmci/vmci_queue_pair.c:1940\n   vmci_host_do_alloc_queuepair drivers/misc/vmw_vmci/vmci_host.c:488\n   vmci_host_unlocked_ioctl+0x24fd/0x43d0 drivers/misc/vmw_vmci/vmci_host.c:927\n  ...\n\n  Local variable ev created at:\n   qp_notify_peer+0x54/0x290 drivers/misc/vmw_vmci/vmci_queue_pair.c:1456\n   qp_broker_attach drivers/misc/vmw_vmci/vmci_queue_pair.c:1662\n   qp_broker_alloc+0x2977/0x2f30 drivers/misc/vmw_vmci/vmci_queue_pair.c:1750\n\n  Bytes 28-31 of 48 are uninitialized\n  Memory access of size 48 starts at ffff888035155e00\n  Data copied to user address 0000000020000100\n\nUse memset() to prevent the infoleaks.\n\nAlso speculatively fix qp_notify_peer_local(), which may suffer from the\nsame problem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49789",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: zfcp: Fix double free of FSF request when qdio send fails",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: zfcp: Fix double free of FSF request when qdio send fails\n\nWe used to use the wrong type of integer in 'zfcp_fsf_req_send()' to cache\nthe FSF request ID when sending a new FSF request. This is used in case the\nsending fails and we need to remove the request from our internal hash\ntable again (so we don't keep an invalid reference and use it when we free\nthe request again).\n\nIn 'zfcp_fsf_req_send()' we used to cache the ID as 'int' (signed and 32\nbit wide), but the rest of the zfcp code (and the firmware specification)\nhandles the ID as 'unsigned long'/'u64' (unsigned and 64 bit wide [s390x\nELF ABI]).  For one this has the obvious problem that when the ID grows\npast 32 bit (this can happen reasonably fast) it is truncated to 32 bit\nwhen storing it in the cache variable and so doesn't match the original ID\nanymore.  The second less obvious problem is that even when the original ID\nhas not yet grown past 32 bit, as soon as the 32nd bit is set in the\noriginal ID (0x80000000 = 2'147'483'648) we will have a mismatch when we\ncast it back to 'unsigned long'. As the cached variable is of a signed\ntype, the compiler will choose a sign-extending instruction to load the 32\nbit variable into a 64 bit register (e.g.: 'lgf %r11,188(%r15)'). So once\nwe pass the cached variable into 'zfcp_reqlist_find_rm()' to remove the\nrequest again all the leading zeros will be flipped to ones to extend the\nsign and won't match the original ID anymore (this has been observed in\npractice).\n\nIf we can't successfully remove the request from the hash table again after\n'zfcp_qdio_send()' fails (this happens regularly when zfcp cannot notify\nthe adapter about new work because the adapter is already gone during\ne.g. a ChpID toggle) we will end up with a double free.  We unconditionally\nfree the request in the calling function when 'zfcp_fsf_req_send()' fails,\nbut because the request is still in the hash table we end up with a stale\nmemory reference, and once the zfcp adapter is either reset during recovery\nor shutdown we end up freeing the same memory twice.\n\nThe resulting stack traces vary depending on the kernel and have no direct\ncorrelation to the place where the bug occurs. Here are three examples that\nhave been seen in practice:\n\n  list_del corruption. next->prev should be 00000001b9d13800, but was 00000000dead4ead. (next=00000001bd131a00)\n  ------------[ cut here ]------------\n  kernel BUG at lib/list_debug.c:62!\n  monitor event: 0040 ilc:2 [#1] PREEMPT SMP\n  Modules linked in: ...\n  CPU: 9 PID: 1617 Comm: zfcperp0.0.1740 Kdump: loaded\n  Hardware name: ...\n  Krnl PSW : 0704d00180000000 00000003cbeea1f8 (__list_del_entry_valid+0x98/0x140)\n             R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 RI:0 EA:3\n  Krnl GPRS: 00000000916d12f1 0000000080000000 000000000000006d 00000003cb665cd6\n             0000000000000001 0000000000000000 0000000000000000 00000000d28d21e8\n             00000000d3844000 00000380099efd28 00000001bd131a00 00000001b9d13800\n             00000000d3290100 0000000000000000 00000003cbeea1f4 00000380099efc70\n  Krnl Code: 00000003cbeea1e8: c020004f68a7        larl    %r2,00000003cc8d7336\n             00000003cbeea1ee: c0e50027fd65        brasl   %r14,00000003cc3e9cb8\n            #00000003cbeea1f4: af000000            mc      0,0\n            >00000003cbeea1f8: c02000920440        larl    %r2,00000003cd12aa78\n             00000003cbeea1fe: c0e500289c25        brasl   %r14,00000003cc3fda48\n             00000003cbeea204: b9040043            lgr     %r4,%r3\n             00000003cbeea208: b9040051            lgr     %r5,%r1\n             00000003cbeea20c: b9040032            lgr     %r3,%r2\n  Call Trace:\n   [<00000003cbeea1f8>] __list_del_entry_valid+0x98/0x140\n  ([<00000003cbeea1f4>] __list_del_entry_valid+0x94/0x140)\n   [<000003ff7ff502fe>] zfcp_fsf_req_dismiss_all+0xde/0x150 [zfcp]\n   [<000003ff7ff49cd0>] zfcp_erp_strategy_do_action+0x160/0x280 [zfcp]\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49840",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf, test_run: Fix alignment problem in bpf_prog_test_run_skb()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, test_run: Fix alignment problem in bpf_prog_test_run_skb()\n\nWe got a syzkaller problem because of aarch64 alignment fault\nif KFENCE enabled. When the size from user bpf program is an odd\nnumber, like 399, 407, etc, it will cause the struct skb_shared_info's\nunaligned access. As seen below:\n\n  BUG: KFENCE: use-after-free read in __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032\n\n  Use-after-free read at 0xffff6254fffac077 (in kfence-#213):\n   __lse_atomic_add arch/arm64/include/asm/atomic_lse.h:26 [inline]\n   arch_atomic_add arch/arm64/include/asm/atomic.h:28 [inline]\n   arch_atomic_inc include/linux/atomic-arch-fallback.h:270 [inline]\n   atomic_inc include/asm-generic/atomic-instrumented.h:241 [inline]\n   __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032\n   skb_clone+0xf4/0x214 net/core/skbuff.c:1481\n   ____bpf_clone_redirect net/core/filter.c:2433 [inline]\n   bpf_clone_redirect+0x78/0x1c0 net/core/filter.c:2420\n   bpf_prog_d3839dd9068ceb51+0x80/0x330\n   bpf_dispatcher_nop_func include/linux/bpf.h:728 [inline]\n   bpf_test_run+0x3c0/0x6c0 net/bpf/test_run.c:53\n   bpf_prog_test_run_skb+0x638/0xa7c net/bpf/test_run.c:594\n   bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline]\n   __do_sys_bpf kernel/bpf/syscall.c:4441 [inline]\n   __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381\n\n  kfence-#213: 0xffff6254fffac000-0xffff6254fffac196, size=407, cache=kmalloc-512\n\n  allocated by task 15074 on cpu 0 at 1342.585390s:\n   kmalloc include/linux/slab.h:568 [inline]\n   kzalloc include/linux/slab.h:675 [inline]\n   bpf_test_init.isra.0+0xac/0x290 net/bpf/test_run.c:191\n   bpf_prog_test_run_skb+0x11c/0xa7c net/bpf/test_run.c:512\n   bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline]\n   __do_sys_bpf kernel/bpf/syscall.c:4441 [inline]\n   __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381\n   __arm64_sys_bpf+0x50/0x60 kernel/bpf/syscall.c:4381\n\nTo fix the problem, we adjust @size so that (@size + @hearoom) is a\nmultiple of SMP_CACHE_BYTES. So we make sure the struct skb_shared_info\nis aligned to a cache line.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49842",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: core: Fix use-after-free in snd_soc_exit()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: core: Fix use-after-free in snd_soc_exit()\n\nKASAN reports a use-after-free:\n\nBUG: KASAN: use-after-free in device_del+0xb5b/0xc60\nRead of size 8 at addr ffff888008655050 by task rmmod/387\nCPU: 2 PID: 387 Comm: rmmod\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996)\nCall Trace:\n<TASK>\ndump_stack_lvl+0x79/0x9a\nprint_report+0x17f/0x47b\nkasan_report+0xbb/0xf0\ndevice_del+0xb5b/0xc60\nplatform_device_del.part.0+0x24/0x200\nplatform_device_unregister+0x2e/0x40\nsnd_soc_exit+0xa/0x22 [snd_soc_core]\n__do_sys_delete_module.constprop.0+0x34f/0x5b0\ndo_syscall_64+0x3a/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n...\n</TASK>\n\nIt's bacause in snd_soc_init(), snd_soc_util_init() is possble to fail,\nbut its ret is ignored, which makes soc_dummy_dev unregistered twice.\n\nsnd_soc_init()\n    snd_soc_util_init()\n        platform_device_register_simple(soc_dummy_dev)\n        platform_driver_register() # fail\n    \tplatform_device_unregister(soc_dummy_dev)\n    platform_driver_register() # success\n...\nsnd_soc_exit()\n    snd_soc_util_exit()\n    # soc_dummy_dev will be unregistered for second time\n\nTo fix it, handle error and stop snd_soc_init() when util_init() fail.\nAlso clean debugfs when util_init() or driver_register() fail.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49846",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: udf: Fix a slab-out-of-bounds write bug in udf_find_entry()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Fix a slab-out-of-bounds write bug in udf_find_entry()\n\nSyzbot reported a slab-out-of-bounds Write bug:\n\nloop0: detected capacity change from 0 to 2048\n==================================================================\nBUG: KASAN: slab-out-of-bounds in udf_find_entry+0x8a5/0x14f0\nfs/udf/namei.c:253\nWrite of size 105 at addr ffff8880123ff896 by task syz-executor323/3610\n\nCPU: 0 PID: 3610 Comm: syz-executor323 Not tainted\n6.1.0-rc2-syzkaller-00105-gb229b6ca5abb #0\nHardware name: Google Compute Engine/Google Compute Engine, BIOS\nGoogle 10/11/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106\n print_address_description+0x74/0x340 mm/kasan/report.c:284\n print_report+0x107/0x1f0 mm/kasan/report.c:395\n kasan_report+0xcd/0x100 mm/kasan/report.c:495\n kasan_check_range+0x2a7/0x2e0 mm/kasan/generic.c:189\n memcpy+0x3c/0x60 mm/kasan/shadow.c:66\n udf_find_entry+0x8a5/0x14f0 fs/udf/namei.c:253\n udf_lookup+0xef/0x340 fs/udf/namei.c:309\n lookup_open fs/namei.c:3391 [inline]\n open_last_lookups fs/namei.c:3481 [inline]\n path_openat+0x10e6/0x2df0 fs/namei.c:3710\n do_filp_open+0x264/0x4f0 fs/namei.c:3740\n do_sys_openat2+0x124/0x4e0 fs/open.c:1310\n do_sys_open fs/open.c:1326 [inline]\n __do_sys_creat fs/open.c:1402 [inline]\n __se_sys_creat fs/open.c:1396 [inline]\n __x64_sys_creat+0x11f/0x160 fs/open.c:1396\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7ffab0d164d9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89\nf7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01\nf0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffe1a7e6bb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000055\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffab0d164d9\nRDX: 00007ffab0d164d9 RSI: 0000000000000000 RDI: 0000000020000180\nRBP: 00007ffab0cd5a10 R08: 0000000000000000 R09: 0000000000000000\nR10: 00005555573552c0 R11: 0000000000000246 R12: 00007ffab0cd5aa0\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nAllocated by task 3610:\n kasan_save_stack mm/kasan/common.c:45 [inline]\n kasan_set_track+0x3d/0x60 mm/kasan/common.c:52\n ____kasan_kmalloc mm/kasan/common.c:371 [inline]\n __kasan_kmalloc+0x97/0xb0 mm/kasan/common.c:380\n kmalloc include/linux/slab.h:576 [inline]\n udf_find_entry+0x7b6/0x14f0 fs/udf/namei.c:243\n udf_lookup+0xef/0x340 fs/udf/namei.c:309\n lookup_open fs/namei.c:3391 [inline]\n open_last_lookups fs/namei.c:3481 [inline]\n path_openat+0x10e6/0x2df0 fs/namei.c:3710\n do_filp_open+0x264/0x4f0 fs/namei.c:3740\n do_sys_openat2+0x124/0x4e0 fs/open.c:1310\n do_sys_open fs/open.c:1326 [inline]\n __do_sys_creat fs/open.c:1402 [inline]\n __se_sys_creat fs/open.c:1396 [inline]\n __x64_sys_creat+0x11f/0x160 fs/open.c:1396\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe buggy address belongs to the object at ffff8880123ff800\n which belongs to the cache kmalloc-256 of size 256\nThe buggy address is located 150 bytes inside of\n 256-byte region [ffff8880123ff800, ffff8880123ff900)\n\nThe buggy address belongs to the physical page:\npage:ffffea000048ff80 refcount:1 mapcount:0 mapping:0000000000000000\nindex:0x0 pfn:0x123fe\nhead:ffffea000048ff80 order:1 compound_mapcount:0 compound_pincount:0\nflags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000010200 ffffea00004b8500 dead000000000003 ffff888012041b40\nraw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 0, migratetype Unmovable, gfp_mask 0x0(),\npid 1, tgid 1 (swapper/0), ts 1841222404, free_ts 0\n create_dummy_stack mm/page_owner.c:\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49892",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ftrace: Fix use-after-free for dynamic ftrace_ops",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix use-after-free for dynamic ftrace_ops\n\nKASAN reported a use-after-free with ftrace ops [1]. It was found from\nvmcore that perf had registered two ops with the same content\nsuccessively, both dynamic. After unregistering the second ops, a\nuse-after-free occurred.\n\nIn ftrace_shutdown(), when the second ops is unregistered, the\nFTRACE_UPDATE_CALLS command is not set because there is another enabled\nops with the same content.  Also, both ops are dynamic and the ftrace\ncallback function is ftrace_ops_list_func, so the\nFTRACE_UPDATE_TRACE_FUNC command will not be set. Eventually the value\nof 'command' will be 0 and ftrace_shutdown() will skip the rcu\nsynchronization.\n\nHowever, ftrace may be activated. When the ops is released, another CPU\nmay be accessing the ops.  Add the missing synchronization to fix this\nproblem.\n\n[1]\nBUG: KASAN: use-after-free in __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline]\nBUG: KASAN: use-after-free in ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049\nRead of size 8 at addr ffff56551965bbc8 by task syz-executor.2/14468\n\nCPU: 1 PID: 14468 Comm: syz-executor.2 Not tainted 5.10.0 #7\nHardware name: linux,dummy-virt (DT)\nCall trace:\n dump_backtrace+0x0/0x40c arch/arm64/kernel/stacktrace.c:132\n show_stack+0x30/0x40 arch/arm64/kernel/stacktrace.c:196\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x1b4/0x248 lib/dump_stack.c:118\n print_address_description.constprop.0+0x28/0x48c mm/kasan/report.c:387\n __kasan_report mm/kasan/report.c:547 [inline]\n kasan_report+0x118/0x210 mm/kasan/report.c:564\n check_memory_region_inline mm/kasan/generic.c:187 [inline]\n __asan_load8+0x98/0xc0 mm/kasan/generic.c:253\n __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline]\n ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049\n ftrace_graph_call+0x0/0x4\n __might_sleep+0x8/0x100 include/linux/perf_event.h:1170\n __might_fault mm/memory.c:5183 [inline]\n __might_fault+0x58/0x70 mm/memory.c:5171\n do_strncpy_from_user lib/strncpy_from_user.c:41 [inline]\n strncpy_from_user+0x1f4/0x4b0 lib/strncpy_from_user.c:139\n getname_flags+0xb0/0x31c fs/namei.c:149\n getname+0x2c/0x40 fs/namei.c:209\n [...]\n\nAllocated by task 14445:\n kasan_save_stack+0x24/0x50 mm/kasan/common.c:48\n kasan_set_track mm/kasan/common.c:56 [inline]\n __kasan_kmalloc mm/kasan/common.c:479 [inline]\n __kasan_kmalloc.constprop.0+0x110/0x13c mm/kasan/common.c:449\n kasan_kmalloc+0xc/0x14 mm/kasan/common.c:493\n kmem_cache_alloc_trace+0x440/0x924 mm/slub.c:2950\n kmalloc include/linux/slab.h:563 [inline]\n kzalloc include/linux/slab.h:675 [inline]\n perf_event_alloc.part.0+0xb4/0x1350 kernel/events/core.c:11230\n perf_event_alloc kernel/events/core.c:11733 [inline]\n __do_sys_perf_event_open kernel/events/core.c:11831 [inline]\n __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723\n __arm64_sys_perf_event_open+0x6c/0x80 kernel/events/core.c:11723\n [...]\n\nFreed by task 14445:\n kasan_save_stack+0x24/0x50 mm/kasan/common.c:48\n kasan_set_track+0x24/0x34 mm/kasan/common.c:56\n kasan_set_free_info+0x20/0x40 mm/kasan/generic.c:358\n __kasan_slab_free.part.0+0x11c/0x1b0 mm/kasan/common.c:437\n __kasan_slab_free mm/kasan/common.c:445 [inline]\n kasan_slab_free+0x2c/0x40 mm/kasan/common.c:446\n slab_free_hook mm/slub.c:1569 [inline]\n slab_free_freelist_hook mm/slub.c:1608 [inline]\n slab_free mm/slub.c:3179 [inline]\n kfree+0x12c/0xc10 mm/slub.c:4176\n perf_event_alloc.part.0+0xa0c/0x1350 kernel/events/core.c:11434\n perf_event_alloc kernel/events/core.c:11733 [inline]\n __do_sys_perf_event_open kernel/events/core.c:11831 [inline]\n __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723\n [...]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49909",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: fix use-after-free in l2cap_conn_del()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: fix use-after-free in l2cap_conn_del()\n\nWhen l2cap_recv_frame() is invoked to receive data, and the cid is\nL2CAP_CID_A2MP, if the channel does not exist, it will create a channel.\nHowever, after a channel is created, the hold operation of the channel\nis not performed. In this case, the value of channel reference counting\nis 1. As a result, after hci_error_reset() is triggered, l2cap_conn_del()\ninvokes the close hook function of A2MP to release the channel. Then\n l2cap_chan_unlock(chan) will trigger UAF issue.\n\nThe process is as follows:\nReceive data:\nl2cap_data_channel()\n    a2mp_channel_create()  --->channel ref is 2\n    l2cap_chan_put()       --->channel ref is 1\n\nTriger event:\n    hci_error_reset()\n        hci_dev_do_close()\n        ...\n        l2cap_disconn_cfm()\n            l2cap_conn_del()\n                l2cap_chan_hold()    --->channel ref is 2\n                l2cap_chan_del()     --->channel ref is 1\n                a2mp_chan_close_cb() --->channel ref is 0, release channel\n                l2cap_chan_unlock()  --->UAF of channel\n\nThe detailed Call Trace is as follows:\nBUG: KASAN: use-after-free in __mutex_unlock_slowpath+0xa6/0x5e0\nRead of size 8 at addr ffff8880160664b8 by task kworker/u11:1/7593\nWorkqueue: hci0 hci_error_reset\nCall Trace:\n <TASK>\n dump_stack_lvl+0xcd/0x134\n print_report.cold+0x2ba/0x719\n kasan_report+0xb1/0x1e0\n kasan_check_range+0x140/0x190\n __mutex_unlock_slowpath+0xa6/0x5e0\n l2cap_conn_del+0x404/0x7b0\n l2cap_disconn_cfm+0x8c/0xc0\n hci_conn_hash_flush+0x11f/0x260\n hci_dev_close_sync+0x5f5/0x11f0\n hci_dev_do_close+0x2d/0x70\n hci_error_reset+0x9e/0x140\n process_one_work+0x98a/0x1620\n worker_thread+0x665/0x1080\n kthread+0x2e4/0x3a0\n ret_from_fork+0x1f/0x30\n </TASK>\n\nAllocated by task 7593:\n kasan_save_stack+0x1e/0x40\n __kasan_kmalloc+0xa9/0xd0\n l2cap_chan_create+0x40/0x930\n amp_mgr_create+0x96/0x990\n a2mp_channel_create+0x7d/0x150\n l2cap_recv_frame+0x51b8/0x9a70\n l2cap_recv_acldata+0xaa3/0xc00\n hci_rx_work+0x702/0x1220\n process_one_work+0x98a/0x1620\n worker_thread+0x665/0x1080\n kthread+0x2e4/0x3a0\n ret_from_fork+0x1f/0x30\n\nFreed by task 7593:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n kasan_set_free_info+0x20/0x30\n ____kasan_slab_free+0x167/0x1c0\n slab_free_freelist_hook+0x89/0x1c0\n kfree+0xe2/0x580\n l2cap_chan_put+0x22a/0x2d0\n l2cap_conn_del+0x3fc/0x7b0\n l2cap_disconn_cfm+0x8c/0xc0\n hci_conn_hash_flush+0x11f/0x260\n hci_dev_close_sync+0x5f5/0x11f0\n hci_dev_do_close+0x2d/0x70\n hci_error_reset+0x9e/0x140\n process_one_work+0x98a/0x1620\n worker_thread+0x665/0x1080\n kthread+0x2e4/0x3a0\n ret_from_fork+0x1f/0x30\n\nLast potentially related work creation:\n kasan_save_stack+0x1e/0x40\n __kasan_record_aux_stack+0xbe/0xd0\n call_rcu+0x99/0x740\n netlink_release+0xe6a/0x1cf0\n __sock_release+0xcd/0x280\n sock_close+0x18/0x20\n __fput+0x27c/0xa90\n task_work_run+0xdd/0x1a0\n exit_to_user_mode_prepare+0x23c/0x250\n syscall_exit_to_user_mode+0x19/0x50\n do_syscall_64+0x42/0x80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nSecond to last potentially related work creation:\n kasan_save_stack+0x1e/0x40\n __kasan_record_aux_stack+0xbe/0xd0\n call_rcu+0x99/0x740\n netlink_release+0xe6a/0x1cf0\n __sock_release+0xcd/0x280\n sock_close+0x18/0x20\n __fput+0x27c/0xa90\n task_work_run+0xdd/0x1a0\n exit_to_user_mode_prepare+0x23c/0x250\n syscall_exit_to_user_mode+0x19/0x50\n do_syscall_64+0x42/0x80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49910",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix use-after-free caused by l2cap_reassemble_sdu",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix use-after-free caused by l2cap_reassemble_sdu\n\nFix the race condition between the following two flows that run in\nparallel:\n\n1. l2cap_reassemble_sdu -> chan->ops->recv (l2cap_sock_recv_cb) ->\n   __sock_queue_rcv_skb.\n\n2. bt_sock_recvmsg -> skb_recv_datagram, skb_free_datagram.\n\nAn SKB can be queued by the first flow and immediately dequeued and\nfreed by the second flow, therefore the callers of l2cap_reassemble_sdu\ncan't use the SKB after that function returns. However, some places\ncontinue accessing struct l2cap_ctrl that resides in the SKB's CB for a\nshort time after l2cap_reassemble_sdu returns, leading to a\nuse-after-free condition (the stack trace is below, line numbers for\nkernel 5.19.8).\n\nFix it by keeping a local copy of struct l2cap_ctrl.\n\nBUG: KASAN: use-after-free in l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth\nRead of size 1 at addr ffff88812025f2f0 by task kworker/u17:3/43169\n\nWorkqueue: hci0 hci_rx_work [bluetooth]\nCall Trace:\n <TASK>\n dump_stack_lvl (lib/dump_stack.c:107 (discriminator 4))\n print_report.cold (mm/kasan/report.c:314 mm/kasan/report.c:429)\n ? l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth\n kasan_report (mm/kasan/report.c:162 mm/kasan/report.c:493)\n ? l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth\n l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth\n l2cap_rx (net/bluetooth/l2cap_core.c:7236 net/bluetooth/l2cap_core.c:7271) bluetooth\n ret_from_fork (arch/x86/entry/entry_64.S:306)\n </TASK>\n\nAllocated by task 43169:\n kasan_save_stack (mm/kasan/common.c:39)\n __kasan_slab_alloc (mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:469)\n kmem_cache_alloc_node (mm/slab.h:750 mm/slub.c:3243 mm/slub.c:3293)\n __alloc_skb (net/core/skbuff.c:414)\n l2cap_recv_frag (./include/net/bluetooth/bluetooth.h:425 net/bluetooth/l2cap_core.c:8329) bluetooth\n l2cap_recv_acldata (net/bluetooth/l2cap_core.c:8442) bluetooth\n hci_rx_work (net/bluetooth/hci_core.c:3642 net/bluetooth/hci_core.c:3832) bluetooth\n process_one_work (kernel/workqueue.c:2289)\n worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2437)\n kthread (kernel/kthread.c:376)\n ret_from_fork (arch/x86/entry/entry_64.S:306)\n\nFreed by task 27920:\n kasan_save_stack (mm/kasan/common.c:39)\n kasan_set_track (mm/kasan/common.c:45)\n kasan_set_free_info (mm/kasan/generic.c:372)\n ____kasan_slab_free (mm/kasan/common.c:368 mm/kasan/common.c:328)\n slab_free_freelist_hook (mm/slub.c:1780)\n kmem_cache_free (mm/slub.c:3536 mm/slub.c:3553)\n skb_free_datagram (./include/net/sock.h:1578 ./include/net/sock.h:1639 net/core/datagram.c:323)\n bt_sock_recvmsg (net/bluetooth/af_bluetooth.c:295) bluetooth\n l2cap_sock_recvmsg (net/bluetooth/l2cap_sock.c:1212) bluetooth\n sock_read_iter (net/socket.c:1087)\n new_sync_read (./include/linux/fs.h:2052 fs/read_write.c:401)\n vfs_read (fs/read_write.c:482)\n ksys_read (fs/read_write.c:620)\n do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)\n entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49919",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: release flow rule object from commit path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: release flow rule object from commit path\n\nNo need to postpone this to the commit release path, since no packets\nare walking over this object, this is accessed from control plane only.\nThis helped uncovered UAF triggered by races with the netlink notifier.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49921",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: sched: Fix use after free in red_enqueue()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: Fix use after free in red_enqueue()\n\nWe can't use \"skb\" again after passing it to qdisc_enqueue().  This is\nbasically identical to commit 2f09707d0c97 (\"sch_sfb: Also store skb\nlen before calling child enqueue\").",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49935",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dma-buf/dma-resv: check if the new fence is really later",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndma-buf/dma-resv: check if the new fence is really later\n\nPreviously when we added a fence to a dma_resv object we always\nassumed the the newer than all the existing fences.\n\nWith Jason's work to add an UAPI to explicit export/import that's not\nnecessary the case any more. So without this check we would allow\nuserspace to force the kernel into an use after free error.\n\nSince the change is very small and defensive it's probably a good\nidea to backport this to stable kernels as well just in case others\nare using the dma_resv object in the same way.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49940",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tty: n_gsm: add sanity check for gsm->receive in gsm_receive_buf()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: n_gsm: add sanity check for gsm->receive in gsm_receive_buf()\n\nA null pointer dereference can happen when attempting to access the\n\"gsm->receive()\" function in gsmld_receive_buf(). Currently, the code\nassumes that gsm->recieve is only called after MUX activation.\nSince the gsmld_receive_buf() function can be accessed without the need to\ninitialize the MUX, the gsm->receive() function will not be set and a\nNULL pointer dereference will occur.\n\nFix this by avoiding the call to \"gsm->receive()\" in case the function is\nnot initialized by adding a sanity check.\n\nCall Trace:\n <TASK>\n gsmld_receive_buf+0x1c2/0x2f0 drivers/tty/n_gsm.c:2861\n tiocsti drivers/tty/tty_io.c:2293 [inline]\n tty_ioctl+0xa75/0x15d0 drivers/tty/tty_io.c:2692\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:870 [inline]\n __se_sys_ioctl fs/ioctl.c:856 [inline]\n __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:856\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49980",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: USB: gadget: Fix use-after-free Read in usb_udc_uevent()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: gadget: Fix use-after-free Read in usb_udc_uevent()\n\nThe syzbot fuzzer found a race between uevent callbacks and gadget\ndriver unregistration that can cause a use-after-free bug:\n\n---------------------------------------------------------------\nBUG: KASAN: use-after-free in usb_udc_uevent+0x11f/0x130\ndrivers/usb/gadget/udc/core.c:1732\nRead of size 8 at addr ffff888078ce2050 by task udevd/2968\n\nCPU: 1 PID: 2968 Comm: udevd Not tainted 5.19.0-rc4-next-20220628-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google\n06/29/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:317 [inline]\n print_report.cold+0x2ba/0x719 mm/kasan/report.c:433\n kasan_report+0xbe/0x1f0 mm/kasan/report.c:495\n usb_udc_uevent+0x11f/0x130 drivers/usb/gadget/udc/core.c:1732\n dev_uevent+0x290/0x770 drivers/base/core.c:2424\n---------------------------------------------------------------\n\nThe bug occurs because usb_udc_uevent() dereferences udc->driver but\ndoes so without acquiring the udc_lock mutex, which protects this\nfield.  If the gadget driver is unbound from the udc concurrently with\nuevent processing, the driver structure may be accessed after it has\nbeen deallocated.\n\nTo prevent the race, we make sure that the routine holds the mutex\naround the racing accesses.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-49997",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: lantiq_xrx200: restore buffer if memory allocation failed",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: lantiq_xrx200: restore buffer if memory allocation failed\n\nIn a situation where memory allocation fails, an invalid buffer address\nis stored. When this descriptor is used again, the system panics in the\nbuild_skb() function when accessing memory.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50000",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: flowtable: fix stuck flows on cleanup due to pending work",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: flowtable: fix stuck flows on cleanup due to pending work\n\nTo clear the flow table on flow table free, the following sequence\nnormally happens in order:\n\n  1) gc_step work is stopped to disable any further stats/del requests.\n  2) All flow table entries are set to teardown state.\n  3) Run gc_step which will queue HW del work for each flow table entry.\n  4) Waiting for the above del work to finish (flush).\n  5) Run gc_step again, deleting all entries from the flow table.\n  6) Flow table is freed.\n\nBut if a flow table entry already has pending HW stats or HW add work\nstep 3 will not queue HW del work (it will be skipped), step 4 will wait\nfor the pending add/stats to finish, and step 5 will queue HW del work\nwhich might execute after freeing of the flow table.\n\nTo fix the above, this patch flushes the pending work, then it sets the\nteardown flag to all flows in the flowtable and it forces a garbage\ncollector run to queue work to remove the flows from hardware, then it\nflushes this new pending work and (finally) it forces another garbage\ncollector run to remove the entry from the software flowtable.\n\nStack trace:\n[47773.882335] BUG: KASAN: use-after-free in down_read+0x99/0x460\n[47773.883634] Write of size 8 at addr ffff888103b45aa8 by task kworker/u20:6/543704\n[47773.885634] CPU: 3 PID: 543704 Comm: kworker/u20:6 Not tainted 5.12.0-rc7+ #2\n[47773.886745] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009)\n[47773.888438] Workqueue: nf_ft_offload_del flow_offload_work_handler [nf_flow_table]\n[47773.889727] Call Trace:\n[47773.890214]  dump_stack+0xbb/0x107\n[47773.890818]  print_address_description.constprop.0+0x18/0x140\n[47773.892990]  kasan_report.cold+0x7c/0xd8\n[47773.894459]  kasan_check_range+0x145/0x1a0\n[47773.895174]  down_read+0x99/0x460\n[47773.899706]  nf_flow_offload_tuple+0x24f/0x3c0 [nf_flow_table]\n[47773.907137]  flow_offload_work_handler+0x72d/0xbe0 [nf_flow_table]\n[47773.913372]  process_one_work+0x8ac/0x14e0\n[47773.921325]\n[47773.921325] Allocated by task 592159:\n[47773.922031]  kasan_save_stack+0x1b/0x40\n[47773.922730]  __kasan_kmalloc+0x7a/0x90\n[47773.923411]  tcf_ct_flow_table_get+0x3cb/0x1230 [act_ct]\n[47773.924363]  tcf_ct_init+0x71c/0x1156 [act_ct]\n[47773.925207]  tcf_action_init_1+0x45b/0x700\n[47773.925987]  tcf_action_init+0x453/0x6b0\n[47773.926692]  tcf_exts_validate+0x3d0/0x600\n[47773.927419]  fl_change+0x757/0x4a51 [cls_flower]\n[47773.928227]  tc_new_tfilter+0x89a/0x2070\n[47773.936652]\n[47773.936652] Freed by task 543704:\n[47773.937303]  kasan_save_stack+0x1b/0x40\n[47773.938039]  kasan_set_track+0x1c/0x30\n[47773.938731]  kasan_set_free_info+0x20/0x30\n[47773.939467]  __kasan_slab_free+0xe7/0x120\n[47773.940194]  slab_free_freelist_hook+0x86/0x190\n[47773.941038]  kfree+0xce/0x3a0\n[47773.941644]  tcf_ct_flow_table_cleanup_work\n\nOriginal patch description and stack trace by Paul Blakey.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50001",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nft_tproxy: restrict to prerouting hook",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_tproxy: restrict to prerouting hook\n\nTPROXY is only allowed from prerouting, but nft_tproxy doesn't check this.\nThis fixes a crash (null dereference) when using tproxy from e.g. output.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50011",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: venus: pm_helpers: Fix warning in OPP during probe",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvenus: pm_helpers: Fix warning in OPP during probe\n\nFix the following WARN triggered during Venus driver probe on\n5.19.0-rc8-next-20220728:\n\n WARNING: CPU: 7 PID: 339 at drivers/opp/core.c:2471 dev_pm_opp_set_config+0x49c/0x610\n Modules linked in: qcom_spmi_adc5 rtc_pm8xxx qcom_spmi_adc_tm5 leds_qcom_lpg led_class_multicolor\n  qcom_pon qcom_vadc_common venus_core(+) qcom_spmi_temp_alarm v4l2_mem2mem videobuf2_v4l2 msm(+)\n  videobuf2_common crct10dif_ce spi_geni_qcom snd_soc_sm8250 i2c_qcom_geni gpu_sched\n  snd_soc_qcom_common videodev qcom_q6v5_pas soundwire_qcom drm_dp_aux_bus qcom_stats\n  drm_display_helper qcom_pil_info soundwire_bus snd_soc_lpass_va_macro mc qcom_q6v5\n  phy_qcom_snps_femto_v2 qcom_rng snd_soc_lpass_macro_common snd_soc_lpass_wsa_macro\n  lpass_gfm_sm8250 slimbus qcom_sysmon qcom_common qcom_glink_smem qmi_helpers\n  qcom_wdt mdt_loader socinfo icc_osm_l3 display_connector\n  drm_kms_helper qnoc_sm8250 drm fuse ip_tables x_tables ipv6\n CPU: 7 PID: 339 Comm: systemd-udevd Not tainted 5.19.0-rc8-next-20220728 #4\n Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : dev_pm_opp_set_config+0x49c/0x610\n lr : dev_pm_opp_set_config+0x58/0x610\n sp : ffff8000093c3710\n x29: ffff8000093c3710 x28: ffffbca3959d82b8 x27: ffff8000093c3d00\n x26: ffffbca3959d8e08 x25: ffff4396cac98118 x24: ffff4396c0e24810\n x23: ffff4396c4272c40 x22: ffff4396c0e24810 x21: ffff8000093c3810\n x20: ffff4396cac36800 x19: ffff4396cac96800 x18: 0000000000000000\n x17: 0000000000000003 x16: ffffbca3f4edf198 x15: 0000001cba64a858\n x14: 0000000000000180 x13: 000000000000017e x12: 0000000000000000\n x11: 0000000000000002 x10: 0000000000000a60 x9 : ffff8000093c35c0\n x8 : ffff4396c4273700 x7 : ffff43983efca6c0 x6 : ffff43983efca640\n x5 : 00000000410fd0d0 x4 : ffff4396c4272c40 x3 : ffffbca3f5d1e008\n x2 : 0000000000000000 x1 : ffff4396c2421600 x0 : ffff4396cac96860\n Call trace:\n  dev_pm_opp_set_config+0x49c/0x610\n  devm_pm_opp_set_config+0x18/0x70\n  vcodec_domains_get+0xb8/0x1638 [venus_core]\n  core_get_v4+0x1d8/0x218 [venus_core]\n  venus_probe+0xf4/0x468 [venus_core]\n  platform_probe+0x68/0xd8\n  really_probe+0xbc/0x2a8\n  __driver_probe_device+0x78/0xe0\n  driver_probe_device+0x3c/0xf0\n  __driver_attach+0x70/0x120\n  bus_for_each_dev+0x70/0xc0\n  driver_attach+0x24/0x30\n  bus_add_driver+0x150/0x200\n  driver_register+0x64/0x120\n  __platform_driver_register+0x28/0x38\n  qcom_venus_driver_init+0x24/0x1000 [venus_core]\n  do_one_initcall+0x54/0x1c8\n  do_init_module+0x44/0x1d0\n  load_module+0x16c8/0x1aa0\n  __do_sys_finit_module+0xbc/0x110\n  __arm64_sys_finit_module+0x20/0x30\n  invoke_syscall+0x44/0x108\n  el0_svc_common.constprop.0+0xcc/0xf0\n  do_el0_svc+0x2c/0xb8\n  el0_svc+0x2c/0x88\n  el0t_64_sync_handler+0xb8/0xc0\n  el0t_64_sync+0x18c/0x190\n  qcom-venus: probe of aa00000.video-codec failed with error -16\n\nThe fix is re-ordering the code related to OPP core. The OPP core\nexpects all configuration options to be provided before the OPP\ntable is added.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50015",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: SOF: Intel: hda-ipc: Do not process IPC reply before firmware boot",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: Intel: hda-ipc: Do not process IPC reply before firmware boot\n\nIt is not yet clear, but it is possible to create a firmware so broken\nthat it will send a reply message before a FW_READY message (it is not\nyet clear if FW_READY will arrive later).\nSince the reply_data is allocated only after the FW_READY message, this\nwill lead to a NULL pointer dereference if not filtered out.\n\nThe issue was reported with IPC4 firmware but the same condition is present\nfor IPC3.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50021",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: block range must be validated before use in ext4_mb_clear_bb()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: block range must be validated before use in ext4_mb_clear_bb()\n\nBlock range to free is validated in ext4_free_blocks() using\next4_inode_block_valid() and then it's passed to ext4_mb_clear_bb().\nHowever in some situations on bigalloc file system the range might be\nadjusted after the validation in ext4_free_blocks() which can lead to\ntroubles on corrupted file systems such as one found by syzkaller that\nresulted in the following BUG\n\nkernel BUG at fs/ext4/ext4.h:3319!\nPREEMPT SMP NOPTI\nCPU: 28 PID: 4243 Comm: repro Kdump: loaded Not tainted 5.19.0-rc6+ #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1.fc35 04/01/2014\nRIP: 0010:ext4_free_blocks+0x95e/0xa90\nCall Trace:\n <TASK>\n ? lock_timer_base+0x61/0x80\n ? __es_remove_extent+0x5a/0x760\n ? __mod_timer+0x256/0x380\n ? ext4_ind_truncate_ensure_credits+0x90/0x220\n ext4_clear_blocks+0x107/0x1b0\n ext4_free_data+0x15b/0x170\n ext4_ind_truncate+0x214/0x2c0\n ? _raw_spin_unlock+0x15/0x30\n ? ext4_discard_preallocations+0x15a/0x410\n ? ext4_journal_check_start+0xe/0x90\n ? __ext4_journal_start_sb+0x2f/0x110\n ext4_truncate+0x1b5/0x460\n ? __ext4_journal_start_sb+0x2f/0x110\n ext4_evict_inode+0x2b4/0x6f0\n evict+0xd0/0x1d0\n ext4_enable_quotas+0x11f/0x1f0\n ext4_orphan_cleanup+0x3de/0x430\n ? proc_create_seq_private+0x43/0x50\n ext4_fill_super+0x295f/0x3ae0\n ? snprintf+0x39/0x40\n ? sget_fc+0x19c/0x330\n ? ext4_reconfigure+0x850/0x850\n get_tree_bdev+0x16d/0x260\n vfs_get_tree+0x25/0xb0\n path_mount+0x431/0xa70\n __x64_sys_mount+0xe2/0x120\n do_syscall_64+0x5b/0x80\n ? do_user_addr_fault+0x1e2/0x670\n ? exc_page_fault+0x70/0x170\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\nRIP: 0033:0x7fdf4e512ace\n\nFix it by making sure that the block range is properly validated before\nused every time it changes in ext4_free_blocks() or ext4_mb_clear_bb().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50023",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dmaengine: dw-axi-dmac: ignore interrupt if no descriptor",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: dw-axi-dmac: ignore interrupt if no descriptor\n\nIf the channel has no descriptor and the interrupt is raised then the\nkernel will OOPS. Check the result of vchan_next_desc() in the handler\naxi_chan_block_xfer_complete() to avoid the error happening.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50024",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dmaengine: dw-axi-dmac: do not print NULL LLI during error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: dw-axi-dmac: do not print NULL LLI during error\n\nDuring debugging we have seen an issue where axi_chan_dump_lli()\nis passed a NULL LLI pointer which ends up causing an OOPS due\nto trying to get fields from it. Simply print NULL LLI and exit\nto avoid this.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50026",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: habanalabs/gaudi: fix shift out of bounds",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhabanalabs/gaudi: fix shift out of bounds\n\nWhen validating NIC queues, queue offset calculation must be\nperformed only for NIC queues.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50050",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: SOF: Intel: hda: Fix potential buffer overflow by snprintf()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: Intel: hda: Fix potential buffer overflow by snprintf()\n\nsnprintf() returns the would-be-filled size when the string overflows\nthe given buffer size, hence using this value may result in the buffer\noverflow (although it's unrealistic).\n\nThis patch replaces with a safer version, scnprintf() for papering\nover such a potential issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50053",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iavf: Fix reset error handling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niavf: Fix reset error handling\n\nDo not call iavf_close in iavf_reset_task error handling. Doing so can\nlead to double call of napi_disable, which can lead to deadlock there.\nRemoving VF would lead to iavf_remove task being stuck, because it\nrequires crit_lock, which is held by iavf_close.\nCall iavf_disable_vf if reset fail, so that driver will clean up\nremaining invalid resources.\nDuring rapid VF resets, HW can fail to setup VF mailbox. Wrong\nerror handling can lead to iavf_remove being stuck with:\n[ 5218.999087] iavf 0000:82:01.0: Failed to init adminq: -53\n...\n[ 5267.189211] INFO: task repro.sh:11219 blocked for more than 30 seconds.\n[ 5267.189520]       Tainted: G S          E     5.18.0-04958-ga54ce3703613-dirty #1\n[ 5267.189764] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n[ 5267.190062] task:repro.sh        state:D stack:    0 pid:11219 ppid:  8162 flags:0x00000000\n[ 5267.190347] Call Trace:\n[ 5267.190647]  <TASK>\n[ 5267.190927]  __schedule+0x460/0x9f0\n[ 5267.191264]  schedule+0x44/0xb0\n[ 5267.191563]  schedule_preempt_disabled+0x14/0x20\n[ 5267.191890]  __mutex_lock.isra.12+0x6e3/0xac0\n[ 5267.192237]  ? iavf_remove+0xf9/0x6c0 [iavf]\n[ 5267.192565]  iavf_remove+0x12a/0x6c0 [iavf]\n[ 5267.192911]  ? _raw_spin_unlock_irqrestore+0x1e/0x40\n[ 5267.193285]  pci_device_remove+0x36/0xb0\n[ 5267.193619]  device_release_driver_internal+0xc1/0x150\n[ 5267.193974]  pci_stop_bus_device+0x69/0x90\n[ 5267.194361]  pci_stop_and_remove_bus_device+0xe/0x20\n[ 5267.194735]  pci_iov_remove_virtfn+0xba/0x120\n[ 5267.195130]  sriov_disable+0x2f/0xe0\n[ 5267.195506]  ice_free_vfs+0x7d/0x2f0 [ice]\n[ 5267.196056]  ? pci_get_device+0x4f/0x70\n[ 5267.196496]  ice_sriov_configure+0x78/0x1a0 [ice]\n[ 5267.196995]  sriov_numvfs_store+0xfe/0x140\n[ 5267.197466]  kernfs_fop_write_iter+0x12e/0x1c0\n[ 5267.197918]  new_sync_write+0x10c/0x190\n[ 5267.198404]  vfs_write+0x24e/0x2d0\n[ 5267.198886]  ksys_write+0x5c/0xd0\n[ 5267.199367]  do_syscall_64+0x3a/0x80\n[ 5267.199827]  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n[ 5267.200317] RIP: 0033:0x7f5b381205c8\n[ 5267.200814] RSP: 002b:00007fff8c7e8c78 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[ 5267.201981] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f5b381205c8\n[ 5267.202620] RDX: 0000000000000002 RSI: 00005569420ee900 RDI: 0000000000000001\n[ 5267.203426] RBP: 00005569420ee900 R08: 000000000000000a R09: 00007f5b38180820\n[ 5267.204327] R10: 000000000000000a R11: 0000000000000246 R12: 00007f5b383c06e0\n[ 5267.205193] R13: 0000000000000002 R14: 00007f5b383bb880 R15: 0000000000000002\n[ 5267.206041]  </TASK>\n[ 5267.206970] Kernel panic - not syncing: hung_task: blocked tasks\n[ 5267.207809] CPU: 48 PID: 551 Comm: khungtaskd Kdump: loaded Tainted: G S          E     5.18.0-04958-ga54ce3703613-dirty #1\n[ 5267.208726] Hardware name: Dell Inc. PowerEdge R730/0WCJNT, BIOS 2.11.0 11/02/2019\n[ 5267.209623] Call Trace:\n[ 5267.210569]  <TASK>\n[ 5267.211480]  dump_stack_lvl+0x33/0x42\n[ 5267.212472]  panic+0x107/0x294\n[ 5267.213467]  watchdog.cold.8+0xc/0xbb\n[ 5267.214413]  ? proc_dohung_task_timeout_secs+0x30/0x30\n[ 5267.215511]  kthread+0xf4/0x120\n[ 5267.216459]  ? kthread_complete_and_exit+0x20/0x20\n[ 5267.217505]  ret_from_fork+0x22/0x30\n[ 5267.218459]  </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50070",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mptcp: do not queue data on closed subflows",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: do not queue data on closed subflows\n\nDipanjan reported a syzbot splat at close time:\n\nWARNING: CPU: 1 PID: 10818 at net/ipv4/af_inet.c:153\ninet_sock_destruct+0x6d0/0x8e0 net/ipv4/af_inet.c:153\nModules linked in: uio_ivshmem(OE) uio(E)\nCPU: 1 PID: 10818 Comm: kworker/1:16 Tainted: G           OE\n5.19.0-rc6-g2eae0556bb9d #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.13.0-1ubuntu1.1 04/01/2014\nWorkqueue: events mptcp_worker\nRIP: 0010:inet_sock_destruct+0x6d0/0x8e0 net/ipv4/af_inet.c:153\nCode: 21 02 00 00 41 8b 9c 24 28 02 00 00 e9 07 ff ff ff e8 34 4d 91\nf9 89 ee 4c 89 e7 e8 4a 47 60 ff e9 a6 fc ff ff e8 20 4d 91 f9 <0f> 0b\ne9 84 fe ff ff e8 14 4d 91 f9 0f 0b e9 d4 fd ff ff e8 08 4d\nRSP: 0018:ffffc9001b35fa78 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 00000000002879d0 RCX: ffff8881326f3b00\nRDX: 0000000000000000 RSI: ffff8881326f3b00 RDI: 0000000000000002\nRBP: ffff888179662674 R08: ffffffff87e983a0 R09: 0000000000000000\nR10: 0000000000000005 R11: 00000000000004ea R12: ffff888179662400\nR13: ffff888179662428 R14: 0000000000000001 R15: ffff88817e38e258\nFS:  0000000000000000(0000) GS:ffff8881f5f00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020007bc0 CR3: 0000000179592000 CR4: 0000000000150ee0\nCall Trace:\n <TASK>\n __sk_destruct+0x4f/0x8e0 net/core/sock.c:2067\n sk_destruct+0xbd/0xe0 net/core/sock.c:2112\n __sk_free+0xef/0x3d0 net/core/sock.c:2123\n sk_free+0x78/0xa0 net/core/sock.c:2134\n sock_put include/net/sock.h:1927 [inline]\n __mptcp_close_ssk+0x50f/0x780 net/mptcp/protocol.c:2351\n __mptcp_destroy_sock+0x332/0x760 net/mptcp/protocol.c:2828\n mptcp_worker+0x5d2/0xc90 net/mptcp/protocol.c:2586\n process_one_work+0x9cc/0x1650 kernel/workqueue.c:2289\n worker_thread+0x623/0x1070 kernel/workqueue.c:2436\n kthread+0x2e9/0x3a0 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:302\n </TASK>\n\nThe root cause of the problem is that an mptcp-level (re)transmit can\nrace with mptcp_close() and the packet scheduler checks the subflow\nstate before acquiring the socket lock: we can try to (re)transmit on\nan already closed ssk.\n\nFix the issue checking again the subflow socket status under the\nsubflow socket lock protection. Additionally add the missing check\nfor the fallback-to-tcp case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50163",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ax25: fix incorrect dev_tracker usage",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: fix incorrect dev_tracker usage\n\nWhile investigating a separate rose issue [1], and enabling\nCONFIG_NET_DEV_REFCNT_TRACKER=y, Bernard reported an orthogonal ax25 issue [2]\n\nAn ax25_dev can be used by one (or many) struct ax25_cb.\nWe thus need different dev_tracker, one per struct ax25_cb.\n\nAfter this patch is applied, we are able to focus on rose.\n\n[1] https://lore.kernel.org/netdev/fb7544a1-f42e-9254-18cc-c9b071f4ca70@free.fr/\n\n[2]\n[  205.798723] reference already released.\n[  205.798732] allocated in:\n[  205.798734]  ax25_bind+0x1a2/0x230 [ax25]\n[  205.798747]  __sys_bind+0xea/0x110\n[  205.798753]  __x64_sys_bind+0x18/0x20\n[  205.798758]  do_syscall_64+0x5c/0x80\n[  205.798763]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  205.798768] freed in:\n[  205.798770]  ax25_release+0x115/0x370 [ax25]\n[  205.798778]  __sock_release+0x42/0xb0\n[  205.798782]  sock_close+0x15/0x20\n[  205.798785]  __fput+0x9f/0x260\n[  205.798789]  ____fput+0xe/0x10\n[  205.798792]  task_work_run+0x64/0xa0\n[  205.798798]  exit_to_user_mode_prepare+0x18b/0x190\n[  205.798804]  syscall_exit_to_user_mode+0x26/0x40\n[  205.798808]  do_syscall_64+0x69/0x80\n[  205.798812]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  205.798827] ------------[ cut here ]------------\n[  205.798829] WARNING: CPU: 2 PID: 2605 at lib/ref_tracker.c:136 ref_tracker_free.cold+0x60/0x81\n[  205.798837] Modules linked in: rose netrom mkiss ax25 rfcomm cmac algif_hash algif_skcipher af_alg bnep snd_hda_codec_hdmi nls_iso8859_1 i915 rtw88_8821ce rtw88_8821c x86_pkg_temp_thermal rtw88_pci intel_powerclamp rtw88_core snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio coretemp snd_hda_intel kvm_intel snd_intel_dspcfg mac80211 snd_hda_codec kvm i2c_algo_bit drm_buddy drm_dp_helper btusb drm_kms_helper snd_hwdep btrtl snd_hda_core btbcm joydev crct10dif_pclmul btintel crc32_pclmul ghash_clmulni_intel mei_hdcp btmtk intel_rapl_msr aesni_intel bluetooth input_leds snd_pcm crypto_simd syscopyarea processor_thermal_device_pci_legacy sysfillrect cryptd intel_soc_dts_iosf snd_seq sysimgblt ecdh_generic fb_sys_fops rapl libarc4 processor_thermal_device intel_cstate processor_thermal_rfim cec snd_timer ecc snd_seq_device cfg80211 processor_thermal_mbox mei_me processor_thermal_rapl mei rc_core at24 snd intel_pch_thermal intel_rapl_common ttm soundcore int340x_thermal_zone video\n[  205.798948]  mac_hid acpi_pad sch_fq_codel ipmi_devintf ipmi_msghandler drm msr parport_pc ppdev lp parport ramoops pstore_blk reed_solomon pstore_zone efi_pstore ip_tables x_tables autofs4 hid_generic usbhid hid i2c_i801 i2c_smbus r8169 xhci_pci ahci libahci realtek lpc_ich xhci_pci_renesas [last unloaded: ax25]\n[  205.798992] CPU: 2 PID: 2605 Comm: ax25ipd Not tainted 5.18.11-F6BVP #3\n[  205.798996] Hardware name: To be filled by O.E.M. To be filled by O.E.M./CK3, BIOS 5.011 09/16/2020\n[  205.798999] RIP: 0010:ref_tracker_free.cold+0x60/0x81\n[  205.799005] Code: e8 d2 01 9b ff 83 7b 18 00 74 14 48 c7 c7 2f d7 ff 98 e8 10 6e fc ff 8b 7b 18 e8 b8 01 9b ff 4c 89 ee 4c 89 e7 e8 5d fd 07 00 <0f> 0b b8 ea ff ff ff e9 30 05 9b ff 41 0f b6 f7 48 c7 c7 a0 fa 4e\n[  205.799008] RSP: 0018:ffffaf5281073958 EFLAGS: 00010286\n[  205.799011] RAX: 0000000080000000 RBX: ffff9a0bd687ebe0 RCX: 0000000000000000\n[  205.799014] RDX: 0000000000000001 RSI: 0000000000000282 RDI: 00000000ffffffff\n[  205.799016] RBP: ffffaf5281073a10 R08: 0000000000000003 R09: fffffffffffd5618\n[  205.799019] R10: 0000000000ffff10 R11: 000000000000000f R12: ffff9a0bc53384d0\n[  205.799022] R13: 0000000000000282 R14: 00000000ae000001 R15: 0000000000000001\n[  205.799024] FS:  0000000000000000(0000) GS:ffff9a0d0f300000(0000) knlGS:0000000000000000\n[  205.799028] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  205.799031] CR2: 00007ff6b8311554 CR3: 000000001ac10004 CR4: 00000000001706e0\n[  205.799033] Call Trace:\n[  205.799035]  <TASK>\n[  205.799038]  ? ax25_dev_device_down+0xd9/\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50224",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: x86/mmu: Treat NX as a valid SPTE bit for NPT",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/mmu: Treat NX as a valid SPTE bit for NPT\n\nTreat the NX bit as valid when using NPT, as KVM will set the NX bit when\nthe NX huge page mitigation is enabled (mindblowing) and trigger the WARN\nthat fires on reserved SPTE bits being set.\n\nKVM has required NX support for SVM since commit b26a71a1a5b9 (\"KVM: SVM:\nRefuse to load kvm_amd if NX support is not available\") for exactly this\nreason, but apparently it never occurred to anyone to actually test NPT\nwith the mitigation enabled.\n\n  ------------[ cut here ]------------\n  spte = 0x800000018a600ee7, level = 2, rsvd bits = 0x800f0000001fe000\n  WARNING: CPU: 152 PID: 15966 at arch/x86/kvm/mmu/spte.c:215 make_spte+0x327/0x340 [kvm]\n  Hardware name: Google, Inc. Arcadia_IT_80/Arcadia_IT_80, BIOS 10.48.0 01/27/2022\n  RIP: 0010:make_spte+0x327/0x340 [kvm]\n  Call Trace:\n   <TASK>\n   tdp_mmu_map_handle_target_level+0xc3/0x230 [kvm]\n   kvm_tdp_mmu_map+0x343/0x3b0 [kvm]\n   direct_page_fault+0x1ae/0x2a0 [kvm]\n   kvm_tdp_page_fault+0x7d/0x90 [kvm]\n   kvm_mmu_page_fault+0xfb/0x2e0 [kvm]\n   npf_interception+0x55/0x90 [kvm_amd]\n   svm_invoke_exit_handler+0x31/0xf0 [kvm_amd]\n   svm_handle_exit+0xf6/0x1d0 [kvm_amd]\n   vcpu_enter_guest+0xb6d/0xee0 [kvm]\n   ? kvm_pmu_trigger_event+0x6d/0x230 [kvm]\n   vcpu_run+0x65/0x2c0 [kvm]\n   kvm_arch_vcpu_ioctl_run+0x355/0x610 [kvm]\n   kvm_vcpu_ioctl+0x551/0x610 [kvm]\n   __se_sys_ioctl+0x77/0xc0\n   __x64_sys_ioctl+0x1d/0x20\n   do_syscall_64+0x44/0xa0\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n   </TASK>\n  ---[ end trace 0000000000000000 ]---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50233",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: eir: Fix using strlen with hdev->{dev_name,short_name}",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: eir: Fix using strlen with hdev->{dev_name,short_name}\n\nBoth dev_name and short_name are not guaranteed to be NULL terminated so\nthis instead use strnlen and then attempt to determine if the resulting\nstring needs to be truncated or not.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50239",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cpufreq: qcom: fix writes in read-only memory region",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: qcom: fix writes in read-only memory region\n\nThis commit fixes a kernel oops because of a write in some read-only memory:\n\n\t[    9.068287] Unable to handle kernel write to read-only memory at virtual address ffff800009240ad8\n\t..snip..\n\t[    9.138790] Internal error: Oops: 9600004f [#1] PREEMPT SMP\n\t..snip..\n\t[    9.269161] Call trace:\n\t[    9.276271]  __memcpy+0x5c/0x230\n\t[    9.278531]  snprintf+0x58/0x80\n\t[    9.282002]  qcom_cpufreq_msm8939_name_version+0xb4/0x190\n\t[    9.284869]  qcom_cpufreq_probe+0xc8/0x39c\n\t..snip..\n\nThe following line defines a pointer that point to a char buffer stored\nin read-only memory:\n\n\tchar *pvs_name = \"speedXX-pvsXX-vXX\";\n\nThis pointer is meant to hold a template \"speedXX-pvsXX-vXX\" where the\nXX values get overridden by the qcom_cpufreq_krait_name_version function. Since\nthe template is actually stored in read-only memory, when the function\nexecutes the following call we get an oops:\n\n\tsnprintf(*pvs_name, sizeof(\"speedXX-pvsXX-vXX\"), \"speed%d-pvs%d-v%d\",\n\t\t speed, pvs, pvs_ver);\n\nTo fix this issue, we instead store the template name onto the stack by\nusing the following syntax:\n\n\tchar pvs_name_buffer[] = \"speedXX-pvsXX-vXX\";\n\nBecause the `pvs_name` needs to be able to be assigned to NULL, the\ntemplate buffer is stored in the pvs_name_buffer and not under the\npvs_name variable.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50266",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: kprobes: Fix check for probe enabled in kill_kprobe()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkprobes: Fix check for probe enabled in kill_kprobe()\n\nIn kill_kprobe(), the check whether disarm_kprobe_ftrace() needs to be\ncalled always fails. This is because before that we set the\nKPROBE_FLAG_GONE flag for kprobe so that \"!kprobe_disabled(p)\" is always\nfalse.\n\nThe disarm_kprobe_ftrace() call introduced by commit:\n\n  0cb2f1372baa (\"kprobes: Fix NULL pointer dereference at kprobe_ftrace_handler\")\n\nto fix the NULL pointer reference problem. When the probe is enabled, if\nwe do not disarm it, this problem still exists.\n\nFix it by putting the probe enabled check before setting the\nKPROBE_FLAG_GONE flag.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50280",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pnode: terminate at peers of source",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npnode: terminate at peers of source\n\nThe propagate_mnt() function handles mount propagation when creating\nmounts and propagates the source mount tree @source_mnt to all\napplicable nodes of the destination propagation mount tree headed by\n@dest_mnt.\n\nUnfortunately it contains a bug where it fails to terminate at peers of\n@source_mnt when looking up copies of the source mount that become\nmasters for copies of the source mount tree mounted on top of slaves in\nthe destination propagation tree causing a NULL dereference.\n\nOnce the mechanics of the bug are understood it's easy to trigger.\nBecause of unprivileged user namespaces it is available to unprivileged\nusers.\n\nWhile fixing this bug we've gotten confused multiple times due to\nunclear terminology or missing concepts. So let's start this with some\nclarifications:\n\n* The terms \"master\" or \"peer\" denote a shared mount. A shared mount\n  belongs to a peer group.\n\n* A peer group is a set of shared mounts that propagate to each other.\n  They are identified by a peer group id. The peer group id is available\n  in @shared_mnt->mnt_group_id.\n  Shared mounts within the same peer group have the same peer group id.\n  The peers in a peer group can be reached via @shared_mnt->mnt_share.\n\n* The terms \"slave mount\" or \"dependent mount\" denote a mount that\n  receives propagation from a peer in a peer group. IOW, shared mounts\n  may have slave mounts and slave mounts have shared mounts as their\n  master. Slave mounts of a given peer in a peer group are listed on\n  that peers slave list available at @shared_mnt->mnt_slave_list.\n\n* The term \"master mount\" denotes a mount in a peer group. IOW, it\n  denotes a shared mount or a peer mount in a peer group. The term\n  \"master mount\" - or \"master\" for short - is mostly used when talking\n  in the context of slave mounts that receive propagation from a master\n  mount. A master mount of a slave identifies the closest peer group a\n  slave mount receives propagation from. The master mount of a slave can\n  be identified via @slave_mount->mnt_master. Different slaves may point\n  to different masters in the same peer group.\n\n* Multiple peers in a peer group can have non-empty ->mnt_slave_lists.\n  Non-empty ->mnt_slave_lists of peers don't intersect. Consequently, to\n  ensure all slave mounts of a peer group are visited the\n  ->mnt_slave_lists of all peers in a peer group have to be walked.\n\n* Slave mounts point to a peer in the closest peer group they receive\n  propagation from via @slave_mnt->mnt_master (see above). Together with\n  these peers they form a propagation group (see below). The closest\n  peer group can thus be identified through the peer group id\n  @slave_mnt->mnt_master->mnt_group_id of the peer/master that a slave\n  mount receives propagation from.\n\n* A shared-slave mount is a slave mount to a peer group pg1 while also\n  a peer in another peer group pg2. IOW, a peer group may receive\n  propagation from another peer group.\n\n  If a peer group pg1 is a slave to another peer group pg2 then all\n  peers in peer group pg1 point to the same peer in peer group pg2 via\n  ->mnt_master. IOW, all peers in peer group pg1 appear on the same\n  ->mnt_slave_list. IOW, they cannot be slaves to different peer groups.\n\n* A pure slave mount is a slave mount that is a slave to a peer group\n  but is not a peer in another peer group.\n\n* A propagation group denotes the set of mounts consisting of a single\n  peer group pg1 and all slave mounts and shared-slave mounts that point\n  to a peer in that peer group via ->mnt_master. IOW, all slave mounts\n  such that @slave_mnt->mnt_master->mnt_group_id is equal to\n  @shared_mnt->mnt_group_id.\n\n  The concept of a propagation group makes it easier to talk about a\n  single propagation level in a propagation tree.\n\n  For example, in propagate_mnt() the immediate peers of @dest_mnt and\n  all slaves of @dest_mnt's peer group form a propagation group pr\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50282",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: chardev: fix error handling in cdev_device_add()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nchardev: fix error handling in cdev_device_add()\n\nWhile doing fault injection test, I got the following report:\n\n------------[ cut here ]------------\nkobject: '(null)' (0000000039956980): is not initialized, yet kobject_put() is being called.\nWARNING: CPU: 3 PID: 6306 at kobject_put+0x23d/0x4e0\nCPU: 3 PID: 6306 Comm: 283 Tainted: G        W          6.1.0-rc2-00005-g307c1086d7c9 #1253\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nRIP: 0010:kobject_put+0x23d/0x4e0\nCall Trace:\n <TASK>\n cdev_device_add+0x15e/0x1b0\n __iio_device_register+0x13b4/0x1af0 [industrialio]\n __devm_iio_device_register+0x22/0x90 [industrialio]\n max517_probe+0x3d8/0x6b4 [max517]\n i2c_device_probe+0xa81/0xc00\n\nWhen device_add() is injected fault and returns error, if dev->devt is not set,\ncdev_add() is not called, cdev_del() is not needed. Fix this by checking dev->devt\nin error path.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50303",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdkfd: Fix double release compute pasid",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: Fix double release compute pasid\n\nIf kfd_process_device_init_vm returns failure after vm is converted to\ncompute vm and vm->pasid set to compute pasid, KFD will not take\npdd->drm_file reference. As a result, drm close file handler maybe\ncalled to release the compute pasid before KFD process destroy worker to\nrelease the same pasid and set vm->pasid to zero, this generates below\nWARNING backtrace and NULL pointer access.\n\nAdd helper amdgpu_amdkfd_gpuvm_set_vm_pasid and call it at the last step\nof kfd_process_device_init_vm, to ensure vm pasid is the original pasid\nif acquiring vm failed or is the compute pasid with pdd->drm_file\nreference taken to avoid double release same pasid.\n\n amdgpu: Failed to create process VM object\n ida_free called for id=32770 which is not allocated.\n WARNING: CPU: 57 PID: 72542 at ../lib/idr.c:522 ida_free+0x96/0x140\n RIP: 0010:ida_free+0x96/0x140\n Call Trace:\n  amdgpu_pasid_free_delayed+0xe1/0x2a0 [amdgpu]\n  amdgpu_driver_postclose_kms+0x2d8/0x340 [amdgpu]\n  drm_file_free.part.13+0x216/0x270 [drm]\n  drm_close_helper.isra.14+0x60/0x70 [drm]\n  drm_release+0x6e/0xf0 [drm]\n  __fput+0xcc/0x280\n  ____fput+0xe/0x20\n  task_work_run+0x96/0xc0\n  do_exit+0x3d0/0xc10\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n RIP: 0010:ida_free+0x76/0x140\n Call Trace:\n  amdgpu_pasid_free_delayed+0xe1/0x2a0 [amdgpu]\n  amdgpu_driver_postclose_kms+0x2d8/0x340 [amdgpu]\n  drm_file_free.part.13+0x216/0x270 [drm]\n  drm_close_helper.isra.14+0x60/0x70 [drm]\n  drm_release+0x6e/0xf0 [drm]\n  __fput+0xcc/0x280\n  ____fput+0xe/0x20\n  task_work_run+0x96/0xc0\n  do_exit+0x3d0/0xc10",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50306",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix potential out of bound read in ext4_fc_replay_scan()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix potential out of bound read in ext4_fc_replay_scan()\n\nFor scan loop must ensure that at least EXT4_FC_TAG_BASE_LEN space. If remain\nspace less than EXT4_FC_TAG_BASE_LEN which will lead to out of bound read\nwhen mounting corrupt file system image.\nADD_RANGE/HEAD/TAIL is needed to add extra check when do journal scan, as this\nthree tags will read data during scan, tag length couldn't less than data length\nwhich will read.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50333",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fs: jfs: fix shift-out-of-bounds in dbDiscardAG",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: jfs: fix shift-out-of-bounds in dbDiscardAG\n\nThis should be applied to most URSAN bugs found recently by syzbot,\nby guarding the dbMount. As syzbot feeding rubbish into the bmap\ndescriptor.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50335",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: 9p: set req refcount to zero to avoid uninitialized usage",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\n9p: set req refcount to zero to avoid uninitialized usage\n\nWhen a new request is allocated, the refcount will be zero if it is\nreused, but if the request is newly allocated from slab, it is not fully\ninitialized before being added to idr.\n\nIf the p9_read_work got a response before the refcount initiated. It will\nuse a uninitialized req, which will result in a bad request data struct.\n\nHere is the logs from syzbot.\n\nCorrupted memory at 0xffff88807eade00b [ 0xff 0x07 0x00 0x00 0x00 0x00\n0x00 0x00 . . . . . . . . ] (in kfence-#110):\n p9_fcall_fini net/9p/client.c:248 [inline]\n p9_req_put net/9p/client.c:396 [inline]\n p9_req_put+0x208/0x250 net/9p/client.c:390\n p9_client_walk+0x247/0x540 net/9p/client.c:1165\n clone_fid fs/9p/fid.h:21 [inline]\n v9fs_fid_xattr_set+0xe4/0x2b0 fs/9p/xattr.c:118\n v9fs_xattr_set fs/9p/xattr.c:100 [inline]\n v9fs_xattr_handler_set+0x6f/0x120 fs/9p/xattr.c:159\n __vfs_setxattr+0x119/0x180 fs/xattr.c:182\n __vfs_setxattr_noperm+0x129/0x5f0 fs/xattr.c:216\n __vfs_setxattr_locked+0x1d3/0x260 fs/xattr.c:277\n vfs_setxattr+0x143/0x340 fs/xattr.c:309\n setxattr+0x146/0x160 fs/xattr.c:617\n path_setxattr+0x197/0x1c0 fs/xattr.c:636\n __do_sys_setxattr fs/xattr.c:652 [inline]\n __se_sys_setxattr fs/xattr.c:648 [inline]\n __ia32_sys_setxattr+0xc0/0x160 fs/xattr.c:648\n do_syscall_32_irqs_on arch/x86/entry/common.c:112 [inline]\n __do_fast_syscall_32+0x65/0xf0 arch/x86/entry/common.c:178\n do_fast_syscall_32+0x33/0x70 arch/x86/entry/common.c:203\n entry_SYSENTER_compat_after_hwframe+0x70/0x82\n\nBelow is a similar scenario, the scenario in the syzbot log looks more\ncomplicated than this one, but this patch can fix it.\n\n     T21124                   p9_read_work\n======================== second trans =================================\np9_client_walk\n  p9_client_rpc\n    p9_client_prepare_req\n      p9_tag_alloc\n        req = kmem_cache_alloc(p9_req_cache, GFP_NOFS);\n        tag = idr_alloc\n        << preempted >>\n        req->tc.tag = tag;\n                            /* req->[refcount/tag] == uninitialized */\n                            m->rreq = p9_tag_lookup(m->client, m->rc.tag);\n                              /* increments uninitalized refcount */\n\n        refcount_set(&req->refcount, 2);\n                            /* cb drops one ref */\n                            p9_client_cb(req)\n                            /* reader thread drops its ref:\n                               request is incorrectly freed */\n                            p9_req_put(req)\n    /* use after free and ref underflow */\n    p9_req_put(req)\n\nTo fix it, we can initialize the refcount to zero before add to idr.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50341",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cifs: fix oops during encryption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix oops during encryption\n\nWhen running xfstests against Azure the following oops occurred on an\narm64 system\n\n  Unable to handle kernel write to read-only memory at virtual address\n  ffff0001221cf000\n  Mem abort info:\n    ESR = 0x9600004f\n    EC = 0x25: DABT (current EL), IL = 32 bits\n    SET = 0, FnV = 0\n    EA = 0, S1PTW = 0\n    FSC = 0x0f: level 3 permission fault\n  Data abort info:\n    ISV = 0, ISS = 0x0000004f\n    CM = 0, WnR = 1\n  swapper pgtable: 4k pages, 48-bit VAs, pgdp=00000000294f3000\n  [ffff0001221cf000] pgd=18000001ffff8003, p4d=18000001ffff8003,\n  pud=18000001ff82e003, pmd=18000001ff71d003, pte=00600001221cf787\n  Internal error: Oops: 9600004f [#1] PREEMPT SMP\n  ...\n  pstate: 80000005 (Nzcv daif -PAN -UAO -TCO BTYPE=--)\n  pc : __memcpy+0x40/0x230\n  lr : scatterwalk_copychunks+0xe0/0x200\n  sp : ffff800014e92de0\n  x29: ffff800014e92de0 x28: ffff000114f9de80 x27: 0000000000000008\n  x26: 0000000000000008 x25: ffff800014e92e78 x24: 0000000000000008\n  x23: 0000000000000001 x22: 0000040000000000 x21: ffff000000000000\n  x20: 0000000000000001 x19: ffff0001037c4488 x18: 0000000000000014\n  x17: 235e1c0d6efa9661 x16: a435f9576b6edd6c x15: 0000000000000058\n  x14: 0000000000000001 x13: 0000000000000008 x12: ffff000114f2e590\n  x11: ffffffffffffffff x10: 0000040000000000 x9 : ffff8000105c3580\n  x8 : 2e9413b10000001a x7 : 534b4410fb86b005 x6 : 534b4410fb86b005\n  x5 : ffff0001221cf008 x4 : ffff0001037c4490 x3 : 0000000000000001\n  x2 : 0000000000000008 x1 : ffff0001037c4488 x0 : ffff0001221cf000\n  Call trace:\n   __memcpy+0x40/0x230\n   scatterwalk_map_and_copy+0x98/0x100\n   crypto_ccm_encrypt+0x150/0x180\n   crypto_aead_encrypt+0x2c/0x40\n   crypt_message+0x750/0x880\n   smb3_init_transform_rq+0x298/0x340\n   smb_send_rqst.part.11+0xd8/0x180\n   smb_send_rqst+0x3c/0x100\n   compound_send_recv+0x534/0xbc0\n   smb2_query_info_compound+0x32c/0x440\n   smb2_set_ea+0x438/0x4c0\n   cifs_xattr_set+0x5d4/0x7c0\n\nThis is because in scatterwalk_copychunks(), we attempted to write to\na buffer (@sign) that was allocated in the stack (vmalloc area) by\ncrypt_message() and thus accessing its remaining 8 (x2) bytes ended up\ncrossing a page boundary.\n\nTo simply fix it, we could just pass @sign kmalloc'd from\ncrypt_message() and then we're done.  Luckily, we don't seem to pass\nany other vmalloc'd buffers in smb_rqst::rq_iov...\n\nInstead, let's map the correct pages and offsets from vmalloc buffers\nas well in cifs_sg_set_buf() and then avoiding such oopses.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50346",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: init quota for 'old.inode' in 'ext4_rename'",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: init quota for 'old.inode' in 'ext4_rename'\n\nSyzbot found the following issue:\next4_parse_param: s_want_extra_isize=128\next4_inode_info_init: s_want_extra_isize=32\next4_rename: old.inode=ffff88823869a2c8 old.dir=ffff888238699828 new.inode=ffff88823869d7e8 new.dir=ffff888238699828\n__ext4_mark_inode_dirty: inode=ffff888238699828 ea_isize=32 want_ea_size=128\n__ext4_mark_inode_dirty: inode=ffff88823869a2c8 ea_isize=32 want_ea_size=128\next4_xattr_block_set: inode=ffff88823869a2c8\n------------[ cut here ]------------\nWARNING: CPU: 13 PID: 2234 at fs/ext4/xattr.c:2070 ext4_xattr_block_set.cold+0x22/0x980\nModules linked in:\nRIP: 0010:ext4_xattr_block_set.cold+0x22/0x980\nRSP: 0018:ffff888227d3f3b0 EFLAGS: 00010202\nRAX: 0000000000000001 RBX: ffff88823007a000 RCX: 0000000000000000\nRDX: 0000000000000a03 RSI: 0000000000000040 RDI: ffff888230078178\nRBP: 0000000000000000 R08: 000000000000002c R09: ffffed1075c7df8e\nR10: ffff8883ae3efc6b R11: ffffed1075c7df8d R12: 0000000000000000\nR13: ffff88823869a2c8 R14: ffff8881012e0460 R15: dffffc0000000000\nFS:  00007f350ac1f740(0000) GS:ffff8883ae200000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f350a6ed6a0 CR3: 0000000237456000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ? ext4_xattr_set_entry+0x3b7/0x2320\n ? ext4_xattr_block_set+0x0/0x2020\n ? ext4_xattr_set_entry+0x0/0x2320\n ? ext4_xattr_check_entries+0x77/0x310\n ? ext4_xattr_ibody_set+0x23b/0x340\n ext4_xattr_move_to_block+0x594/0x720\n ext4_expand_extra_isize_ea+0x59a/0x10f0\n __ext4_expand_extra_isize+0x278/0x3f0\n __ext4_mark_inode_dirty.cold+0x347/0x410\n ext4_rename+0xed3/0x174f\n vfs_rename+0x13a7/0x2510\n do_renameat2+0x55d/0x920\n __x64_sys_rename+0x7d/0xb0\n do_syscall_64+0x3b/0xa0\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nAs 'ext4_rename' will modify 'old.inode' ctime and mark inode dirty,\nwhich may trigger expand 'extra_isize' and allocate block. If inode\ndidn't init quota will lead to warning.  To solve above issue, init\n'old.inode' firstly in 'ext4_rename'.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50356",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: sched: sfb: fix null pointer access issue when sfb_init() fails",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: sfb: fix null pointer access issue when sfb_init() fails\n\nWhen the default qdisc is sfb, if the qdisc of dev_queue fails to be\ninited during mqprio_init(), sfb_reset() is invoked to clear resources.\nIn this case, the q->qdisc is NULL, and it will cause gpf issue.\n\nThe process is as follows:\nqdisc_create_dflt()\n\tsfb_init()\n\t\ttcf_block_get()          --->failed, q->qdisc is NULL\n\t...\n\tqdisc_put()\n\t\t...\n\t\tsfb_reset()\n\t\t\tqdisc_reset(q->qdisc)    --->q->qdisc is NULL\n\t\t\t\tops = qdisc->ops\n\nThe following is the Call Trace information:\ngeneral protection fault, probably for non-canonical address\n0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f]\nRIP: 0010:qdisc_reset+0x2b/0x6f0\nCall Trace:\n<TASK>\nsfb_reset+0x37/0xd0\nqdisc_reset+0xed/0x6f0\nqdisc_destroy+0x82/0x4c0\nqdisc_put+0x9e/0xb0\nqdisc_create_dflt+0x2c3/0x4a0\nmqprio_init+0xa71/0x1760\nqdisc_create+0x3eb/0x1000\ntc_modify_qdisc+0x408/0x1720\nrtnetlink_rcv_msg+0x38e/0xac0\nnetlink_rcv_skb+0x12d/0x3a0\nnetlink_unicast+0x4a2/0x740\nnetlink_sendmsg+0x826/0xcc0\nsock_sendmsg+0xc5/0x100\n____sys_sendmsg+0x583/0x690\n___sys_sendmsg+0xe8/0x160\n__sys_sendmsg+0xbf/0x160\ndo_syscall_64+0x35/0x80\nentry_SYSCALL_64_after_hwframe+0x46/0xb0\nRIP: 0033:0x7f2164122d04\n</TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50386",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix user-after-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix user-after-free\n\nThis uses l2cap_chan_hold_unless_zero() after calling\n__l2cap_get_chan_blah() to prevent the following trace:\n\nBluetooth: l2cap_core.c:static void l2cap_chan_destroy(struct kref\n*kref)\nBluetooth: chan 0000000023c4974d\nBluetooth: parent 00000000ae861c08\n==================================================================\nBUG: KASAN: use-after-free in __mutex_waiter_is_first\nkernel/locking/mutex.c:191 [inline]\nBUG: KASAN: use-after-free in __mutex_lock_common\nkernel/locking/mutex.c:671 [inline]\nBUG: KASAN: use-after-free in __mutex_lock+0x278/0x400\nkernel/locking/mutex.c:729\nRead of size 8 at addr ffff888006a49b08 by task kworker/u3:2/389",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50408",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: brcmfmac: fix use-after-free bug in brcmf_netdev_start_xmit()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix use-after-free bug in brcmf_netdev_start_xmit()\n\n> ret = brcmf_proto_tx_queue_data(drvr, ifp->ifidx, skb);\n\nmay be schedule, and then complete before the line\n\n> ndev->stats.tx_bytes += skb->len;\n\n[   46.912801] ==================================================================\n[   46.920552] BUG: KASAN: use-after-free in brcmf_netdev_start_xmit+0x718/0x8c8 [brcmfmac]\n[   46.928673] Read of size 4 at addr ffffff803f5882e8 by task systemd-resolve/328\n[   46.935991]\n[   46.937514] CPU: 1 PID: 328 Comm: systemd-resolve Tainted: G           O      5.4.199-[REDACTED] #1\n[   46.947255] Hardware name: [REDACTED]\n[   46.954568] Call trace:\n[   46.957037]  dump_backtrace+0x0/0x2b8\n[   46.960719]  show_stack+0x24/0x30\n[   46.964052]  dump_stack+0x128/0x194\n[   46.967557]  print_address_description.isra.0+0x64/0x380\n[   46.972877]  __kasan_report+0x1d4/0x240\n[   46.976723]  kasan_report+0xc/0x18\n[   46.980138]  __asan_report_load4_noabort+0x18/0x20\n[   46.985027]  brcmf_netdev_start_xmit+0x718/0x8c8 [brcmfmac]\n[   46.990613]  dev_hard_start_xmit+0x1bc/0xda0\n[   46.994894]  sch_direct_xmit+0x198/0xd08\n[   46.998827]  __qdisc_run+0x37c/0x1dc0\n[   47.002500]  __dev_queue_xmit+0x1528/0x21f8\n[   47.006692]  dev_queue_xmit+0x24/0x30\n[   47.010366]  neigh_resolve_output+0x37c/0x678\n[   47.014734]  ip_finish_output2+0x598/0x2458\n[   47.018927]  __ip_finish_output+0x300/0x730\n[   47.023118]  ip_output+0x2e0/0x430\n[   47.026530]  ip_local_out+0x90/0x140\n[   47.030117]  igmpv3_sendpack+0x14c/0x228\n[   47.034049]  igmpv3_send_cr+0x384/0x6b8\n[   47.037895]  igmp_ifc_timer_expire+0x4c/0x118\n[   47.042262]  call_timer_fn+0x1cc/0xbe8\n[   47.046021]  __run_timers+0x4d8/0xb28\n[   47.049693]  run_timer_softirq+0x24/0x40\n[   47.053626]  __do_softirq+0x2c0/0x117c\n[   47.057387]  irq_exit+0x2dc/0x388\n[   47.060715]  __handle_domain_irq+0xb4/0x158\n[   47.064908]  gic_handle_irq+0x58/0xb0\n[   47.068581]  el0_irq_naked+0x50/0x5c\n[   47.072162]\n[   47.073665] Allocated by task 328:\n[   47.077083]  save_stack+0x24/0xb0\n[   47.080410]  __kasan_kmalloc.isra.0+0xc0/0xe0\n[   47.084776]  kasan_slab_alloc+0x14/0x20\n[   47.088622]  kmem_cache_alloc+0x15c/0x468\n[   47.092643]  __alloc_skb+0xa4/0x498\n[   47.096142]  igmpv3_newpack+0x158/0xd78\n[   47.099987]  add_grhead+0x210/0x288\n[   47.103485]  add_grec+0x6b0/0xb70\n[   47.106811]  igmpv3_send_cr+0x2e0/0x6b8\n[   47.110657]  igmp_ifc_timer_expire+0x4c/0x118\n[   47.115027]  call_timer_fn+0x1cc/0xbe8\n[   47.118785]  __run_timers+0x4d8/0xb28\n[   47.122457]  run_timer_softirq+0x24/0x40\n[   47.126389]  __do_softirq+0x2c0/0x117c\n[   47.130142]\n[   47.131643] Freed by task 180:\n[   47.134712]  save_stack+0x24/0xb0\n[   47.138041]  __kasan_slab_free+0x108/0x180\n[   47.142146]  kasan_slab_free+0x10/0x18\n[   47.145904]  slab_free_freelist_hook+0xa4/0x1b0\n[   47.150444]  kmem_cache_free+0x8c/0x528\n[   47.154292]  kfree_skbmem+0x94/0x108\n[   47.157880]  consume_skb+0x10c/0x5a8\n[   47.161466]  __dev_kfree_skb_any+0x88/0xa0\n[   47.165598]  brcmu_pkt_buf_free_skb+0x44/0x68 [brcmutil]\n[   47.171023]  brcmf_txfinalize+0xec/0x190 [brcmfmac]\n[   47.176016]  brcmf_proto_bcdc_txcomplete+0x1c0/0x210 [brcmfmac]\n[   47.182056]  brcmf_sdio_sendfromq+0x8dc/0x1e80 [brcmfmac]\n[   47.187568]  brcmf_sdio_dpc+0xb48/0x2108 [brcmfmac]\n[   47.192529]  brcmf_sdio_dataworker+0xc8/0x238 [brcmfmac]\n[   47.197859]  process_one_work+0x7fc/0x1a80\n[   47.201965]  worker_thread+0x31c/0xc40\n[   47.205726]  kthread+0x2d8/0x370\n[   47.208967]  ret_from_fork+0x10/0x18\n[   47.212546]\n[   47.214051] The buggy address belongs to the object at ffffff803f588280\n[   47.214051]  which belongs to the cache skbuff_head_cache of size 208\n[   47.227086] The buggy address is located 104 bytes inside of\n[   47.227086]  208-byte region [ffffff803f588280, ffffff803f588350)\n[   47.238814] The buggy address belongs to the page:\n[   47.243618] page:ffffffff00dd6200 refcount:1 mapcou\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50410",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFSD: Protect against send buffer overflow in NFSv2 READ",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Protect against send buffer overflow in NFSv2 READ\n\nSince before the git era, NFSD has conserved the number of pages\nheld by each nfsd thread by combining the RPC receive and send\nbuffers into a single array of pages. This works because there are\nno cases where an operation needs a large RPC Call message and a\nlarge RPC Reply at the same time.\n\nOnce an RPC Call has been received, svc_process() updates\nsvc_rqst::rq_res to describe the part of rq_pages that can be\nused for constructing the Reply. This means that the send buffer\n(rq_res) shrinks when the received RPC record containing the RPC\nCall is large.\n\nA client can force this shrinkage on TCP by sending a correctly-\nformed RPC Call header contained in an RPC record that is\nexcessively large. The full maximum payload size cannot be\nconstructed in that case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50430",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mmc: vub300: fix warning - do not call blocking ops when !TASK_RUNNING",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmmc: vub300: fix warning - do not call blocking ops when !TASK_RUNNING\n\nvub300_enable_sdio_irq() works with mutex and need TASK_RUNNING here.\nEnsure that we mark current as TASK_RUNNING for sleepable context.\n\n[   77.554641] do not call blocking ops when !TASK_RUNNING; state=1 set at [<ffffffff92a72c1d>] sdio_irq_thread+0x17d/0x5b0\n[   77.554652] WARNING: CPU: 2 PID: 1983 at kernel/sched/core.c:9813 __might_sleep+0x116/0x160\n[   77.554905] CPU: 2 PID: 1983 Comm: ksdioirqd/mmc1 Tainted: G           OE      6.1.0-rc5 #1\n[   77.554910] Hardware name: Intel(R) Client Systems NUC8i7BEH/NUC8BEB, BIOS BECFL357.86A.0081.2020.0504.1834 05/04/2020\n[   77.554912] RIP: 0010:__might_sleep+0x116/0x160\n[   77.554920] RSP: 0018:ffff888107b7fdb8 EFLAGS: 00010282\n[   77.554923] RAX: 0000000000000000 RBX: ffff888118c1b740 RCX: 0000000000000000\n[   77.554926] RDX: 0000000000000001 RSI: 0000000000000004 RDI: ffffed1020f6ffa9\n[   77.554928] RBP: ffff888107b7fde0 R08: 0000000000000001 R09: ffffed1043ea60ba\n[   77.554930] R10: ffff88821f5305cb R11: ffffed1043ea60b9 R12: ffffffff93aa3a60\n[   77.554932] R13: 000000000000011b R14: 7fffffffffffffff R15: ffffffffc0558660\n[   77.554934] FS:  0000000000000000(0000) GS:ffff88821f500000(0000) knlGS:0000000000000000\n[   77.554937] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   77.554939] CR2: 00007f8a44010d68 CR3: 000000024421a003 CR4: 00000000003706e0\n[   77.554942] Call Trace:\n[   77.554944]  <TASK>\n[   77.554952]  mutex_lock+0x78/0xf0\n[   77.554973]  vub300_enable_sdio_irq+0x103/0x3c0 [vub300]\n[   77.554981]  sdio_irq_thread+0x25c/0x5b0\n[   77.555006]  kthread+0x2b8/0x370\n[   77.555017]  ret_from_fork+0x1f/0x30\n[   77.555023]  </TASK>\n[   77.555025] ---[ end trace 0000000000000000 ]---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50439",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: mediatek: mt8173: Enable IRQ when pdata is ready",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: mediatek: mt8173: Enable IRQ when pdata is ready\n\nIf the device does not come straight from reset, we might receive an IRQ\nbefore we are ready to handle it.\n\n\n[    2.334737] Unable to handle kernel read from unreadable memory at virtual address 00000000000001e4\n[    2.522601] Call trace:\n[    2.525040]  regmap_read+0x1c/0x80\n[    2.528434]  mt8173_afe_irq_handler+0x40/0xf0\n...\n[    2.598921]  start_kernel+0x338/0x42c",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50493",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: qla2xxx: Fix crash when I/O abort times out",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix crash when I/O abort times out\n\nWhile performing CPU hotplug, a crash with the following stack was seen:\n\nCall Trace:\n     qla24xx_process_response_queue+0x42a/0x970 [qla2xxx]\n     qla2x00_start_nvme_mq+0x3a2/0x4b0 [qla2xxx]\n     qla_nvme_post_cmd+0x166/0x240 [qla2xxx]\n     nvme_fc_start_fcp_op.part.0+0x119/0x2e0 [nvme_fc]\n     blk_mq_dispatch_rq_list+0x17b/0x610\n     __blk_mq_sched_dispatch_requests+0xb0/0x140\n     blk_mq_sched_dispatch_requests+0x30/0x60\n     __blk_mq_run_hw_queue+0x35/0x90\n     __blk_mq_delay_run_hw_queue+0x161/0x180\n     blk_execute_rq+0xbe/0x160\n     __nvme_submit_sync_cmd+0x16f/0x220 [nvme_core]\n     nvmf_connect_admin_queue+0x11a/0x170 [nvme_fabrics]\n     nvme_fc_create_association.cold+0x50/0x3dc [nvme_fc]\n     nvme_fc_connect_ctrl_work+0x19/0x30 [nvme_fc]\n     process_one_work+0x1e8/0x3c0\n\nOn abort timeout, completion was called without checking if the I/O was\nalready completed.\n\nVerify that I/O and abort request are indeed outstanding before attempting\ncompletion.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50554",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: blk-mq: avoid double ->queue_rq() because of early timeout",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: avoid double ->queue_rq() because of early timeout\n\nDavid Jeffery found one double ->queue_rq() issue, so far it can\nbe triggered in VM use case because of long vmexit latency or preempt\nlatency of vCPU pthread or long page fault in vCPU pthread, then block\nIO req could be timed out before queuing the request to hardware but after\ncalling blk_mq_start_request() during ->queue_rq(), then timeout handler\nmay handle it by requeue, then double ->queue_rq() is caused, and kernel\npanic.\n\nSo far, it is driver's responsibility to cover the race between timeout\nand completion, so it seems supposed to be solved in driver in theory,\ngiven driver has enough knowledge.\n\nBut it is really one common problem, lots of driver could have similar\nissue, and could be hard to fix all affected drivers, even it isn't easy\nfor driver to handle the race. So David suggests this patch by draining\nin-progress ->queue_rq() for solving this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50567",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fs: jfs: fix shift-out-of-bounds in dbAllocAG",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: jfs: fix shift-out-of-bounds in dbAllocAG\n\nSyzbot found a crash : UBSAN: shift-out-of-bounds in dbAllocAG. The\nunderlying bug is the missing check of bmp->db_agl2size. The field can\nbe greater than 64 and trigger the shift-out-of-bounds.\n\nFix this bug by adding a check of bmp->db_agl2size in dbMount since this\nfield is used in many following functions. The upper bound for this\nfield is L2MAXL2SIZE - L2MAXAG, thanks for the help of Dave Kleikamp.\nNote that, for maintenance, I reorganized error handling code of dbMount.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-50579",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arm64: ftrace: fix module PLTs with mcount",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: ftrace: fix module PLTs with mcount\n\nLi Huafei reports that mcount-based ftrace with module PLTs was broken\nby commit:\n\n  a6253579977e4c6f (\"arm64: ftrace: consistently handle PLTs.\")\n\nWhen a module PLTs are used and a module is loaded sufficiently far away\nfrom the kernel, we'll create PLTs for any branches which are\nout-of-range. These are separate from the special ftrace trampoline\nPLTs, which the module PLT code doesn't directly manipulate.\n\nWhen mcount is in use this is a problem, as each mcount callsite in a\nmodule will be initialized to point to a module PLT, but since commit\na6253579977e4c6f ftrace_make_nop() will assume that the callsite has\nbeen initialized to point to the special ftrace trampoline PLT, and\nftrace_find_callable_addr() rejects other cases.\n\nThis means that when ftrace tries to initialize a callsite via\nftrace_make_nop(), the call to ftrace_find_callable_addr() will find\nthat the `_mcount` stub is out-of-range and is not handled by the ftrace\nPLT, resulting in a splat:\n\n| ftrace_test: loading out-of-tree module taints kernel.\n| ftrace: no module PLT for _mcount\n| ------------[ ftrace bug ]------------\n| ftrace failed to modify\n| [<ffff800029180014>] 0xffff800029180014\n|  actual:   44:00:00:94\n| Initializing ftrace call sites\n| ftrace record flags: 2000000\n|  (0)\n|  expected tramp: ffff80000802eb3c\n| ------------[ cut here ]------------\n| WARNING: CPU: 3 PID: 157 at kernel/trace/ftrace.c:2120 ftrace_bug+0x94/0x270\n| Modules linked in:\n| CPU: 3 PID: 157 Comm: insmod Tainted: G           O       6.0.0-rc6-00151-gcd722513a189-dirty #22\n| Hardware name: linux,dummy-virt (DT)\n| pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n| pc : ftrace_bug+0x94/0x270\n| lr : ftrace_bug+0x21c/0x270\n| sp : ffff80000b2bbaf0\n| x29: ffff80000b2bbaf0 x28: 0000000000000000 x27: ffff0000c4d38000\n| x26: 0000000000000001 x25: ffff800009d7e000 x24: ffff0000c4d86e00\n| x23: 0000000002000000 x22: ffff80000a62b000 x21: ffff8000098ebea8\n| x20: ffff0000c4d38000 x19: ffff80000aa24158 x18: ffffffffffffffff\n| x17: 0000000000000000 x16: 0a0d2d2d2d2d2d2d x15: ffff800009aa9118\n| x14: 0000000000000000 x13: 6333626532303830 x12: 3030303866666666\n| x11: 203a706d61727420 x10: 6465746365707865 x9 : 3362653230383030\n| x8 : c0000000ffffefff x7 : 0000000000017fe8 x6 : 000000000000bff4\n| x5 : 0000000000057fa8 x4 : 0000000000000000 x3 : 0000000000000001\n| x2 : ad2cb14bb5438900 x1 : 0000000000000000 x0 : 0000000000000022\n| Call trace:\n|  ftrace_bug+0x94/0x270\n|  ftrace_process_locs+0x308/0x430\n|  ftrace_module_init+0x44/0x60\n|  load_module+0x15b4/0x1ce8\n|  __do_sys_init_module+0x1ec/0x238\n|  __arm64_sys_init_module+0x24/0x30\n|  invoke_syscall+0x54/0x118\n|  el0_svc_common.constprop.4+0x84/0x100\n|  do_el0_svc+0x3c/0xd0\n|  el0_svc+0x1c/0x50\n|  el0t_64_sync_handler+0x90/0xb8\n|  el0t_64_sync+0x15c/0x160\n| ---[ end trace 0000000000000000 ]---\n| ---------test_init-----------\n\nFix this by reverting to the old behaviour of ignoring the old\ninstruction when initialising an mcount callsite in a module, which was\nthe behaviour prior to commit a6253579977e4c6f.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-0045",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bypassing Spectre-BTI User Space Mitigations",
      "description": "The current implementation of the prctl syscall does not issue an IBPB immediately during the syscall. The ib_prctl_set \u00a0function updates the Thread Information Flags (TIFs) for the task and updates the SPEC_CTRL MSR on the function __speculation_ctrl_update, but the IBPB is only issued on the next schedule, when the TIF bits are checked. This leaves the victim vulnerable to values already injected on the BTB, prior to the prctl syscall. \u00a0The patch that added the support for the conditional mitigation via prctl (ib_prctl_set) dates back to the kernel 4.9.176.\n\nWe recommend upgrading past commit\u00a0a664ec9158eeddd75121d39c9a0758016097fa96",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-0179",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Netfilter integer overflow vulnerability in nft_payload_copy_vlan",
      "description": "A buffer overflow vulnerability was found in the Netfilter subsystem in the Linux Kernel. This issue could allow the leakage of both stack and heap addresses, and potentially allow Local Privilege Escalation to the root user via arbitrary code execution.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-0240",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: io_uring: reference counting issue in io_prep_async_work leads to use-after-free",
      "description": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-0266",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ALSA: pcm: Move rwsem lock inside snd_ctl_elem_read to prevent UAF",
      "description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-0386",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: FUSE filesystem low-privileged user privileges escalation",
      "description": "A flaw was found in the Linux kernel, where unauthorized access to the execution of the setuid file with capabilities was found in the Linux kernel\u2019s OverlayFS subsystem in how a user copies a capable file from a nosuid mount into another mount. This uid mapping bug allows a local user to escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-0461",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/ulp: use-after-free in listening ULP sockets",
      "description": "There is a use-after-free vulnerability in the Linux Kernel which can be exploited to achieve local privilege escalation. To reach the vulnerability kernel configuration flag CONFIG_TLS\u00a0or CONFIG_XFRM_ESPINTCP\u00a0has to be configured, but the operation does not require any privilege.\n\nThere is a use-after-free bug of icsk_ulp_data\u00a0of a struct inet_connection_sock.\n\nWhen CONFIG_TLS\u00a0is enabled, user can install a tls context (struct tls_context) on a connected tcp socket. The context is not cleared if this socket is disconnected and reused as a listener. If a new socket is created from the listener, the context is inherited and vulnerable.\n\nThe setsockopt\u00a0TCP_ULP\u00a0operation does not require any privilege.\n\nWe recommend upgrading past commit\u00a02c02d41d71f90a5168391b6a5f2954112ba2307c",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1077",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Type confusion in pick_next_rt_entity()",
      "description": "In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1078",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Heap OOB Write in rds_rm_zerocopy_callback()",
      "description": "A flaw was found in the Linux Kernel in RDS (Reliable Datagram Sockets) protocol. The rds_rm_zerocopy_callback() uses list_entry() on the head of a list causing a type confusion. Local user can trigger this with rds_message_put(). Type confusion leads to `struct rds_msg_zcopy_info *info` actually points to something else that is potentially controlled by local user. It is known how to trigger this, which causes an out of bounds access, and a lock corruption.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1118",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in drivers/media/rc/ene_ir.c due to race condition",
      "description": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1281",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcindex: use-after-free vulnerability in traffic control index filter allows privilege escalation",
      "description": "Use After Free vulnerability in Linux kernel traffic control index filter (tcindex) allows Privilege Escalation.\u00a0The imperfect hash area can be updated while packets are traversing, which will cause a use-after-free when 'tcf_exts_exec()' is called with the destroyed tcf_ext.\u00a0A local attacker user can use this vulnerability to elevate its privileges to root.\nThis issue affects Linux Kernel: from 4.14 before git commit ee059170b1f7e94e55fa6cadee544e176a6e59c2.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1295",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.162-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: io_uring: TOCTOU vulnerability in IORING_OP_CLOSE operation",
      "description": "A time-of-check to time-of-use issue exists in io_uring subsystem's IORING_OP_CLOSE operation in the Linux kernel's versions 5.6 - 5.11 (inclusive), which allows a local user to elevate their privileges to root. Introduced in b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb, patched in 9eac1904d3364254d622bf2c771c4f85cd435fc2, backported to stable in 788d0824269bef539fe31a785b1517882eafed93.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1380",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Kernel: a USB-accessible slab-out-of-bounds read in brcmfmac",
      "description": "A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info->req_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1670",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use after free bug in xirc2ps_detach",
      "description": "A flaw use after free in the Linux kernel Xircom 16-bit PCMCIA (PC-card) Ethernet driver was found.A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1829",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Use-after-free vulnerability in the Linux Kernel traffic control index filter",
      "description": "A use-after-free vulnerability in the Linux Kernel traffic control index filter (tcindex) can be exploited to achieve local privilege escalation.\u00a0The tcindex_delete function which does not properly deactivate filters in case of a perfect hashes while deleting the underlying structure which can later lead to double freeing the structure.\u00a0A local attacker user can use this vulnerability to elevate its privileges to root.\nWe recommend upgrading past commit 8c710f75256bb3cf05ac7b1672c82b92c43f3d28.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1872",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: io_uring: use-after-free vulnerability in io_file_get_fixed",
      "description": "A use-after-free vulnerability in the Linux Kernel io_uring system can be exploited to achieve local privilege escalation.\n\nThe io_file_get_fixed function lacks the presence of ctx->uring_lock which can lead to a Use-After-Free vulnerability due a race condition with fixed files getting unregistered.\n\nWe recommend upgrading past commit da24142b1ef9fd5d36b76e36bab328a5b27523e8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-1989",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Use after free bug in btsdio_remove due to race condition",
      "description": "A use-after-free flaw was found in btsdio_remove in drivers\\bluetooth\\btsdio.c in the Linux Kernel. In this flaw, a call to btsdio_remove with an unfinished job, may cause a race problem leading to a UAF on hdev devices.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-2006",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: rxrpc: race condition between connection bundle lookup and removal",
      "description": "A race condition was found in the Linux kernel's RxRPC network protocol, within the processing of RxRPC bundles. This issue results from the lack of proper locking when performing operations on an object. This may allow an attacker to escalate privileges and execute arbitrary code in the context of the kernel.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-2007",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: DPT I2O controller TOCTOU information disclosure vulnerability",
      "description": "The specific flaw exists within the DPT I2O Controller driver. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this in conjunction with other vulnerabilities to escalate privileges and execute arbitrary code in the context of the kernel.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-20928",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "In binder_vma_close of binder.c, there is a possible use after free du ...",
      "description": "In binder_vma_close of binder.c, there is a possible use after free due to improper locking. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-254837884References: Upstream kernel",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-20938",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "In binder_transaction_buffer_release of binder.c, there is a possible  ...",
      "description": "In binder_transaction_buffer_release of binder.c, there is a possible use after free due to improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-257685302References: Upstream kernel",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-21102",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bypass of shadow stack protection due to a logic error",
      "description": "In __efi_rt_asm_wrapper of efi-rt-wrapper.S, there is a possible bypass of shadow stack protection due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-260821414References: Upstream kernel",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-2124",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: OOB access in the Linux kernel's XFS subsystem",
      "description": "An out-of-bounds memory access flaw was found in the Linux kernel\u2019s XFS file system in how a user restores an XFS image after failure (with a dirty log journal). This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-21255",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "In multiple functions of binder.c, there is a possible memory corrupti ...",
      "description": "In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-2156",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: IPv6 RPL protocol reachable assertion leads to DoS",
      "description": "A flaw was found in the networking subsystem of the Linux kernel within the handling of the RPL protocol. This issue results from the lack of proper handling of user-supplied data, which can lead to an assertion failure. This may allow an unauthenticated remote attacker to create a denial of service condition on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-2163",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Incorrect verifier pruning leads to unsafe code paths being incorrectly marked as safe",
      "description": "Incorrect verifier pruning\u00a0in BPF in Linux Kernel\u00a0>=5.4\u00a0leads to unsafe\ncode paths being incorrectly marked as safe, resulting in\u00a0arbitrary read/write in\nkernel memory, lateral privilege escalation, and container escape.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-23559",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Integer overflow in function rndis_query_oid of rndis_wlan.c",
      "description": "In rndis_query_oid in drivers/net/wireless/rndis_wlan.c in the Linux kernel through 6.1.5, there is an integer overflow in an addition.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-28466",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tls: race condition in do_tls_getsockopt may lead to use-after-free or NULL pointer dereference",
      "description": "do_tls_getsockopt in net/tls/tls_main.c in the Linux kernel through 6.2.6 lacks a lock_sock call, leading to a race condition (with a resultant use-after-free or NULL pointer dereference).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3090",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipvlan: out-of-bounds write caused by unclear skb->cb",
      "description": "A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation.\n\nThe out-of-bounds write is caused by missing skb->cb  initialization in the ipvlan network driver. The vulnerability is reachable if\u00a0CONFIG_IPVLAN is enabled.\n\n\nWe recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3111",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Use after free in prepare_to_relocate in fs/btrfs/relocation.c",
      "description": "A use after free vulnerability was found in prepare_to_relocate in fs/btrfs/relocation.c in btrfs in the Linux Kernel. This possible flaw can be triggered by calling btrfs_ioctl_balance() before calling btrfs_ioctl_defrag().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-31248",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nf_tables: use-after-free in nft_chain_lookup_byid()",
      "description": "Linux Kernel nftables Use-After-Free Local Privilege Escalation Vulnerability; `nft_chain_lookup_byid()` failed to check whether a chain was active and CAP_NET_ADMIN is in any user or network namespace",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-31436",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: out-of-bounds write in qfq_change_class function",
      "description": "qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13 allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-32233",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: use-after-free in nf_tables when processing batch requests can lead to privilege escalation",
      "description": "In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables when processing batch requests can be abused to perform arbitrary read and write operations on kernel memory. Unprivileged local users can obtain root privileges. This occurs because anonymous sets are mishandled.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-32256",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ksmbd race issue from smb2 close and logoff with multichannel",
      "description": "A flaw was found in the Linux kernel's ksmbd component. A race condition between smb2 close operation and logoff in multichannel connections could result in a use-after-free issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3268",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: out-of-bounds access in relay_file_read",
      "description": "An out of bounds (OOB) memory access flaw was found in the Linux kernel in relay_file_read_start_pos in kernel/relay.c in the relayfs. This flaw could allow a local attacker to crash the system or leak kernel internal information.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3389",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Racing a io_uring cancel poll request with a linked timeout can cause a UAF in a hrtimer",
      "description": "A use-after-free vulnerability in the Linux Kernel io_uring subsystem can be exploited to achieve local privilege escalation.\n\nRacing a io_uring cancel poll request with a linked timeout can cause a UAF in a hrtimer.\n\nWe recommend upgrading past commit ef7dfac51d8ed961b742218f526bd589f3900a59 (4716c73b188566865bdd79c3a6709696a224ac04 for 5.10 stable and\u00a00e388fce7aec40992eadee654193cad345d62663 for 5.15 stable).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3390",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: UAF in nftables when nft_set_lookup_global triggered after handling named and anonymous sets in batch requests",
      "description": "A use-after-free vulnerability was found in the Linux kernel's netfilter subsystem in net/netfilter/nf_tables_api.c.\n\nMishandled error handling with NFT_MSG_NEWRULE makes it possible to use a dangling pointer in the same transaction causing a use-after-free vulnerability. This flaw allows a local attacker with user access to cause a privilege escalation issue.\n\nWe recommend upgrading past commit\u00a01240eb93f0616b21c675416516ff3d74798fdc97.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-34319",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "xen: buffer overrun in netback due to unusual packet (XSA-432)",
      "description": "The fix for XSA-423 added logic to Linux'es netback driver to deal with\na frontend splitting a packet in a way such that not all of the headers\nwould come in one piece.  Unfortunately the logic introduced there\ndidn't account for the extreme case of the entire packet being split\ninto as many pieces as permitted by the protocol, yet still being\nsmaller than the area that's specially dealt with to keep all (possible)\nheaders together.  Such an unusual packet would therefore trigger a\nbuffer overrun in the driver.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-35001",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nf_tables: stack-out-of-bounds-read in nft_byteorder_eval()",
      "description": "Linux Kernel nftables Out-Of-Bounds Read/Write Vulnerability; nft_byteorder poorly handled vm register contents when CAP_NET_ADMIN is in any user or network namespace",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3567",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use after free in vcs_read in drivers/tty/vt/vc_screen.c due to race",
      "description": "A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-35788",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cls_flower: out-of-bounds write in fl_set_geneve_opt()",
      "description": "An issue was discovered in fl_set_geneve_opt in net/sched/cls_flower.c in the Linux kernel before 6.3.7. It allows an out-of-bounds write in the flower classifier code via TCA_FLOWER_KEY_ENC_OPTS_GENEVE packets. This may result in denial of service or privilege escalation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-35827",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ravb: race condition leading to use-after-free in ravb_remove()",
      "description": "An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3609",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: cls_u32 component reference counter leak if tcf_change_indev() fails",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.\n\nIf tcf_change_indev() fails, u32_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.\n\nWe recommend upgrading past commit 04c55383fa5689357bcdd2c8036725a55ed632bc.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3610",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.179-3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: fix chain binding transaction logic in the abort path of NFT_MSG_NEWRULE",
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.\n\nFlaw in the error handling of bound chains causes a use-after-free in the abort path of NFT_MSG_NEWRULE. The vulnerability requires CAP_NET_ADMIN to be triggered.\n\nWe recommend upgrading past commit 4bedf9eee016286c835e3d8fa981ddece5338795.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3611",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: sch_qfq component can be exploited if in qfq_change_agg function happens qfq_enqueue overhead",
      "description": "An out-of-bounds write vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.\n\nThe qfq_change_agg() function in net/sched/sch_qfq.c allows an out-of-bounds write because lmax is updated according to packet sizes without bounds checks.\n\nWe recommend upgrading past commit 3e337087c3b5805fe0b8a46ba622a962880b5d64.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3776",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: cls_fw component can be exploited as result of failure in tcf_change_indev function",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.\n\nIf tcf_change_indev() fails, fw_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.\n\nWe recommend upgrading past commit 0323bce598eea038714f941ce2b22541c46d488f.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3777",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in netfilter: nf_tables",
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.\n\nWhen nf_tables_delrule() is flushing table rules, it is not checked whether the chain is bound and the chain's owner rule can also release the objects in certain circumstances.\n\nWe recommend upgrading past commit 6eaf41e87a223ae6f8e7a28d6e78384ad7e407f8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-3812",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.158-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tun: bugs for oversize packet when napi frags enabled in tun_napi_alloc_frags",
      "description": "An out-of-bounds memory access flaw was found in the Linux kernel\u2019s TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-39197",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: DCCP: conntrack out-of-bounds read in nf_conntrack_dccp_packet()",
      "description": "An out-of-bounds read vulnerability was found in Netfilter Connection Tracking (conntrack) in the Linux kernel. This flaw allows a remote user to disclose sensitive information via the DCCP protocol.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4004",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: use-after-free due to improper element removal in nft_pipapo_remove()",
      "description": "A use-after-free flaw was found in the Linux kernel's netfilter in the way a user triggers the nft_pipapo_remove function with the element, without a NFT_SET_EXT_KEY_END. This issue could allow a local user to crash the system or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-40283",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in l2cap_sock_release in net/bluetooth/l2cap_sock.c",
      "description": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4147",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables_newrule when adding a rule with NFTA_RULE_CHAIN_ID leads to use-after-free",
      "description": "A use-after-free flaw was found in the Linux kernel\u2019s Netfilter functionality when adding a rule with NFTA_RULE_CHAIN_ID. This flaw allows a local user to crash or escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4206",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Use-after-free vulnerabilities in the net/sched classifiers: cls_fw, cls_u32 and cls_route",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_route component can be exploited to achieve local privilege escalation.\n\nWhen route4_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.\n\nWe recommend upgrading past commit b80b829e9e2c1b3f7aae34855e04d8f6ecaf13c8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4207",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Use-after-free vulnerabilities in the net/sched classifiers: cls_fw, cls_u32 and cls_route",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_fw component can be exploited to achieve local privilege escalation.\n\nWhen fw_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.\n\nWe recommend upgrading past commit 76e42ae831991c828cffa8c37736ebfb831ad5ec.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4208",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Use-after-free vulnerabilities in the net/sched classifiers: cls_fw, cls_u32 and cls_route",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.\n\nWhen u32_change() is called on an existing filter, the whole tcf_result struct is always copied into the new instance of the filter. This causes a problem when updating a filter bound to a class, as tcf_unbind_filter() is always called on the old instance in the success path, decreasing filter_cnt of the still referenced class and allowing it to be deleted, leading to a use-after-free.\n\nWe recommend upgrading past commit 3044b16e7c6fe5d24b1cdbcf1bd0a9d92d1ebd81.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4244",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Use-after-free in nft_verdict_dump due to a race between set GC and transaction",
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.\n\nDue to a race condition between nf_tables netlink control plane transaction and nft_set element garbage collection, it is possible to underflow the reference counter causing a use-after-free vulnerability.\n\nWe recommend upgrading past commit 3e91b0ebd994635df2346353322ac51ce84ce6d8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-42753",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: potential slab-out-of-bound access due to integer underflow",
      "description": "An array indexing vulnerability was found in the netfilter subsystem of the Linux kernel. A missing macro could lead to a miscalculation of the `h->nets` array offset, providing attackers with the primitive to arbitrarily increment/decrement a memory buffer out-of-bound. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-45871",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: IGB driver inadequate buffer size for frames larger than MTU",
      "description": "An issue was discovered in drivers/net/ethernet/intel/igb/igb_main.c in the IGB driver in the Linux kernel before 6.5.3. A buffer size may not be adequate for frames larger than the MTU.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4622",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use after free in unix_stream_sendpage",
      "description": "A use-after-free vulnerability in the Linux kernel's af_unix component can be exploited to achieve local privilege escalation.\n\nThe unix_stream_sendpage() function tries to add data to the last skb in the peer's recv queue without locking the queue. Thus there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free.\n\nWe recommend upgrading past commit 790c2f9d15b594350ae9bca7b236f2b1859de02c.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4623",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: sch_hfsc UAF",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: sch_hfsc (HFSC qdisc traffic control) component can be exploited to achieve local privilege escalation.\n\nIf a class with a link-sharing curve (i.e. with the HFSC_FSC flag set) has a parent without a link-sharing curve, then init_vf() will call vttree_insert() on the parent, but vttree_remove() will be skipped in update_vf(). This leaves a dangling pointer that can cause a use-after-free.\n\nWe recommend upgrading past commit b3d26c5702c7d6c45456326e56d2ccf3f103e60f.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-46813",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: SEV-ES local priv escalation",
      "description": "An issue was discovered in the Linux kernel before 6.5.9, exploitable by local users with userspace access to MMIO registers. Incorrect access checking in the #VC handler and instruction emulation of the SEV-ES emulation of MMIO accesses could lead to arbitrary write access to kernel memory (and thus privilege escalation). This depends on a race condition through which userspace can replace an instruction before the #VC handler reads it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-46838",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "Transmit requests in Xen's virtual network protocol can consist of mul ...",
      "description": "Transmit requests in Xen's virtual network protocol can consist of\nmultiple parts.  While not really useful, except for the initial part\nany of them may be of zero length, i.e. carry no data at all.  Besides a\ncertain initial portion of the to be transferred data, these parts are\ndirectly translated into what Linux calls SKB fragments.  Such converted\nrequest parts can, when for a particular SKB they are all of length\nzero, lead to a de-reference of NULL in core networking code.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-4921",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in sch_qfq network scheduler",
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: sch_qfq component can be exploited to achieve local privilege escalation.\n\nWhen the plug qdisc is used as a class of the qfq qdisc, sending network packets triggers use-after-free in qfq_dequeue() due to the incorrect .peek handler of sch_plug and lack of error checking in agg_dequeue().\n\nWe recommend upgrading past commit 8fc134fee27f2263988ae38920bc03da416b03d8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-51042",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c",
      "description": "In the Linux kernel before 6.4.12, amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c has a fence use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-51043",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free during a race condition between a nonblocking atomic commit and a driver unload in drivers/gpu/drm/drm_atomic.c",
      "description": "In the Linux kernel before 6.4.5, drivers/gpu/drm/drm_atomic.c has a use-after-free during a race condition between a nonblocking atomic commit and a driver unload.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-51779",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bluetooth: bt_sock_ioctl race condition leads to use-after-free in bt_sock_recvmsg",
      "description": "bt_sock_recvmsg in net/bluetooth/af_bluetooth.c in the Linux kernel through 6.6.8 has a use-after-free because of a bt_sock_ioctl race condition.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-5178",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use after free in nvmet_tcp_free_crypto in NVMe",
      "description": "A use-after-free vulnerability was found in drivers/nvme/target/tcp.c` in `nvmet_tcp_free_crypto` due to a logical bug in the NVMe/TCP subsystem in the Linux kernel. This issue may allow a malicious user to cause a use-after-free and double-free problem, which may permit remote code execution or lead to local privilege escalation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-51780",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in net/atm/ioctl.c",
      "description": "An issue was discovered in the Linux kernel before 6.6.8. do_vcc_ioctl in net/atm/ioctl.c has a use-after-free because of a vcc_recvmsg race condition.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-51781",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in net/appletalk/ddp.c",
      "description": "An issue was discovered in the Linux kernel before 6.6.8. atalk_ioctl in net/appletalk/ddp.c has a use-after-free because of an atalk_recvmsg race condition.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-51782",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "An issue was discovered in the Linux kernel before 6.6.8. rose_ioctl i ...",
      "description": "An issue was discovered in the Linux kernel before 6.6.8. rose_ioctl in net/rose/af_rose.c has a use-after-free because of a rose_accept race condition.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52340",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ICMPv6 \u201cPacket Too Big\u201d packets force a DoS of the Linux kernel by forcing 100% CPU",
      "description": "The IPv6 implementation in the Linux kernel before 6.3 has a net/ipv6/route.c max_size threshold that can be consumed easily, e.g., leading to a denial of service (network is unreachable errors) when IPv6 packets are sent in a loop via a raw socket.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52434",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential OOBs in smb2_parse_contexts()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential OOBs in smb2_parse_contexts()\n\nValidate offsets and lengths before dereferencing create contexts in\nsmb2_parse_contexts().\n\nThis fixes following oops when accessing invalid create contexts from\nserver:\n\n  BUG: unable to handle page fault for address: ffff8881178d8cc3\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 4a01067 P4D 4a01067 PUD 0\n  Oops: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 3 PID: 1736 Comm: mount.cifs Not tainted 6.7.0-rc4 #1\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\n  rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014\n  RIP: 0010:smb2_parse_contexts+0xa0/0x3a0 [cifs]\n  Code: f8 10 75 13 48 b8 93 ad 25 50 9c b4 11 e7 49 39 06 0f 84 d2 00\n  00 00 8b 45 00 85 c0 74 61 41 29 c5 48 01 c5 41 83 fd 0f 76 55 <0f> b7\n  7d 04 0f b7 45 06 4c 8d 74 3d 00 66 83 f8 04 75 bc ba 04 00\n  RSP: 0018:ffffc900007939e0 EFLAGS: 00010216\n  RAX: ffffc90000793c78 RBX: ffff8880180cc000 RCX: ffffc90000793c90\n  RDX: ffffc90000793cc0 RSI: ffff8880178d8cc0 RDI: ffff8880180cc000\n  RBP: ffff8881178d8cbf R08: ffffc90000793c22 R09: 0000000000000000\n  R10: ffff8880180cc000 R11: 0000000000000024 R12: 0000000000000000\n  R13: 0000000000000020 R14: 0000000000000000 R15: ffffc90000793c22\n  FS: 00007f873753cbc0(0000) GS:ffff88806bc00000(0000)\n  knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: ffff8881178d8cc3 CR3: 00000000181ca000 CR4: 0000000000750ef0\n  PKRU: 55555554\n  Call Trace:\n   <TASK>\n   ? __die+0x23/0x70\n   ? page_fault_oops+0x181/0x480\n   ? search_module_extables+0x19/0x60\n   ? srso_alias_return_thunk+0x5/0xfbef5\n   ? exc_page_fault+0x1b6/0x1c0\n   ? asm_exc_page_fault+0x26/0x30\n   ? smb2_parse_contexts+0xa0/0x3a0 [cifs]\n   SMB2_open+0x38d/0x5f0 [cifs]\n   ? smb2_is_path_accessible+0x138/0x260 [cifs]\n   smb2_is_path_accessible+0x138/0x260 [cifs]\n   cifs_is_path_remote+0x8d/0x230 [cifs]\n   cifs_mount+0x7e/0x350 [cifs]\n   cifs_smb3_do_mount+0x128/0x780 [cifs]\n   smb3_get_tree+0xd9/0x290 [cifs]\n   vfs_get_tree+0x2c/0x100\n   ? capable+0x37/0x70\n   path_mount+0x2d7/0xb80\n   ? srso_alias_return_thunk+0x5/0xfbef5\n   ? _raw_spin_unlock_irqrestore+0x44/0x60\n   __x64_sys_mount+0x11a/0x150\n   do_syscall_64+0x47/0xf0\n   entry_SYSCALL_64_after_hwframe+0x6f/0x77\n  RIP: 0033:0x7f8737657b1e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52436",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: explicitly null-terminate the xattr list",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: explicitly null-terminate the xattr list\n\nWhen setting an xattr, explicitly null-terminate the xattr list.  This\neliminates the fragile assumption that the unused xattr space is always\nzeroed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52438",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: binder: fix use-after-free in shinker's callback",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbinder: fix use-after-free in shinker's callback\n\nThe mmap read lock is used during the shrinker's callback, which means\nthat using alloc->vma pointer isn't safe as it can race with munmap().\nAs of commit dd2283f2605e (\"mm: mmap: zap pages with read mmap_sem in\nmunmap\") the mmap lock is downgraded after the vma has been isolated.\n\nI was able to reproduce this issue by manually adding some delays and\ntriggering page reclaiming through the shrinker's debug sysfs. The\nfollowing KASAN report confirms the UAF:\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in zap_page_range_single+0x470/0x4b8\n  Read of size 8 at addr ffff356ed50e50f0 by task bash/478\n\n  CPU: 1 PID: 478 Comm: bash Not tainted 6.6.0-rc5-00055-g1c8b86a3799f-dirty #70\n  Hardware name: linux,dummy-virt (DT)\n  Call trace:\n   zap_page_range_single+0x470/0x4b8\n   binder_alloc_free_page+0x608/0xadc\n   __list_lru_walk_one+0x130/0x3b0\n   list_lru_walk_node+0xc4/0x22c\n   binder_shrink_scan+0x108/0x1dc\n   shrinker_debugfs_scan_write+0x2b4/0x500\n   full_proxy_write+0xd4/0x140\n   vfs_write+0x1ac/0x758\n   ksys_write+0xf0/0x1dc\n   __arm64_sys_write+0x6c/0x9c\n\n  Allocated by task 492:\n   kmem_cache_alloc+0x130/0x368\n   vm_area_alloc+0x2c/0x190\n   mmap_region+0x258/0x18bc\n   do_mmap+0x694/0xa60\n   vm_mmap_pgoff+0x170/0x29c\n   ksys_mmap_pgoff+0x290/0x3a0\n   __arm64_sys_mmap+0xcc/0x144\n\n  Freed by task 491:\n   kmem_cache_free+0x17c/0x3c8\n   vm_area_free_rcu_cb+0x74/0x98\n   rcu_core+0xa38/0x26d4\n   rcu_core_si+0x10/0x1c\n   __do_softirq+0x2fc/0xd24\n\n  Last potentially related work creation:\n   __call_rcu_common.constprop.0+0x6c/0xba0\n   call_rcu+0x10/0x1c\n   vm_area_free+0x18/0x24\n   remove_vma+0xe4/0x118\n   do_vmi_align_munmap.isra.0+0x718/0xb5c\n   do_vmi_munmap+0xdc/0x1fc\n   __vm_munmap+0x10c/0x278\n   __arm64_sys_munmap+0x58/0x7c\n\nFix this issue by performing instead a vma_lookup() which will fail to\nfind the vma that was isolated before the mmap lock downgrade. Note that\nthis option has better performance than upgrading to a mmap write lock\nwhich would increase contention. Plus, mmap_write_trylock() has been\nrecently removed anyway.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52439",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: uio: Fix use-after-free in uio_open",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuio: Fix use-after-free in uio_open\n\ncore-1\t\t\t\tcore-2\n-------------------------------------------------------\nuio_unregister_device\t\tuio_open\n\t\t\t\tidev = idr_find()\ndevice_unregister(&idev->dev)\nput_device(&idev->dev)\nuio_device_release\n\t\t\t\tget_device(&idev->dev)\nkfree(idev)\nuio_free_minor(minor)\n\t\t\t\tuio_release\n\t\t\t\tput_device(&idev->dev)\n\t\t\t\tkfree(idev)\n-------------------------------------------------------\n\nIn the core-1 uio_unregister_device(), the device_unregister will kfree\nidev when the idev->dev kobject ref is 1. But after core-1\ndevice_unregister, put_device and before doing kfree, the core-2 may\nget_device. Then:\n1. After core-1 kfree idev, the core-2 will do use-after-free for idev.\n2. When core-2 do uio_release and put_device, the idev will be double\n   freed.\n\nTo address this issue, we can get idev atomic & inc idev reference with\nminor_lock.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52444",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "In the Linux kernel, the following vulnerability has been resolved:  f ...",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid dirent corruption\n\nAs Al reported in link[1]:\n\nf2fs_rename()\n...\n\tif (old_dir != new_dir && !whiteout)\n\t\tf2fs_set_link(old_inode, old_dir_entry,\n\t\t\t\t\told_dir_page, new_dir);\n\telse\n\t\tf2fs_put_page(old_dir_page, 0);\n\nYou want correct inumber in the \"..\" link.  And cross-directory\nrename does move the source to new parent, even if you'd been asked\nto leave a whiteout in the old place.\n\n[1] https://lore.kernel.org/all/20231017055040.GN800259@ZenIV/\n\nWith below testcase, it may cause dirent corruption, due to it missed\nto call f2fs_set_link() to update \"..\" link to new directory.\n- mkdir -p dir/foo\n- renameat2 -w dir/foo bar\n\n[ASSERT] (__chk_dots_dentries:1421)  --> Bad inode number[0x4] for '..', parent parent ino is [0x3]\n[FSCK] other corrupted bugs                           [Fail]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52445",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pvrusb2: fix use after free on context disconnection",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: pvrusb2: fix use after free on context disconnection\n\nUpon module load, a kthread is created targeting the\npvr2_context_thread_func function, which may call pvr2_context_destroy\nand thus call kfree() on the context object. However, that might happen\nbefore the usb hub_event handler is able to notify the driver. This\npatch adds a sanity check before the invalid read reported by syzbot,\nwithin the context disconnection call stack.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52451",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: powerpc: Fix access beyond end of drmem array",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/pseries/memhp: Fix access beyond end of drmem array\n\ndlpar_memory_remove_by_index() may access beyond the bounds of the\ndrmem lmb array when the LMB lookup fails to match an entry with the\ngiven DRC index. When the search fails, the cursor is left pointing to\n&drmem_info->lmbs[drmem_info->n_lmbs], which is one element past the\nlast valid entry in the array. The debug message at the end of the\nfunction then dereferences this pointer:\n\n        pr_debug(\"Failed to hot-remove memory at %llx\\n\",\n                 lmb->base_addr);\n\nThis was found by inspection and confirmed with KASAN:\n\n  pseries-hotplug-mem: Attempting to hot-remove LMB, drc index 1234\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in dlpar_memory+0x298/0x1658\n  Read of size 8 at addr c000000364e97fd0 by task bash/949\n\n  dump_stack_lvl+0xa4/0xfc (unreliable)\n  print_report+0x214/0x63c\n  kasan_report+0x140/0x2e0\n  __asan_load8+0xa8/0xe0\n  dlpar_memory+0x298/0x1658\n  handle_dlpar_errorlog+0x130/0x1d0\n  dlpar_store+0x18c/0x3e0\n  kobj_attr_store+0x68/0xa0\n  sysfs_kf_write+0xc4/0x110\n  kernfs_fop_write_iter+0x26c/0x390\n  vfs_write+0x2d4/0x4e0\n  ksys_write+0xac/0x1a0\n  system_call_exception+0x268/0x530\n  system_call_vectored_common+0x15c/0x2ec\n\n  Allocated by task 1:\n   kasan_save_stack+0x48/0x80\n   kasan_set_track+0x34/0x50\n   kasan_save_alloc_info+0x34/0x50\n   __kasan_kmalloc+0xd0/0x120\n   __kmalloc+0x8c/0x320\n   kmalloc_array.constprop.0+0x48/0x5c\n   drmem_init+0x2a0/0x41c\n   do_one_initcall+0xe0/0x5c0\n   kernel_init_freeable+0x4ec/0x5a0\n   kernel_init+0x30/0x1e0\n   ret_from_kernel_user_thread+0x14/0x1c\n\n  The buggy address belongs to the object at c000000364e80000\n   which belongs to the cache kmalloc-128k of size 131072\n  The buggy address is located 0 bytes to the right of\n   allocated 98256-byte region [c000000364e80000, c000000364e97fd0)\n\n  ==================================================================\n  pseries-hotplug-mem: Failed to hot-remove memory at 0\n\nLog failed lookups with a separate message and dereference the\ncursor only when it points to a valid entry.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52452",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Fix accesses to uninit stack slots",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52457",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "In the Linux kernel, the following vulnerability has been resolved:  s ...",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: 8250: omap: Don't skip resource freeing if pm_runtime_resume_and_get() failed\n\nReturning an error code from .remove() makes the driver core emit the\nlittle helpful error message:\n\n\tremove callback returned a non-zero value. This will be ignored.\n\nand then remove the device anyhow. So all resources that were not freed\nare leaked in this case. Skipping serial8250_unregister_port() has the\npotential to keep enough of the UART around to trigger a use-after-free.\n\nSo replace the error return (and with it the little helpful error\nmessage) by a more useful error message and continue to cleanup.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52464",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: EDAC/thunderx: Incorrect buffer size in drivers/edac/thunderx_edac.c",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nEDAC/thunderx: Fix possible out-of-bounds string access\n\nEnabling -Wstringop-overflow globally exposes a warning for a common bug\nin the usage of strncat():\n\n  drivers/edac/thunderx_edac.c: In function 'thunderx_ocx_com_threaded_isr':\n  drivers/edac/thunderx_edac.c:1136:17: error: 'strncat' specified bound 1024 equals destination size [-Werror=stringop-overflow=]\n   1136 |                 strncat(msg, other, OCX_MESSAGE_SIZE);\n        |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   ...\n   1145 |                                 strncat(msg, other, OCX_MESSAGE_SIZE);\n   ...\n   1150 |                                 strncat(msg, other, OCX_MESSAGE_SIZE);\n\n   ...\n\nApparently the author of this driver expected strncat() to behave the\nway that strlcat() does, which uses the size of the destination buffer\nas its third argument rather than the length of the source buffer. The\nresult is that there is no check on the size of the allocated buffer.\n\nChange it to strlcat().\n\n  [ bp: Trim compiler output, fixup commit message. ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52469",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in kv_parse_power_table",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers/amd/pm: fix a use-after-free in kv_parse_power_table\n\nWhen ps allocated by kzalloc equals to NULL, kv_parse_power_table\nfrees adev->pm.dpm.ps that allocated before. However, after the control\nflow goes through the following call chains:\n\nkv_parse_power_table\n  |-> kv_dpm_init\n        |-> kv_dpm_sw_init\n\t      |-> kv_dpm_fini\n\nThe adev->pm.dpm.ps is used in the for loop of kv_dpm_fini after its\nfirst free in kv_parse_power_table and causes a use-after-free bug.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52474",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: non-PAGE_SIZE-end multi-iovec user SDMA requests",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests\n\nhfi1 user SDMA request processing has two bugs that can cause data\ncorruption for user SDMA requests that have multiple payload iovecs\nwhere an iovec other than the tail iovec does not run up to the page\nboundary for the buffer pointed to by that iovec.a\n\nHere are the specific bugs:\n1. user_sdma_txadd() does not use struct user_sdma_iovec->iov.iov_len.\n   Rather, user_sdma_txadd() will add up to PAGE_SIZE bytes from iovec\n   to the packet, even if some of those bytes are past\n   iovec->iov.iov_len and are thus not intended to be in the packet.\n2. user_sdma_txadd() and user_sdma_send_pkts() fail to advance to the\n   next iovec in user_sdma_request->iovs when the current iovec\n   is not PAGE_SIZE and does not contain enough data to complete the\n   packet. The transmitted packet will contain the wrong data from the\n   iovec pages.\n\nThis has not been an issue with SDMA packets from hfi1 Verbs or PSM2\nbecause they only produce iovecs that end short of PAGE_SIZE as the tail\niovec of an SDMA request.\n\nFixing these bugs exposes other bugs with the SDMA pin cache\n(struct mmu_rb_handler) that get in way of supporting user SDMA requests\nwith multiple payload iovecs whose buffers do not end at PAGE_SIZE. So\nthis commit fixes those issues as well.\n\nHere are the mmu_rb_handler bugs that non-PAGE_SIZE-end multi-iovec\npayload user SDMA requests can hit:\n1. Overlapping memory ranges in mmu_rb_handler will result in duplicate\n   pinnings.\n2. When extending an existing mmu_rb_handler entry (struct mmu_rb_node),\n   the mmu_rb code (1) removes the existing entry under a lock, (2)\n   releases that lock, pins the new pages, (3) then reacquires the lock\n   to insert the extended mmu_rb_node.\n\n   If someone else comes in and inserts an overlapping entry between (2)\n   and (3), insert in (3) will fail.\n\n   The failure path code in this case unpins _all_ pages in either the\n   original mmu_rb_node or the new mmu_rb_node that was inserted between\n   (2) and (3).\n3. In hfi1_mmu_rb_remove_unless_exact(), mmu_rb_node->refcount is\n   incremented outside of mmu_rb_handler->lock. As a result, mmu_rb_node\n   could be evicted by another thread that gets mmu_rb_handler->lock and\n   checks mmu_rb_node->refcount before mmu_rb_node->refcount is\n   incremented.\n4. Related to #2 above, SDMA request submission failure path does not\n   check mmu_rb_node->refcount before freeing mmu_rb_node object.\n\n   If there are other SDMA requests in progress whose iovecs have\n   pointers to the now-freed mmu_rb_node(s), those pointers to the\n   now-freed mmu_rb nodes will be dereferenced when those SDMA requests\n   complete.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52475",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in powermate_config_complete",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: powermate - fix use-after-free in powermate_config_complete\n\nsyzbot has found a use-after-free bug [1] in the powermate driver. This\nhappens when the device is disconnected, which leads to a memory free from\nthe powermate_device struct.  When an asynchronous control message\ncompletes after the kfree and its callback is invoked, the lock does not\nexist anymore and hence the bug.\n\nUse usb_kill_urb() on pm->config to cancel any in-progress requests upon\ndevice disconnection.\n\n[1] https://syzkaller.appspot.com/bug?extid=0434ac83f907a1dbdd1e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52482",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/srso: Add SRSO mitigation for Hygon processors",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/srso: Add SRSO mitigation for Hygon processors\n\nAdd mitigation for the speculative return stack overflow vulnerability\nwhich exists on Hygon processors too.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52491",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: mtk-jpeg: Fix use after free bug due to error path handling in mtk_jpeg_dec_device_run",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: mtk-jpeg: Fix use after free bug due to error path handling in mtk_jpeg_dec_device_run\n\nIn mtk_jpeg_probe, &jpeg->job_timeout_work is bound with\nmtk_jpeg_job_timeout_work.\n\nIn mtk_jpeg_dec_device_run, if error happens in\nmtk_jpeg_set_dec_dst, it will finally start the worker while\nmark the job as finished by invoking v4l2_m2m_job_finish.\n\nThere are two methods to trigger the bug. If we remove the\nmodule, it which will call mtk_jpeg_remove to make cleanup.\nThe possible sequence is as follows, which will cause a\nuse-after-free bug.\n\nCPU0                  CPU1\nmtk_jpeg_dec_...    |\n  start worker\t    |\n                    |mtk_jpeg_job_timeout_work\nmtk_jpeg_remove     |\n  v4l2_m2m_release  |\n    kfree(m2m_dev); |\n                    |\n                    | v4l2_m2m_get_curr_priv\n                    |   m2m_dev->curr_ctx //use\n\nIf we close the file descriptor, which will call mtk_jpeg_release,\nit will have a similar sequence.\n\nFix this bug by starting timeout worker only if started jpegdec worker\nsuccessfully. Then v4l2_m2m_job_finish will only be called in\neither mtk_jpeg_job_timeout_work or mtk_jpeg_dec_device_run.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52494",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bus: mhi: host: Add alignment check for event ring read pointer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: mhi: host: Add alignment check for event ring read pointer\n\nThough we do check the event ring read pointer by \"is_valid_ring_ptr\"\nto make sure it is in the buffer range, but there is another risk the\npointer may be not aligned.  Since we are expecting event ring elements\nare 128 bits(struct mhi_ring_element) aligned, an unaligned read pointer\ncould lead to multiple issues like DoS or ring buffer memory corruption.\n\nSo add a alignment check for event ring read pointer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52501",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ring-buffer: Do not attempt to read past \"commit\"",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nring-buffer: Do not attempt to read past \"commit\"\n\nWhen iterating over the ring buffer while the ring buffer is active, the\nwriter can corrupt the reader. There's barriers to help detect this and\nhandle it, but that code missed the case where the last event was at the\nvery end of the page and has only 4 bytes left.\n\nThe checks to detect the corruption by the writer to reads needs to see the\nlength of the event. If the length in the first 4 bytes is zero then the\nlength is stored in the second 4 bytes. But if the writer is in the process\nof updating that code, there's a small window where the length in the first\n4 bytes could be zero even though the length is only 4 bytes. That will\ncause rb_event_length() to read the next 4 bytes which could happen to be off the\nallocated page.\n\nTo protect against this, fail immediately if the next event pointer is\nless than 8 bytes from the end of the commit (last byte of data), as all\nevents must be a minimum of 8 bytes anyway.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52502",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: nfc: fix races in nfc_llcp_sock_get() and nfc_llcp_sock_get_sn()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: nfc: fix races in nfc_llcp_sock_get() and nfc_llcp_sock_get_sn()\n\nSili Luo reported a race in nfc_llcp_sock_get(), leading to UAF.\n\nGetting a reference on the socket found in a lookup while\nholding a lock should happen before releasing the lock.\n\nnfc_llcp_sock_get_sn() has a similar problem.\n\nFinally nfc_llcp_recv_snl() needs to make sure the socket\nfound by nfc_llcp_sock_from_sn() does not disappear.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52503",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tee: amdtee: fix use-after-free vulnerability in amdtee_close_session",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntee: amdtee: fix use-after-free vulnerability in amdtee_close_session\n\nThere is a potential race condition in amdtee_close_session that may\ncause use-after-free in amdtee_open_session. For instance, if a session\nhas refcount == 1, and one thread tries to free this session via:\n\n    kref_put(&sess->refcount, destroy_session);\n\nthe reference count will get decremented, and the next step would be to\ncall destroy_session(). However, if in another thread,\namdtee_open_session() is called before destroy_session() has completed\nexecution, alloc_session() may return 'sess' that will be freed up\nlater in destroy_session() leading to use-after-free in\namdtee_open_session.\n\nTo fix this issue, treat decrement of sess->refcount and removal of\n'sess' from session list in destroy_session() as a critical section, so\nthat it is executed atomically.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52504",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/alternatives: Disable KASAN in apply_alternatives()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/alternatives: Disable KASAN in apply_alternatives()\n\nFei has reported that KASAN triggers during apply_alternatives() on\na 5-level paging machine:\n\n\tBUG: KASAN: out-of-bounds in rcu_is_watching()\n\tRead of size 4 at addr ff110003ee6419a0 by task swapper/0/0\n\t...\n\t__asan_load4()\n\trcu_is_watching()\n\ttrace_hardirqs_on()\n\ttext_poke_early()\n\tapply_alternatives()\n\t...\n\nOn machines with 5-level paging, cpu_feature_enabled(X86_FEATURE_LA57)\ngets patched. It includes KASAN code, where KASAN_SHADOW_START depends on\n__VIRTUAL_MASK_SHIFT, which is defined with cpu_feature_enabled().\n\nKASAN gets confused when apply_alternatives() patches the\nKASAN_SHADOW_START users. A test patch that makes KASAN_SHADOW_START\nstatic, by replacing __VIRTUAL_MASK_SHIFT with 56, works around the issue.\n\nFix it for real by disabling KASAN while the kernel is patching alternatives.\n\n[ mingo: updated the changelog ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52507",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfc: nci: assert requested protocol is valid",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfc: nci: assert requested protocol is valid\n\nThe protocol is used in a bit mask to determine if the protocol is\nsupported. Assert the provided protocol is less than the maximum\ndefined so it doesn't potentially perform a shift-out-of-bounds and\nprovide a clearer error for undefined protocols vs unsupported ones.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52509",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ravb: Fix use-after-free issue in ravb_tx_timeout_work()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nravb: Fix use-after-free issue in ravb_tx_timeout_work()\n\nThe ravb_stop() should call cancel_work_sync(). Otherwise,\nravb_tx_timeout_work() is possible to use the freed priv after\nravb_remove() was called like below:\n\nCPU0\t\t\tCPU1\n\t\t\travb_tx_timeout()\nravb_remove()\nunregister_netdev()\nfree_netdev(ndev)\n// free priv\n\t\t\travb_tx_timeout_work()\n\t\t\t// use priv\n\nunregister_netdev() will call .ndo_stop() so that ravb_stop() is\ncalled. And, after phy_stop() is called, netif_carrier_off()\nis also called. So that .ndo_tx_timeout() will not be called\nafter phy_stop().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52510",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ieee802154: ca8210: Fix a potential UAF in ca8210_probe",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nieee802154: ca8210: Fix a potential UAF in ca8210_probe\n\nIf of_clk_add_provider() fails in ca8210_register_ext_clock(),\nit calls clk_unregister() to release priv->clk and returns an\nerror. However, the caller ca8210_probe() then calls ca8210_remove(),\nwhere priv->clk is freed again in ca8210_unregister_ext_clock(). In\nthis case, a use-after-free may happen in the second time we call\nclk_unregister().\n\nFix this by removing the first clk_unregister(). Also, priv->clk could\nbe an error code on failure of clk_register_fixed_rate(). Use\nIS_ERR_OR_NULL to catch this case in ca8210_unregister_ext_clock().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52515",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/srp: Do not call scsi_done() from srp_abort()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/srp: Do not call scsi_done() from srp_abort()\n\nAfter scmd_eh_abort_handler() has called the SCSI LLD eh_abort_handler\ncallback, it performs one of the following actions:\n* Call scsi_queue_insert().\n* Call scsi_finish_command().\n* Call scsi_eh_scmd_add().\nHence, SCSI abort handlers must not call scsi_done(). Otherwise all\nthe above actions would trigger a use-after-free. Hence remove the\nscsi_done() call from srp_abort(). Keep the srp_free_req() call\nbefore returning SUCCESS because we may not see the command again if\nSUCCESS is returned.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52517",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: spi: sun6i: fix race between DMA RX transfer completion and RX FIFO drain",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: sun6i: fix race between DMA RX transfer completion and RX FIFO drain\n\nPreviously the transfer complete IRQ immediately drained to RX FIFO to\nread any data remaining in FIFO to the RX buffer. This behaviour is\ncorrect when dealing with SPI in interrupt mode. However in DMA mode the\ntransfer complete interrupt still fires as soon as all bytes to be\ntransferred have been stored in the FIFO. At that point data in the FIFO\nstill needs to be picked up by the DMA engine. Thus the drain procedure\nand DMA engine end up racing to read from RX FIFO, corrupting any data\nread. Additionally the RX buffer pointer is never adjusted according to\nDMA progress in DMA mode, thus calling the RX FIFO drain procedure in DMA\nmode is a bug.\nFix corruptions in DMA RX mode by draining RX FIFO only in interrupt mode.\nAlso wait for completion of RX DMA when in DMA mode before returning to\nensure all data has been copied to the supplied memory buffer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52524",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: nfc: llcp: Add lock when modifying device list",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: nfc: llcp: Add lock when modifying device list\n\nThe device list needs its associated lock held when modifying it, or the\nlist could become corrupted, as syzbot discovered.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52525",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mwifiex: Fix oob check condition in mwifiex_process_rx_packet",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Fix oob check condition in mwifiex_process_rx_packet\n\nOnly skip the code path trying to access the rfc1042 headers when the\nbuffer is too small, so the driver can still process packets without\nrfc1042 headers.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52530",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mac80211: fix potential key use-after-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix potential key use-after-free\n\nWhen ieee80211_key_link() is called by ieee80211_gtk_rekey_add()\nbut returns 0 due to KRACK protection (identical key reinstall),\nieee80211_gtk_rekey_add() will still return a pointer into the\nkey, in a potential use-after-free. This normally doesn't happen\nsince it's only called by iwlwifi in case of WoWLAN rekey offload\nwhich has its own KRACK protection, but still better to fix, do\nthat by returning an error code and converting that to success on\nthe cfg80211 boundary only, leaving the error for bad callers of\nieee80211_gtk_rekey_add().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52531",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: mvm: Fix a memory corruption issue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: Fix a memory corruption issue\n\nA few lines above, space is kzalloc()'ed for:\n\tsizeof(struct iwl_nvm_data) +\n\tsizeof(struct ieee80211_channel) +\n\tsizeof(struct ieee80211_rate)\n\n'mvm->nvm_data' is a 'struct iwl_nvm_data', so it is fine.\n\nAt the end of this structure, there is the 'channels' flex array.\nEach element is of type 'struct ieee80211_channel'.\nSo only 1 element is allocated in this array.\n\nWhen doing:\n  mvm->nvm_data->bands[0].channels = mvm->nvm_data->channels;\nWe point at the first element of the 'channels' flex array.\nSo this is fine.\n\nHowever, when doing:\n  mvm->nvm_data->bands[0].bitrates =\n\t\t\t(void *)((u8 *)mvm->nvm_data->channels + 1);\nbecause of the \"(u8 *)\" cast, we add only 1 to the address of the beginning\nof the flex array.\n\nIt is likely that we want point at the 'struct ieee80211_rate' allocated\njust after.\n\nRemove the spurious casting so that the pointer arithmetic works as\nexpected.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52572",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cifs: use-after-free in cifs_demultiplex_thread()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix UAF in cifs_demultiplex_thread()\n\nThere is a UAF when xfstests on cifs:\n\n  BUG: KASAN: use-after-free in smb2_is_network_name_deleted+0x27/0x160\n  Read of size 4 at addr ffff88810103fc08 by task cifsd/923\n\n  CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45\n  ...\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x34/0x44\n   print_report+0x171/0x472\n   kasan_report+0xad/0x130\n   kasan_check_range+0x145/0x1a0\n   smb2_is_network_name_deleted+0x27/0x160\n   cifs_demultiplex_thread.cold+0x172/0x5a4\n   kthread+0x165/0x1a0\n   ret_from_fork+0x1f/0x30\n   </TASK>\n\n  Allocated by task 923:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   __kasan_slab_alloc+0x54/0x60\n   kmem_cache_alloc+0x147/0x320\n   mempool_alloc+0xe1/0x260\n   cifs_small_buf_get+0x24/0x60\n   allocate_buffers+0xa1/0x1c0\n   cifs_demultiplex_thread+0x199/0x10d0\n   kthread+0x165/0x1a0\n   ret_from_fork+0x1f/0x30\n\n  Freed by task 921:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   kasan_save_free_info+0x2a/0x40\n   ____kasan_slab_free+0x143/0x1b0\n   kmem_cache_free+0xe3/0x4d0\n   cifs_small_buf_release+0x29/0x90\n   SMB2_negotiate+0x8b7/0x1c60\n   smb2_negotiate+0x51/0x70\n   cifs_negotiate_protocol+0xf0/0x160\n   cifs_get_smb_ses+0x5fa/0x13c0\n   mount_get_conns+0x7a/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThe UAF is because:\n\n mount(pid: 921)               | cifsd(pid: 923)\n-------------------------------|-------------------------------\n                               | cifs_demultiplex_thread\nSMB2_negotiate                 |\n cifs_send_recv                |\n  compound_send_recv           |\n   smb_send_rqst               |\n    wait_for_response          |\n     wait_event_state      [1] |\n                               |  standard_receive3\n                               |   cifs_handle_standard\n                               |    handle_mid\n                               |     mid->resp_buf = buf;  [2]\n                               |     dequeue_mid           [3]\n     KILL the process      [4] |\n    resp_iov[i].iov_base = buf |\n free_rsp_buf              [5] |\n                               |   is_network_name_deleted [6]\n                               |   callback\n\n1. After send request to server, wait the response until\n    mid->mid_state != SUBMITTED;\n2. Receive response from server, and set it to mid;\n3. Set the mid state to RECEIVED;\n4. Kill the process, the mid state already RECEIVED, get 0;\n5. Handle and release the negotiate response;\n6. UAF.\n\nIt can be easily reproduce with add some delay in [3] - [6].\n\nOnly sync call has the problem since async call's callback is\nexecuted in cifsd process.\n\nAdd an extra state to mark the mid state to READY before wakeup the\nwaitter, then it can get the resp safely.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52578",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: bridge: data races indata-races in br_handle_frame_finish()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: use DEV_STATS_INC()\n\nsyzbot/KCSAN reported data-races in br_handle_frame_finish() [1]\nThis function can run from multiple cpus without mutual exclusion.\n\nAdopt SMP safe DEV_STATS_INC() to update dev->stats fields.\n\nHandles updates to dev->stats.tx_dropped while we are at it.\n\n[1]\nBUG: KCSAN: data-race in br_handle_frame_finish / br_handle_frame_finish\n\nread-write to 0xffff8881374b2178 of 8 bytes by interrupt on cpu 1:\nbr_handle_frame_finish+0xd4f/0xef0 net/bridge/br_input.c:189\nbr_nf_hook_thresh+0x1ed/0x220\nbr_nf_pre_routing_finish_ipv6+0x50f/0x540\nNF_HOOK include/linux/netfilter.h:304 [inline]\nbr_nf_pre_routing_ipv6+0x1e3/0x2a0 net/bridge/br_netfilter_ipv6.c:178\nbr_nf_pre_routing+0x526/0xba0 net/bridge/br_netfilter_hooks.c:508\nnf_hook_entry_hookfn include/linux/netfilter.h:144 [inline]\nnf_hook_bridge_pre net/bridge/br_input.c:272 [inline]\nbr_handle_frame+0x4c9/0x940 net/bridge/br_input.c:417\n__netif_receive_skb_core+0xa8a/0x21e0 net/core/dev.c:5417\n__netif_receive_skb_one_core net/core/dev.c:5521 [inline]\n__netif_receive_skb+0x57/0x1b0 net/core/dev.c:5637\nprocess_backlog+0x21f/0x380 net/core/dev.c:5965\n__napi_poll+0x60/0x3b0 net/core/dev.c:6527\nnapi_poll net/core/dev.c:6594 [inline]\nnet_rx_action+0x32b/0x750 net/core/dev.c:6727\n__do_softirq+0xc1/0x265 kernel/softirq.c:553\nrun_ksoftirqd+0x17/0x20 kernel/softirq.c:921\nsmpboot_thread_fn+0x30a/0x4a0 kernel/smpboot.c:164\nkthread+0x1d7/0x210 kernel/kthread.c:388\nret_from_fork+0x48/0x60 arch/x86/kernel/process.c:147\nret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304\n\nread-write to 0xffff8881374b2178 of 8 bytes by interrupt on cpu 0:\nbr_handle_frame_finish+0xd4f/0xef0 net/bridge/br_input.c:189\nbr_nf_hook_thresh+0x1ed/0x220\nbr_nf_pre_routing_finish_ipv6+0x50f/0x540\nNF_HOOK include/linux/netfilter.h:304 [inline]\nbr_nf_pre_routing_ipv6+0x1e3/0x2a0 net/bridge/br_netfilter_ipv6.c:178\nbr_nf_pre_routing+0x526/0xba0 net/bridge/br_netfilter_hooks.c:508\nnf_hook_entry_hookfn include/linux/netfilter.h:144 [inline]\nnf_hook_bridge_pre net/bridge/br_input.c:272 [inline]\nbr_handle_frame+0x4c9/0x940 net/bridge/br_input.c:417\n__netif_receive_skb_core+0xa8a/0x21e0 net/core/dev.c:5417\n__netif_receive_skb_one_core net/core/dev.c:5521 [inline]\n__netif_receive_skb+0x57/0x1b0 net/core/dev.c:5637\nprocess_backlog+0x21f/0x380 net/core/dev.c:5965\n__napi_poll+0x60/0x3b0 net/core/dev.c:6527\nnapi_poll net/core/dev.c:6594 [inline]\nnet_rx_action+0x32b/0x750 net/core/dev.c:6727\n__do_softirq+0xc1/0x265 kernel/softirq.c:553\ndo_softirq+0x5e/0x90 kernel/softirq.c:454\n__local_bh_enable_ip+0x64/0x70 kernel/softirq.c:381\n__raw_spin_unlock_bh include/linux/spinlock_api_smp.h:167 [inline]\n_raw_spin_unlock_bh+0x36/0x40 kernel/locking/spinlock.c:210\nspin_unlock_bh include/linux/spinlock.h:396 [inline]\nbatadv_tt_local_purge+0x1a8/0x1f0 net/batman-adv/translation-table.c:1356\nbatadv_tt_purge+0x2b/0x630 net/batman-adv/translation-table.c:3560\nprocess_one_work kernel/workqueue.c:2630 [inline]\nprocess_scheduled_works+0x5b8/0xa30 kernel/workqueue.c:2703\nworker_thread+0x525/0x730 kernel/workqueue.c:2784\nkthread+0x1d7/0x210 kernel/kthread.c:388\nret_from_fork+0x48/0x60 arch/x86/kernel/process.c:147\nret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304\n\nvalue changed: 0x00000000000d7190 -> 0x00000000000d7191\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 14848 Comm: kworker/u4:11 Not tainted 6.6.0-rc1-syzkaller-00236-gad8a69f361b9 #0",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52586",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/msm/dpu: Add mutex lock in control vblank irq",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm/dpu: Add mutex lock in control vblank irq\n\nAdd a mutex lock to control vblank irq to synchronize vblank\nenable/disable operations happening from different threads to prevent\nrace conditions while registering/unregistering the vblank irq callback.\n\nv4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a\n    parameter of dpu_encoder_phys.\n    -Switch from atomic refcnt to a simple int counter as mutex has\n    now been added\nv3: Mistakenly did not change wording in last version. It is done now.\nv2: Slightly changed wording of commit message\n\nPatchwork: https://patchwork.freedesktop.org/patch/571854/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52588",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to tag gcing flag on page during block migration",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to tag gcing flag on page during block migration\n\nIt needs to add missing gcing flag on page during block migration,\nin order to garantee migrated data be persisted during checkpoint,\notherwise out-of-order persistency between data and node may cause\ndata corruption after SPOR.\n\nSimilar issue was fixed by commit 2d1fe8a86bf5 (\"f2fs: fix to tag\ngcing flag on page during file defragment\").",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52594",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath9k: Fix potential array-index-out-of-bounds read in ath9k_htc_txstatus()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: Fix potential array-index-out-of-bounds read in ath9k_htc_txstatus()\n\nFix an array-index-out-of-bounds read in ath9k_htc_txstatus(). The bug\noccurs when txs->cnt, data from a URB provided by a USB device, is\nbigger than the size of the array txs->txstatus, which is\nHTC_MAX_TX_STATUS. WARN_ON() already checks it, but there is no bug\nhandling code after the check. Make the function return if that is the\ncase.\n\nFound by a modified version of syzkaller.\n\nUBSAN: array-index-out-of-bounds in htc_drv_txrx.c\nindex 13 is out of range for type '__wmi_event_txstatus [12]'\nCall Trace:\n ath9k_htc_txstatus\n ath9k_wmi_event_tasklet\n tasklet_action_common\n __do_softirq\n irq_exit_rxu\n sysvec_apic_timer_interrupt",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52598",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: s390/ptrace: handle setting of fpc register correctly",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/ptrace: handle setting of fpc register correctly\n\nIf the content of the floating point control (fpc) register of a traced\nprocess is modified with the ptrace interface the new value is tested for\nvalidity by temporarily loading it into the fpc register.\n\nThis may lead to corruption of the fpc register of the tracing process:\nif an interrupt happens while the value is temporarily loaded into the\nfpc register, and within interrupt context floating point or vector\nregisters are used, the current fp/vx registers are saved with\nsave_fpu_regs() assuming they belong to user space and will be loaded into\nfp/vx registers when returning to user space.\n\ntest_fp_ctl() restores the original user space fpc register value, however\nit will be discarded, when returning to user space.\n\nIn result the tracer will incorrectly continue to run with the value that\nwas supposed to be used for the traced process.\n\nFix this by saving fpu register contents with save_fpu_regs() before using\ntest_fp_ctl().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52599",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix array-index-out-of-bounds in diNewExt",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds in diNewExt\n\n[Syz report]\nUBSAN: array-index-out-of-bounds in fs/jfs/jfs_imap.c:2360:2\nindex -878706688 is out of range for type 'struct iagctl[128]'\nCPU: 1 PID: 5065 Comm: syz-executor282 Not tainted 6.7.0-rc4-syzkaller-00009-gbee0e7762ad2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/10/2023\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106\n ubsan_epilogue lib/ubsan.c:217 [inline]\n __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348\n diNewExt+0x3cf3/0x4000 fs/jfs/jfs_imap.c:2360\n diAllocExt fs/jfs/jfs_imap.c:1949 [inline]\n diAllocAG+0xbe8/0x1e50 fs/jfs/jfs_imap.c:1666\n diAlloc+0x1d3/0x1760 fs/jfs/jfs_imap.c:1587\n ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56\n jfs_mkdir+0x1c5/0xb90 fs/jfs/namei.c:225\n vfs_mkdir+0x2f1/0x4b0 fs/namei.c:4106\n do_mkdirat+0x264/0x3a0 fs/namei.c:4129\n __do_sys_mkdir fs/namei.c:4149 [inline]\n __se_sys_mkdir fs/namei.c:4147 [inline]\n __x64_sys_mkdir+0x6e/0x80 fs/namei.c:4147\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x45/0x110 arch/x86/entry/common.c:82\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\nRIP: 0033:0x7fcb7e6a0b57\nCode: ff ff 77 07 31 c0 c3 0f 1f 40 00 48 c7 c2 b8 ff ff ff f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 b8 53 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffd83023038 EFLAGS: 00000286 ORIG_RAX: 0000000000000053\nRAX: ffffffffffffffda RBX: 00000000ffffffff RCX: 00007fcb7e6a0b57\nRDX: 00000000000a1020 RSI: 00000000000001ff RDI: 0000000020000140\nRBP: 0000000020000140 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000286 R12: 00007ffd830230d0\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n\n[Analysis]\nWhen the agstart is too large, it can cause agno overflow.\n\n[Fix]\nAfter obtaining agno, if the value is invalid, exit the subsequent process.\n\n\nModified the test from agno > MAXAG to agno >= MAXAG based on linux-next\nreport by kernel test robot (Dan Carpenter).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52600",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix uaf in jfs_evict_inode",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix uaf in jfs_evict_inode\n\nWhen the execution of diMount(ipimap) fails, the object ipimap that has been\nreleased may be accessed in diFreeSpecial(). Asynchronous ipimap release occurs\nwhen rcu_core() calls jfs_free_node().\n\nTherefore, when diMount(ipimap) fails, sbi->ipimap should not be initialized as\nipimap.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52603",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: UBSAN: array-index-out-of-bounds in dtSplitRoot",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUBSAN: array-index-out-of-bounds in dtSplitRoot\n\nSyzkaller reported the following issue:\n\noop0: detected capacity change from 0 to 32768\n\nUBSAN: array-index-out-of-bounds in fs/jfs/jfs_dtree.c:1971:9\nindex -2 is out of range for type 'struct dtslot [128]'\nCPU: 0 PID: 3613 Comm: syz-executor270 Not tainted 6.0.0-syzkaller-09423-g493ffd6605b2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1b1/0x28e lib/dump_stack.c:106\n ubsan_epilogue lib/ubsan.c:151 [inline]\n __ubsan_handle_out_of_bounds+0xdb/0x130 lib/ubsan.c:283\n dtSplitRoot+0x8d8/0x1900 fs/jfs/jfs_dtree.c:1971\n dtSplitUp fs/jfs/jfs_dtree.c:985 [inline]\n dtInsert+0x1189/0x6b80 fs/jfs/jfs_dtree.c:863\n jfs_mkdir+0x757/0xb00 fs/jfs/namei.c:270\n vfs_mkdir+0x3b3/0x590 fs/namei.c:4013\n do_mkdirat+0x279/0x550 fs/namei.c:4038\n __do_sys_mkdirat fs/namei.c:4053 [inline]\n __se_sys_mkdirat fs/namei.c:4051 [inline]\n __x64_sys_mkdirat+0x85/0x90 fs/namei.c:4051\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7fcdc0113fd9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffeb8bc67d8 EFLAGS: 00000246 ORIG_RAX: 0000000000000102\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fcdc0113fd9\nRDX: 0000000000000000 RSI: 0000000020000340 RDI: 0000000000000003\nRBP: 00007fcdc00d37a0 R08: 0000000000000000 R09: 00007fcdc00d37a0\nR10: 00005555559a72c0 R11: 0000000000000246 R12: 00000000f8008000\nR13: 0000000000000000 R14: 00083878000000f8 R15: 0000000000000000\n </TASK>\n\nThe issue is caused when the value of fsi becomes less than -1.\nThe check to break the loop when fsi value becomes -1 is present\nbut syzbot was able to produce value less than -1 which cause the error.\nThis patch simply add the change for the values less than 0.\n\nThe patch is tested via syzbot.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52604",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: FS:JFS:UBSAN: array-index-out-of-bounds in dbAdjTree",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nFS:JFS:UBSAN:array-index-out-of-bounds in dbAdjTree\n\nSyzkaller reported the following issue:\n\nUBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:2867:6\nindex 196694 is out of range for type 's8[1365]' (aka 'signed char[1365]')\nCPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106\n ubsan_epilogue lib/ubsan.c:217 [inline]\n __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348\n dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867\n dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834\n dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331\n dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]\n dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402\n txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534\n txUpdateMap+0x342/0x9e0\n txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]\n jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732\n kthread+0x2d3/0x370 kernel/kthread.c:388\n ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304\n </TASK>\n================================================================================\nKernel panic - not syncing: UBSAN: panic_on_warn set ...\nCPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106\n panic+0x30f/0x770 kernel/panic.c:340\n check_panic_on_warn+0x82/0xa0 kernel/panic.c:236\n ubsan_epilogue lib/ubsan.c:223 [inline]\n __ubsan_handle_out_of_bounds+0x13c/0x150 lib/ubsan.c:348\n dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867\n dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834\n dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331\n dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]\n dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402\n txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534\n txUpdateMap+0x342/0x9e0\n txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]\n jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732\n kthread+0x2d3/0x370 kernel/kthread.c:388\n ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304\n </TASK>\nKernel Offset: disabled\nRebooting in 86400 seconds..\n\nThe issue is caused when the value of lp becomes greater than\nCTLTREESIZE which is the max size of stree. Adding a simple check\nsolves this issue.\n\nDave:\nAs the function returns a void, good error handling\nwould require a more intrusive code reorganization, so I modified\nOsama's patch at use WARN_ON_ONCE for lack of a cleaner option.\n\nThe patch is tested via syzbot.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52612",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: scomp - fix req-&gt;dst buffer overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: scomp - fix req->dst buffer overflow\n\nThe req->dst buffer size should be checked before copying from the\nscomp_scratch->dst to avoid req->dst buffer overflow problem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52614",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: PM / devfreq: Fix buffer overflow in trans_stat_show",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPM / devfreq: Fix buffer overflow in trans_stat_show\n\nFix buffer overflow in trans_stat_show().\n\nConvert simple snprintf to the more secure scnprintf with size of\nPAGE_SIZE.\n\nAdd condition checking if we are exceeding PAGE_SIZE and exit early from\nloop. Also add at the end a warning that we exceeded PAGE_SIZE and that\nstats is disabled.\n\nReturn -EFBIG in the case where we don't have enough space to write the\nfull transition table.\n\nAlso document in the ABI that this function can return -EFBIG error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52621",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Check rcu_read_lock_trace_held() before calling bpf map helpers",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Check rcu_read_lock_trace_held() before calling bpf map helpers\n\nThese three bpf_map_{lookup,update,delete}_elem() helpers are also\navailable for sleepable bpf program, so add the corresponding lock\nassertion for sleepable bpf program, otherwise the following warning\nwill be reported when a sleepable bpf program manipulates bpf map under\ninterpreter mode (aka bpf_jit_enable=0):\n\n  WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ......\n  CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......\n  RIP: 0010:bpf_map_lookup_elem+0x54/0x60\n  ......\n  Call Trace:\n   <TASK>\n   ? __warn+0xa5/0x240\n   ? bpf_map_lookup_elem+0x54/0x60\n   ? report_bug+0x1ba/0x1f0\n   ? handle_bug+0x40/0x80\n   ? exc_invalid_op+0x18/0x50\n   ? asm_exc_invalid_op+0x1b/0x20\n   ? __pfx_bpf_map_lookup_elem+0x10/0x10\n   ? rcu_lockdep_current_cpu_online+0x65/0xb0\n   ? rcu_is_watching+0x23/0x50\n   ? bpf_map_lookup_elem+0x54/0x60\n   ? __pfx_bpf_map_lookup_elem+0x10/0x10\n   ___bpf_prog_run+0x513/0x3b70\n   __bpf_prog_run32+0x9d/0xd0\n   ? __bpf_prog_enter_sleepable_recur+0xad/0x120\n   ? __bpf_prog_enter_sleepable_recur+0x3e/0x120\n   bpf_trampoline_6442580665+0x4d/0x1000\n   __x64_sys_getpgid+0x5/0x30\n   ? do_syscall_64+0x36/0xb0\n   entry_SYSCALL_64_after_hwframe+0x6e/0x76\n   </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52624",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Wake DMCUB before executing GPINT commands",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Wake DMCUB before executing GPINT commands\n\n[Why]\nDMCUB can be in idle when we attempt to interface with the HW through\nthe GPINT mailbox resulting in a system hang.\n\n[How]\nAdd dc_wake_and_execute_gpint() to wrap the wake, execute, sleep\nsequence.\n\nIf the GPINT executes successfully then DMCUB will be put back into\nsleep after the optional response is returned.\n\nIt functions similar to the inbox command interface.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52628",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nftables: exthdr: fix 4-byte stack OOB write",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nftables: exthdr: fix 4-byte stack OOB write\n\nIf priv->len is a multiple of 4, then dst[len / 4] can write past\nthe destination array which leads to stack corruption.\n\nThis construct is necessary to clean the remainder of the register\nin case ->len is NOT a multiple of the register size, so make it\nconditional just like nft_payload.c does.\n\nThe bug was added in 4.1 cycle and then copied/inherited when\ntcp/sctp and ip option support was added.\n\nBug reported by Zero Day Initiative project (ZDI-CAN-21950,\nZDI-CAN-21951, ZDI-CAN-21961).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52637",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: can: j1939: Fix UAF in j1939_sk_match_filter during setsockopt(SO_J1939_FILTER)",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: j1939: Fix UAF in j1939_sk_match_filter during setsockopt(SO_J1939_FILTER)\n\nLock jsk->sk to prevent UAF when setsockopt(..., SO_J1939_FILTER, ...)\nmodifies jsk->filters while receiving packets.\n\nFollowing trace was seen on affected system:\n ==================================================================\n BUG: KASAN: slab-use-after-free in j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n Read of size 4 at addr ffff888012144014 by task j1939/350\n\n CPU: 0 PID: 350 Comm: j1939 Tainted: G        W  OE      6.5.0-rc5 #1\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n Call Trace:\n  print_report+0xd3/0x620\n  ? kasan_complete_mode_report_info+0x7d/0x200\n  ? j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n  kasan_report+0xc2/0x100\n  ? j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n  __asan_load4+0x84/0xb0\n  j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n  j1939_sk_recv+0x20b/0x320 [can_j1939]\n  ? __kasan_check_write+0x18/0x20\n  ? __pfx_j1939_sk_recv+0x10/0x10 [can_j1939]\n  ? j1939_simple_recv+0x69/0x280 [can_j1939]\n  ? j1939_ac_recv+0x5e/0x310 [can_j1939]\n  j1939_can_recv+0x43f/0x580 [can_j1939]\n  ? __pfx_j1939_can_recv+0x10/0x10 [can_j1939]\n  ? raw_rcv+0x42/0x3c0 [can_raw]\n  ? __pfx_j1939_can_recv+0x10/0x10 [can_j1939]\n  can_rcv_filter+0x11f/0x350 [can]\n  can_receive+0x12f/0x190 [can]\n  ? __pfx_can_rcv+0x10/0x10 [can]\n  can_rcv+0xdd/0x130 [can]\n  ? __pfx_can_rcv+0x10/0x10 [can]\n  __netif_receive_skb_one_core+0x13d/0x150\n  ? __pfx___netif_receive_skb_one_core+0x10/0x10\n  ? __kasan_check_write+0x18/0x20\n  ? _raw_spin_lock_irq+0x8c/0xe0\n  __netif_receive_skb+0x23/0xb0\n  process_backlog+0x107/0x260\n  __napi_poll+0x69/0x310\n  net_rx_action+0x2a1/0x580\n  ? __pfx_net_rx_action+0x10/0x10\n  ? __pfx__raw_spin_lock+0x10/0x10\n  ? handle_irq_event+0x7d/0xa0\n  __do_softirq+0xf3/0x3f8\n  do_softirq+0x53/0x80\n  </IRQ>\n  <TASK>\n  __local_bh_enable_ip+0x6e/0x70\n  netif_rx+0x16b/0x180\n  can_send+0x32b/0x520 [can]\n  ? __pfx_can_send+0x10/0x10 [can]\n  ? __check_object_size+0x299/0x410\n  raw_sendmsg+0x572/0x6d0 [can_raw]\n  ? __pfx_raw_sendmsg+0x10/0x10 [can_raw]\n  ? apparmor_socket_sendmsg+0x2f/0x40\n  ? __pfx_raw_sendmsg+0x10/0x10 [can_raw]\n  sock_sendmsg+0xef/0x100\n  sock_write_iter+0x162/0x220\n  ? __pfx_sock_write_iter+0x10/0x10\n  ? __rtnl_unlock+0x47/0x80\n  ? security_file_permission+0x54/0x320\n  vfs_write+0x6ba/0x750\n  ? __pfx_vfs_write+0x10/0x10\n  ? __fget_light+0x1ca/0x1f0\n  ? __rcu_read_unlock+0x5b/0x280\n  ksys_write+0x143/0x170\n  ? __pfx_ksys_write+0x10/0x10\n  ? __kasan_check_read+0x15/0x20\n  ? fpregs_assert_state_consistent+0x62/0x70\n  __x64_sys_write+0x47/0x60\n  do_syscall_64+0x60/0x90\n  ? do_syscall_64+0x6d/0x90\n  ? irqentry_exit+0x3f/0x50\n  ? exc_page_fault+0x79/0xf0\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\n Allocated by task 348:\n  kasan_save_stack+0x2a/0x50\n  kasan_set_track+0x29/0x40\n  kasan_save_alloc_info+0x1f/0x30\n  __kasan_kmalloc+0xb5/0xc0\n  __kmalloc_node_track_caller+0x67/0x160\n  j1939_sk_setsockopt+0x284/0x450 [can_j1939]\n  __sys_setsockopt+0x15c/0x2f0\n  __x64_sys_setsockopt+0x6b/0x80\n  do_syscall_64+0x60/0x90\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\n Freed by task 349:\n  kasan_save_stack+0x2a/0x50\n  kasan_set_track+0x29/0x40\n  kasan_save_free_info+0x2f/0x50\n  __kasan_slab_free+0x12e/0x1c0\n  __kmem_cache_free+0x1b9/0x380\n  kfree+0x7a/0x120\n  j1939_sk_setsockopt+0x3b2/0x450 [can_j1939]\n  __sys_setsockopt+0x15c/0x2f0\n  __x64_sys_setsockopt+0x6b/0x80\n  do_syscall_64+0x60/0x90\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52642",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: rc: bpf attach/detach requires write permission",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: rc: bpf attach/detach requires write permission\n\nNote that bpf attach/detach also requires CAP_NET_ADMIN.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52664",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: atlantic: eliminate double free in error handling logic",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atlantic: eliminate double free in error handling logic\n\nDriver has a logic leak in ring data allocation/free,\nwhere aq_ring_free could be called multiple times on same ring,\nif system is under stress and got memory allocation error.\n\nRing pointer was used as an indicator of failure, but this is\nnot correct since only ring data is allocated/deallocated.\nRing itself is an array member.\n\nChanging ring allocation functions to return error code directly.\nThis simplifies error handling and eliminates aq_ring_free\non higher layer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52679",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: of: Fix double free in of_parse_phandle_with_args_map",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nof: Fix double free in of_parse_phandle_with_args_map\n\nIn of_parse_phandle_with_args_map() the inner loop that\niterates through the map entries calls of_node_put(new)\nto free the reference acquired by the previous iteration\nof the inner loop. This assumes that the value of \"new\" is\nNULL on the first iteration of the inner loop.\n\nMake sure that this is true in all iterations of the outer\nloop by setting \"new\" to NULL after its value is assigned to \"cur\".\n\nExtend the unittest to detect the double free and add an additional\ntest case that actually triggers this path.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52682",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to wait on block writeback for post_read case",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to wait on block writeback for post_read case\n\nIf inode is compressed, but not encrypted, it missed to call\nf2fs_wait_on_block_writeback() to wait for GCed page writeback\nin IPU write path.\n\nThread A\t\t\t\tGC-Thread\n\t\t\t\t\t- f2fs_gc\n\t\t\t\t\t - do_garbage_collect\n\t\t\t\t\t  - gc_data_segment\n\t\t\t\t\t   - move_data_block\n\t\t\t\t\t    - f2fs_submit_page_write\n\t\t\t\t\t     migrate normal cluster's block via\n\t\t\t\t\t     meta_inode's page cache\n- f2fs_write_single_data_page\n - f2fs_do_write_data_page\n  - f2fs_inplace_write_data\n   - f2fs_submit_page_bio\n\nIRQ\n- f2fs_read_end_io\n\t\t\t\t\tIRQ\n\t\t\t\t\told data overrides new data due to\n\t\t\t\t\tout-of-order GC and common IO.\n\t\t\t\t\t- f2fs_read_end_io",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52691",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/pm: fix a double-free in si_dpm_init",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/pm: fix a double-free in si_dpm_init\n\nWhen the allocation of\nadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries fails,\namdgpu_free_extended_power_table is called to free some fields of adev.\nHowever, when the control flow returns to si_dpm_sw_init, it goes to\nlabel dpm_failed and calls si_dpm_fini, which calls\namdgpu_free_extended_power_table again and free those fields again. Thus\na double-free is triggered.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52707",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sched/psi: Fix use-after-free in ep_remove_wait_queue()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/psi: Fix use-after-free in ep_remove_wait_queue()\n\nIf a non-root cgroup gets removed when there is a thread that registered\ntrigger and is polling on a pressure file within the cgroup, the polling\nwaitqueue gets freed in the following path:\n\n do_rmdir\n   cgroup_rmdir\n     kernfs_drain_open_files\n       cgroup_file_release\n         cgroup_pressure_release\n           psi_trigger_destroy\n\nHowever, the polling thread still has a reference to the pressure file and\nwill access the freed waitqueue when the file is closed or upon exit:\n\n fput\n   ep_eventpoll_release\n     ep_free\n       ep_remove_wait_queue\n         remove_wait_queue\n\nThis results in use-after-free as pasted below.\n\nThe fundamental problem here is that cgroup_file_release() (and\nconsequently waitqueue's lifetime) is not tied to the file's real lifetime.\nUsing wake_up_pollfree() here might be less than ideal, but it is in line\nwith the comment at commit 42288cb44c4b (\"wait: add wake_up_pollfree()\")\nsince the waitqueue's lifetime is not tied to file's one and can be\nconsidered as another special case. While this would be fixable by somehow\nmaking cgroup_file_release() be tied to the fput(), it would require\nsizable refactoring at cgroups or higher layer which might be more\njustifiable if we identify more cases like this.\n\n  BUG: KASAN: use-after-free in _raw_spin_lock_irqsave+0x60/0xc0\n  Write of size 4 at addr ffff88810e625328 by task a.out/4404\n\n\tCPU: 19 PID: 4404 Comm: a.out Not tainted 6.2.0-rc6 #38\n\tHardware name: Amazon EC2 c5a.8xlarge/, BIOS 1.0 10/16/2017\n\tCall Trace:\n\t<TASK>\n\tdump_stack_lvl+0x73/0xa0\n\tprint_report+0x16c/0x4e0\n\tkasan_report+0xc3/0xf0\n\tkasan_check_range+0x2d2/0x310\n\t_raw_spin_lock_irqsave+0x60/0xc0\n\tremove_wait_queue+0x1a/0xa0\n\tep_free+0x12c/0x170\n\tep_eventpoll_release+0x26/0x30\n\t__fput+0x202/0x400\n\ttask_work_run+0x11d/0x170\n\tdo_exit+0x495/0x1130\n\tdo_group_exit+0x100/0x100\n\tget_signal+0xd67/0xde0\n\tarch_do_signal_or_restart+0x2a/0x2b0\n\texit_to_user_mode_prepare+0x94/0x100\n\tsyscall_exit_to_user_mode+0x20/0x40\n\tdo_syscall_64+0x52/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\t</TASK>\n\n Allocated by task 4404:\n\n\tkasan_set_track+0x3d/0x60\n\t__kasan_kmalloc+0x85/0x90\n\tpsi_trigger_create+0x113/0x3e0\n\tpressure_write+0x146/0x2e0\n\tcgroup_file_write+0x11c/0x250\n\tkernfs_fop_write_iter+0x186/0x220\n\tvfs_write+0x3d8/0x5c0\n\tksys_write+0x90/0x110\n\tdo_syscall_64+0x43/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\n Freed by task 4407:\n\n\tkasan_set_track+0x3d/0x60\n\tkasan_save_free_info+0x27/0x40\n\t____kasan_slab_free+0x11d/0x170\n\tslab_free_freelist_hook+0x87/0x150\n\t__kmem_cache_free+0xcb/0x180\n\tpsi_trigger_destroy+0x2e8/0x310\n\tcgroup_file_release+0x4f/0xb0\n\tkernfs_drain_open_files+0x165/0x1f0\n\tkernfs_drain+0x162/0x1a0\n\t__kernfs_remove+0x1fb/0x310\n\tkernfs_remove_by_name_ns+0x95/0xe0\n\tcgroup_addrm_files+0x67f/0x700\n\tcgroup_destroy_locked+0x283/0x3c0\n\tcgroup_rmdir+0x29/0x100\n\tkernfs_iop_rmdir+0xd1/0x140\n\tvfs_rmdir+0xfe/0x240\n\tdo_rmdir+0x13d/0x280\n\t__x64_sys_rmdir+0x2c/0x30\n\tdo_syscall_64+0x43/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52741",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cifs: Fix use-after-free in rdata-&gt;read_into_pages()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix use-after-free in rdata->read_into_pages()\n\nWhen the network status is unstable, use-after-free may occur when\nread data from the server.\n\n  BUG: KASAN: use-after-free in readpages_fill_pages+0x14c/0x7e0\n\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x38/0x4c\n   print_report+0x16f/0x4a6\n   kasan_report+0xb7/0x130\n   readpages_fill_pages+0x14c/0x7e0\n   cifs_readv_receive+0x46d/0xa40\n   cifs_demultiplex_thread+0x121c/0x1490\n   kthread+0x16b/0x1a0\n   ret_from_fork+0x2c/0x50\n   </TASK>\n\n  Allocated by task 2535:\n   kasan_save_stack+0x22/0x50\n   kasan_set_track+0x25/0x30\n   __kasan_kmalloc+0x82/0x90\n   cifs_readdata_direct_alloc+0x2c/0x110\n   cifs_readdata_alloc+0x2d/0x60\n   cifs_readahead+0x393/0xfe0\n   read_pages+0x12f/0x470\n   page_cache_ra_unbounded+0x1b1/0x240\n   filemap_get_pages+0x1c8/0x9a0\n   filemap_read+0x1c0/0x540\n   cifs_strict_readv+0x21b/0x240\n   vfs_read+0x395/0x4b0\n   ksys_read+0xb8/0x150\n   do_syscall_64+0x3f/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\n  Freed by task 79:\n   kasan_save_stack+0x22/0x50\n   kasan_set_track+0x25/0x30\n   kasan_save_free_info+0x2e/0x50\n   __kasan_slab_free+0x10e/0x1a0\n   __kmem_cache_free+0x7a/0x1a0\n   cifs_readdata_release+0x49/0x60\n   process_one_work+0x46c/0x760\n   worker_thread+0x2a4/0x6f0\n   kthread+0x16b/0x1a0\n   ret_from_fork+0x2c/0x50\n\n  Last potentially related work creation:\n   kasan_save_stack+0x22/0x50\n   __kasan_record_aux_stack+0x95/0xb0\n   insert_work+0x2b/0x130\n   __queue_work+0x1fe/0x660\n   queue_work_on+0x4b/0x60\n   smb2_readv_callback+0x396/0x800\n   cifs_abort_connection+0x474/0x6a0\n   cifs_reconnect+0x5cb/0xa50\n   cifs_readv_from_socket.cold+0x22/0x6c\n   cifs_read_page_from_socket+0xc1/0x100\n   readpages_fill_pages.cold+0x2f/0x46\n   cifs_readv_receive+0x46d/0xa40\n   cifs_demultiplex_thread+0x121c/0x1490\n   kthread+0x16b/0x1a0\n   ret_from_fork+0x2c/0x50\n\nThe following function calls will cause UAF of the rdata pointer.\n\nreadpages_fill_pages\n cifs_read_page_from_socket\n  cifs_readv_from_socket\n   cifs_reconnect\n    __cifs_reconnect\n     cifs_abort_connection\n      mid->callback() --> smb2_readv_callback\n       queue_work(&rdata->work)  # if the worker completes first,\n                                 # the rdata is freed\n          cifs_readv_complete\n            kref_put\n              cifs_readdata_release\n                kfree(rdata)\n return rdata->...               # UAF in readpages_fill_pages()\n\nSimilarly, this problem also occurs in the uncache_fill_pages().\n\nFix this by adjusts the order of condition judgment in the return\nstatement.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52748",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: avoid format-overflow warning",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: avoid format-overflow warning\n\nWith gcc and W=1 option, there's a warning like this:\n\nfs/f2fs/compress.c: In function \u2018f2fs_init_page_array_cache\u2019:\nfs/f2fs/compress.c:1984:47: error: \u2018%u\u2019 directive writing between\n1 and 7 bytes into a region of size between 5 and 8\n[-Werror=format-overflow=]\n 1984 |  sprintf(slab_name, \"f2fs_page_array_entry-%u:%u\", MAJOR(dev),\n\t\tMINOR(dev));\n      |                                               ^~\n\nString \"f2fs_page_array_entry-%u:%u\" can up to 35. The first \"%u\" can up\nto 4 and the second \"%u\" can up to 7, so total size is \"24 + 4 + 7 = 35\".\nslab_name's size should be 35 rather than 32.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52751",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix use-after-free in smb2_query_info_compound()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free in smb2_query_info_compound()\n\nThe following UAF was triggered when running fstests generic/072 with\nKASAN enabled against Windows Server 2022 and mount options\n'multichannel,max_channels=2,vers=3.1.1,mfsymlinks,noperm'\n\n  BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423/0x6d0 [cifs]\n  Read of size 8 at addr ffff888014941048 by task xfs_io/27534\n\n  CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\n  rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014\n  Call Trace:\n   dump_stack_lvl+0x4a/0x80\n   print_report+0xcf/0x650\n   ? srso_alias_return_thunk+0x5/0x7f\n   ? srso_alias_return_thunk+0x5/0x7f\n   ? __phys_addr+0x46/0x90\n   kasan_report+0xda/0x110\n   ? smb2_query_info_compound+0x423/0x6d0 [cifs]\n   ? smb2_query_info_compound+0x423/0x6d0 [cifs]\n   smb2_query_info_compound+0x423/0x6d0 [cifs]\n   ? __pfx_smb2_query_info_compound+0x10/0x10 [cifs]\n   ? srso_alias_return_thunk+0x5/0x7f\n   ? __stack_depot_save+0x39/0x480\n   ? kasan_save_stack+0x33/0x60\n   ? kasan_set_track+0x25/0x30\n   ? ____kasan_slab_free+0x126/0x170\n   smb2_queryfs+0xc2/0x2c0 [cifs]\n   ? __pfx_smb2_queryfs+0x10/0x10 [cifs]\n   ? __pfx___lock_acquire+0x10/0x10\n   smb311_queryfs+0x210/0x220 [cifs]\n   ? __pfx_smb311_queryfs+0x10/0x10 [cifs]\n   ? srso_alias_return_thunk+0x5/0x7f\n   ? __lock_acquire+0x480/0x26c0\n   ? lock_release+0x1ed/0x640\n   ? srso_alias_return_thunk+0x5/0x7f\n   ? do_raw_spin_unlock+0x9b/0x100\n   cifs_statfs+0x18c/0x4b0 [cifs]\n   statfs_by_dentry+0x9b/0xf0\n   fd_statfs+0x4e/0xb0\n   __do_sys_fstatfs+0x7f/0xe0\n   ? __pfx___do_sys_fstatfs+0x10/0x10\n   ? srso_alias_return_thunk+0x5/0x7f\n   ? lockdep_hardirqs_on_prepare+0x136/0x200\n   ? srso_alias_return_thunk+0x5/0x7f\n   do_syscall_64+0x3f/0x90\n   entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\n  Allocated by task 27534:\n   kasan_save_stack+0x33/0x60\n   kasan_set_track+0x25/0x30\n   __kasan_kmalloc+0x8f/0xa0\n   open_cached_dir+0x71b/0x1240 [cifs]\n   smb2_query_info_compound+0x5c3/0x6d0 [cifs]\n   smb2_queryfs+0xc2/0x2c0 [cifs]\n   smb311_queryfs+0x210/0x220 [cifs]\n   cifs_statfs+0x18c/0x4b0 [cifs]\n   statfs_by_dentry+0x9b/0xf0\n   fd_statfs+0x4e/0xb0\n   __do_sys_fstatfs+0x7f/0xe0\n   do_syscall_64+0x3f/0x90\n   entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\n  Freed by task 27534:\n   kasan_save_stack+0x33/0x60\n   kasan_set_track+0x25/0x30\n   kasan_save_free_info+0x2b/0x50\n   ____kasan_slab_free+0x126/0x170\n   slab_free_freelist_hook+0xd0/0x1e0\n   __kmem_cache_free+0x9d/0x1b0\n   open_cached_dir+0xff5/0x1240 [cifs]\n   smb2_query_info_compound+0x5c3/0x6d0 [cifs]\n   smb2_queryfs+0xc2/0x2c0 [cifs]\n\nThis is a race between open_cached_dir() and cached_dir_lease_break()\nwhere the cache entry for the open directory handle receives a lease\nbreak while creating it.  And before returning from open_cached_dir(),\nwe put the last reference of the new @cfid because of\n!@cfid->has_lease.\n\nBesides the UAF, while running xfstests a lot of missed lease breaks\nhave been noticed in tests that run several concurrent statfs(2) calls\non those cached fids\n\n  CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame...\n  CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...\n  CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108\n  CIFS: VFS: Dump pending requests:\n  CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame...\n  CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...\n  CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 000000005aa7316e len 108\n  ...\n\nTo fix both, in open_cached_dir() ensure that @cfid->has_lease is set\nright before sending out compounded request so that any potential\nlease break will be get processed by demultiplex thread while we're\nstill caching @cfid.  And, if open failed for some reason, re-check\n@cfid->has_lease to decide whether or not put lease reference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52752",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix use-after-free bug in cifs_debug_data_proc_show()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free bug in cifs_debug_data_proc_show()\n\nSkip SMB sessions that are being teared down\n(e.g. @ses->ses_status == SES_EXITING) in cifs_debug_data_proc_show()\nto avoid use-after-free in @ses.\n\nThis fixes the following GPF when reading from /proc/fs/cifs/DebugData\nwhile mounting and umounting\n\n  [ 816.251274] general protection fault, probably for non-canonical\n  address 0x6b6b6b6b6b6b6d81: 0000 [#1] PREEMPT SMP NOPTI\n  ...\n  [  816.260138] Call Trace:\n  [  816.260329]  <TASK>\n  [  816.260499]  ? die_addr+0x36/0x90\n  [  816.260762]  ? exc_general_protection+0x1b3/0x410\n  [  816.261126]  ? asm_exc_general_protection+0x26/0x30\n  [  816.261502]  ? cifs_debug_tcon+0xbd/0x240 [cifs]\n  [  816.261878]  ? cifs_debug_tcon+0xab/0x240 [cifs]\n  [  816.262249]  cifs_debug_data_proc_show+0x516/0xdb0 [cifs]\n  [  816.262689]  ? seq_read_iter+0x379/0x470\n  [  816.262995]  seq_read_iter+0x118/0x470\n  [  816.263291]  proc_reg_read_iter+0x53/0x90\n  [  816.263596]  ? srso_alias_return_thunk+0x5/0x7f\n  [  816.263945]  vfs_read+0x201/0x350\n  [  816.264211]  ksys_read+0x75/0x100\n  [  816.264472]  do_syscall_64+0x3f/0x90\n  [  816.264750]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n  [  816.265135] RIP: 0033:0x7fd5e669d381",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52757",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential deadlock when releasing mids",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential deadlock when releasing mids\n\nAll release_mid() callers seem to hold a reference of @mid so there is\nno need to call kref_put(&mid->refcount, __release_mid) under\n@server->mid_lock spinlock.  If they don't, then an use-after-free bug\nwould have occurred anyways.\n\nBy getting rid of such spinlock also fixes a potential deadlock as\nshown below\n\nCPU 0                                CPU 1\n------------------------------------------------------------------\ncifs_demultiplex_thread()            cifs_debug_data_proc_show()\n release_mid()\n  spin_lock(&server->mid_lock);\n                                     spin_lock(&cifs_tcp_ses_lock)\n\t\t\t\t      spin_lock(&server->mid_lock)\n  __release_mid()\n   smb2_find_smb_tcon()\n    spin_lock(&cifs_tcp_ses_lock) *deadlock*",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52764",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: gspca: cpia1: shift-out-of-bounds in set_flicker",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: gspca: cpia1: shift-out-of-bounds in set_flicker\n\nSyzkaller reported the following issue:\nUBSAN: shift-out-of-bounds in drivers/media/usb/gspca/cpia1.c:1031:27\nshift exponent 245 is too large for 32-bit type 'int'\n\nWhen the value of the variable \"sd->params.exposure.gain\" exceeds the\nnumber of bits in an integer, a shift-out-of-bounds error is reported. It\nis triggered because the variable \"currentexp\" cannot be left-shifted by\nmore than the number of bits in an integer. In order to avoid invalid\nrange during left-shift, the conditional expression is added.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52766",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i3c: mipi-i3c-hci: Fix out of bounds access in hci_dma_irq_handler",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni3c: mipi-i3c-hci: Fix out of bounds access in hci_dma_irq_handler\n\nDo not loop over ring headers in hci_dma_irq_handler() that are not\nallocated and enabled in hci_dma_init(). Otherwise out of bounds access\nwill occur from rings->headers[i] access when i >= number of allocated\nring headers.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52775",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/smc: avoid data corruption caused by decline",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: avoid data corruption caused by decline\n\nWe found a data corruption issue during testing of SMC-R on Redis\napplications.\n\nThe benchmark has a low probability of reporting a strange error as\nshown below.\n\n\"Error: Protocol error, got \"\\xe2\" as reply type byte\"\n\nFinally, we found that the retrieved error data was as follows:\n\n0xE2 0xD4 0xC3 0xD9 0x04 0x00 0x2C 0x20 0xA6 0x56 0x00 0x16 0x3E 0x0C\n0xCB 0x04 0x02 0x01 0x00 0x00 0x20 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xE2\n\nIt is quite obvious that this is a SMC DECLINE message, which means that\nthe applications received SMC protocol message.\nWe found that this was caused by the following situations:\n\nclient                  server\n        \u00a6  clc proposal\n        ------------->\n        \u00a6  clc accept\n        <-------------\n        \u00a6  clc confirm\n        ------------->\nwait llc confirm\n\t\t\tsend llc confirm\n        \u00a6failed llc confirm\n        \u00a6   x------\n(after 2s)timeout\n                        wait llc confirm rsp\n\nwait decline\n\n(after 1s) timeout\n                        (after 2s) timeout\n        \u00a6   decline\n        -------------->\n        \u00a6   decline\n        <--------------\n\nAs a result, a decline message was sent in the implementation, and this\nmessage was read from TCP by the already-fallback connection.\n\nThis patch double the client timeout as 2x of the server value,\nWith this simple change, the Decline messages should never cross or\ncollide (during Confirm link timeout).\n\nThis issue requires an immediate solution, since the protocol updates\ninvolve a more long-term solution.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52796",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipvlan: add ipvlan_route_v6_outbound() helper",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipvlan: add ipvlan_route_v6_outbound() helper\n\nInspired by syzbot reports using a stack of multiple ipvlan devices.\n\nReduce stack size needed in ipvlan_process_v6_outbound() by moving\nthe flowi6 struct used for the route lookup in an non inlined\nhelper. ipvlan_route_v6_outbound() needs 120 bytes on the stack,\nimmediately reclaimed.\n\nAlso make sure ipvlan_process_v4_outbound() is not inlined.\n\nWe might also have to lower MAX_NEST_DEV, because only syzbot uses\nsetups with more than four stacked devices.\n\nBUG: TASK stack guard page was hit at ffffc9000e803ff8 (stack is ffffc9000e804000..ffffc9000e808000)\nstack guard page: 0000 [#1] SMP KASAN\nCPU: 0 PID: 13442 Comm: syz-executor.4 Not tainted 6.1.52-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/09/2023\nRIP: 0010:kasan_check_range+0x4/0x2a0 mm/kasan/generic.c:188\nCode: 48 01 c6 48 89 c7 e8 db 4e c1 03 31 c0 5d c3 cc 0f 0b eb 02 0f 0b b8 ea ff ff ff 5d c3 cc 00 00 cc cc 00 00 cc cc 55 48 89 e5 <41> 57 41 56 41 55 41 54 53 b0 01 48 85 f6 0f 84 a4 01 00 00 48 89\nRSP: 0018:ffffc9000e804000 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817e5bf2\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffff887c6568\nRBP: ffffc9000e804000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: dffffc0000000001 R12: 1ffff92001d0080c\nR13: dffffc0000000000 R14: ffffffff87e6b100 R15: 0000000000000000\nFS: 00007fd0c55826c0(0000) GS:ffff8881f6800000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000e803ff8 CR3: 0000000170ef7000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n<#DF>\n</#DF>\n<TASK>\n[<ffffffff81f281d1>] __kasan_check_read+0x11/0x20 mm/kasan/shadow.c:31\n[<ffffffff817e5bf2>] instrument_atomic_read include/linux/instrumented.h:72 [inline]\n[<ffffffff817e5bf2>] _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]\n[<ffffffff817e5bf2>] cpumask_test_cpu include/linux/cpumask.h:506 [inline]\n[<ffffffff817e5bf2>] cpu_online include/linux/cpumask.h:1092 [inline]\n[<ffffffff817e5bf2>] trace_lock_acquire include/trace/events/lock.h:24 [inline]\n[<ffffffff817e5bf2>] lock_acquire+0xe2/0x590 kernel/locking/lockdep.c:5632\n[<ffffffff8563221e>] rcu_lock_acquire+0x2e/0x40 include/linux/rcupdate.h:306\n[<ffffffff8561464d>] rcu_read_lock include/linux/rcupdate.h:747 [inline]\n[<ffffffff8561464d>] ip6_pol_route+0x15d/0x1440 net/ipv6/route.c:2221\n[<ffffffff85618120>] ip6_pol_route_output+0x50/0x80 net/ipv6/route.c:2606\n[<ffffffff856f65b5>] pol_lookup_func include/net/ip6_fib.h:584 [inline]\n[<ffffffff856f65b5>] fib6_rule_lookup+0x265/0x620 net/ipv6/fib6_rules.c:116\n[<ffffffff85618009>] ip6_route_output_flags_noref+0x2d9/0x3a0 net/ipv6/route.c:2638\n[<ffffffff8561821a>] ip6_route_output_flags+0xca/0x340 net/ipv6/route.c:2651\n[<ffffffff838bd5a3>] ip6_route_output include/net/ip6_route.h:100 [inline]\n[<ffffffff838bd5a3>] ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:473 [inline]\n[<ffffffff838bd5a3>] ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:529 [inline]\n[<ffffffff838bd5a3>] ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:602 [inline]\n[<ffffffff838bd5a3>] ipvlan_queue_xmit+0xc33/0x1be0 drivers/net/ipvlan/ipvlan_core.c:677\n[<ffffffff838c2909>] ipvlan_start_xmit+0x49/0x100 drivers/net/ipvlan/ipvlan_main.c:229\n[<ffffffff84d03900>] netdev_start_xmit include/linux/netdevice.h:4966 [inline]\n[<ffffffff84d03900>] xmit_one net/core/dev.c:3644 [inline]\n[<ffffffff84d03900>] dev_hard_start_xmit+0x320/0x980 net/core/dev.c:3660\n[<ffffffff84d080e2>] __dev_queue_xmit+0x16b2/0x3370 net/core/dev.c:4324\n[<ffffffff855ce4cd>] dev_queue_xmit include/linux/netdevice.h:3067 [inline]\n[<ffffffff855ce4cd>] neigh_hh_output include/net/neighbour.h:529 [inline]\n[<f\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52799",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix array-index-out-of-bounds in dbFindLeaf",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds in dbFindLeaf\n\nCurrently while searching for dmtree_t for sufficient free blocks there\nis an array out of bounds while getting element in tp->dm_stree. To add\nthe required check for out of bound we first need to determine the type\nof dmtree. Thus added an extra parameter to dbFindLeaf so that the type\nof tree can be determined and the required check can be applied.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52804",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fs/jfs: Add validity check for db_maxag and db_agpref",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/jfs: Add validity check for db_maxag and db_agpref\n\nBoth db_maxag and db_agpref are used as the index of the\ndb_agfree array, but there is currently no validity check for\ndb_maxag and db_agpref, which can lead to errors.\n\nThe following is related bug reported by Syzbot:\n\nUBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:639:20\nindex 7936 is out of range for type 'atomic_t[128]'\n\nAdd checking that the values of db_maxag and db_agpref are valid\nindexes for the db_agfree array.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52805",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix array-index-out-of-bounds in diAlloc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds in diAlloc\n\nCurrently there is not check against the agno of the iag while\nallocating new inodes to avoid fragmentation problem. Added the check\nwhich is required.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52812",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd: check num of link levels when update pcie param",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd: check num of link levels when update pcie param\n\nIn SR-IOV environment, the value of pcie_table->num_of_link_levels will\nbe 0, and num_of_levels - 1 will cause array index out of bounds",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52818",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd: Fix UBSAN array-index-out-of-bounds for SMU7",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd: Fix UBSAN array-index-out-of-bounds for SMU7\n\nFor pptable structs that use flexible array sizes, use flexible arrays.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52835",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf/core: Bail out early if the request AUX area is out of bound",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Bail out early if the request AUX area is out of bound\n\nWhen perf-record with a large AUX area, e.g 4GB, it fails with:\n\n    #perf record -C 0 -m ,4G -e arm_spe_0// -- sleep 1\n    failed to mmap with 12 (Cannot allocate memory)\n\nand it reveals a WARNING with __alloc_pages():\n\n\t------------[ cut here ]------------\n\tWARNING: CPU: 44 PID: 17573 at mm/page_alloc.c:5568 __alloc_pages+0x1ec/0x248\n\tCall trace:\n\t __alloc_pages+0x1ec/0x248\n\t __kmalloc_large_node+0xc0/0x1f8\n\t __kmalloc_node+0x134/0x1e8\n\t rb_alloc_aux+0xe0/0x298\n\t perf_mmap+0x440/0x660\n\t mmap_region+0x308/0x8a8\n\t do_mmap+0x3c0/0x528\n\t vm_mmap_pgoff+0xf4/0x1b8\n\t ksys_mmap_pgoff+0x18c/0x218\n\t __arm64_sys_mmap+0x38/0x58\n\t invoke_syscall+0x50/0x128\n\t el0_svc_common.constprop.0+0x58/0x188\n\t do_el0_svc+0x34/0x50\n\t el0_svc+0x34/0x108\n\t el0t_64_sync_handler+0xb8/0xc0\n\t el0t_64_sync+0x1a4/0x1a8\n\n'rb->aux_pages' allocated by kcalloc() is a pointer array which is used to\nmaintains AUX trace pages. The allocated page for this array is physically\ncontiguous (and virtually contiguous) with an order of 0..MAX_ORDER. If the\nsize of pointer array crosses the limitation set by MAX_ORDER, it reveals a\nWARNING.\n\nSo bail out early with -ENOMEM if the request AUX area is out of bound,\ne.g.:\n\n    #perf record -C 0 -m ,4G -e arm_spe_0// -- sleep 1\n    failed to mmap with 12 (Cannot allocate memory)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52836",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: locking/ww_mutex/test: Fix potential workqueue corruption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlocking/ww_mutex/test: Fix potential workqueue corruption\n\nIn some cases running with the test-ww_mutex code, I was seeing\nodd behavior where sometimes it seemed flush_workqueue was\nreturning before all the work threads were finished.\n\nOften this would cause strange crashes as the mutexes would be\nfreed while they were being used.\n\nLooking at the code, there is a lifetime problem as the\ncontrolling thread that spawns the work allocates the\n\"struct stress\" structures that are passed to the workqueue\nthreads. Then when the workqueue threads are finished,\nthey free the stress struct that was passed to them.\n\nUnfortunately the workqueue work_struct node is in the stress\nstruct. Which means the work_struct is freed before the work\nthread returns and while flush_workqueue is waiting.\n\nIt seems like a better idea to have the controlling thread\nboth allocate and free the stress structures, so that we can\nbe sure we don't corrupt the workqueue by freeing the structure\nprematurely.\n\nSo this patch reworks the test to do so, and with this change\nI no longer see the early flush_workqueue returns.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52840",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Input: synaptics-rmi4 - fix use after free in rmi_unregister_function()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: synaptics-rmi4 - fix use after free in rmi_unregister_function()\n\nThe put_device() calls rmi_release_function() which frees \"fn\" so the\ndereference on the next line \"fn->num_of_irqs\" is a use after free.\nMove the put_device() to the end to fix this.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52846",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hsr: Prevent use after free in prp_create_tagged_frame()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhsr: Prevent use after free in prp_create_tagged_frame()\n\nThe prp_fill_rct() function can fail.  In that situation, it frees the\nskb and returns NULL.  Meanwhile on the success path, it returns the\noriginal skb.  So it's straight forward to fix bug by using the returned\nvalue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52854",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: padata: Fix refcnt handling in padata_free_shell()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: Fix refcnt handling in padata_free_shell()\n\nIn a high-load arm64 environment, the pcrypt_aead01 test in LTP can lead\nto system UAF (Use-After-Free) issues. Due to the lengthy analysis of\nthe pcrypt_aead01 function call, I'll describe the problem scenario\nusing a simplified model:\n\nSuppose there's a user of padata named `user_function` that adheres to\nthe padata requirement of calling `padata_free_shell` after `serial()`\nhas been invoked, as demonstrated in the following code:\n\n```c\nstruct request {\n    struct padata_priv padata;\n    struct completion *done;\n};\n\nvoid parallel(struct padata_priv *padata) {\n    do_something();\n}\n\nvoid serial(struct padata_priv *padata) {\n    struct request *request = container_of(padata,\n    \t\t\t\tstruct request,\n\t\t\t\tpadata);\n    complete(request->done);\n}\n\nvoid user_function() {\n    DECLARE_COMPLETION(done)\n    padata->parallel = parallel;\n    padata->serial = serial;\n    padata_do_parallel();\n    wait_for_completion(&done);\n    padata_free_shell();\n}\n```\n\nIn the corresponding padata.c file, there's the following code:\n\n```c\nstatic void padata_serial_worker(struct work_struct *serial_work) {\n    ...\n    cnt = 0;\n\n    while (!list_empty(&local_list)) {\n        ...\n        padata->serial(padata);\n        cnt++;\n    }\n\n    local_bh_enable();\n\n    if (refcount_sub_and_test(cnt, &pd->refcnt))\n        padata_free_pd(pd);\n}\n```\n\nBecause of the high system load and the accumulation of unexecuted\nsoftirq at this moment, `local_bh_enable()` in padata takes longer\nto execute than usual. Subsequently, when accessing `pd->refcnt`,\n`pd` has already been released by `padata_free_shell()`, resulting\nin a UAF issue with `pd->refcnt`.\n\nThe fix is straightforward: add `refcount_dec_and_test` before calling\n`padata_free_pd` in `padata_free_shell`.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52864",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: platform/x86: wmi: Fix opening of char device",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: wmi: Fix opening of char device\n\nSince commit fa1f68db6ca7 (\"drivers: misc: pass miscdevice pointer via\nfile private data\"), the miscdevice stores a pointer to itself inside\nfilp->private_data, which means that private_data will not be NULL when\nwmi_char_open() is called. This might cause memory corruption should\nwmi_char_open() be unable to find its driver, something which can\nhappen when the associated WMI device is deleted in wmi_free_devices().\n\nFix the problem by using the miscdevice pointer to retrieve the WMI\ndevice data associated with a char device using container_of(). This\nalso avoids wmi_char_open() picking a wrong WMI device bound to a\ndriver with the same name as the original driver.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52867",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/radeon: possible buffer overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/radeon: possible buffer overflow\n\nBuffer 'afmt_status' of size 6 could overflow, since index 'afmt_idx' is\nchecked after access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52868",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: thermal: core: prevent potential string overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nthermal: core: prevent potential string overflow\n\nThe dev->id value comes from ida_alloc() so it's a number between zero\nand INT_MAX.  If it's too high then these sprintf()s will overflow.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52885",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: SUNRPC: Fix UAF in svc_tcp_listen_data_ready()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: Fix UAF in svc_tcp_listen_data_ready()\n\nAfter the listener svc_sock is freed, and before invoking svc_tcp_accept()\nfor the established child sock, there is a window that the newsock\nretaining a freed listener svc_sock in sk_user_data which cloning from\nparent. In the race window, if data is received on the newsock, we will\nobserve use-after-free report in svc_tcp_listen_data_ready().\n\nReproduce by two tasks:\n\n1. while :; do rpc.nfsd 0 ; rpc.nfsd; done\n2. while :; do echo \"\" | ncat -4 127.0.0.1 2049 ; done\n\nKASAN report:\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in svc_tcp_listen_data_ready+0x1cf/0x1f0 [sunrpc]\n  Read of size 8 at addr ffff888139d96228 by task nc/102553\n  CPU: 7 PID: 102553 Comm: nc Not tainted 6.3.0+ #18\n  Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\n  Call Trace:\n   <IRQ>\n   dump_stack_lvl+0x33/0x50\n   print_address_description.constprop.0+0x27/0x310\n   print_report+0x3e/0x70\n   kasan_report+0xae/0xe0\n   svc_tcp_listen_data_ready+0x1cf/0x1f0 [sunrpc]\n   tcp_data_queue+0x9f4/0x20e0\n   tcp_rcv_established+0x666/0x1f60\n   tcp_v4_do_rcv+0x51c/0x850\n   tcp_v4_rcv+0x23fc/0x2e80\n   ip_protocol_deliver_rcu+0x62/0x300\n   ip_local_deliver_finish+0x267/0x350\n   ip_local_deliver+0x18b/0x2d0\n   ip_rcv+0x2fb/0x370\n   __netif_receive_skb_one_core+0x166/0x1b0\n   process_backlog+0x24c/0x5e0\n   __napi_poll+0xa2/0x500\n   net_rx_action+0x854/0xc90\n   __do_softirq+0x1bb/0x5de\n   do_softirq+0xcb/0x100\n   </IRQ>\n   <TASK>\n   ...\n   </TASK>\n\n  Allocated by task 102371:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   __kasan_kmalloc+0x7b/0x90\n   svc_setup_socket+0x52/0x4f0 [sunrpc]\n   svc_addsock+0x20d/0x400 [sunrpc]\n   __write_ports_addfd+0x209/0x390 [nfsd]\n   write_ports+0x239/0x2c0 [nfsd]\n   nfsctl_transaction_write+0xac/0x110 [nfsd]\n   vfs_write+0x1c3/0xae0\n   ksys_write+0xed/0x1c0\n   do_syscall_64+0x38/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\n  Freed by task 102551:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   kasan_save_free_info+0x2a/0x50\n   __kasan_slab_free+0x106/0x190\n   __kmem_cache_free+0x133/0x270\n   svc_xprt_free+0x1e2/0x350 [sunrpc]\n   svc_xprt_destroy_all+0x25a/0x440 [sunrpc]\n   nfsd_put+0x125/0x240 [nfsd]\n   nfsd_svc+0x2cb/0x3c0 [nfsd]\n   write_threads+0x1ac/0x2a0 [nfsd]\n   nfsctl_transaction_write+0xac/0x110 [nfsd]\n   vfs_write+0x1c3/0xae0\n   ksys_write+0xed/0x1c0\n   do_syscall_64+0x38/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFix the UAF by simply doing nothing in svc_tcp_listen_data_ready()\nif state != TCP_LISTEN, that will avoid dereferencing svsk for all\nchild socket.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52906",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: act_mpls: Fix warning during failed attribute validation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_mpls: Fix warning during failed attribute validation\n\nThe 'TCA_MPLS_LABEL' attribute is of 'NLA_U32' type, but has a\nvalidation type of 'NLA_VALIDATE_FUNCTION'. This is an invalid\ncombination according to the comment above 'struct nla_policy':\n\n\"\nMeaning of `validate' field, use via NLA_POLICY_VALIDATE_FN:\n   NLA_BINARY           Validation function called for the attribute.\n   All other            Unused - but note that it's a union\n\"\n\nThis can trigger the warning [1] in nla_get_range_unsigned() when\nvalidation of the attribute fails. Despite being of 'NLA_U32' type, the\nassociated 'min'/'max' fields in the policy are negative as they are\naliased by the 'validate' field.\n\nFix by changing the attribute type to 'NLA_BINARY' which is consistent\nwith the above comment and all other users of NLA_POLICY_VALIDATE_FN().\nAs a result, move the length validation to the validation function.\n\nNo regressions in MPLS tests:\n\n # ./tdc.py -f tc-tests/actions/mpls.json\n [...]\n # echo $?\n 0\n\n[1]\nWARNING: CPU: 0 PID: 17743 at lib/nlattr.c:118\nnla_get_range_unsigned+0x1d8/0x1e0 lib/nlattr.c:117\nModules linked in:\nCPU: 0 PID: 17743 Comm: syz-executor.0 Not tainted 6.1.0-rc8 #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nrel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014\nRIP: 0010:nla_get_range_unsigned+0x1d8/0x1e0 lib/nlattr.c:117\n[...]\nCall Trace:\n <TASK>\n __netlink_policy_dump_write_attr+0x23d/0x990 net/netlink/policy.c:310\n netlink_policy_dump_write_attr+0x22/0x30 net/netlink/policy.c:411\n netlink_ack_tlv_fill net/netlink/af_netlink.c:2454 [inline]\n netlink_ack+0x546/0x760 net/netlink/af_netlink.c:2506\n netlink_rcv_skb+0x1b7/0x240 net/netlink/af_netlink.c:2546\n rtnetlink_rcv+0x18/0x20 net/core/rtnetlink.c:6109\n netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n netlink_unicast+0x5e9/0x6b0 net/netlink/af_netlink.c:1345\n netlink_sendmsg+0x739/0x860 net/netlink/af_netlink.c:1921\n sock_sendmsg_nosec net/socket.c:714 [inline]\n sock_sendmsg net/socket.c:734 [inline]\n ____sys_sendmsg+0x38f/0x500 net/socket.c:2482\n ___sys_sendmsg net/socket.c:2536 [inline]\n __sys_sendmsg+0x197/0x230 net/socket.c:2565\n __do_sys_sendmsg net/socket.c:2574 [inline]\n __se_sys_sendmsg net/socket.c:2572 [inline]\n __x64_sys_sendmsg+0x42/0x50 net/socket.c:2572\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52916",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: aspeed: Fix memory overwrite if timing is 1600x900",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: aspeed: Fix memory overwrite if timing is 1600x900\n\nWhen capturing 1600x900, system could crash when system memory usage is\ntight.\n\nThe way to reproduce this issue:\n1. Use 1600x900 to display on host\n2. Mount ISO through 'Virtual media' on OpenBMC's web\n3. Run script as below on host to do sha continuously\n  #!/bin/bash\n  while [ [1] ];\n  do\n\tfind /media -type f -printf '\"%h/%f\"\\n' | xargs sha256sum\n  done\n4. Open KVM on OpenBMC's web\n\nThe size of macro block captured is 8x8. Therefore, we should make sure\nthe height of src-buf is 8 aligned to fix this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52922",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: can: bcm: Fix UAF in bcm_proc_show()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: bcm: Fix UAF in bcm_proc_show()\n\nBUG: KASAN: slab-use-after-free in bcm_proc_show+0x969/0xa80\nRead of size 8 at addr ffff888155846230 by task cat/7862\n\nCPU: 1 PID: 7862 Comm: cat Not tainted 6.5.0-rc1-00153-gc8746099c197 #230\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0xd5/0x150\n print_report+0xc1/0x5e0\n kasan_report+0xba/0xf0\n bcm_proc_show+0x969/0xa80\n seq_read_iter+0x4f6/0x1260\n seq_read+0x165/0x210\n proc_reg_read+0x227/0x300\n vfs_read+0x1d5/0x8d0\n ksys_read+0x11e/0x240\n do_syscall_64+0x35/0xb0\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nAllocated by task 7846:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n __kasan_kmalloc+0x9e/0xa0\n bcm_sendmsg+0x264b/0x44e0\n sock_sendmsg+0xda/0x180\n ____sys_sendmsg+0x735/0x920\n ___sys_sendmsg+0x11d/0x1b0\n __sys_sendmsg+0xfa/0x1d0\n do_syscall_64+0x35/0xb0\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nFreed by task 7846:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n kasan_save_free_info+0x27/0x40\n ____kasan_slab_free+0x161/0x1c0\n slab_free_freelist_hook+0x119/0x220\n __kmem_cache_free+0xb4/0x2e0\n rcu_core+0x809/0x1bd0\n\nbcm_op is freed before procfs entry be removed in bcm_release(),\nthis lead to bcm_proc_show() may read the freed bcm_op.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52930",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/i915: Fix potential bit_17 double-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915: Fix potential bit_17 double-free\n\nA userspace with multiple threads racing I915_GEM_SET_TILING to set the\ntiling to I915_TILING_NONE could trigger a double free of the bit_17\nbitmask.  (Or conversely leak memory on the transition to tiled.)  Move\nallocation/free'ing of the bitmask within the section protected by the\nobj lock.\n\n[tursulin: Correct fixes tag and added cc stable.]\n(cherry picked from commit 10e0cbaaf1104f449d695c80bcacf930dcd3c42e)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52935",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm/khugepaged: fix ->anon_vma race",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/khugepaged: fix ->anon_vma race\n\nIf an ->anon_vma is attached to the VMA, collapse_and_free_pmd() requires\nit to be locked.\n\nPage table traversal is allowed under any one of the mmap lock, the\nanon_vma lock (if the VMA is associated with an anon_vma), and the\nmapping lock (if the VMA is associated with a mapping); and so to be\nable to remove page tables, we must hold all three of them. \nretract_page_tables() bails out if an ->anon_vma is attached, but does\nthis check before holding the mmap lock (as the comment above the check\nexplains).\n\nIf we racily merged an existing ->anon_vma (shared with a child\nprocess) from a neighboring VMA, subsequent rmap traversals on pages\nbelonging to the child will be able to see the page tables that we are\nconcurrently removing while assuming that nothing else can access them.\n\nRepeat the ->anon_vma check once we hold the mmap lock to ensure that\nthere really is no concurrent page table access.\n\nHitting this bug causes a lockdep warning in collapse_and_free_pmd(),\nin the line \"lockdep_assert_held_write(&vma->anon_vma->root->rwsem)\". \nIt can also lead to use-after-free access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52974",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: iscsi_tcp: Fix UAF during login when accessing the shost ipaddress",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi_tcp: Fix UAF during login when accessing the shost ipaddress\n\nIf during iscsi_sw_tcp_session_create() iscsi_tcp_r2tpool_alloc() fails,\nuserspace could be accessing the host's ipaddress attr. If we then free the\nsession via iscsi_session_teardown() while userspace is still accessing the\nsession we will hit a use after free bug.\n\nSet the tcp_sw_host->session after we have completed session creation and\ncan no longer fail.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52983",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: block, bfq: fix uaf for bfqq in bic_set_bfqq()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock, bfq: fix uaf for bfqq in bic_set_bfqq()\n\nAfter commit 64dc8c732f5c (\"block, bfq: fix possible uaf for 'bfqq->bic'\"),\nbic->bfqq will be accessed in bic_set_bfqq(), however, in some context\nbic->bfqq will be freed, and bic_set_bfqq() is called with the freed\nbic->bfqq.\n\nFix the problem by always freeing bfqq after bic_set_bfqq().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52988",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: hda/via: Avoid potential array out-of-bound in add_secret_dac_path()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda/via: Avoid potential array out-of-bound in add_secret_dac_path()\n\nsnd_hda_get_connections() can return a negative error code.\nIt may lead to accessing 'conn' array at a negative index.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52996",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv4: prevent potential spectre v1 gadget in fib_metrics_match()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv4: prevent potential spectre v1 gadget in fib_metrics_match()\n\nif (!type)\n        continue;\n    if (type > RTAX_MAX)\n        return false;\n    ...\n    fi_val = fi->fib_metrics->metrics[type - 1];\n\n@type being used as an array index, we need to prevent\ncpu speculation or risk leaking kernel memory content.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-52999",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: fix UaF in netns ops registration error path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix UaF in netns ops registration error path\n\nIf net_assign_generic() fails, the current error path in ops_init() tries\nto clear the gen pointer slot. Anyway, in such error path, the gen pointer\nitself has not been modified yet, and the existing and accessed one is\nsmaller than the accessed index, causing an out-of-bounds error:\n\n BUG: KASAN: slab-out-of-bounds in ops_init+0x2de/0x320\n Write of size 8 at addr ffff888109124978 by task modprobe/1018\n\n CPU: 2 PID: 1018 Comm: modprobe Not tainted 6.2.0-rc2.mptcp_ae5ac65fbed5+ #1641\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x6a/0x9f\n  print_address_description.constprop.0+0x86/0x2b5\n  print_report+0x11b/0x1fb\n  kasan_report+0x87/0xc0\n  ops_init+0x2de/0x320\n  register_pernet_operations+0x2e4/0x750\n  register_pernet_subsys+0x24/0x40\n  tcf_register_action+0x9f/0x560\n  do_one_initcall+0xf9/0x570\n  do_init_module+0x190/0x650\n  load_module+0x1fa5/0x23c0\n  __do_sys_finit_module+0x10d/0x1b0\n  do_syscall_64+0x58/0x80\n  entry_SYSCALL_64_after_hwframe+0x72/0xdc\n RIP: 0033:0x7f42518f778d\n Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48\n       89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff\n       ff 73 01 c3 48 8b 0d cb 56 2c 00 f7 d8 64 89 01 48\n RSP: 002b:00007fff96869688 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\n RAX: ffffffffffffffda RBX: 00005568ef7f7c90 RCX: 00007f42518f778d\n RDX: 0000000000000000 RSI: 00005568ef41d796 RDI: 0000000000000003\n RBP: 00005568ef41d796 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000003 R11: 0000000000000246 R12: 0000000000000000\n R13: 00005568ef7f7d30 R14: 0000000000040000 R15: 0000000000000000\n  </TASK>\n\nThis change addresses the issue by skipping the gen pointer\nde-reference in the mentioned error-path.\n\nFound by code inspection and verified with explicit error injection\non a kasan-enabled kernel.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53003",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: EDAC/qcom: Do not pass llcc_driv_data as edac_device_ctl_info's pvt_info",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nEDAC/qcom: Do not pass llcc_driv_data as edac_device_ctl_info's pvt_info\n\nThe memory for llcc_driv_data is allocated by the LLCC driver. But when\nit is passed as the private driver info to the EDAC core, it will get freed\nduring the qcom_edac driver release. So when the qcom_edac driver gets probed\nagain, it will try to use the freed data leading to the use-after-free bug.\n\nHence, do not pass llcc_driv_data as pvt_info but rather reference it\nusing the platform_data pointer in the qcom_edac driver.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53034",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_trans",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_trans\n\nThere is a kernel API ntb_mw_clear_trans() would pass 0 to both addr and\nsize. This would make xlate_pos negative.\n\n[   23.734156] switchtec switchtec0: MW 0: part 0 addr 0x0000000000000000 size 0x0000000000000000\n[   23.734158] ================================================================================\n[   23.734172] UBSAN: shift-out-of-bounds in drivers/ntb/hw/mscc/ntb_hw_switchtec.c:293:7\n[   23.734418] shift exponent -1 is negative\n\nEnsuring xlate_pos is a positive or zero before BIT.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53047",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tee: amdtee: fix race condition in amdtee_open_session",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntee: amdtee: fix race condition in amdtee_open_session\n\nThere is a potential race condition in amdtee_open_session that may\nlead to use-after-free. For instance, in amdtee_open_session() after\nsess->sess_mask is set, and before setting:\n\n    sess->session_info[i] = session_info;\n\nif amdtee_close_session() closes this same session, then 'sess' data\nstructure will be released, causing kernel panic when 'sess' is\naccessed within amdtee_open_session().\n\nThe solution is to set the bit sess->sess_mask as the last step in\namdtee_open_session().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53125",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: usb: smsc75xx: Limit packet length to skb->len",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: smsc75xx: Limit packet length to skb->len\n\nPacket length retrieved from skb data may be larger than\nthe actual socket buffer length (up to 9026 bytes). In such\ncase the cloned skb passed up the network stack will leak\nkernel memory contents.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53165",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: udf: Fix uninitialized array access for some pathnames",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Fix uninitialized array access for some pathnames\n\nFor filenames that begin with . and are between 2 and 5 characters long,\nUDF charset conversion code would read uninitialized memory in the\noutput buffer. The only practical impact is that the name may be prepended a\n\"unification hash\" when it is not actually needed but still it is good\nto fix this.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53178",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm: fix zswap writeback race condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: fix zswap writeback race condition\n\nThe zswap writeback mechanism can cause a race condition resulting in\nmemory corruption, where a swapped out page gets swapped in with data that\nwas written to a different page.\n\nThe race unfolds like this:\n1. a page with data A and swap offset X is stored in zswap\n2. page A is removed off the LRU by zpool driver for writeback in\n   zswap-shrink work, data for A is mapped by zpool driver\n3. user space program faults and invalidates page entry A, offset X is\n   considered free\n4. kswapd stores page B at offset X in zswap (zswap could also be\n   full, if so, page B would then be IOed to X, then skip step 5.)\n5. entry A is replaced by B in tree->rbroot, this doesn't affect the\n   local reference held by zswap-shrink work\n6. zswap-shrink work writes back A at X, and frees zswap entry A\n7. swapin of slot X brings A in memory instead of B\n\nThe fix:\nOnce the swap page cache has been allocated (case ZSWAP_SWAPCACHE_NEW),\nzswap-shrink work just checks that the local zswap_entry reference is\nstill the same as the one in the tree.  If it's not the same it means that\nit's either been invalidated or replaced, in both cases the writeback is\naborted because the local entry contains stale data.\n\nReproducer:\nI originally found this by running `stress` overnight to validate my work\non the zswap writeback mechanism, it manifested after hours on my test\nmachine.  The key to make it happen is having zswap writebacks, so\nwhatever setup pumps /sys/kernel/debug/zswap/written_back_pages should do\nthe trick.\n\nIn order to reproduce this faster on a vm, I setup a system with ~100M of\navailable memory and a 500M swap file, then running `stress --vm 1\n--vm-bytes 300000000 --vm-stride 4000` makes it happen in matter of tens\nof minutes.  One can speed things up even more by swinging\n/sys/module/zswap/parameters/max_pool_percent up and down between, say, 20\nand 1; this makes it reproduce in tens of seconds.  It's crucial to set\n`--vm-stride` to something other than 4096 otherwise `stress` won't\nrealize that memory has been corrupted because all pages would have the\nsame data.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53185",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath9k: don't allow to overwrite ENDPOINT0 attributes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: don't allow to overwrite ENDPOINT0 attributes\n\nA bad USB device is able to construct a service connection response\nmessage with target endpoint being ENDPOINT0 which is reserved for\nHTC_CTRL_RSVD_SVC and should not be modified to be used for any other\nservices.\n\nReject such service connection responses.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53204",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: af_unix: Fix data-races around user->unix_inflight",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix data-races around user->unix_inflight.\n\nuser->unix_inflight is changed under spin_lock(unix_gc_lock),\nbut too_many_unix_fds() reads it locklessly.\n\nLet's annotate the write/read accesses to user->unix_inflight.\n\nBUG: KCSAN: data-race in unix_attach_fds / unix_inflight\n\nwrite to 0xffffffff8546f2d0 of 8 bytes by task 44798 on cpu 1:\n unix_inflight+0x157/0x180 net/unix/scm.c:66\n unix_attach_fds+0x147/0x1e0 net/unix/scm.c:123\n unix_scm_to_skb net/unix/af_unix.c:1827 [inline]\n unix_dgram_sendmsg+0x46a/0x14f0 net/unix/af_unix.c:1950\n unix_seqpacket_sendmsg net/unix/af_unix.c:2308 [inline]\n unix_seqpacket_sendmsg+0xba/0x130 net/unix/af_unix.c:2292\n sock_sendmsg_nosec net/socket.c:725 [inline]\n sock_sendmsg+0x148/0x160 net/socket.c:748\n ____sys_sendmsg+0x4e4/0x610 net/socket.c:2494\n ___sys_sendmsg+0xc6/0x140 net/socket.c:2548\n __sys_sendmsg+0x94/0x140 net/socket.c:2577\n __do_sys_sendmsg net/socket.c:2586 [inline]\n __se_sys_sendmsg net/socket.c:2584 [inline]\n __x64_sys_sendmsg+0x45/0x50 net/socket.c:2584\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nread to 0xffffffff8546f2d0 of 8 bytes by task 44814 on cpu 0:\n too_many_unix_fds net/unix/scm.c:101 [inline]\n unix_attach_fds+0x54/0x1e0 net/unix/scm.c:110\n unix_scm_to_skb net/unix/af_unix.c:1827 [inline]\n unix_dgram_sendmsg+0x46a/0x14f0 net/unix/af_unix.c:1950\n unix_seqpacket_sendmsg net/unix/af_unix.c:2308 [inline]\n unix_seqpacket_sendmsg+0xba/0x130 net/unix/af_unix.c:2292\n sock_sendmsg_nosec net/socket.c:725 [inline]\n sock_sendmsg+0x148/0x160 net/socket.c:748\n ____sys_sendmsg+0x4e4/0x610 net/socket.c:2494\n ___sys_sendmsg+0xc6/0x140 net/socket.c:2548\n __sys_sendmsg+0x94/0x140 net/socket.c:2577\n __do_sys_sendmsg net/socket.c:2586 [inline]\n __se_sys_sendmsg net/socket.c:2584 [inline]\n __x64_sys_sendmsg+0x45/0x50 net/socket.c:2584\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nvalue changed: 0x000000000000000c -> 0x000000000000000d\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 44814 Comm: systemd-coredum Not tainted 6.4.0-11989-g6843306689af #6\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53213",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: brcmfmac: slab-out-of-bounds read in brcmf_get_assoc_ies()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: slab-out-of-bounds read in brcmf_get_assoc_ies()\n\nFix a slab-out-of-bounds read that occurs in kmemdup() called from\nbrcmf_get_assoc_ies().\nThe bug could occur when assoc_info->req_len, data from a URB provided\nby a USB device, is bigger than the size of buffer which is defined as\nWL_EXTRA_BUF_MAX.\n\nAdd the size check for req_len/resp_len of assoc_info.\n\nFound by a modified version of syzkaller.\n\n[   46.592467][    T7] ==================================================================\n[   46.594687][    T7] BUG: KASAN: slab-out-of-bounds in kmemdup+0x3e/0x50\n[   46.596572][    T7] Read of size 3014656 at addr ffff888019442000 by task kworker/0:1/7\n[   46.598575][    T7]\n[   46.599157][    T7] CPU: 0 PID: 7 Comm: kworker/0:1 Tainted: G           O      5.14.0+ #145\n[   46.601333][    T7] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\n[   46.604360][    T7] Workqueue: events brcmf_fweh_event_worker\n[   46.605943][    T7] Call Trace:\n[   46.606584][    T7]  dump_stack_lvl+0x8e/0xd1\n[   46.607446][    T7]  print_address_description.constprop.0.cold+0x93/0x334\n[   46.608610][    T7]  ? kmemdup+0x3e/0x50\n[   46.609341][    T7]  kasan_report.cold+0x79/0xd5\n[   46.610151][    T7]  ? kmemdup+0x3e/0x50\n[   46.610796][    T7]  kasan_check_range+0x14e/0x1b0\n[   46.611691][    T7]  memcpy+0x20/0x60\n[   46.612323][    T7]  kmemdup+0x3e/0x50\n[   46.612987][    T7]  brcmf_get_assoc_ies+0x967/0xf60\n[   46.613904][    T7]  ? brcmf_notify_vif_event+0x3d0/0x3d0\n[   46.614831][    T7]  ? lock_chain_count+0x20/0x20\n[   46.615683][    T7]  ? mark_lock.part.0+0xfc/0x2770\n[   46.616552][    T7]  ? lock_chain_count+0x20/0x20\n[   46.617409][    T7]  ? mark_lock.part.0+0xfc/0x2770\n[   46.618244][    T7]  ? lock_chain_count+0x20/0x20\n[   46.619024][    T7]  brcmf_bss_connect_done.constprop.0+0x241/0x2e0\n[   46.620019][    T7]  ? brcmf_parse_configure_security.isra.0+0x2a0/0x2a0\n[   46.620818][    T7]  ? __lock_acquire+0x181f/0x5790\n[   46.621462][    T7]  brcmf_notify_connect_status+0x448/0x1950\n[   46.622134][    T7]  ? rcu_read_lock_bh_held+0xb0/0xb0\n[   46.622736][    T7]  ? brcmf_cfg80211_join_ibss+0x7b0/0x7b0\n[   46.623390][    T7]  ? find_held_lock+0x2d/0x110\n[   46.623962][    T7]  ? brcmf_fweh_event_worker+0x19f/0xc60\n[   46.624603][    T7]  ? mark_held_locks+0x9f/0xe0\n[   46.625145][    T7]  ? lockdep_hardirqs_on_prepare+0x3e0/0x3e0\n[   46.625871][    T7]  ? brcmf_cfg80211_join_ibss+0x7b0/0x7b0\n[   46.626545][    T7]  brcmf_fweh_call_event_handler.isra.0+0x90/0x100\n[   46.627338][    T7]  brcmf_fweh_event_worker+0x557/0xc60\n[   46.627962][    T7]  ? brcmf_fweh_call_event_handler.isra.0+0x100/0x100\n[   46.628736][    T7]  ? rcu_read_lock_sched_held+0xa1/0xd0\n[   46.629396][    T7]  ? rcu_read_lock_bh_held+0xb0/0xb0\n[   46.629970][    T7]  ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n[   46.630649][    T7]  process_one_work+0x92b/0x1460\n[   46.631205][    T7]  ? pwq_dec_nr_in_flight+0x330/0x330\n[   46.631821][    T7]  ? rwlock_bug.part.0+0x90/0x90\n[   46.632347][    T7]  worker_thread+0x95/0xe00\n[   46.632832][    T7]  ? __kthread_parkme+0x115/0x1e0\n[   46.633393][    T7]  ? process_one_work+0x1460/0x1460\n[   46.633957][    T7]  kthread+0x3a1/0x480\n[   46.634369][    T7]  ? set_kthread_struct+0x120/0x120\n[   46.634933][    T7]  ret_from_fork+0x1f/0x30\n[   46.635431][    T7]\n[   46.635687][    T7] Allocated by task 7:\n[   46.636151][    T7]  kasan_save_stack+0x1b/0x40\n[   46.636628][    T7]  __kasan_kmalloc+0x7c/0x90\n[   46.637108][    T7]  kmem_cache_alloc_trace+0x19e/0x330\n[   46.637696][    T7]  brcmf_cfg80211_attach+0x4a0/0x4040\n[   46.638275][    T7]  brcmf_attach+0x389/0xd40\n[   46.638739][    T7]  brcmf_usb_probe+0x12de/0x1690\n[   46.639279][    T7]  usb_probe_interface+0x2aa/0x760\n[   46.639820][    T7]  really_probe+0x205/0xb70\n[   46.640342][    T7]  __driver_probe_device+0\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53216",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arm64: efi: Make efi_rt_lock a raw_spinlock",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: efi: Make efi_rt_lock a raw_spinlock\n\nRunning a rt-kernel base on 6.2.0-rc3-rt1 on an Ampere Altra outputs\nthe following:\n  BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46\n  in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 9, name: kworker/u320:0\n  preempt_count: 2, expected: 0\n  RCU nest depth: 0, expected: 0\n  3 locks held by kworker/u320:0/9:\n  #0: ffff3fff8c27d128 ((wq_completion)efi_rts_wq){+.+.}-{0:0}, at: process_one_work (./include/linux/atomic/atomic-long.h:41)\n  #1: ffff80000861bdd0 ((work_completion)(&efi_rts_work.work)){+.+.}-{0:0}, at: process_one_work (./include/linux/atomic/atomic-long.h:41)\n  #2: ffffdf7e1ed3e460 (efi_rt_lock){+.+.}-{3:3}, at: efi_call_rts (drivers/firmware/efi/runtime-wrappers.c:101)\n  Preemption disabled at:\n  efi_virtmap_load (./arch/arm64/include/asm/mmu_context.h:248)\n  CPU: 0 PID: 9 Comm: kworker/u320:0 Tainted: G        W          6.2.0-rc3-rt1\n  Hardware name: WIWYNN Mt.Jade Server System B81.03001.0005/Mt.Jade Motherboard, BIOS 1.08.20220218 (SCP: 1.08.20220218) 2022/02/18\n  Workqueue: efi_rts_wq efi_call_rts\n  Call trace:\n  dump_backtrace (arch/arm64/kernel/stacktrace.c:158)\n  show_stack (arch/arm64/kernel/stacktrace.c:165)\n  dump_stack_lvl (lib/dump_stack.c:107 (discriminator 4))\n  dump_stack (lib/dump_stack.c:114)\n  __might_resched (kernel/sched/core.c:10134)\n  rt_spin_lock (kernel/locking/rtmutex.c:1769 (discriminator 4))\n  efi_call_rts (drivers/firmware/efi/runtime-wrappers.c:101)\n  [...]\n\nThis seems to come from commit ff7a167961d1 (\"arm64: efi: Execute\nruntime services from a dedicated stack\") which adds a spinlock. This\nspinlock is taken through:\nefi_call_rts()\n\\-efi_call_virt()\n  \\-efi_call_virt_pointer()\n    \\-arch_efi_call_virt_setup()\n\nMake 'efi_rt_lock' a raw_spinlock to avoid being preempted.\n\n[ardb: The EFI runtime services are called with a different set of\n       translation tables, and are permitted to use the SIMD registers.\n       The context switch code preserves/restores neither, and so EFI\n       calls must be made with preemption disabled, rather than only\n       disabling migration.]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53222",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: jfs_dmap: Validate db_l2nbperpage while mounting",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: jfs_dmap: Validate db_l2nbperpage while mounting\n\nIn jfs_dmap.c at line 381, BLKTODMAP is used to get a logical block\nnumber inside dbFree(). db_l2nbperpage, which is the log2 number of\nblocks per page, is passed as an argument to BLKTODMAP which uses it\nfor shifting.\n\nSyzbot reported a shift out-of-bounds crash because db_l2nbperpage is\ntoo big. This happens because the large value is set without any\nvalidation in dbMount() at line 181.\n\nThus, make sure that db_l2nbperpage is correct while mounting.\n\nMax number of blocks per page = Page size / Min block size\n=> log2(Max num_block per page) = log2(Page size / Min block size)\n\t\t\t\t= log2(Page size) - log2(Min block size)\n\n=> Max db_l2nbperpage = L2PSIZE - L2MINBLOCKSIZE",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53225",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: spi: imx: Don't skip cleanup in remove's error path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: imx: Don't skip cleanup in remove's error path\n\nReturning early in a platform driver's remove callback is wrong. In this\ncase the dma resources are not released in the error path. this is never\nretried later and so this is a permanent leak. To fix this, only skip\nhardware disabling if waking the device fails.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53226",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mwifiex: Fix OOB and integer underflow when rx packets",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Fix OOB and integer underflow when rx packets\n\nMake sure mwifiex_process_mgmt_packet,\nmwifiex_process_sta_rx_packet and mwifiex_process_uap_rx_packet,\nmwifiex_uap_queue_bridged_pkt and mwifiex_process_rx_packet\nnot out-of-bounds access the skb->data buffer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53229",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mac80211: fix invalid drv_sta_pre_rcu_remove calls for non-uploaded sta",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix invalid drv_sta_pre_rcu_remove calls for non-uploaded sta\n\nAvoid potential data corruption issues caused by uninitialized driver\nprivate data structures.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53254",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cacheinfo: Fix shared_cpu_map to handle shared caches at different levels",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncacheinfo: Fix shared_cpu_map to handle shared caches at different levels\n\nThe cacheinfo sets up the shared_cpu_map by checking whether the caches\nwith the same index are shared between CPUs. However, this will trigger\nslab-out-of-bounds access if the CPUs do not have the same cache hierarchy.\nAnother problem is the mismatched shared_cpu_map when the shared cache does\nnot have the same index between CPUs.\n\nCPU0\tI\tD\tL3\nindex\t0\t1\t2\tx\n\t^\t^\t^\t^\nindex\t0\t1\t2\t3\nCPU1\tI\tD\tL2\tL3\n\nThis patch checks each cache is shared with all caches on other CPUs.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53257",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mac80211: check S1G action frame size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: check S1G action frame size\n\nBefore checking the action code, check that it even\nexists in the frame.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53259",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: VMCI: check context->notify_page after call to get_user_pages_fast() to avoid GPF",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nVMCI: check context->notify_page after call to get_user_pages_fast() to avoid GPF\n\nThe call to get_user_pages_fast() in vmci_host_setup_notify() can return\nNULL context->notify_page causing a GPF. To avoid GPF check if\ncontext->notify_page == NULL and return error if so.\n\ngeneral protection fault, probably for non-canonical address\n    0xe0009d1000000060: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: maybe wild-memory-access in range [0x0005088000000300-\n    0x0005088000000307]\nCPU: 2 PID: 26180 Comm: repro_34802241 Not tainted 6.1.0-rc4 #1\nHardware name: Red Hat KVM, BIOS 1.15.0-2.module+el8.6.0 04/01/2014\nRIP: 0010:vmci_ctx_check_signal_notify+0x91/0xe0\nCall Trace:\n <TASK>\n vmci_host_unlocked_ioctl+0x362/0x1f40\n __x64_sys_ioctl+0x1a1/0x230\n do_syscall_64+0x3a/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53295",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: udf: Do not update file length for failed writes to inline files",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Do not update file length for failed writes to inline files\n\nWhen write to inline file fails (or happens only partly), we still\nupdated length of inline data as if the whole write succeeded. Fix the\nupdate of length of inline data to happen only if the write succeeds.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53297",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: fix \"bad unlock balance\" in l2cap_disconnect_rsp",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: fix \"bad unlock balance\" in l2cap_disconnect_rsp\n\nconn->chan_lock isn't acquired before l2cap_get_chan_by_scid,\nif l2cap_get_chan_by_scid returns NULL, then 'bad unlock balance'\nis triggered.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53305",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix use-after-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix use-after-free\n\nFix potential use-after-free in l2cap_le_command_rej.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53322",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: qla2xxx: Wait for io return on terminate rport",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Wait for io return on terminate rport\n\nSystem crash due to use after free.\nCurrent code allows terminate_rport_io to exit before making\nsure all IOs has returned. For FCP-2 device, IO's can hang\non in HW because driver has not tear down the session in FW at\nfirst sign of cable pull. When dev_loss_tmo timer pops,\nterminate_rport_io is called and upper layer is about to\nfree various resources. Terminate_rport_io trigger qla to do\nthe final cleanup, but the cleanup might not be fast enough where it\nleave qla still holding on to the same resource.\n\nWait for IO's to return to upper layer before resources are freed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53331",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pstore/ram: Check start of empty przs during init",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npstore/ram: Check start of empty przs during init\n\nAfter commit 30696378f68a (\"pstore/ram: Do not treat empty buffers as\nvalid\"), initialization would assume a prz was valid after seeing that\nthe buffer_size is zero (regardless of the buffer start position). This\nunchecked start value means it could be outside the bounds of the buffer,\nleading to future access panics when written to:\n\n sysdump_panic_event+0x3b4/0x5b8\n atomic_notifier_call_chain+0x54/0x90\n panic+0x1c8/0x42c\n die+0x29c/0x2a8\n die_kernel_fault+0x68/0x78\n __do_kernel_fault+0x1c4/0x1e0\n do_bad_area+0x40/0x100\n do_translation_fault+0x68/0x80\n do_mem_abort+0x68/0xf8\n el1_da+0x1c/0xc0\n __raw_writeb+0x38/0x174\n __memcpy_toio+0x40/0xac\n persistent_ram_update+0x44/0x12c\n persistent_ram_write+0x1a8/0x1b8\n ramoops_pstore_write+0x198/0x1e8\n pstore_console_write+0x94/0xe0\n ...\n\nTo avoid this, also check if the prz start is 0 during the initialization\nphase. If not, the next prz sanity check case will discover it (start >\nsize) and zap the buffer back to a sane state.\n\n[kees: update commit log with backtrace and clarifications]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53354",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: skbuff: skb_segment, Call zero copy functions before using skbuff frags",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nskbuff: skb_segment, Call zero copy functions before using skbuff frags\n\nCommit bf5c25d60861 (\"skbuff: in skb_segment, call zerocopy functions\nonce per nskb\") added the call to zero copy functions in skb_segment().\nThe change introduced a bug in skb_segment() because skb_orphan_frags()\nmay possibly change the number of fragments or allocate new fragments\naltogether leaving nrfrags and frag to point to the old values. This can\ncause a panic with stacktrace like the one below.\n\n[  193.894380] BUG: kernel NULL pointer dereference, address: 00000000000000bc\n[  193.895273] CPU: 13 PID: 18164 Comm: vh-net-17428 Kdump: loaded Tainted: G           O      5.15.123+ #26\n[  193.903919] RIP: 0010:skb_segment+0xb0e/0x12f0\n[  194.021892] Call Trace:\n[  194.027422]  <TASK>\n[  194.072861]  tcp_gso_segment+0x107/0x540\n[  194.082031]  inet_gso_segment+0x15c/0x3d0\n[  194.090783]  skb_mac_gso_segment+0x9f/0x110\n[  194.095016]  __skb_gso_segment+0xc1/0x190\n[  194.103131]  netem_enqueue+0x290/0xb10 [sch_netem]\n[  194.107071]  dev_qdisc_enqueue+0x16/0x70\n[  194.110884]  __dev_queue_xmit+0x63b/0xb30\n[  194.121670]  bond_start_xmit+0x159/0x380 [bonding]\n[  194.128506]  dev_hard_start_xmit+0xc3/0x1e0\n[  194.131787]  __dev_queue_xmit+0x8a0/0xb30\n[  194.138225]  macvlan_start_xmit+0x4f/0x100 [macvlan]\n[  194.141477]  dev_hard_start_xmit+0xc3/0x1e0\n[  194.144622]  sch_direct_xmit+0xe3/0x280\n[  194.147748]  __dev_queue_xmit+0x54a/0xb30\n[  194.154131]  tap_get_user+0x2a8/0x9c0 [tap]\n[  194.157358]  tap_sendmsg+0x52/0x8e0 [tap]\n[  194.167049]  handle_tx_zerocopy+0x14e/0x4c0 [vhost_net]\n[  194.173631]  handle_tx+0xcd/0xe0 [vhost_net]\n[  194.176959]  vhost_worker+0x76/0xb0 [vhost]\n[  194.183667]  kthread+0x118/0x140\n[  194.190358]  ret_from_fork+0x1f/0x30\n[  194.193670]  </TASK>\n\nIn this case calling skb_orphan_frags() updated nr_frags leaving nrfrags\nlocal variable in skb_segment() stale. This resulted in the code hitting\ni >= nrfrags prematurely and trying to move to next frag_skb using\nlist_skb pointer, which was NULL, and caused kernel panic. Move the call\nto zero copy functions before using frags and nr_frags.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53363",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: PCI: Fix use-after-free in pci_bus_release_domain_nr()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: Fix use-after-free in pci_bus_release_domain_nr()\n\nCommit c14f7ccc9f5d (\"PCI: Assign PCI domain IDs by ida_alloc()\")\nintroduced a use-after-free bug in the bus removal cleanup. The issue was\nfound with kfence:\n\n  [   19.293351] BUG: KFENCE: use-after-free read in pci_bus_release_domain_nr+0x10/0x70\n\n  [   19.302817] Use-after-free read at 0x000000007f3b80eb (in kfence-#115):\n  [   19.309677]  pci_bus_release_domain_nr+0x10/0x70\n  [   19.309691]  dw_pcie_host_deinit+0x28/0x78\n  [   19.309702]  tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194]\n  [   19.309734]  tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194]\n  [   19.309752]  platform_probe+0x90/0xd8\n  ...\n\n  [   19.311457] kfence-#115: 0x00000000063a155a-0x00000000ba698da8, size=1072, cache=kmalloc-2k\n\n  [   19.311469] allocated by task 96 on cpu 10 at 19.279323s:\n  [   19.311562]  __kmem_cache_alloc_node+0x260/0x278\n  [   19.311571]  kmalloc_trace+0x24/0x30\n  [   19.311580]  pci_alloc_bus+0x24/0xa0\n  [   19.311590]  pci_register_host_bridge+0x48/0x4b8\n  [   19.311601]  pci_scan_root_bus_bridge+0xc0/0xe8\n  [   19.311613]  pci_host_probe+0x18/0xc0\n  [   19.311623]  dw_pcie_host_init+0x2c0/0x568\n  [   19.311630]  tegra_pcie_dw_probe+0x610/0xb28 [pcie_tegra194]\n  [   19.311647]  platform_probe+0x90/0xd8\n  ...\n\n  [   19.311782] freed by task 96 on cpu 10 at 19.285833s:\n  [   19.311799]  release_pcibus_dev+0x30/0x40\n  [   19.311808]  device_release+0x30/0x90\n  [   19.311814]  kobject_put+0xa8/0x120\n  [   19.311832]  device_unregister+0x20/0x30\n  [   19.311839]  pci_remove_bus+0x78/0x88\n  [   19.311850]  pci_remove_root_bus+0x5c/0x98\n  [   19.311860]  dw_pcie_host_deinit+0x28/0x78\n  [   19.311866]  tegra_pcie_deinit_controller+0x1c/0x38 [pcie_tegra194]\n  [   19.311883]  tegra_pcie_dw_probe+0x648/0xb28 [pcie_tegra194]\n  [   19.311900]  platform_probe+0x90/0xd8\n  ...\n\n  [   19.313579] CPU: 10 PID: 96 Comm: kworker/u24:2 Not tainted 6.2.0 #4\n  [   19.320171] Hardware name:  /, BIOS 1.0-d7fb19b 08/10/2022\n  [   19.325852] Workqueue: events_unbound deferred_probe_work_func\n\nThe stack trace is a bit misleading as dw_pcie_host_deinit() doesn't\ndirectly call pci_bus_release_domain_nr(). The issue turns out to be in\npci_remove_root_bus() which first calls pci_remove_bus() which frees the\nstruct pci_bus when its struct device is released. Then\npci_bus_release_domain_nr() is called and accesses the freed struct\npci_bus. Reordering these fixes the issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53365",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ip6mr: Fix skb_under_panic in ip6mr_cache_report()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nip6mr: Fix skb_under_panic in ip6mr_cache_report()\n\nskbuff: skb_under_panic: text:ffffffff88771f69 len:56 put:-4\n head:ffff88805f86a800 data:ffff887f5f86a850 tail:0x88 end:0x2c0 dev:pim6reg\n ------------[ cut here ]------------\n kernel BUG at net/core/skbuff.c:192!\n invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n CPU: 2 PID: 22968 Comm: kworker/2:11 Not tainted 6.5.0-rc3-00044-g0a8db05b571a #236\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n Workqueue: ipv6_addrconf addrconf_dad_work\n RIP: 0010:skb_panic+0x152/0x1d0\n Call Trace:\n  <TASK>\n  skb_push+0xc4/0xe0\n  ip6mr_cache_report+0xd69/0x19b0\n  reg_vif_xmit+0x406/0x690\n  dev_hard_start_xmit+0x17e/0x6e0\n  __dev_queue_xmit+0x2d6a/0x3d20\n  vlan_dev_hard_start_xmit+0x3ab/0x5c0\n  dev_hard_start_xmit+0x17e/0x6e0\n  __dev_queue_xmit+0x2d6a/0x3d20\n  neigh_connected_output+0x3ed/0x570\n  ip6_finish_output2+0x5b5/0x1950\n  ip6_finish_output+0x693/0x11c0\n  ip6_output+0x24b/0x880\n  NF_HOOK.constprop.0+0xfd/0x530\n  ndisc_send_skb+0x9db/0x1400\n  ndisc_send_rs+0x12a/0x6c0\n  addrconf_dad_completed+0x3c9/0xea0\n  addrconf_dad_work+0x849/0x1420\n  process_one_work+0xa22/0x16e0\n  worker_thread+0x679/0x10c0\n  ret_from_fork+0x28/0x60\n  ret_from_fork_asm+0x11/0x20\n\nWhen setup a vlan device on dev pim6reg, DAD ns packet may sent on reg_vif_xmit().\nreg_vif_xmit()\n    ip6mr_cache_report()\n        skb_push(skb, -skb_network_offset(pkt));//skb_network_offset(pkt) is 4\nAnd skb_push declared as:\n\tvoid *skb_push(struct sk_buff *skb, unsigned int len);\n\t\tskb->data -= len;\n\t\t//0xffff88805f86a84c - 0xfffffffc = 0xffff887f5f86a850\nskb->data is set to 0xffff887f5f86a850, which is invalid mem addr, lead to skb_push() fails.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53373",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: seqiv - Handle EBUSY correctly",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: seqiv - Handle EBUSY correctly\n\nAs it is seqiv only handles the special return value of EINPROGERSS,\nwhich means that in all other cases it will free data related to the\nrequest.\n\nHowever, as the caller of seqiv may specify MAY_BACKLOG, we also need\nto expect EBUSY and treat it in the same way.  Otherwise backlogged\nrequests will trigger a use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53386",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: Fix potential use-after-free when clear keys",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix potential use-after-free when clear keys\n\nSimilar to commit c5d2b6fa26b5 (\"Bluetooth: Fix use-after-free in\nhci_remove_ltk/hci_remove_irk\"). We can not access k after kfree_rcu()\ncall.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53401",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm: kmem: fix a NULL pointer dereference in obj_stock_flush_required()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: kmem: fix a NULL pointer dereference in obj_stock_flush_required()\n\nKCSAN found an issue in obj_stock_flush_required():\nstock->cached_objcg can be reset between the check and dereference:\n\n==================================================================\nBUG: KCSAN: data-race in drain_all_stock / drain_obj_stock\n\nwrite to 0xffff888237c2a2f8 of 8 bytes by task 19625 on cpu 0:\n drain_obj_stock+0x408/0x4e0 mm/memcontrol.c:3306\n refill_obj_stock+0x9c/0x1e0 mm/memcontrol.c:3340\n obj_cgroup_uncharge+0xe/0x10 mm/memcontrol.c:3408\n memcg_slab_free_hook mm/slab.h:587 [inline]\n __cache_free mm/slab.c:3373 [inline]\n __do_kmem_cache_free mm/slab.c:3577 [inline]\n kmem_cache_free+0x105/0x280 mm/slab.c:3602\n __d_free fs/dcache.c:298 [inline]\n dentry_free fs/dcache.c:375 [inline]\n __dentry_kill+0x422/0x4a0 fs/dcache.c:621\n dentry_kill+0x8d/0x1e0\n dput+0x118/0x1f0 fs/dcache.c:913\n __fput+0x3bf/0x570 fs/file_table.c:329\n ____fput+0x15/0x20 fs/file_table.c:349\n task_work_run+0x123/0x160 kernel/task_work.c:179\n resume_user_mode_work include/linux/resume_user_mode.h:49 [inline]\n exit_to_user_mode_loop+0xcf/0xe0 kernel/entry/common.c:171\n exit_to_user_mode_prepare+0x6a/0xa0 kernel/entry/common.c:203\n __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]\n syscall_exit_to_user_mode+0x26/0x140 kernel/entry/common.c:296\n do_syscall_64+0x4d/0xc0 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nread to 0xffff888237c2a2f8 of 8 bytes by task 19632 on cpu 1:\n obj_stock_flush_required mm/memcontrol.c:3319 [inline]\n drain_all_stock+0x174/0x2a0 mm/memcontrol.c:2361\n try_charge_memcg+0x6d0/0xd10 mm/memcontrol.c:2703\n try_charge mm/memcontrol.c:2837 [inline]\n mem_cgroup_charge_skmem+0x51/0x140 mm/memcontrol.c:7290\n sock_reserve_memory+0xb1/0x390 net/core/sock.c:1025\n sk_setsockopt+0x800/0x1e70 net/core/sock.c:1525\n udp_lib_setsockopt+0x99/0x6c0 net/ipv4/udp.c:2692\n udp_setsockopt+0x73/0xa0 net/ipv4/udp.c:2817\n sock_common_setsockopt+0x61/0x70 net/core/sock.c:3668\n __sys_setsockopt+0x1c3/0x230 net/socket.c:2271\n __do_sys_setsockopt net/socket.c:2282 [inline]\n __se_sys_setsockopt net/socket.c:2279 [inline]\n __x64_sys_setsockopt+0x66/0x80 net/socket.c:2279\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nvalue changed: 0xffff8881382d52c0 -> 0xffff888138893740\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 1 PID: 19632 Comm: syz-executor.0 Not tainted 6.3.0-rc2-syzkaller-00387-g534293368afa #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/02/2023\n\nFix it by using READ_ONCE()/WRITE_ONCE() for all accesses to\nstock->cached_objcg.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53458",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: cx23885: Fix a null-ptr-deref bug in buffer_prepare() and buffer_finish()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: cx23885: Fix a null-ptr-deref bug in buffer_prepare() and buffer_finish()\n\nWhen the driver calls cx23885_risc_buffer() to prepare the buffer, the\nfunction call dma_alloc_coherent may fail, resulting in a empty buffer\nrisc->cpu. Later when we free the buffer or access the buffer, null ptr\nderef is triggered.\n\nThis bug is similar to the following one:\nhttps://git.linuxtv.org/media_stage.git/commit/?id=2b064d91440b33fba5b452f2d1b31f13ae911d71.\n\nWe believe the bug can be also dynamically triggered from user side.\nSimilarly, we fix this by checking the return value of cx23885_risc_buffer()\nand the value of risc->cpu before buffer free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53480",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: kobject: Add sanity check for kset->kobj.ktype in kset_register()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkobject: Add sanity check for kset->kobj.ktype in kset_register()\n\nWhen I register a kset in the following way:\n\tstatic struct kset my_kset;\n\tkobject_set_name(&my_kset.kobj, \"my_kset\");\n        ret = kset_register(&my_kset);\n\nA null pointer dereference exception is occurred:\n[ 4453.568337] Unable to handle kernel NULL pointer dereference at \\\nvirtual address 0000000000000028\n... ...\n[ 4453.810361] Call trace:\n[ 4453.813062]  kobject_get_ownership+0xc/0x34\n[ 4453.817493]  kobject_add_internal+0x98/0x274\n[ 4453.822005]  kset_register+0x5c/0xb4\n[ 4453.825820]  my_kobj_init+0x44/0x1000 [my_kset]\n... ...\n\nBecause I didn't initialize my_kset.kobj.ktype.\n\nAccording to the description in Documentation/core-api/kobject.rst:\n - A ktype is the type of object that embeds a kobject.  Every structure\n   that embeds a kobject needs a corresponding ktype.\n\nSo add sanity check to make sure kset->kobj.ktype is not NULL.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53487",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: powerpc/rtas_flash: allow user copy to flash block cache objects",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/rtas_flash: allow user copy to flash block cache objects\n\nWith hardened usercopy enabled (CONFIG_HARDENED_USERCOPY=y), using the\n/proc/powerpc/rtas/firmware_update interface to prepare a system\nfirmware update yields a BUG():\n\n  kernel BUG at mm/usercopy.c:102!\n  Oops: Exception in kernel mode, sig: 5 [#1]\n  LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries\n  Modules linked in:\n  CPU: 0 PID: 2232 Comm: dd Not tainted 6.5.0-rc3+ #2\n  Hardware name: IBM,8408-E8E POWER8E (raw) 0x4b0201 0xf000004 of:IBM,FW860.50 (SV860_146) hv:phyp pSeries\n  NIP:  c0000000005991d0 LR: c0000000005991cc CTR: 0000000000000000\n  REGS: c0000000148c76a0 TRAP: 0700   Not tainted  (6.5.0-rc3+)\n  MSR:  8000000000029033 <SF,EE,ME,IR,DR,RI,LE>  CR: 24002242  XER: 0000000c\n  CFAR: c0000000001fbd34 IRQMASK: 0\n  [ ... GPRs omitted ... ]\n  NIP usercopy_abort+0xa0/0xb0\n  LR  usercopy_abort+0x9c/0xb0\n  Call Trace:\n    usercopy_abort+0x9c/0xb0 (unreliable)\n    __check_heap_object+0x1b4/0x1d0\n    __check_object_size+0x2d0/0x380\n    rtas_flash_write+0xe4/0x250\n    proc_reg_write+0xfc/0x160\n    vfs_write+0xfc/0x4e0\n    ksys_write+0x90/0x160\n    system_call_exception+0x178/0x320\n    system_call_common+0x160/0x2c4\n\nThe blocks of the firmware image are copied directly from user memory\nto objects allocated from flash_block_cache, so flash_block_cache must\nbe created using kmem_cache_create_usercopy() to mark it safe for user\naccess.\n\n[mpe: Trim and indent oops]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53491",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: start_kernel: Add __no_stack_protector function attribute",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nstart_kernel: Add __no_stack_protector function attribute\n\nBack during the discussion of\ncommit a9a3ed1eff36 (\"x86: Fix early boot crash on gcc-10, third try\")\nwe discussed the need for a function attribute to control the omission\nof stack protectors on a per-function basis; at the time Clang had\nsupport for no_stack_protector but GCC did not. This was fixed in\ngcc-11. Now that the function attribute is available, let's start using\nit.\n\nCallers of boot_init_stack_canary need to use this function attribute\nunless they're compiled with -fno-stack-protector, otherwise the canary\nstored in the stack slot of the caller will differ upon the call to\nboot_init_stack_canary. This will lead to a call to __stack_chk_fail()\nthen panic.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53494",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: xts - Handle EBUSY correctly",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: xts - Handle EBUSY correctly\n\nAs it is xts only handles the special return value of EINPROGRESS,\nwhich means that in all other cases it will free data related to the\nrequest.\n\nHowever, as the caller of xts may specify MAY_BACKLOG, we also need\nto expect EBUSY and treat it in the same way.  Otherwise backlogged\nrequests will trigger a use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53499",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: virtio_net: Fix error unwinding of XDP initialization",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_net: Fix error unwinding of XDP initialization\n\nWhen initializing XDP in virtnet_open(), some rq xdp initialization\nmay hit an error causing net device open failed. However, previous\nrqs have already initialized XDP and enabled NAPI, which is not the\nexpected behavior. Need to roll back the previous rq initialization\nto avoid leaks in error unwinding of init code.\n\nAlso extract helper functions of disable and enable queue pairs.\nUse newly introduced disable helper function in error unwinding and\nvirtnet_close. Use enable helper function in virtnet_open.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53510",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: ufs: core: Fix handling of lrbp->cmd",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ufs: core: Fix handling of lrbp->cmd\n\nufshcd_queuecommand() may be called two times in a row for a SCSI command\nbefore it is completed. Hence make the following changes:\n\n - In the functions that submit a command, do not check the old value of\n   lrbp->cmd nor clear lrbp->cmd in error paths.\n\n - In ufshcd_release_scsi_cmd(), do not clear lrbp->cmd.\n\nSee also scsi_send_eh_cmnd().\n\nThis commit prevents that the following appears if a command times out:\n\nWARNING: at drivers/ufs/core/ufshcd.c:2965 ufshcd_queuecommand+0x6f8/0x9a8\nCall trace:\n ufshcd_queuecommand+0x6f8/0x9a8\n scsi_send_eh_cmnd+0x2c0/0x960\n scsi_eh_test_devices+0x100/0x314\n scsi_eh_ready_devs+0xd90/0x114c\n scsi_error_handler+0x2b4/0xb70\n kthread+0x16c/0x1e0",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53513",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nbd: fix incomplete validation of ioctl arg",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: fix incomplete validation of ioctl arg\n\nWe tested and found an alarm caused by nbd_ioctl arg without verification.\nThe UBSAN warning calltrace like below:\n\nUBSAN: Undefined behaviour in fs/buffer.c:1709:35\nsigned integer overflow:\n-9223372036854775808 - 1 cannot be represented in type 'long long int'\nCPU: 3 PID: 2523 Comm: syz-executor.0 Not tainted 4.19.90 #1\nHardware name: linux,dummy-virt (DT)\nCall trace:\n dump_backtrace+0x0/0x3f0 arch/arm64/kernel/time.c:78\n show_stack+0x28/0x38 arch/arm64/kernel/traps.c:158\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x170/0x1dc lib/dump_stack.c:118\n ubsan_epilogue+0x18/0xb4 lib/ubsan.c:161\n handle_overflow+0x188/0x1dc lib/ubsan.c:192\n __ubsan_handle_sub_overflow+0x34/0x44 lib/ubsan.c:206\n __block_write_full_page+0x94c/0xa20 fs/buffer.c:1709\n block_write_full_page+0x1f0/0x280 fs/buffer.c:2934\n blkdev_writepage+0x34/0x40 fs/block_dev.c:607\n __writepage+0x68/0xe8 mm/page-writeback.c:2305\n write_cache_pages+0x44c/0xc70 mm/page-writeback.c:2240\n generic_writepages+0xdc/0x148 mm/page-writeback.c:2329\n blkdev_writepages+0x2c/0x38 fs/block_dev.c:2114\n do_writepages+0xd4/0x250 mm/page-writeback.c:2344\n\nThe reason for triggering this warning is __block_write_full_page()\n-> i_size_read(inode) - 1 overflow.\ninode->i_size is assigned in __nbd_ioctl() -> nbd_set_size() -> bytesize.\nWe think it is necessary to limit the size of arg to prevent errors.\n\nMoreover, __nbd_ioctl() -> nbd_add_socket(), arg will be cast to int.\nAssuming the value of arg is 0x80000000000000001) (on a 64-bit machine),\nit will become 1 after the coercion, which will return unexpected results.\n\nFix it by adding checks to prevent passing in too large numbers.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53519",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: v4l2-mem2mem: add lock to protect parameter num_rdy",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-mem2mem: add lock to protect parameter num_rdy\n\nGetting below error when using KCSAN to check the driver. Adding lock to\nprotect parameter num_rdy when getting the value with function:\nv4l2_m2m_num_src_bufs_ready/v4l2_m2m_num_dst_bufs_ready.\n\nkworker/u16:3: [name:report&]BUG: KCSAN: data-race in v4l2_m2m_buf_queue\nkworker/u16:3: [name:report&]\n\nkworker/u16:3: [name:report&]read-write to 0xffffff8105f35b94 of 1 bytes by task 20865 on cpu 7:\nkworker/u16:3:\u00a0 v4l2_m2m_buf_queue+0xd8/0x10c",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53530",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: qla2xxx: Use raw_smp_processor_id() instead of smp_processor_id()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Use raw_smp_processor_id() instead of smp_processor_id()\n\nThe following call trace was observed:\n\nlocalhost kernel: nvme nvme0: NVME-FC{0}: controller connect complete\nlocalhost kernel: BUG: using smp_processor_id() in preemptible [00000000] code: kworker/u129:4/75092\nlocalhost kernel: nvme nvme0: NVME-FC{0}: new ctrl: NQN \"nqn.1992-08.com.netapp:sn.b42d198afb4d11ecad6d00a098d6abfa:subsystem.PR_Channel2022_RH84_subsystem_291\"\nlocalhost kernel: caller is qla_nvme_post_cmd+0x216/0x1380 [qla2xxx]\nlocalhost kernel: CPU: 6 PID: 75092 Comm: kworker/u129:4 Kdump: loaded Tainted: G    B   W  OE    --------- ---  5.14.0-70.22.1.el9_0.x86_64+debug #1\nlocalhost kernel: Hardware name: HPE ProLiant XL420 Gen10/ProLiant XL420 Gen10, BIOS U39 01/13/2022\nlocalhost kernel: Workqueue: nvme-wq nvme_async_event_work [nvme_core]\nlocalhost kernel: Call Trace:\nlocalhost kernel: dump_stack_lvl+0x57/0x7d\nlocalhost kernel: check_preemption_disabled+0xc8/0xd0\nlocalhost kernel: qla_nvme_post_cmd+0x216/0x1380 [qla2xxx]\n\nUse raw_smp_processor_id() instead of smp_processor_id().\n\nAlso use queue_work() across the driver instead of queue_work_on() thus\navoiding usage of smp_processor_id() when CONFIG_DEBUG_PREEMPT is enabled.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53536",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: blk-crypto: make blk_crypto_evict_key() more robust",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-crypto: make blk_crypto_evict_key() more robust\n\nIf blk_crypto_evict_key() sees that the key is still in-use (due to a\nbug) or that ->keyslot_evict failed, it currently just returns while\nleaving the key linked into the keyslot management structures.\n\nHowever, blk_crypto_evict_key() is only called in contexts such as inode\neviction where failure is not an option.  So actually the caller\nproceeds with freeing the blk_crypto_key regardless of the return value\nof blk_crypto_evict_key().\n\nThese two assumptions don't match, and the result is that there can be a\nuse-after-free in blk_crypto_reprogram_all_keys() after one of these\nerrors occurs.  (Note, these errors *shouldn't* happen; we're just\ntalking about what happens if they do anyway.)\n\nFix this by making blk_crypto_evict_key() unlink the key from the\nkeyslot management structures even on failure.\n\nAlso improve some comments.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53539",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/rxe: Fix incomplete state save in rxe_requester",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix incomplete state save in rxe_requester\n\nIf a send packet is dropped by the IP layer in rxe_requester()\nthe call to rxe_xmit_packet() can fail with err == -EAGAIN.\nTo recover, the state of the wqe is restored to the state before\nthe packet was sent so it can be resent. However, the routines\nthat save and restore the state miss a significnt part of the\nvariable state in the wqe, the dma struct which is used to process\nthrough the sge table. And, the state is not saved before the packet\nis built which modifies the dma struct.\n\nUnder heavy stress testing with many QPs on a fast node sending\nlarge messages to a slow node dropped packets are observed and\nthe resent packets are corrupted because the dma struct was not\nrestored. This patch fixes this behavior and allows the test cases\nto succeed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53544",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cpufreq: davinci: Fix clk use after free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: davinci: Fix clk use after free\n\nThe remove function first frees the clks and only then calls\ncpufreq_unregister_driver(). If one of the cpufreq callbacks is called\njust before cpufreq_unregister_driver() is run, the freed clks might be\nused.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53581",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5e: Check for NOT_READY flag state after locking",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Check for NOT_READY flag state after locking\n\nCurrently the check for NOT_READY flag is performed before obtaining the\nnecessary lock. This opens a possibility for race condition when the flow\nis concurrently removed from unready_flows list by the workqueue task,\nwhich causes a double-removal from the list and a crash[0]. Fix the issue\nby moving the flag check inside the section protected by\nuplink_priv->unready_flows_lock mutex.\n\n[0]:\n[44376.389654] general protection fault, probably for non-canonical address 0xdead000000000108: 0000 [#1] SMP\n[44376.391665] CPU: 7 PID: 59123 Comm: tc Not tainted 6.4.0-rc4+ #1\n[44376.392984] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[44376.395342] RIP: 0010:mlx5e_tc_del_fdb_flow+0xb3/0x340 [mlx5_core]\n[44376.396857] Code: 00 48 8b b8 68 ce 02 00 e8 8a 4d 02 00 4c 8d a8 a8 01 00 00 4c 89 ef e8 8b 79 88 e1 48 8b 83 98 06 00 00 48 8b 93 90 06 00 00 <48> 89 42 08 48 89 10 48 b8 00 01 00 00 00 00 ad de 48 89 83 90 06\n[44376.399167] RSP: 0018:ffff88812cc97570 EFLAGS: 00010246\n[44376.399680] RAX: dead000000000122 RBX: ffff8881088e3800 RCX: ffff8881881bac00\n[44376.400337] RDX: dead000000000100 RSI: ffff88812cc97500 RDI: ffff8881242f71b0\n[44376.401001] RBP: ffff88811cbb0940 R08: 0000000000000400 R09: 0000000000000001\n[44376.401663] R10: 0000000000000001 R11: 0000000000000000 R12: ffff88812c944000\n[44376.402342] R13: ffff8881242f71a8 R14: ffff8881222b4000 R15: 0000000000000000\n[44376.402999] FS:  00007f0451104800(0000) GS:ffff88852cb80000(0000) knlGS:0000000000000000\n[44376.403787] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[44376.404343] CR2: 0000000000489108 CR3: 0000000123a79003 CR4: 0000000000370ea0\n[44376.405004] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[44376.405665] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[44376.406339] Call Trace:\n[44376.406651]  <TASK>\n[44376.406939]  ? die_addr+0x33/0x90\n[44376.407311]  ? exc_general_protection+0x192/0x390\n[44376.407795]  ? asm_exc_general_protection+0x22/0x30\n[44376.408292]  ? mlx5e_tc_del_fdb_flow+0xb3/0x340 [mlx5_core]\n[44376.408876]  __mlx5e_tc_del_fdb_peer_flow+0xbc/0xe0 [mlx5_core]\n[44376.409482]  mlx5e_tc_del_flow+0x42/0x210 [mlx5_core]\n[44376.410055]  mlx5e_flow_put+0x25/0x50 [mlx5_core]\n[44376.410529]  mlx5e_delete_flower+0x24b/0x350 [mlx5_core]\n[44376.411043]  tc_setup_cb_reoffload+0x22/0x80\n[44376.411462]  fl_reoffload+0x261/0x2f0 [cls_flower]\n[44376.411907]  ? mlx5e_rep_indr_setup_ft_cb+0x160/0x160 [mlx5_core]\n[44376.412481]  ? mlx5e_rep_indr_setup_ft_cb+0x160/0x160 [mlx5_core]\n[44376.413044]  tcf_block_playback_offloads+0x76/0x170\n[44376.413497]  tcf_block_unbind+0x7b/0xd0\n[44376.413881]  tcf_block_setup+0x17d/0x1c0\n[44376.414269]  tcf_block_offload_cmd.isra.0+0xf1/0x130\n[44376.414725]  tcf_block_offload_unbind+0x43/0x70\n[44376.415153]  __tcf_block_put+0x82/0x150\n[44376.415532]  ingress_destroy+0x22/0x30 [sch_ingress]\n[44376.415986]  qdisc_destroy+0x3b/0xd0\n[44376.416343]  qdisc_graft+0x4d0/0x620\n[44376.416706]  tc_get_qdisc+0x1c9/0x3b0\n[44376.417074]  rtnetlink_rcv_msg+0x29c/0x390\n[44376.419978]  ? rep_movs_alternative+0x3a/0xa0\n[44376.420399]  ? rtnl_calcit.isra.0+0x120/0x120\n[44376.420813]  netlink_rcv_skb+0x54/0x100\n[44376.421192]  netlink_unicast+0x1f6/0x2c0\n[44376.421573]  netlink_sendmsg+0x232/0x4a0\n[44376.421980]  sock_sendmsg+0x38/0x60\n[44376.422328]  ____sys_sendmsg+0x1d0/0x1e0\n[44376.422709]  ? copy_msghdr_from_user+0x6d/0xa0\n[44376.423127]  ___sys_sendmsg+0x80/0xc0\n[44376.423495]  ? ___sys_recvmsg+0x8b/0xc0\n[44376.423869]  __sys_sendmsg+0x51/0x90\n[44376.424226]  do_syscall_64+0x3d/0x90\n[44376.424587]  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n[44376.425046] RIP: 0033:0x7f045134f887\n[44376.425403] Code: 0a 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b9 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2e 00\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53600",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tunnels: fix kasan splat when generating ipv4 pmtu error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntunnels: fix kasan splat when generating ipv4 pmtu error\n\nIf we try to emit an icmp error in response to a nonliner skb, we get\n\nBUG: KASAN: slab-out-of-bounds in ip_compute_csum+0x134/0x220\nRead of size 4 at addr ffff88811c50db00 by task iperf3/1691\nCPU: 2 PID: 1691 Comm: iperf3 Not tainted 6.5.0-rc3+ #309\n[..]\n kasan_report+0x105/0x140\n ip_compute_csum+0x134/0x220\n iptunnel_pmtud_build_icmp+0x554/0x1020\n skb_tunnel_check_pmtu+0x513/0xb80\n vxlan_xmit_one+0x139e/0x2ef0\n vxlan_xmit+0x1867/0x2760\n dev_hard_start_xmit+0x1ee/0x4f0\n br_dev_queue_push_xmit+0x4d1/0x660\n [..]\n\nip_compute_csum() cannot deal with nonlinear skbs, so avoid it.\nAfter this change, splat is gone and iperf3 is no longer stuck.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53627",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: hisi_sas: Grab sas_dev lock when traversing the members of sas_dev.list",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: hisi_sas: Grab sas_dev lock when traversing the members of sas_dev.list\n\nWhen freeing slots in function slot_complete_v3_hw(), it is possible that\nsas_dev.list is being traversed elsewhere, and it may trigger a NULL\npointer exception, such as follows:\n\n==>cq thread                    ==>scsi_eh_6\n\n                                ==>scsi_error_handler()\n\t\t\t\t  ==>sas_eh_handle_sas_errors()\n\t\t\t\t    ==>sas_scsi_find_task()\n\t\t\t\t      ==>lldd_abort_task()\n==>slot_complete_v3_hw()              ==>hisi_sas_abort_task()\n  ==>hisi_sas_slot_task_free()\t        ==>dereg_device_v3_hw()\n    ==>list_del_init()        \t\t  ==>list_for_each_entry_safe()\n\n[ 7165.434918] sas: Enter sas_scsi_recover_host busy: 32 failed: 32\n[ 7165.434926] sas: trying to find task 0x00000000769b5ba5\n[ 7165.434927] sas: sas_scsi_find_task: aborting task 0x00000000769b5ba5\n[ 7165.434940] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000769b5ba5) aborted\n[ 7165.434964] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000c9f7aa07) ignored\n[ 7165.434965] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000e2a1cf01) ignored\n[ 7165.434968] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\n[ 7165.434972] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(0000000022d52d93) ignored\n[ 7165.434975] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(0000000066a7516c) ignored\n[ 7165.434976] Mem abort info:\n[ 7165.434982]   ESR = 0x96000004\n[ 7165.434991]   Exception class = DABT (current EL), IL = 32 bits\n[ 7165.434992]   SET = 0, FnV = 0\n[ 7165.434993]   EA = 0, S1PTW = 0\n[ 7165.434994] Data abort info:\n[ 7165.434994]   ISV = 0, ISS = 0x00000004\n[ 7165.434995]   CM = 0, WnR = 0\n[ 7165.434997] user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000f29543f2\n[ 7165.434998] [0000000000000000] pgd=0000000000000000\n[ 7165.435003] Internal error: Oops: 96000004 [#1] SMP\n[ 7165.439863] Process scsi_eh_6 (pid: 4109, stack limit = 0x00000000c43818d5)\n[ 7165.468862] pstate: 00c00009 (nzcv daif +PAN +UAO)\n[ 7165.473637] pc : dereg_device_v3_hw+0x68/0xa8 [hisi_sas_v3_hw]\n[ 7165.479443] lr : dereg_device_v3_hw+0x2c/0xa8 [hisi_sas_v3_hw]\n[ 7165.485247] sp : ffff00001d623bc0\n[ 7165.488546] x29: ffff00001d623bc0 x28: ffffa027d03b9508\n[ 7165.493835] x27: ffff80278ed50af0 x26: ffffa027dd31e0a8\n[ 7165.499123] x25: ffffa027d9b27f88 x24: ffffa027d9b209f8\n[ 7165.504411] x23: ffffa027c45b0d60 x22: ffff80278ec07c00\n[ 7165.509700] x21: 0000000000000008 x20: ffffa027d9b209f8\n[ 7165.514988] x19: ffffa027d9b27f88 x18: ffffffffffffffff\n[ 7165.520276] x17: 0000000000000000 x16: 0000000000000000\n[ 7165.525564] x15: ffff0000091d9708 x14: ffff0000093b7dc8\n[ 7165.530852] x13: ffff0000093b7a23 x12: 6e7265746e692067\n[ 7165.536140] x11: 0000000000000000 x10: 0000000000000bb0\n[ 7165.541429] x9 : ffff00001d6238f0 x8 : ffffa027d877af00\n[ 7165.546718] x7 : ffffa027d6329600 x6 : ffff7e809f58ca00\n[ 7165.552006] x5 : 0000000000001f8a x4 : 000000000000088e\n[ 7165.557295] x3 : ffffa027d9b27fa8 x2 : 0000000000000000\n[ 7165.562583] x1 : 0000000000000000 x0 : 000000003000188e\n[ 7165.567872] Call trace:\n[ 7165.570309]  dereg_device_v3_hw+0x68/0xa8 [hisi_sas_v3_hw]\n[ 7165.575775]  hisi_sas_abort_task+0x248/0x358 [hisi_sas_main]\n[ 7165.581415]  sas_eh_handle_sas_errors+0x258/0x8e0 [libsas]\n[ 7165.586876]  sas_scsi_recover_host+0x134/0x458 [libsas]\n[ 7165.592082]  scsi_error_handler+0xb4/0x488\n[ 7165.596163]  kthread+0x134/0x138\n[ 7165.599380]  ret_from_fork+0x10/0x18\n[ 7165.602940] Code: d5033e9f b9000040 aa0103e2 eb03003f (f9400021)\n[ 7165.609004] kernel fault(0x1) notification starting on CPU 75\n[ 7165.700728] ---[ end trace fc042cbbea224efc ]---\n[ 7165.705326] Kernel panic - not syncing: Fatal exception\n\nTo fix the issue, grab sas_dev lock when traversing the members of\nsas_dev.list in dereg_device_v3_hw() and hisi_sas_release_tasks() to avoid\nconcurrency of adding and deleting member. When \n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53639",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath6kl: reduce WARN to dev_dbg() in callback",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath6kl: reduce WARN to dev_dbg() in callback\n\nThe warn is triggered on a known race condition, documented in the code above\nthe test, that is correctly handled.  Using WARN() hinders automated testing.\nReducing severity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53640",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: lpass: Fix for KASAN use_after_free out of bounds",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: lpass: Fix for KASAN use_after_free out of bounds\n\nWhen we run syzkaller we get below Out of Bounds error.\n\n\"KASAN: slab-out-of-bounds Read in regcache_flat_read\"\n\nBelow is the backtrace of the issue:\n\nBUG: KASAN: slab-out-of-bounds in regcache_flat_read+0x10c/0x110\nRead of size 4 at addr ffffff8088fbf714 by task syz-executor.4/14144\nCPU: 6 PID: 14144 Comm: syz-executor.4 Tainted: G        W\nHardware name: Qualcomm Technologies, Inc. sc7280 CRD platform (rev5+) (DT)\nCall trace:\ndump_backtrace+0x0/0x4ec\nshow_stack+0x34/0x50\ndump_stack_lvl+0xdc/0x11c\nprint_address_description+0x30/0x2d8\nkasan_report+0x178/0x1e4\n__asan_report_load4_noabort+0x44/0x50\nregcache_flat_read+0x10c/0x110\nregcache_read+0xf8/0x5a0\n_regmap_read+0x45c/0x86c\n_regmap_update_bits+0x128/0x290\nregmap_update_bits_base+0xc0/0x15c\nsnd_soc_component_update_bits+0xa8/0x22c\nsnd_soc_component_write_field+0x68/0xd4\ntx_macro_put_dec_enum+0x1d0/0x268\nsnd_ctl_elem_write+0x288/0x474\n\nBy Error checking and checking valid values issue gets rectifies.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53648",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: ac97: Fix possible NULL dereference in snd_ac97_mixer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: ac97: Fix possible NULL dereference in snd_ac97_mixer\n\nsmatch error:\nsound/pci/ac97/ac97_codec.c:2354 snd_ac97_mixer() error:\nwe previously assumed 'rac97' could be null (see line 2072)\n\nremove redundant assignment, return error if rac97 is NULL.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53673",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: hci_event: call disconnect callback before deleting conn",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_event: call disconnect callback before deleting conn\n\nIn hci_cs_disconnect, we do hci_conn_del even if disconnection failed.\n\nISO, L2CAP and SCO connections refer to the hci_conn without\nhci_conn_get, so disconn_cfm must be called so they can clean up their\nconn, otherwise use-after-free occurs.\n\nISO:\n==========================================================\niso_sock_connect:880: sk 00000000eabd6557\niso_connect_cis:356: 70:1a:b8:98:ff:a2 -> 28:3d:c2:4a:7e:da\n...\niso_conn_add:140: hcon 000000001696f1fd conn 00000000b6251073\nhci_dev_put:1487: hci0 orig refcnt 17\n__iso_chan_add:214: conn 00000000b6251073\niso_sock_clear_timer:117: sock 00000000eabd6557 state 3\n...\nhci_rx_work:4085: hci0 Event packet\nhci_event_packet:7601: hci0: event 0x0f\nhci_cmd_status_evt:4346: hci0: opcode 0x0406\nhci_cs_disconnect:2760: hci0: status 0x0c\nhci_sent_cmd_data:3107: hci0 opcode 0x0406\nhci_conn_del:1151: hci0 hcon 000000001696f1fd handle 2560\nhci_conn_unlink:1102: hci0: hcon 000000001696f1fd\nhci_conn_drop:1451: hcon 00000000d8521aaf orig refcnt 2\nhci_chan_list_flush:2780: hcon 000000001696f1fd\nhci_dev_put:1487: hci0 orig refcnt 21\nhci_dev_put:1487: hci0 orig refcnt 20\nhci_req_cmd_complete:3978: opcode 0x0406 status 0x0c\n... <no iso_* activity on sk/conn> ...\niso_sock_sendmsg:1098: sock 00000000dea5e2e0, sk 00000000eabd6557\nBUG: kernel NULL pointer dereference, address: 0000000000000668\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP PTI\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014\nRIP: 0010:iso_sock_sendmsg (net/bluetooth/iso.c:1112) bluetooth\n==========================================================\n\nL2CAP:\n==================================================================\nhci_cmd_status_evt:4359: hci0: opcode 0x0406\nhci_cs_disconnect:2760: hci0: status 0x0c\nhci_sent_cmd_data:3085: hci0 opcode 0x0406\nhci_conn_del:1151: hci0 hcon ffff88800c999000 handle 3585\nhci_conn_unlink:1102: hci0: hcon ffff88800c999000\nhci_chan_list_flush:2780: hcon ffff88800c999000\nhci_chan_del:2761: hci0 hcon ffff88800c999000 chan ffff888018ddd280\n...\nBUG: KASAN: slab-use-after-free in hci_send_acl+0x2d/0x540 [bluetooth]\nRead of size 8 at addr ffff888018ddd298 by task bluetoothd/1175\n\nCPU: 0 PID: 1175 Comm: bluetoothd Tainted: G            E      6.4.0-rc4+ #2\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x5b/0x90\n print_report+0xcf/0x670\n ? __virt_addr_valid+0xf8/0x180\n ? hci_send_acl+0x2d/0x540 [bluetooth]\n kasan_report+0xa8/0xe0\n ? hci_send_acl+0x2d/0x540 [bluetooth]\n hci_send_acl+0x2d/0x540 [bluetooth]\n ? __pfx___lock_acquire+0x10/0x10\n l2cap_chan_send+0x1fd/0x1300 [bluetooth]\n ? l2cap_sock_sendmsg+0xf2/0x170 [bluetooth]\n ? __pfx_l2cap_chan_send+0x10/0x10 [bluetooth]\n ? lock_release+0x1d5/0x3c0\n ? mark_held_locks+0x1a/0x90\n l2cap_sock_sendmsg+0x100/0x170 [bluetooth]\n sock_write_iter+0x275/0x280\n ? __pfx_sock_write_iter+0x10/0x10\n ? __pfx___lock_acquire+0x10/0x10\n do_iter_readv_writev+0x176/0x220\n ? __pfx_do_iter_readv_writev+0x10/0x10\n ? find_held_lock+0x83/0xa0\n ? selinux_file_permission+0x13e/0x210\n do_iter_write+0xda/0x340\n vfs_writev+0x1b4/0x400\n ? __pfx_vfs_writev+0x10/0x10\n ? __seccomp_filter+0x112/0x750\n ? populate_seccomp_data+0x182/0x220\n ? __fget_light+0xdf/0x100\n ? do_writev+0x19d/0x210\n do_writev+0x19d/0x210\n ? __pfx_do_writev+0x10/0x10\n ? mark_held_locks+0x1a/0x90\n do_syscall_64+0x60/0x90\n ? lockdep_hardirqs_on_prepare+0x149/0x210\n ? do_syscall_64+0x6c/0x90\n ? lockdep_hardirqs_on_prepare+0x149/0x210\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x7ff45cb23e64\nCode: 15 d1 1f 0d 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 f3 0f 1e fa 80 3d 9d a7 0d 00 00 74 13 b8 14 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 48 83 ec 28 89 54 24 1c 48 89\nRSP: 002b:00007fff21ae09b8 EFLAGS: 00000202 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: \n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53675",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: ses: Fix possible desc_ptr out-of-bounds accesses",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Fix possible desc_ptr out-of-bounds accesses\n\nSanitize possible desc_ptr out-of-bounds accesses in\nses_enclosure_data_process().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53679",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.178-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mt7601u: fix an integer underflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt7601u: fix an integer underflow\n\nFix an integer underflow that leads to a null pointer dereference in\n'mt7601u_rx_skb_from_seg()'. The variable 'dma_len' in the URB packet\ncould be manipulated, which could trigger an integer underflow of\n'seg_len' in 'mt7601u_rx_process_seg()'. This underflow subsequently\ncauses the 'bad_frame' checks in 'mt7601u_rx_skb_from_seg()' to be\nbypassed, eventually leading to a dereference of the pointer 'p', which\nis a null pointer.\n\nEnsure that 'dma_len' is greater than 'min_seg_len'.\n\nFound by a modified version of syzkaller.\n\nKASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]\nCPU: 0 PID: 12 Comm: ksoftirqd/0 Tainted: G        W  O      5.14.0+\n#139\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nrel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\nRIP: 0010:skb_add_rx_frag+0x143/0x370\nCode: e2 07 83 c2 03 38 ca 7c 08 84 c9 0f 85 86 01 00 00 4c 8d 7d 08 44\n89 68 08 48 b8 00 00 00 00 00 fc ff df 4c 89 fa 48 c1 ea 03 <80> 3c 02\n00 0f 85 cd 01 00 00 48 8b 45 08 a8 01 0f 85 3d 01 00 00\nRSP: 0018:ffffc900000cfc90 EFLAGS: 00010202\nRAX: dffffc0000000000 RBX: ffff888115520dc0 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: ffff8881118430c0 RDI: ffff8881118430f8\nRBP: 0000000000000000 R08: 0000000000000e09 R09: 0000000000000010\nR10: ffff888111843017 R11: ffffed1022308602 R12: 0000000000000000\nR13: 0000000000000e09 R14: 0000000000000010 R15: 0000000000000008\nFS:  0000000000000000(0000) GS:ffff88811a800000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000004035af40 CR3: 00000001157f2000 CR4: 0000000000750ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n mt7601u_rx_tasklet+0xc73/0x1270\n ? mt7601u_submit_rx_buf.isra.0+0x510/0x510\n ? tasklet_action_common.isra.0+0x79/0x2f0\n tasklet_action_common.isra.0+0x206/0x2f0\n __do_softirq+0x1b5/0x880\n ? tasklet_unlock+0x30/0x30\n run_ksoftirqd+0x26/0x50\n smpboot_thread_fn+0x34f/0x7d0\n ? smpboot_register_percpu_thread+0x370/0x370\n kthread+0x3a1/0x480\n ? set_kthread_struct+0x120/0x120\n ret_from_fork+0x1f/0x30\nModules linked in: 88XXau(O) 88x2bu(O)\n---[ end trace 57f34f93b4da0f9b ]---\nRIP: 0010:skb_add_rx_frag+0x143/0x370\nCode: e2 07 83 c2 03 38 ca 7c 08 84 c9 0f 85 86 01 00 00 4c 8d 7d 08 44\n89 68 08 48 b8 00 00 00 00 00 fc ff df 4c 89 fa 48 c1 ea 03 <80> 3c 02\n00 0f 85 cd 01 00 00 48 8b 45 08 a8 01 0f 85 3d 01 00 00\nRSP: 0018:ffffc900000cfc90 EFLAGS: 00010202\nRAX: dffffc0000000000 RBX: ffff888115520dc0 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: ffff8881118430c0 RDI: ffff8881118430f8\nRBP: 0000000000000000 R08: 0000000000000e09 R09: 0000000000000010\nR10: ffff888111843017 R11: ffffed1022308602 R12: 0000000000000000\nR13: 0000000000000e09 R14: 0000000000000010 R15: 0000000000000008\nFS:  0000000000000000(0000) GS:ffff88811a800000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000004035af40 CR3: 00000001157f2000 CR4: 0000000000750ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53680",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFSD: Avoid calling OPDESC() with ops->opnum == OP_ILLEGAL",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Avoid calling OPDESC() with ops->opnum == OP_ILLEGAL\n\nOPDESC() simply indexes into nfsd4_ops[] by the op's operation\nnumber, without range checking that value. It assumes callers are\ncareful to avoid calling it with an out-of-bounds opnum value.\n\nnfsd4_decode_compound() is not so careful, and can invoke OPDESC()\nwith opnum set to OP_ILLEGAL, which is 10044 -- well beyond the end\nof nfsd4_ops[].",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53705",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv6: Fix out-of-bounds access in ipv6_find_tlv()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix out-of-bounds access in ipv6_find_tlv()\n\noptlen is fetched without checking whether there is more than one byte to parse.\nIt can lead to out-of-bounds access.\n\nFound by InfoTeCS on behalf of Linux Verification Center\n(linuxtesting.org) with SVACE.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53721",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath12k: Fix a NULL pointer dereference in ath12k_mac_op_hw_scan()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: Fix a NULL pointer dereference in ath12k_mac_op_hw_scan()\n\nIn ath12k_mac_op_hw_scan(), the return value of kzalloc() is directly\nused in memcpy(), which may lead to a NULL pointer dereference on\nfailure of kzalloc().\n\nFix this bug by adding a check of arg.extraie.ptr.\n\nTested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0-03427-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1.15378.4",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53726",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arm64: csum: Fix OoB access in IP checksum code for negative lengths",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: csum: Fix OoB access in IP checksum code for negative lengths\n\nAlthough commit c2c24edb1d9c (\"arm64: csum: Fix pathological zero-length\ncalls\") added an early return for zero-length input, syzkaller has\npopped up with an example of a _negative_ length which causes an\nundefined shift and an out-of-bounds read:\n\n | BUG: KASAN: slab-out-of-bounds in do_csum+0x44/0x254 arch/arm64/lib/csum.c:39\n | Read of size 4294966928 at addr ffff0000d7ac0170 by task syz-executor412/5975\n |\n | CPU: 0 PID: 5975 Comm: syz-executor412 Not tainted 6.4.0-rc4-syzkaller-g908f31f2a05b #0\n | Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/25/2023\n | Call trace:\n |  dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c:233\n |  show_stack+0x2c/0x44 arch/arm64/kernel/stacktrace.c:240\n |  __dump_stack lib/dump_stack.c:88 [inline]\n |  dump_stack_lvl+0xd0/0x124 lib/dump_stack.c:106\n |  print_address_description mm/kasan/report.c:351 [inline]\n |  print_report+0x174/0x514 mm/kasan/report.c:462\n |  kasan_report+0xd4/0x130 mm/kasan/report.c:572\n |  kasan_check_range+0x264/0x2a4 mm/kasan/generic.c:187\n |  __kasan_check_read+0x20/0x30 mm/kasan/shadow.c:31\n |  do_csum+0x44/0x254 arch/arm64/lib/csum.c:39\n |  csum_partial+0x30/0x58 lib/checksum.c:128\n |  gso_make_checksum include/linux/skbuff.h:4928 [inline]\n |  __udp_gso_segment+0xaf4/0x1bc4 net/ipv4/udp_offload.c:332\n |  udp6_ufo_fragment+0x540/0xca0 net/ipv6/udp_offload.c:47\n |  ipv6_gso_segment+0x5cc/0x1760 net/ipv6/ip6_offload.c:119\n |  skb_mac_gso_segment+0x2b4/0x5b0 net/core/gro.c:141\n |  __skb_gso_segment+0x250/0x3d0 net/core/dev.c:3401\n |  skb_gso_segment include/linux/netdevice.h:4859 [inline]\n |  validate_xmit_skb+0x364/0xdbc net/core/dev.c:3659\n |  validate_xmit_skb_list+0x94/0x130 net/core/dev.c:3709\n |  sch_direct_xmit+0xe8/0x548 net/sched/sch_generic.c:327\n |  __dev_xmit_skb net/core/dev.c:3805 [inline]\n |  __dev_queue_xmit+0x147c/0x3318 net/core/dev.c:4210\n |  dev_queue_xmit include/linux/netdevice.h:3085 [inline]\n |  packet_xmit+0x6c/0x318 net/packet/af_packet.c:276\n |  packet_snd net/packet/af_packet.c:3081 [inline]\n |  packet_sendmsg+0x376c/0x4c98 net/packet/af_packet.c:3113\n |  sock_sendmsg_nosec net/socket.c:724 [inline]\n |  sock_sendmsg net/socket.c:747 [inline]\n |  __sys_sendto+0x3b4/0x538 net/socket.c:2144\n\nExtend the early return to reject negative lengths as well, aligning our\nimplementation with the generic code in lib/checksum.c",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-53733",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: sched: cls_u32: Undo tcf_bind_filter if u32_replace_hw_knode",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: cls_u32: Undo tcf_bind_filter if u32_replace_hw_knode\n\nWhen u32_replace_hw_knode fails, we need to undo the tcf_bind_filter\noperation done at u32_set_parms.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-5717",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: A heap out-of-bounds write when function perf_read_group is called and sibling_list is smaller than its child's sibling_list",
      "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6040",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: out-of-bounds access in nf_tables_newtable()",
      "description": "An out-of-bounds access vulnerability involving netfilter was reported and fixed as: f1082dd31fe4 (netfilter: nf_tables: Reject tables of unsupported family); While creating a new netfilter table, lack of a safeguard against invalid nf_tables family (pf) values within `nf_tables_newtable` function enables an attacker to achieve out-of-bounds access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6270",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: AoE: improper reference count leads to use-after-free vulnerability",
      "description": "A flaw was found in the ATA over Ethernet (AoE) driver in the Linux kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on `struct net_device`, and a use-after-free can be triggered by racing between the free on the struct and the access through the `skbtxq` global queue. This could lead to a denial of service condition or potential code execution.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6356",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NULL pointer dereference in nvmet_tcp_build_iovec",
      "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver and causing kernel panic and a denial of service.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6531",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: GC's deletion of an SKB races with unix_stream_read_generic()  leading to UAF",
      "description": "A use-after-free flaw was found in the Linux Kernel due to a race problem in the unix garbage collector's deletion of SKB races with unix_stream_read_generic() on the socket that the SKB is queued on.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6535",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NULL pointer dereference in nvmet_tcp_execute_request",
      "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6536",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NULL pointer dereference in __nvmet_req_complete",
      "description": "A flaw was found in the Linux kernel's NVMe driver. This issue may allow an unauthenticated malicious actor to send a set of crafted TCP packages when using NVMe over TCP, leading the NVMe driver to a NULL pointer dereference in the NVMe driver, causing kernel panic and a denial of service.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6546",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.197-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: GSM multiplexing race condition leads to privilege escalation",
      "description": "A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6606",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Out-Of-Bounds Read vulnerability in smbCalcSize",
      "description": "An out-of-bounds read vulnerability was found in smbCalcSize in fs/smb/client/netmisc.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6817",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: inactive elements in nft_pipapo_walk",
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.\n\nThe function nft_pipapo_walk did not skip inactive elements during set walk which could lead double deactivations of PIPAPO (Pile Packet Policies) elements, leading to use-after-free.\n\nWe recommend upgrading past commit 317eb9685095678f2c9f5a8189de698c5354316a.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6931",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Out of boundary write in perf_read_group() as result of overflow a perf_event's read_size",
      "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation.\n\nA perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group().\n\nWe recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-6932",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.205-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free in IPv4 IGMP",
      "description": "A use-after-free vulnerability in the Linux kernel's ipv4: igmp component can be exploited to achieve local privilege escalation.\n\nA race condition can be exploited to cause a timer be mistakenly registered on a RCU read locked object which is freed by another thread.\n\nWe recommend upgrading past commit e2b706c691905fe78468c361aaabc719d0a496f1.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-0565",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: CIFS Filesystem Decryption Improper Input Validation Remote Code Execution Vulnerability in function receive_encrypted_standard of client",
      "description": "An out-of-bounds memory read flaw was found in receive_encrypted_standard in fs/smb/client/smb2ops.c in the SMB Client sub-component in the Linux Kernel. This issue occurs due to integer underflow on the memcpy length, leading to a denial of service.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-0646",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ktls overwrites readonly memory pages when using function splice with a ktls socket as destination",
      "description": "An out-of-bounds memory write flaw was found in the Linux kernel\u2019s Transport Layer Security functionality in how a user calls a function splice with a ktls socket as the destination. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-0775",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.191-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: use-after-free while changing the mount option in __ext4_remount leading",
      "description": "A use-after-free flaw was found in the __ext4_remount in fs/ext4/super.c in ext4 in the Linux kernel. This flaw allows a local user to cause an information leak problem while freeing the old quota file names before a potential failure, leading to a use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-0841",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hugetlbfs: Null pointer dereference in hugetlbfs_fill_super function",
      "description": "A null pointer dereference flaw was found in the hugetlbfs_fill_super function in the Linux kernel hugetlbfs (HugeTLB pages) functionality. This issue may allow a local user to crash the system or potentially escalate their privileges on the system.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-1086",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nf_tables: use-after-free vulnerability in the nft_verdict_init() function",
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation.\n\nThe nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability when NF_DROP is issued with a drop error which resembles NF_ACCEPT.\n\nWe recommend upgrading past commit f342de4e2f33e0e39165d8639387aa6c19dff660.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-21803",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bluetooth: use-after-free vulnerability in af_bluetooth.c",
      "description": "Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C.\n\nThis issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.\n\n",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-23307",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Integer Overflow in raid5_cache_count",
      "description": "Integer Overflow or Wraparound vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (md, raid, raid5 modules) allows Forced Integer Overflow.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-25742",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "hw: amd: Instruction raise #VC exception at exit",
      "description": "In the Linux kernel before 6.9, an untrusted hypervisor can inject virtual interrupt 29 (#VC) at any point in time and can trigger its handler. This affects AMD SEV-SNP and AMD SEV-ES.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-25743",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "hw: amd: Instruction raise #VC exception at exit",
      "description": "In the Linux kernel through 6.9, an untrusted hypervisor can inject virtual interrupts 0 and 14 at any point in time and can trigger the SIGFPE signal handler in userspace applications. This affects AMD SEV-SNP and AMD SEV-ES.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26581",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nftables: nft_set_rbtree skip end interval element from gc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_rbtree: skip end interval element from gc\n\nrbtree lazy gc on insert might collect an end interval element that has\nbeen just added in this transactions, skip end interval elements that\nare not yet active.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26589",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Reject variable offset alu on PTR_TO_FLOW_KEYS",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Reject variable offset alu on PTR_TO_FLOW_KEYS\n\nFor PTR_TO_FLOW_KEYS, check_flow_keys_access() only uses fixed off\nfor validation. However, variable offset ptr alu is not prohibited\nfor this ptr kind. So the variable offset is not checked.\n\nThe following prog is accepted:\n\n  func#0 @0\n  0: R1=ctx() R10=fp0\n  0: (bf) r6 = r1                       ; R1=ctx() R6_w=ctx()\n  1: (79) r7 = *(u64 *)(r6 +144)        ; R6_w=ctx() R7_w=flow_keys()\n  2: (b7) r8 = 1024                     ; R8_w=1024\n  3: (37) r8 /= 1                       ; R8_w=scalar()\n  4: (57) r8 &= 1024                    ; R8_w=scalar(smin=smin32=0,\n  smax=umax=smax32=umax32=1024,var_off=(0x0; 0x400))\n  5: (0f) r7 += r8\n  mark_precise: frame0: last_idx 5 first_idx 0 subseq_idx -1\n  mark_precise: frame0: regs=r8 stack= before 4: (57) r8 &= 1024\n  mark_precise: frame0: regs=r8 stack= before 3: (37) r8 /= 1\n  mark_precise: frame0: regs=r8 stack= before 2: (b7) r8 = 1024\n  6: R7_w=flow_keys(smin=smin32=0,smax=umax=smax32=umax32=1024,var_off\n  =(0x0; 0x400)) R8_w=scalar(smin=smin32=0,smax=umax=smax32=umax32=1024,\n  var_off=(0x0; 0x400))\n  6: (79) r0 = *(u64 *)(r7 +0)          ; R0_w=scalar()\n  7: (95) exit\n\nThis prog loads flow_keys to r7, and adds the variable offset r8\nto r7, and finally causes out-of-bounds access:\n\n  BUG: unable to handle page fault for address: ffffc90014c80038\n  [...]\n  Call Trace:\n   <TASK>\n   bpf_dispatcher_nop_func include/linux/bpf.h:1231 [inline]\n   __bpf_prog_run include/linux/filter.h:651 [inline]\n   bpf_prog_run include/linux/filter.h:658 [inline]\n   bpf_prog_run_pin_on_cpu include/linux/filter.h:675 [inline]\n   bpf_flow_dissect+0x15f/0x350 net/core/flow_dissector.c:991\n   bpf_prog_test_run_flow_dissector+0x39d/0x620 net/bpf/test_run.c:1359\n   bpf_prog_test_run kernel/bpf/syscall.c:4107 [inline]\n   __sys_bpf+0xf8f/0x4560 kernel/bpf/syscall.c:5475\n   __do_sys_bpf kernel/bpf/syscall.c:5561 [inline]\n   __se_sys_bpf kernel/bpf/syscall.c:5559 [inline]\n   __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:5559\n   do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n   do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:83\n   entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nFix this by rejecting ptr alu with variable offset on flow_keys.\nApplying the patch rejects the program with \"R7 pointer arithmetic\non flow_keys prohibited\".",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26593",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i2c: i801: Fix block process call transactions",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: i801: Fix block process call transactions\n\nAccording to the Intel datasheets, software must reset the block\nbuffer index twice for block process call transactions: once before\nwriting the outgoing data to the buffer, and once again before\nreading the incoming data from the buffer.\n\nThe driver is currently missing the second reset, causing the wrong\nportion of the block buffer to be read.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26597",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "In the Linux kernel, the following vulnerability has been resolved:  n ...",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: qualcomm: rmnet: fix global oob in rmnet_policy\n\nThe variable rmnet_link_ops assign a *bigger* maxtype which leads to a\nglobal out-of-bounds read when parsing the netlink attributes. See bug\ntrace below:\n\n==================================================================\nBUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline]\nBUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600\nRead of size 1 at addr ffffffff92c438d0 by task syz-executor.6/84207\n\nCPU: 0 PID: 84207 Comm: syz-executor.6 Tainted: G                 N 6.1.0 #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:284 [inline]\n print_report+0x172/0x475 mm/kasan/report.c:395\n kasan_report+0xbb/0x1c0 mm/kasan/report.c:495\n validate_nla lib/nlattr.c:386 [inline]\n __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600\n __nla_parse+0x3e/0x50 lib/nlattr.c:697\n nla_parse_nested_deprecated include/net/netlink.h:1248 [inline]\n __rtnl_newlink+0x50a/0x1880 net/core/rtnetlink.c:3485\n rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3594\n rtnetlink_rcv_msg+0x43c/0xd70 net/core/rtnetlink.c:6091\n netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540\n netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345\n netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921\n sock_sendmsg_nosec net/socket.c:714 [inline]\n sock_sendmsg+0x154/0x190 net/socket.c:734\n ____sys_sendmsg+0x6df/0x840 net/socket.c:2482\n ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536\n __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7fdcf2072359\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fdcf13e3168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007fdcf219ff80 RCX: 00007fdcf2072359\nRDX: 0000000000000000 RSI: 0000000020000200 RDI: 0000000000000003\nRBP: 00007fdcf20bd493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fffbb8d7bdf R14: 00007fdcf13e3300 R15: 0000000000022000\n </TASK>\n\nThe buggy address belongs to the variable:\n rmnet_policy+0x30/0xe0\n\nThe buggy address belongs to the physical page:\npage:0000000065bdeb3c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x155243\nflags: 0x200000000001000(reserved|node=0|zone=2)\nraw: 0200000000001000 ffffea00055490c8 ffffea00055490c8 0000000000000000\nraw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffffffff92c43780: f9 f9 f9 f9 00 00 00 02 f9 f9 f9 f9 00 00 00 07\n ffffffff92c43800: f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 06 f9 f9 f9\n>ffffffff92c43880: f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9\n                                                 ^\n ffffffff92c43900: 00 00 00 00 00 00 00 00 07 f9 f9 f9 f9 f9 f9 f9\n ffffffff92c43980: 00 00 00 07 f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9\n\nAccording to the comment of `nla_parse_nested_deprecated`, the maxtype\nshould be len(destination array) - 1. Hence use `IFLA_RMNET_MAX` here.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26598",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.209-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: kvm: Avoid potential UAF in LPI translation cache",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: vgic-its: Avoid potential UAF in LPI translation cache\n\nThere is a potential UAF scenario in the case of an LPI translation\ncache hit racing with an operation that invalidates the cache, such\nas a DISCARD ITS command. The root of the problem is that\nvgic_its_check_cache() does not elevate the refcount on the vgic_irq\nbefore dropping the lock that serializes refcount changes.\n\nHave vgic_its_check_cache() raise the refcount on the returned vgic_irq\nand add the corresponding decrement after queueing the interrupt.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26610",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: fix a memory corruption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: fix a memory corruption\n\niwl_fw_ini_trigger_tlv::data is a pointer to a __le32, which means that\nif we copy to iwl_fw_ini_trigger_tlv::data + offset while offset is in\nbytes, we'll write past the buffer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26622",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tomoyo: fix UAF write bug in tomoyo_write_control()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntomoyo: fix UAF write bug in tomoyo_write_control()\n\nSince tomoyo_write_control() updates head->write_buf when write()\nof long lines is requested, we need to fetch head->write_buf after\nhead->io_sem is held.  Otherwise, concurrent write() requests can\ncause use-after-free-write and double-free problems.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26625",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: llc: call sock_orphan() at release time",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nllc: call sock_orphan() at release time\n\nsyzbot reported an interesting trace [1] caused by a stale sk->sk_wq\npointer in a closed llc socket.\n\nIn commit ff7b11aa481f (\"net: socket: set sock->sk to NULL after\ncalling proto_ops::release()\") Eric Biggers hinted that some protocols\nare missing a sock_orphan(), we need to perform a full audit.\n\nIn net-next, I plan to clear sock->sk from sock_orphan() and\namend Eric patch to add a warning.\n\n[1]\n BUG: KASAN: slab-use-after-free in list_empty include/linux/list.h:373 [inline]\n BUG: KASAN: slab-use-after-free in waitqueue_active include/linux/wait.h:127 [inline]\n BUG: KASAN: slab-use-after-free in sock_def_write_space_wfree net/core/sock.c:3384 [inline]\n BUG: KASAN: slab-use-after-free in sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468\nRead of size 8 at addr ffff88802f4fc880 by task ksoftirqd/1/27\n\nCPU: 1 PID: 27 Comm: ksoftirqd/1 Not tainted 6.8.0-rc1-syzkaller-00049-g6098d87eaf31 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0xc4/0x620 mm/kasan/report.c:488\n  kasan_report+0xda/0x110 mm/kasan/report.c:601\n  list_empty include/linux/list.h:373 [inline]\n  waitqueue_active include/linux/wait.h:127 [inline]\n  sock_def_write_space_wfree net/core/sock.c:3384 [inline]\n  sock_wfree+0x9a8/0x9d0 net/core/sock.c:2468\n  skb_release_head_state+0xa3/0x2b0 net/core/skbuff.c:1080\n  skb_release_all net/core/skbuff.c:1092 [inline]\n  napi_consume_skb+0x119/0x2b0 net/core/skbuff.c:1404\n  e1000_unmap_and_free_tx_resource+0x144/0x200 drivers/net/ethernet/intel/e1000/e1000_main.c:1970\n  e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3860 [inline]\n  e1000_clean+0x4a1/0x26e0 drivers/net/ethernet/intel/e1000/e1000_main.c:3801\n  __napi_poll.constprop.0+0xb4/0x540 net/core/dev.c:6576\n  napi_poll net/core/dev.c:6645 [inline]\n  net_rx_action+0x956/0xe90 net/core/dev.c:6778\n  __do_softirq+0x21a/0x8de kernel/softirq.c:553\n  run_ksoftirqd kernel/softirq.c:921 [inline]\n  run_ksoftirqd+0x31/0x60 kernel/softirq.c:913\n  smpboot_thread_fn+0x660/0xa10 kernel/smpboot.c:164\n  kthread+0x2c6/0x3a0 kernel/kthread.c:388\n  ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:242\n </TASK>\n\nAllocated by task 5167:\n  kasan_save_stack+0x33/0x50 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  unpoison_slab_object mm/kasan/common.c:314 [inline]\n  __kasan_slab_alloc+0x81/0x90 mm/kasan/common.c:340\n  kasan_slab_alloc include/linux/kasan.h:201 [inline]\n  slab_post_alloc_hook mm/slub.c:3813 [inline]\n  slab_alloc_node mm/slub.c:3860 [inline]\n  kmem_cache_alloc_lru+0x142/0x6f0 mm/slub.c:3879\n  alloc_inode_sb include/linux/fs.h:3019 [inline]\n  sock_alloc_inode+0x25/0x1c0 net/socket.c:308\n  alloc_inode+0x5d/0x220 fs/inode.c:260\n  new_inode_pseudo+0x16/0x80 fs/inode.c:1005\n  sock_alloc+0x40/0x270 net/socket.c:634\n  __sock_create+0xbc/0x800 net/socket.c:1535\n  sock_create net/socket.c:1622 [inline]\n  __sys_socket_create net/socket.c:1659 [inline]\n  __sys_socket+0x14c/0x260 net/socket.c:1706\n  __do_sys_socket net/socket.c:1720 [inline]\n  __se_sys_socket net/socket.c:1718 [inline]\n  __x64_sys_socket+0x72/0xb0 net/socket.c:1718\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xd3/0x250 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nFreed by task 0:\n  kasan_save_stack+0x33/0x50 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  kasan_save_free_info+0x3f/0x60 mm/kasan/generic.c:640\n  poison_slab_object mm/kasan/common.c:241 [inline]\n  __kasan_slab_free+0x121/0x1b0 mm/kasan/common.c:257\n  kasan_slab_free include/linux/kasan.h:184 [inline]\n  slab_free_hook mm/slub.c:2121 [inlin\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26654",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: sh: aica: reorder cleanup operations to avoid UAF bugs",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: sh: aica: reorder cleanup operations to avoid UAF bugs\n\nThe dreamcastcard->timer could schedule the spu_dma_work and the\nspu_dma_work could also arm the dreamcastcard->timer.\n\nWhen the snd_pcm_substream is closing, the aica_channel will be\ndeallocated. But it could still be dereferenced in the worker\nthread. The reason is that del_timer() will return directly\nregardless of whether the timer handler is running or not and\nthe worker could be rescheduled in the timer handler. As a result,\nthe UAF bug will happen. The racy situation is shown below:\n\n      (Thread 1)                 |      (Thread 2)\nsnd_aicapcm_pcm_close()          |\n ...                             |  run_spu_dma() //worker\n                                 |    mod_timer()\n  flush_work()                   |\n  del_timer()                    |  aica_period_elapsed() //timer\n  kfree(dreamcastcard->channel)  |    schedule_work()\n                                 |  run_spu_dma() //worker\n  ...                            |    dreamcastcard->channel-> //USE\n\nIn order to mitigate this bug and other possible corner cases,\ncall mod_timer() conditionally in run_spu_dma(), then implement\nPCM sync_stop op to cancel both the timer and worker. The sync_stop\nop will be called from PCM core appropriately when needed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26664",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hwmon: (coretemp) Fix out-of-bounds memory access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (coretemp) Fix out-of-bounds memory access\n\nFix a bug that pdata->cpu_map[] is set before out-of-bounds check.\nThe problem might be triggered on systems with more than 128 cores per\npackage.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26665",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tunnels: fix out of bounds access when building IPv6 PMTU error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntunnels: fix out of bounds access when building IPv6 PMTU error\n\nIf the ICMPv6 error is built from a non-linear skb we get the following\nsplat,\n\n  BUG: KASAN: slab-out-of-bounds in do_csum+0x220/0x240\n  Read of size 4 at addr ffff88811d402c80 by task netperf/820\n  CPU: 0 PID: 820 Comm: netperf Not tainted 6.8.0-rc1+ #543\n  ...\n   kasan_report+0xd8/0x110\n   do_csum+0x220/0x240\n   csum_partial+0xc/0x20\n   skb_tunnel_check_pmtu+0xeb9/0x3280\n   vxlan_xmit_one+0x14c2/0x4080\n   vxlan_xmit+0xf61/0x5c00\n   dev_hard_start_xmit+0xfb/0x510\n   __dev_queue_xmit+0x7cd/0x32a0\n   br_dev_queue_push_xmit+0x39d/0x6a0\n\nUse skb_checksum instead of csum_partial who cannot deal with non-linear\nSKBs.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26669",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: flower: Fix chain template offload",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: flower: Fix chain template offload\n\nWhen a qdisc is deleted from a net device the stack instructs the\nunderlying driver to remove its flow offload callback from the\nassociated filter block using the 'FLOW_BLOCK_UNBIND' command. The stack\nthen continues to replay the removal of the filters in the block for\nthis driver by iterating over the chains in the block and invoking the\n'reoffload' operation of the classifier being used. In turn, the\nclassifier in its 'reoffload' operation prepares and emits a\n'FLOW_CLS_DESTROY' command for each filter.\n\nHowever, the stack does not do the same for chain templates and the\nunderlying driver never receives a 'FLOW_CLS_TMPLT_DESTROY' command when\na qdisc is deleted. This results in a memory leak [1] which can be\nreproduced using [2].\n\nFix by introducing a 'tmplt_reoffload' operation and have the stack\ninvoke it with the appropriate arguments as part of the replay.\nImplement the operation in the sole classifier that supports chain\ntemplates (flower) by emitting the 'FLOW_CLS_TMPLT_{CREATE,DESTROY}'\ncommand based on whether a flow offload callback is being bound to a\nfilter block or being unbound from one.\n\nAs far as I can tell, the issue happens since cited commit which\nreordered tcf_block_offload_unbind() before tcf_block_flush_all_chains()\nin __tcf_block_put(). The order cannot be reversed as the filter block\nis expected to be freed after flushing all the chains.\n\n[1]\nunreferenced object 0xffff888107e28800 (size 2048):\n  comm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s)\n  hex dump (first 32 bytes):\n    b1 a6 7c 11 81 88 ff ff e0 5b b3 10 81 88 ff ff  ..|......[......\n    01 00 00 00 00 00 00 00 e0 aa b0 84 ff ff ff ff  ................\n  backtrace:\n    [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320\n    [<ffffffff81ab374e>] __kmalloc+0x4e/0x90\n    [<ffffffff832aec6d>] mlxsw_sp_acl_ruleset_get+0x34d/0x7a0\n    [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180\n    [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280\n    [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340\n    [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0\n    [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170\n    [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0\n    [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440\n    [<ffffffff83ac6270>] netlink_unicast+0x540/0x820\n    [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0\n    [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80\n    [<ffffffff8379d29a>] ___sys_sendmsg+0x13a/0x1e0\n    [<ffffffff8379d50c>] __sys_sendmsg+0x11c/0x1f0\n    [<ffffffff843b9ce0>] do_syscall_64+0x40/0xe0\nunreferenced object 0xffff88816d2c0400 (size 1024):\n  comm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s)\n  hex dump (first 32 bytes):\n    40 00 00 00 00 00 00 00 57 f6 38 be 00 00 00 00  @.......W.8.....\n    10 04 2c 6d 81 88 ff ff 10 04 2c 6d 81 88 ff ff  ..,m......,m....\n  backtrace:\n    [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320\n    [<ffffffff81ab36c1>] __kmalloc_node+0x51/0x90\n    [<ffffffff81a8ed96>] kvmalloc_node+0xa6/0x1f0\n    [<ffffffff82827d03>] bucket_table_alloc.isra.0+0x83/0x460\n    [<ffffffff82828d2b>] rhashtable_init+0x43b/0x7c0\n    [<ffffffff832aed48>] mlxsw_sp_acl_ruleset_get+0x428/0x7a0\n    [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180\n    [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280\n    [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340\n    [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0\n    [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170\n    [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0\n    [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440\n    [<ffffffff83ac6270>] netlink_unicast+0x540/0x820\n    [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0\n    [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80\n\n[2]\n # tc qdisc add dev swp1 clsact\n # tc chain add dev swp1 ingress proto ip chain 1 flower dst_ip 0.0.0.0/32\n # tc qdisc del dev\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26673",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nft_ct: sanitize layer 3 and 4 protocol number in custom expectations",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_ct: sanitize layer 3 and 4 protocol number in custom expectations\n\n- Disallow families other than NFPROTO_{IPV4,IPV6,INET}.\n- Disallow layer 4 protocol with no ports, since destination port is a\n  mandatory attribute for this object.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26689",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ceph: prevent use-after-free in encode_cap_msg()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: prevent use-after-free in encode_cap_msg()\n\nIn fs/ceph/caps.c, in encode_cap_msg(), \"use after free\" error was\ncaught by KASAN at this line - 'ceph_buffer_get(arg->xattr_buf);'. This\nimplies before the refcount could be increment here, it was freed.\n\nIn same file, in \"handle_cap_grant()\" refcount is decremented by this\nline - 'ceph_buffer_put(ci->i_xattrs.blob);'. It appears that a race\noccurred and resource was freed by the latter line before the former\nline could increment it.\n\nencode_cap_msg() is called by __send_cap() and __send_cap() is called by\nceph_check_caps() after calling __prep_cap(). __prep_cap() is where\narg->xattr_buf is assigned to ci->i_xattrs.blob. This is the spot where\nthe refcount must be increased to prevent \"use after free\" error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26704",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix double-free of blocks due to wrong extents moved_len",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix double-free of blocks due to wrong extents moved_len\n\nIn ext4_move_extents(), moved_len is only updated when all moves are\nsuccessfully executed, and only discards orig_inode and donor_inode\npreallocations when moved_len is not zero. When the loop fails to exit\nafter successfully moving some extents, moved_len is not updated and\nremains at 0, so it does not discard the preallocations.\n\nIf the moved extents overlap with the preallocated extents, the\noverlapped extents are freed twice in ext4_mb_release_inode_pa() and\next4_process_freed_data() (as described in commit 94d7c16cbbbd (\"ext4:\nFix double-free of blocks with EXT4_IOC_MOVE_EXT\")), and bb_free is\nincremented twice. Hence when trim is executed, a zero-division bug is\ntriggered in mb_update_avg_fragment_size() because bb_free is not zero\nand bb_fragments is zero.\n\nTherefore, update move_len after each extent move to avoid the issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26736",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: afs: Increase buffer size in afs_update_volume_status()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Increase buffer size in afs_update_volume_status()\n\nThe max length of volume->vid value is 20 characters.\nSo increase idbuf[] size up to 24 to avoid overflow.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\n\n[DH: Actually, it's 20 + NUL, so increase it to 24 and use snprintf()]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26739",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: act_mirred: don't override retval if we already lost the skb",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_mirred: don't override retval if we already lost the skb\n\nIf we're redirecting the skb, and haven't called tcf_mirred_forward(),\nyet, we need to tell the core to drop the skb by setting the retcode\nto SHOT. If we have called tcf_mirred_forward(), however, the skb\nis out of our hands and returning SHOT will lead to UaF.\n\nMove the retval override to the error path which actually need it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26748",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: cdns3: fix memory double free when handle zero packet",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdns3: fix memory double free when handle zero packet\n\n829  if (request->complete) {\n830          spin_unlock(&priv_dev->lock);\n831          usb_gadget_giveback_request(&priv_ep->endpoint,\n832                                    request);\n833          spin_lock(&priv_dev->lock);\n834  }\n835\n836  if (request->buf == priv_dev->zlp_buf)\n837      cdns3_gadget_ep_free_request(&priv_ep->endpoint, request);\n\nDriver append an additional zero packet request when queue a packet, which\nlength mod max packet size is 0. When transfer complete, run to line 831,\nusb_gadget_giveback_request() will free this requestion. 836 condition is\ntrue, so cdns3_gadget_ep_free_request() free this request again.\n\nLog:\n\n[ 1920.140696][  T150] BUG: KFENCE: use-after-free read in cdns3_gadget_giveback+0x134/0x2c0 [cdns3]\n[ 1920.140696][  T150]\n[ 1920.151837][  T150] Use-after-free read at 0x000000003d1cd10b (in kfence-#36):\n[ 1920.159082][  T150]  cdns3_gadget_giveback+0x134/0x2c0 [cdns3]\n[ 1920.164988][  T150]  cdns3_transfer_completed+0x438/0x5f8 [cdns3]\n\nAdd check at line 829, skip call usb_gadget_giveback_request() if it is\nadditional zero length packet request. Needn't call\nusb_gadget_giveback_request() because it is allocated in this driver.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26749",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: cdns3: fixed memory use after free at cdns3_gadget_ep_disable()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdns3: fixed memory use after free at cdns3_gadget_ep_disable()\n\n  ...\n  cdns3_gadget_ep_free_request(&priv_ep->endpoint, &priv_req->request);\n  list_del_init(&priv_req->list);\n  ...\n\n'priv_req' actually free at cdns3_gadget_ep_free_request(). But\nlist_del_init() use priv_req->list after it.\n\n[ 1542.642868][  T534] BUG: KFENCE: use-after-free read in __list_del_entry_valid+0x10/0xd4\n[ 1542.642868][  T534]\n[ 1542.653162][  T534] Use-after-free read at 0x000000009ed0ba99 (in kfence-#3):\n[ 1542.660311][  T534]  __list_del_entry_valid+0x10/0xd4\n[ 1542.665375][  T534]  cdns3_gadget_ep_disable+0x1f8/0x388 [cdns3]\n[ 1542.671571][  T534]  usb_ep_disable+0x44/0xe4\n[ 1542.675948][  T534]  ffs_func_eps_disable+0x64/0xc8\n[ 1542.680839][  T534]  ffs_func_set_alt+0x74/0x368\n[ 1542.685478][  T534]  ffs_func_disable+0x18/0x28\n\nMove list_del_init() before cdns3_gadget_ep_free_request() to resolve this\nproblem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26753",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: virtio/akcipher - Fix stack overflow on memcpy",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: virtio/akcipher - Fix stack overflow on memcpy\n\nsizeof(struct virtio_crypto_akcipher_session_para) is less than\nsizeof(struct virtio_crypto_op_ctrl_req::u), copying more bytes from\nstack variable leads stack overflow. Clang reports this issue by\ncommands:\nmake -j CC=clang-14 mrproper >/dev/null 2>&1\nmake -j O=/tmp/crypto-build CC=clang-14 allmodconfig >/dev/null 2>&1\nmake -j O=/tmp/crypto-build W=1 CC=clang-14 drivers/crypto/virtio/\n  virtio_crypto_akcipher_algs.o",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26754",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gtp: fix use-after-free and null-ptr-deref in gtp_genl_dump_pdp()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngtp: fix use-after-free and null-ptr-deref in gtp_genl_dump_pdp()\n\nThe gtp_net_ops pernet operations structure for the subsystem must be\nregistered before registering the generic netlink family.\n\nSyzkaller hit 'general protection fault in gtp_genl_dump_pdp' bug:\n\ngeneral protection fault, probably for non-canonical address\n0xdffffc0000000002: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]\nCPU: 1 PID: 5826 Comm: gtp Not tainted 6.8.0-rc3-std-def-alt1 #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-alt1 04/01/2014\nRIP: 0010:gtp_genl_dump_pdp+0x1be/0x800 [gtp]\nCode: c6 89 c6 e8 64 e9 86 df 58 45 85 f6 0f 85 4e 04 00 00 e8 c5 ee 86\n      df 48 8b 54 24 18 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80>\n      3c 02 00 0f 85 de 05 00 00 48 8b 44 24 18 4c 8b 30 4c 39 f0 74\nRSP: 0018:ffff888014107220 EFLAGS: 00010202\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000002 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff88800fcda588 R14: 0000000000000001 R15: 0000000000000000\nFS:  00007f1be4eb05c0(0000) GS:ffff88806ce80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f1be4e766cf CR3: 000000000c33e000 CR4: 0000000000750ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? show_regs+0x90/0xa0\n ? die_addr+0x50/0xd0\n ? exc_general_protection+0x148/0x220\n ? asm_exc_general_protection+0x22/0x30\n ? gtp_genl_dump_pdp+0x1be/0x800 [gtp]\n ? __alloc_skb+0x1dd/0x350\n ? __pfx___alloc_skb+0x10/0x10\n genl_dumpit+0x11d/0x230\n netlink_dump+0x5b9/0xce0\n ? lockdep_hardirqs_on_prepare+0x253/0x430\n ? __pfx_netlink_dump+0x10/0x10\n ? kasan_save_track+0x10/0x40\n ? __kasan_kmalloc+0x9b/0xa0\n ? genl_start+0x675/0x970\n __netlink_dump_start+0x6fc/0x9f0\n genl_family_rcv_msg_dumpit+0x1bb/0x2d0\n ? __pfx_genl_family_rcv_msg_dumpit+0x10/0x10\n ? genl_op_from_small+0x2a/0x440\n ? cap_capable+0x1d0/0x240\n ? __pfx_genl_start+0x10/0x10\n ? __pfx_genl_dumpit+0x10/0x10\n ? __pfx_genl_done+0x10/0x10\n ? security_capable+0x9d/0xe0",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26763",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dm-crypt: don't modify the data when using authenticated encryption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm-crypt: don't modify the data when using authenticated encryption\n\nIt was said that authenticated encryption could produce invalid tag when\nthe data that is being encrypted is modified [1]. So, fix this problem by\ncopying the data into the clone bio first and then encrypt them inside the\nclone bio.\n\nThis may reduce performance, but it is needed to prevent the user from\ncorrupting the device by writing data with O_DIRECT and modifying them at\nthe same time.\n\n[1] https://lore.kernel.org/all/20240207004723.GA35324@sol.localdomain/T/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26782",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mptcp: fix double-free on socket dismantle",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix double-free on socket dismantle\n\nwhen MPTCP server accepts an incoming connection, it clones its listener\nsocket. However, the pointer to 'inet_opt' for the new socket has the same\nvalue as the original one: as a consequence, on program exit it's possible\nto observe the following splat:\n\n  BUG: KASAN: double-free in inet_sock_destruct+0x54f/0x8b0\n  Free of addr ffff888485950880 by task swapper/25/0\n\n  CPU: 25 PID: 0 Comm: swapper/25 Kdump: loaded Not tainted 6.8.0-rc1+ #609\n  Hardware name: Supermicro SYS-6027R-72RF/X9DRH-7TF/7F/iTF/iF, BIOS 3.0  07/26/2013\n  Call Trace:\n   <IRQ>\n   dump_stack_lvl+0x32/0x50\n   print_report+0xca/0x620\n   kasan_report_invalid_free+0x64/0x90\n   __kasan_slab_free+0x1aa/0x1f0\n   kfree+0xed/0x2e0\n   inet_sock_destruct+0x54f/0x8b0\n   __sk_destruct+0x48/0x5b0\n   rcu_do_batch+0x34e/0xd90\n   rcu_core+0x559/0xac0\n   __do_softirq+0x183/0x5a4\n   irq_exit_rcu+0x12d/0x170\n   sysvec_apic_timer_interrupt+0x6b/0x80\n   </IRQ>\n   <TASK>\n   asm_sysvec_apic_timer_interrupt+0x16/0x20\n  RIP: 0010:cpuidle_enter_state+0x175/0x300\n  Code: 30 00 0f 84 1f 01 00 00 83 e8 01 83 f8 ff 75 e5 48 83 c4 18 44 89 e8 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc fb 45 85 ed <0f> 89 60 ff ff ff 48 c1 e5 06 48 c7 43 18 00 00 00 00 48 83 44 2b\n  RSP: 0018:ffff888481cf7d90 EFLAGS: 00000202\n  RAX: 0000000000000000 RBX: ffff88887facddc8 RCX: 0000000000000000\n  RDX: 1ffff1110ff588b1 RSI: 0000000000000019 RDI: ffff88887fac4588\n  RBP: 0000000000000004 R08: 0000000000000002 R09: 0000000000043080\n  R10: 0009b02ea273363f R11: ffff88887fabf42b R12: ffffffff932592e0\n  R13: 0000000000000004 R14: 0000000000000000 R15: 00000022c880ec80\n   cpuidle_enter+0x4a/0xa0\n   do_idle+0x310/0x410\n   cpu_startup_entry+0x51/0x60\n   start_secondary+0x211/0x270\n   secondary_startup_64_no_verify+0x184/0x18b\n   </TASK>\n\n  Allocated by task 6853:\n   kasan_save_stack+0x1c/0x40\n   kasan_save_track+0x10/0x30\n   __kasan_kmalloc+0xa6/0xb0\n   __kmalloc+0x1eb/0x450\n   cipso_v4_sock_setattr+0x96/0x360\n   netlbl_sock_setattr+0x132/0x1f0\n   selinux_netlbl_socket_post_create+0x6c/0x110\n   selinux_socket_post_create+0x37b/0x7f0\n   security_socket_post_create+0x63/0xb0\n   __sock_create+0x305/0x450\n   __sys_socket_create.part.23+0xbd/0x130\n   __sys_socket+0x37/0xb0\n   __x64_sys_socket+0x6f/0xb0\n   do_syscall_64+0x83/0x160\n   entry_SYSCALL_64_after_hwframe+0x6e/0x76\n\n  Freed by task 6858:\n   kasan_save_stack+0x1c/0x40\n   kasan_save_track+0x10/0x30\n   kasan_save_free_info+0x3b/0x60\n   __kasan_slab_free+0x12c/0x1f0\n   kfree+0xed/0x2e0\n   inet_sock_destruct+0x54f/0x8b0\n   __sk_destruct+0x48/0x5b0\n   subflow_ulp_release+0x1f0/0x250\n   tcp_cleanup_ulp+0x6e/0x110\n   tcp_v4_destroy_sock+0x5a/0x3a0\n   inet_csk_destroy_sock+0x135/0x390\n   tcp_fin+0x416/0x5c0\n   tcp_data_queue+0x1bc8/0x4310\n   tcp_rcv_state_process+0x15a3/0x47b0\n   tcp_v4_do_rcv+0x2c1/0x990\n   tcp_v4_rcv+0x41fb/0x5ed0\n   ip_protocol_deliver_rcu+0x6d/0x9f0\n   ip_local_deliver_finish+0x278/0x360\n   ip_local_deliver+0x182/0x2c0\n   ip_rcv+0xb5/0x1c0\n   __netif_receive_skb_one_core+0x16e/0x1b0\n   process_backlog+0x1e3/0x650\n   __napi_poll+0xa6/0x500\n   net_rx_action+0x740/0xbb0\n   __do_softirq+0x183/0x5a4\n\n  The buggy address belongs to the object at ffff888485950880\n   which belongs to the cache kmalloc-64 of size 64\n  The buggy address is located 0 bytes inside of\n   64-byte region [ffff888485950880, ffff8884859508c0)\n\n  The buggy address belongs to the physical page:\n  page:0000000056d1e95e refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888485950700 pfn:0x485950\n  flags: 0x57ffffc0000800(slab|node=1|zone=2|lastcpupid=0x1fffff)\n  page_type: 0xffffffff()\n  raw: 0057ffffc0000800 ffff88810004c640 ffffea00121b8ac0 dead000000000006\n  raw: ffff888485950700 0000000000200019 00000001ffffffff 0000000000000000\n  page dumped because: kasan: bad access detected\n\n  Memory state around the buggy address:\n   ffff888485950780: fa fb fb\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26791",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: dev-replace: properly validate device names",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: dev-replace: properly validate device names\n\nThere's a syzbot report that device name buffers passed to device\nreplace are not properly checked for string termination which could lead\nto a read out of bounds in getname_kernel().\n\nAdd a helper that validates both source and target device name buffers.\nFor devid as the source initialize the buffer to empty string in case\nsomething tries to read it later.\n\nThis was originally analyzed and fixed in a different way by Edward Adam\nDavis (see links).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26792",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: fix double free of anonymous device after snapshot creation failure",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix double free of anonymous device after snapshot creation failure\n\nWhen creating a snapshot we may do a double free of an anonymous device\nin case there's an error committing the transaction. The second free may\nresult in freeing an anonymous device number that was allocated by some\nother subsystem in the kernel or another btrfs filesystem.\n\nThe steps that lead to this:\n\n1) At ioctl.c:create_snapshot() we allocate an anonymous device number\n   and assign it to pending_snapshot->anon_dev;\n\n2) Then we call btrfs_commit_transaction() and end up at\n   transaction.c:create_pending_snapshot();\n\n3) There we call btrfs_get_new_fs_root() and pass it the anonymous device\n   number stored in pending_snapshot->anon_dev;\n\n4) btrfs_get_new_fs_root() frees that anonymous device number because\n   btrfs_lookup_fs_root() returned a root - someone else did a lookup\n   of the new root already, which could some task doing backref walking;\n\n5) After that some error happens in the transaction commit path, and at\n   ioctl.c:create_snapshot() we jump to the 'fail' label, and after\n   that we free again the same anonymous device number, which in the\n   meanwhile may have been reallocated somewhere else, because\n   pending_snapshot->anon_dev still has the same value as in step 1.\n\nRecently syzbot ran into this and reported the following trace:\n\n  ------------[ cut here ]------------\n  ida_free called for id=51 which is not allocated.\n  WARNING: CPU: 1 PID: 31038 at lib/idr.c:525 ida_free+0x370/0x420 lib/idr.c:525\n  Modules linked in:\n  CPU: 1 PID: 31038 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-00410-gc02197fc9076 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024\n  RIP: 0010:ida_free+0x370/0x420 lib/idr.c:525\n  Code: 10 42 80 3c 28 (...)\n  RSP: 0018:ffffc90015a67300 EFLAGS: 00010246\n  RAX: be5130472f5dd000 RBX: 0000000000000033 RCX: 0000000000040000\n  RDX: ffffc90009a7a000 RSI: 000000000003ffff RDI: 0000000000040000\n  RBP: ffffc90015a673f0 R08: ffffffff81577992 R09: 1ffff92002b4cdb4\n  R10: dffffc0000000000 R11: fffff52002b4cdb5 R12: 0000000000000246\n  R13: dffffc0000000000 R14: ffffffff8e256b80 R15: 0000000000000246\n  FS:  00007fca3f4b46c0(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f167a17b978 CR3: 000000001ed26000 CR4: 0000000000350ef0\n  Call Trace:\n   <TASK>\n   btrfs_get_root_ref+0xa48/0xaf0 fs/btrfs/disk-io.c:1346\n   create_pending_snapshot+0xff2/0x2bc0 fs/btrfs/transaction.c:1837\n   create_pending_snapshots+0x195/0x1d0 fs/btrfs/transaction.c:1931\n   btrfs_commit_transaction+0xf1c/0x3740 fs/btrfs/transaction.c:2404\n   create_snapshot+0x507/0x880 fs/btrfs/ioctl.c:848\n   btrfs_mksubvol+0x5d0/0x750 fs/btrfs/ioctl.c:998\n   btrfs_mksnapshot+0xb5/0xf0 fs/btrfs/ioctl.c:1044\n   __btrfs_ioctl_snap_create+0x387/0x4b0 fs/btrfs/ioctl.c:1306\n   btrfs_ioctl_snap_create_v2+0x1ca/0x400 fs/btrfs/ioctl.c:1393\n   btrfs_ioctl+0xa74/0xd40\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:871 [inline]\n   __se_sys_ioctl+0xfe/0x170 fs/ioctl.c:857\n   do_syscall_64+0xfb/0x240\n   entry_SYSCALL_64_after_hwframe+0x6f/0x77\n  RIP: 0033:0x7fca3e67dda9\n  Code: 28 00 00 00 (...)\n  RSP: 002b:00007fca3f4b40c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 00007fca3e7abf80 RCX: 00007fca3e67dda9\n  RDX: 00000000200005c0 RSI: 0000000050009417 RDI: 0000000000000003\n  RBP: 00007fca3e6ca47a R08: 0000000000000000 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n  R13: 000000000000000b R14: 00007fca3e7abf80 R15: 00007fff6bf95658\n   </TASK>\n\nWhere we get an explicit message where we attempt to free an anonymous\ndevice number that is not currently allocated. It happens in a different\ncode path from the example below, at btrfs_get_root_ref(), so this change\nmay not fix the case triggered by sy\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26793",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gtp: fix use-after-free and null-ptr-deref in gtp_newlink()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngtp: fix use-after-free and null-ptr-deref in gtp_newlink()\n\nThe gtp_link_ops operations structure for the subsystem must be\nregistered after registering the gtp_net_ops pernet operations structure.\n\nSyzkaller hit 'general protection fault in gtp_genl_dump_pdp' bug:\n\n[ 1010.702740] gtp: GTP module unloaded\n[ 1010.715877] general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] SMP KASAN NOPTI\n[ 1010.715888] KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]\n[ 1010.715895] CPU: 1 PID: 128616 Comm: a.out Not tainted 6.8.0-rc6-std-def-alt1 #1\n[ 1010.715899] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-alt1 04/01/2014\n[ 1010.715908] RIP: 0010:gtp_newlink+0x4d7/0x9c0 [gtp]\n[ 1010.715915] Code: 80 3c 02 00 0f 85 41 04 00 00 48 8b bb d8 05 00 00 e8 ed f6 ff ff 48 89 c2 48 89 c5 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 4f 04 00 00 4c 89 e2 4c 8b 6d 00 48 b8 00 00 00\n[ 1010.715920] RSP: 0018:ffff888020fbf180 EFLAGS: 00010203\n[ 1010.715929] RAX: dffffc0000000000 RBX: ffff88800399c000 RCX: 0000000000000000\n[ 1010.715933] RDX: 0000000000000001 RSI: ffffffff84805280 RDI: 0000000000000282\n[ 1010.715938] RBP: 000000000000000d R08: 0000000000000001 R09: 0000000000000000\n[ 1010.715942] R10: 0000000000000001 R11: 0000000000000001 R12: ffff88800399cc80\n[ 1010.715947] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000400\n[ 1010.715953] FS:  00007fd1509ab5c0(0000) GS:ffff88805b300000(0000) knlGS:0000000000000000\n[ 1010.715958] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 1010.715962] CR2: 0000000000000000 CR3: 000000001c07a000 CR4: 0000000000750ee0\n[ 1010.715968] PKRU: 55555554\n[ 1010.715972] Call Trace:\n[ 1010.715985]  ? __die_body.cold+0x1a/0x1f\n[ 1010.715995]  ? die_addr+0x43/0x70\n[ 1010.716002]  ? exc_general_protection+0x199/0x2f0\n[ 1010.716016]  ? asm_exc_general_protection+0x1e/0x30\n[ 1010.716026]  ? gtp_newlink+0x4d7/0x9c0 [gtp]\n[ 1010.716034]  ? gtp_net_exit+0x150/0x150 [gtp]\n[ 1010.716042]  __rtnl_newlink+0x1063/0x1700\n[ 1010.716051]  ? rtnl_setlink+0x3c0/0x3c0\n[ 1010.716063]  ? is_bpf_text_address+0xc0/0x1f0\n[ 1010.716070]  ? kernel_text_address.part.0+0xbb/0xd0\n[ 1010.716076]  ? __kernel_text_address+0x56/0xa0\n[ 1010.716084]  ? unwind_get_return_address+0x5a/0xa0\n[ 1010.716091]  ? create_prof_cpu_mask+0x30/0x30\n[ 1010.716098]  ? arch_stack_walk+0x9e/0xf0\n[ 1010.716106]  ? stack_trace_save+0x91/0xd0\n[ 1010.716113]  ? stack_trace_consume_entry+0x170/0x170\n[ 1010.716121]  ? __lock_acquire+0x15c5/0x5380\n[ 1010.716139]  ? mark_held_locks+0x9e/0xe0\n[ 1010.716148]  ? kmem_cache_alloc_trace+0x35f/0x3c0\n[ 1010.716155]  ? __rtnl_newlink+0x1700/0x1700\n[ 1010.716160]  rtnl_newlink+0x69/0xa0\n[ 1010.716166]  rtnetlink_rcv_msg+0x43b/0xc50\n[ 1010.716172]  ? rtnl_fdb_dump+0x9f0/0x9f0\n[ 1010.716179]  ? lock_acquire+0x1fe/0x560\n[ 1010.716188]  ? netlink_deliver_tap+0x12f/0xd50\n[ 1010.716196]  netlink_rcv_skb+0x14d/0x440\n[ 1010.716202]  ? rtnl_fdb_dump+0x9f0/0x9f0\n[ 1010.716208]  ? netlink_ack+0xab0/0xab0\n[ 1010.716213]  ? netlink_deliver_tap+0x202/0xd50\n[ 1010.716220]  ? netlink_deliver_tap+0x218/0xd50\n[ 1010.716226]  ? __virt_addr_valid+0x30b/0x590\n[ 1010.716233]  netlink_unicast+0x54b/0x800\n[ 1010.716240]  ? netlink_attachskb+0x870/0x870\n[ 1010.716248]  ? __check_object_size+0x2de/0x3b0\n[ 1010.716254]  netlink_sendmsg+0x938/0xe40\n[ 1010.716261]  ? netlink_unicast+0x800/0x800\n[ 1010.716269]  ? __import_iovec+0x292/0x510\n[ 1010.716276]  ? netlink_unicast+0x800/0x800\n[ 1010.716284]  __sock_sendmsg+0x159/0x190\n[ 1010.716290]  ____sys_sendmsg+0x712/0x880\n[ 1010.716297]  ? sock_write_iter+0x3d0/0x3d0\n[ 1010.716304]  ? __ia32_sys_recvmmsg+0x270/0x270\n[ 1010.716309]  ? lock_acquire+0x1fe/0x560\n[ 1010.716315]  ? drain_array_locked+0x90/0x90\n[ 1010.716324]  ___sys_sendmsg+0xf8/0x170\n[ 1010.716331]  ? sendmsg_copy_msghdr+0x170/0x170\n[ 1010.716337]  ? lockdep_init_map\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26852",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/ipv6: avoid possible UAF in ip6_route_mpath_notify()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/ipv6: avoid possible UAF in ip6_route_mpath_notify()\n\nsyzbot found another use-after-free in ip6_route_mpath_notify() [1]\n\nCommit f7225172f25a (\"net/ipv6: prevent use after free in\nip6_route_mpath_notify\") was not able to fix the root cause.\n\nWe need to defer the fib6_info_release() calls after\nip6_route_mpath_notify(), in the cleanup phase.\n\n[1]\nBUG: KASAN: slab-use-after-free in rt6_fill_node+0x1460/0x1ac0\nRead of size 4 at addr ffff88809a07fc64 by task syz-executor.2/23037\n\nCPU: 0 PID: 23037 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-01035-gea7f3cfaa588 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x1e7/0x2e0 lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x167/0x540 mm/kasan/report.c:488\n  kasan_report+0x142/0x180 mm/kasan/report.c:601\n rt6_fill_node+0x1460/0x1ac0\n  inet6_rt_notify+0x13b/0x290 net/ipv6/route.c:6184\n  ip6_route_mpath_notify net/ipv6/route.c:5198 [inline]\n  ip6_route_multipath_add net/ipv6/route.c:5404 [inline]\n  inet6_rtm_newroute+0x1d0f/0x2300 net/ipv6/route.c:5517\n  rtnetlink_rcv_msg+0x885/0x1040 net/core/rtnetlink.c:6597\n  netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543\n  netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]\n  netlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367\n  netlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x221/0x270 net/socket.c:745\n  ____sys_sendmsg+0x525/0x7d0 net/socket.c:2584\n  ___sys_sendmsg net/socket.c:2638 [inline]\n  __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667\n do_syscall_64+0xf9/0x240\n entry_SYSCALL_64_after_hwframe+0x6f/0x77\nRIP: 0033:0x7f73dd87dda9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f73de6550c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f73dd9ac050 RCX: 00007f73dd87dda9\nRDX: 0000000000000000 RSI: 0000000020000140 RDI: 0000000000000005\nRBP: 00007f73dd8ca47a R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000006e R14: 00007f73dd9ac050 R15: 00007ffdbdeb7858\n </TASK>\n\nAllocated by task 23037:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  poison_kmalloc_redzone mm/kasan/common.c:372 [inline]\n  __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:389\n  kasan_kmalloc include/linux/kasan.h:211 [inline]\n  __do_kmalloc_node mm/slub.c:3981 [inline]\n  __kmalloc+0x22e/0x490 mm/slub.c:3994\n  kmalloc include/linux/slab.h:594 [inline]\n  kzalloc include/linux/slab.h:711 [inline]\n  fib6_info_alloc+0x2e/0xf0 net/ipv6/ip6_fib.c:155\n  ip6_route_info_create+0x445/0x12b0 net/ipv6/route.c:3758\n  ip6_route_multipath_add net/ipv6/route.c:5298 [inline]\n  inet6_rtm_newroute+0x744/0x2300 net/ipv6/route.c:5517\n  rtnetlink_rcv_msg+0x885/0x1040 net/core/rtnetlink.c:6597\n  netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543\n  netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]\n  netlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367\n  netlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x221/0x270 net/socket.c:745\n  ____sys_sendmsg+0x525/0x7d0 net/socket.c:2584\n  ___sys_sendmsg net/socket.c:2638 [inline]\n  __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667\n do_syscall_64+0xf9/0x240\n entry_SYSCALL_64_after_hwframe+0x6f/0x77\n\nFreed by task 16:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  kasan_save_free_info+0x4e/0x60 mm/kasan/generic.c:640\n  poison_slab_object+0xa6/0xe0 m\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26865",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: rds: tcp: Fix use-after-free of net in reqsk_timer_handler().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrds: tcp: Fix use-after-free of net in reqsk_timer_handler().\n\nsyzkaller reported a warning of netns tracker [0] followed by KASAN\nsplat [1] and another ref tracker warning [1].\n\nsyzkaller could not find a repro, but in the log, the only suspicious\nsequence was as follows:\n\n  18:26:22 executing program 1:\n  r0 = socket$inet6_mptcp(0xa, 0x1, 0x106)\n  ...\n  connect$inet6(r0, &(0x7f0000000080)={0xa, 0x4001, 0x0, @loopback}, 0x1c) (async)\n\nThe notable thing here is 0x4001 in connect(), which is RDS_TCP_PORT.\n\nSo, the scenario would be:\n\n  1. unshare(CLONE_NEWNET) creates a per netns tcp listener in\n      rds_tcp_listen_init().\n  2. syz-executor connect()s to it and creates a reqsk.\n  3. syz-executor exit()s immediately.\n  4. netns is dismantled.  [0]\n  5. reqsk timer is fired, and UAF happens while freeing reqsk.  [1]\n  6. listener is freed after RCU grace period.  [2]\n\nBasically, reqsk assumes that the listener guarantees netns safety\nuntil all reqsk timers are expired by holding the listener's refcount.\nHowever, this was not the case for kernel sockets.\n\nCommit 740ea3c4a0b2 (\"tcp: Clean up kernel listener's reqsk in\ninet_twsk_purge()\") fixed this issue only for per-netns ehash.\n\nLet's apply the same fix for the global ehash.\n\n[0]:\nref_tracker: net notrefcnt@0000000065449cc3 has 1/1 users at\n     sk_alloc (./include/net/net_namespace.h:337 net/core/sock.c:2146)\n     inet6_create (net/ipv6/af_inet6.c:192 net/ipv6/af_inet6.c:119)\n     __sock_create (net/socket.c:1572)\n     rds_tcp_listen_init (net/rds/tcp_listen.c:279)\n     rds_tcp_init_net (net/rds/tcp.c:577)\n     ops_init (net/core/net_namespace.c:137)\n     setup_net (net/core/net_namespace.c:340)\n     copy_net_ns (net/core/net_namespace.c:497)\n     create_new_namespaces (kernel/nsproxy.c:110)\n     unshare_nsproxy_namespaces (kernel/nsproxy.c:228 (discriminator 4))\n     ksys_unshare (kernel/fork.c:3429)\n     __x64_sys_unshare (kernel/fork.c:3496)\n     do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)\n     entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129)\n...\nWARNING: CPU: 0 PID: 27 at lib/ref_tracker.c:179 ref_tracker_dir_exit (lib/ref_tracker.c:179)\n\n[1]:\nBUG: KASAN: slab-use-after-free in inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966)\nRead of size 8 at addr ffff88801b370400 by task swapper/0/0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1))\n print_report (mm/kasan/report.c:378 mm/kasan/report.c:488)\n kasan_report (mm/kasan/report.c:603)\n inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966)\n reqsk_timer_handler (net/ipv4/inet_connection_sock.c:979 net/ipv4/inet_connection_sock.c:1092)\n call_timer_fn (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/timer.h:127 kernel/time/timer.c:1701)\n __run_timers.part.0 (kernel/time/timer.c:1752 kernel/time/timer.c:2038)\n run_timer_softirq (kernel/time/timer.c:2053)\n __do_softirq (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/irq.h:142 kernel/softirq.c:554)\n irq_exit_rcu (kernel/softirq.c:427 kernel/softirq.c:632 kernel/softirq.c:644)\n sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1076 (discriminator 14))\n </IRQ>\n\nAllocated by task 258 on cpu 0 at 83.612050s:\n kasan_save_stack (mm/kasan/common.c:48)\n kasan_save_track (mm/kasan/common.c:68)\n __kasan_slab_alloc (mm/kasan/common.c:343)\n kmem_cache_alloc (mm/slub.c:3813 mm/slub.c:3860 mm/slub.c:3867)\n copy_net_ns (./include/linux/slab.h:701 net/core/net_namespace.c:421 net/core/net_namespace.c:480)\n create_new_namespaces (kernel/nsproxy.c:110)\n unshare_nsproxy_name\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26882",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: ip_tunnel: make sure to pull inner header in ip_tunnel_rcv()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ip_tunnel: make sure to pull inner header in ip_tunnel_rcv()\n\nApply the same fix than ones found in :\n\n8d975c15c0cd (\"ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()\")\n1ca1ba465e55 (\"geneve: make sure to pull inner header in geneve_rx()\")\n\nWe have to save skb->network_header in a temporary variable\nin order to be able to recompute the network_header pointer\nafter a pskb_inet_may_pull() call.\n\npskb_inet_may_pull() makes sure the needed headers are in skb->head.\n\nsyzbot reported:\nBUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n BUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n BUG: KMSAN: uninit-value in ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n  INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n  IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n  ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __ipgre_rcv+0x9bc/0xbc0 net/ipv4/ip_gre.c:389\n  ipgre_rcv net/ipv4/ip_gre.c:411 [inline]\n  gre_rcv+0x423/0x19f0 net/ipv4/ip_gre.c:447\n  gre_rcv+0x2a4/0x390 net/ipv4/gre_demux.c:163\n  ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254\n  dst_input include/net/dst.h:461 [inline]\n  ip_rcv_finish net/ipv4/ip_input.c:449 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569\n  __netif_receive_skb_one_core net/core/dev.c:5534 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648\n  netif_receive_skb_internal net/core/dev.c:5734 [inline]\n  netif_receive_skb+0x58/0x660 net/core/dev.c:5793\n  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1556\n  tun_get_user+0x53b9/0x66e0 drivers/net/tun.c:2009\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  __alloc_pages+0x9a6/0xe00 mm/page_alloc.c:4590\n  alloc_pages_mpol+0x62b/0x9d0 mm/mempolicy.c:2133\n  alloc_pages+0x1be/0x1e0 mm/mempolicy.c:2204\n  skb_page_frag_refill+0x2bf/0x7c0 net/core/sock.c:2909\n  tun_build_skb drivers/net/tun.c:1686 [inline]\n  tun_get_user+0xe0a/0x66e0 drivers/net/tun.c:1826\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26883",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Fix stackmap overflow check on 32-bit arches",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash buckets, and contains an overflow check by checking if the\nresulting value is 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not account for the UB, so the fix only works on CPUs where an\noverflow does result in a neat truncation to zero, which is not\nguaranteed. Checking the value before rounding does not have this\nproblem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26884",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Fix hashtab overflow check on 32-bit arches",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix hashtab overflow check on 32-bit arches\n\nThe hashtab code relies on roundup_pow_of_two() to compute the number of\nhash buckets, and contains an overflow check by checking if the\nresulting value is 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code. So apply the same\nfix to hashtab, by moving the overflow check to before the roundup.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26885",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Fix DEVMAP_HASH overflow check on 32-bit arches",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix DEVMAP_HASH overflow check on 32-bit arches\n\nThe devmap code allocates a number hash buckets equal to the next power\nof two of the max_entries value provided when creating the map. When\nrounding up to the next power of two, the 32-bit variable storing the\nnumber of buckets can overflow, and the code checks for overflow by\nchecking if the truncated 32-bit value is equal to 0. However, on 32-bit\narches the rounding up itself can overflow mid-way through, because it\nends up doing a left-shift of 32 bits on an unsigned long value. If the\nsize of an unsigned long is four bytes, this is undefined behaviour, so\nthere is no guarantee that we'll end up with a nice and tidy 0-value at\nthe end.\n\nSyzbot managed to turn this into a crash on arm32 by creating a\nDEVMAP_HASH with max_entries > 0x80000000 and then trying to update it.\nFix this by moving the overflow check to before the rounding up\noperation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26895",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: wilc1000: prevent use-after-free on vif when cleaning up all interfaces",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: prevent use-after-free on vif when cleaning up all interfaces\n\nwilc_netdev_cleanup currently triggers a KASAN warning, which can be\nobserved on interface registration error path, or simply by\nremoving the module/unbinding device from driver:\n\necho spi0.1 > /sys/bus/spi/drivers/wilc1000_spi/unbind\n\n==================================================================\nBUG: KASAN: slab-use-after-free in wilc_netdev_cleanup+0x508/0x5cc\nRead of size 4 at addr c54d1ce8 by task sh/86\n\nCPU: 0 PID: 86 Comm: sh Not tainted 6.8.0-rc1+ #117\nHardware name: Atmel SAMA5\n unwind_backtrace from show_stack+0x18/0x1c\n show_stack from dump_stack_lvl+0x34/0x58\n dump_stack_lvl from print_report+0x154/0x500\n print_report from kasan_report+0xac/0xd8\n kasan_report from wilc_netdev_cleanup+0x508/0x5cc\n wilc_netdev_cleanup from wilc_bus_remove+0xc8/0xec\n wilc_bus_remove from spi_remove+0x8c/0xac\n spi_remove from device_release_driver_internal+0x434/0x5f8\n device_release_driver_internal from unbind_store+0xbc/0x108\n unbind_store from kernfs_fop_write_iter+0x398/0x584\n kernfs_fop_write_iter from vfs_write+0x728/0xf88\n vfs_write from ksys_write+0x110/0x1e4\n ksys_write from ret_fast_syscall+0x0/0x1c\n\n[...]\n\nAllocated by task 1:\n kasan_save_track+0x30/0x5c\n __kasan_kmalloc+0x8c/0x94\n __kmalloc_node+0x1cc/0x3e4\n kvmalloc_node+0x48/0x180\n alloc_netdev_mqs+0x68/0x11dc\n alloc_etherdev_mqs+0x28/0x34\n wilc_netdev_ifc_init+0x34/0x8ec\n wilc_cfg80211_init+0x690/0x910\n wilc_bus_probe+0xe0/0x4a0\n spi_probe+0x158/0x1b0\n really_probe+0x270/0xdf4\n __driver_probe_device+0x1dc/0x580\n driver_probe_device+0x60/0x140\n __driver_attach+0x228/0x5d4\n bus_for_each_dev+0x13c/0x1a8\n bus_add_driver+0x2a0/0x608\n driver_register+0x24c/0x578\n do_one_initcall+0x180/0x310\n kernel_init_freeable+0x424/0x484\n kernel_init+0x20/0x148\n ret_from_fork+0x14/0x28\n\nFreed by task 86:\n kasan_save_track+0x30/0x5c\n kasan_save_free_info+0x38/0x58\n __kasan_slab_free+0xe4/0x140\n kfree+0xb0/0x238\n device_release+0xc0/0x2a8\n kobject_put+0x1d4/0x46c\n netdev_run_todo+0x8fc/0x11d0\n wilc_netdev_cleanup+0x1e4/0x5cc\n wilc_bus_remove+0xc8/0xec\n spi_remove+0x8c/0xac\n device_release_driver_internal+0x434/0x5f8\n unbind_store+0xbc/0x108\n kernfs_fop_write_iter+0x398/0x584\n vfs_write+0x728/0xf88\n ksys_write+0x110/0x1e4\n ret_fast_syscall+0x0/0x1c\n [...]\n\nDavid Mosberger-Tan initial investigation [1] showed that this\nuse-after-free is due to netdevice unregistration during vif list\ntraversal. When unregistering a net device, since the needs_free_netdev has\nbeen set to true during registration, the netdevice object is also freed,\nand as a consequence, the corresponding vif object too, since it is\nattached to it as private netdevice data. The next occurrence of the loop\nthen tries to access freed vif pointer to the list to move forward in the\nlist.\n\nFix this use-after-free thanks to two mechanisms:\n- navigate in the list with list_for_each_entry_safe, which allows to\n  safely modify the list as we go through each element. For each element,\n  remove it from the list with list_del_rcu\n- make sure to wait for RCU grace period end after each vif removal to make\n  sure it is safe to free the corresponding vif too (through\n  unregister_netdev)\n\nSince we are in a RCU \"modifier\" path (not a \"reader\" path), and because\nsuch path is expected not to be concurrent to any other modifier (we are\nusing the vif_mutex lock), we do not need to use RCU list API, that's why\nwe can benefit from list_for_each_entry_safe.\n\n[1] https://lore.kernel.org/linux-wireless/ab077dbe58b1ea5de0a3b2ca21f275a07af967d2.camel@egauge.net/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26898",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: aoe: fix the potential use-after-free problem in aoecmd_cfg_pkts",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naoe: fix the potential use-after-free problem in aoecmd_cfg_pkts\n\nThis patch is against CVE-2023-6270. The description of cve is:\n\n  A flaw was found in the ATA over Ethernet (AoE) driver in the Linux\n  kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on\n  `struct net_device`, and a use-after-free can be triggered by racing\n  between the free on the struct and the access through the `skbtxq`\n  global queue. This could lead to a denial of service condition or\n  potential code execution.\n\nIn aoecmd_cfg_pkts(), it always calls dev_put(ifp) when skb initial\ncode is finished. But the net_device ifp will still be used in\nlater tx()->dev_queue_xmit() in kthread. Which means that the\ndev_put(ifp) should NOT be called in the success path of skb\ninitial code in aoecmd_cfg_pkts(). Otherwise tx() may run into\nuse-after-free because the net_device is freed.\n\nThis patch removed the dev_put(ifp) in the success path in\naoecmd_cfg_pkts(), and added dev_put() after skb xmit in tx().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26907",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/mlx5: Fix fortify source warning while accessing Eth segment",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx5: Fix fortify source warning while accessing Eth segment\n\n ------------[ cut here ]------------\n memcpy: detected field-spanning write (size 56) of single field \"eseg->inline_hdr.start\" at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 (size 2)\n WARNING: CPU: 0 PID: 293779 at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Modules linked in: 8021q garp mrp stp llc rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) ib_uverbs(OE) ib_core(OE) mlx5_core(OE) pci_hyperv_intf mlxdevm(OE) mlx_compat(OE) tls mlxfw(OE) psample nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink mst_pciconf(OE) knem(OE) vfio_pci vfio_pci_core vfio_iommu_type1 vfio iommufd irqbypass cuse nfsv3 nfs fscache netfs xfrm_user xfrm_algo ipmi_devintf ipmi_msghandler binfmt_misc crct10dif_pclmul crc32_pclmul polyval_clmulni polyval_generic ghash_clmulni_intel sha512_ssse3 snd_pcsp aesni_intel crypto_simd cryptd snd_pcm snd_timer joydev snd soundcore input_leds serio_raw evbug nfsd auth_rpcgss nfs_acl lockd grace sch_fq_codel sunrpc drm efi_pstore ip_tables x_tables autofs4 psmouse virtio_net net_failover failover floppy\n  [last unloaded: mlx_compat(OE)]\n CPU: 0 PID: 293779 Comm: ssh Tainted: G           OE      6.2.0-32-generic #32~22.04.1-Ubuntu\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Code: 0c 01 00 a8 01 75 25 48 8b 75 a0 b9 02 00 00 00 48 c7 c2 10 5b fd c0 48 c7 c7 80 5b fd c0 c6 05 57 0c 03 00 01 e8 95 4d 93 da <0f> 0b 44 8b 4d b0 4c 8b 45 c8 48 8b 4d c0 e9 49 fb ff ff 41 0f b7\n RSP: 0018:ffffb5b48478b570 EFLAGS: 00010046\n RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffffb5b48478b628 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000000 R12: ffffb5b48478b5e8\n R13: ffff963a3c609b5e R14: ffff9639c3fbd800 R15: ffffb5b480475a80\n FS:  00007fc03b444c80(0000) GS:ffff963a3dc00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000556f46bdf000 CR3: 0000000006ac6003 CR4: 00000000003706f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <TASK>\n  ? show_regs+0x72/0x90\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? __warn+0x8d/0x160\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? report_bug+0x1bb/0x1d0\n  ? handle_bug+0x46/0x90\n  ? exc_invalid_op+0x19/0x80\n  ? asm_exc_invalid_op+0x1b/0x20\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  mlx5_ib_post_send_nodrain+0xb/0x20 [mlx5_ib]\n  ipoib_send+0x2ec/0x770 [ib_ipoib]\n  ipoib_start_xmit+0x5a0/0x770 [ib_ipoib]\n  dev_hard_start_xmit+0x8e/0x1e0\n  ? validate_xmit_skb_list+0x4d/0x80\n  sch_direct_xmit+0x116/0x3a0\n  __dev_xmit_skb+0x1fd/0x580\n  __dev_queue_xmit+0x284/0x6b0\n  ? _raw_spin_unlock_irq+0xe/0x50\n  ? __flush_work.isra.0+0x20d/0x370\n  ? push_pseudo_header+0x17/0x40 [ib_ipoib]\n  neigh_connected_output+0xcd/0x110\n  ip_finish_output2+0x179/0x480\n  ? __smp_call_single_queue+0x61/0xa0\n  __ip_finish_output+0xc3/0x190\n  ip_finish_output+0x2e/0xf0\n  ip_output+0x78/0x110\n  ? __pfx_ip_finish_output+0x10/0x10\n  ip_local_out+0x64/0x70\n  __ip_queue_xmit+0x18a/0x460\n  ip_queue_xmit+0x15/0x30\n  __tcp_transmit_skb+0x914/0x9c0\n  tcp_write_xmit+0x334/0x8d0\n  tcp_push_one+0x3c/0x60\n  tcp_sendmsg_locked+0x2e1/0xac0\n  tcp_sendmsg+0x2d/0x50\n  inet_sendmsg+0x43/0x90\n  sock_sendmsg+0x68/0x80\n  sock_write_iter+0x93/0x100\n  vfs_write+0x326/0x3c0\n  ksys_write+0xbd/0xf0\n  ? do_syscall_64+0x69/0x90\n  __x64_sys_write+0x19/0x30\n  do_syscall_\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26913",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix dcn35 8k30 Underflow/Corruption Issue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix dcn35 8k30 Underflow/Corruption Issue\n\n[why]\nodm calculation is missing for pipe split policy determination\nand cause Underflow/Corruption issue.\n\n[how]\nAdd the odm calculation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26914",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: fix incorrect mpc_combine array size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: fix incorrect mpc_combine array size\n\n[why]\nMAX_SURFACES is per stream, while MAX_PLANES is per asic. The\nmpc_combine is an array that records all the planes per asic. Therefore\nMAX_PLANES should be used as the array size. Using MAX_SURFACES causes\narray overflow when there are more than 3 planes.\n\n[how]\nUse the MAX_PLANES for the mpc_combine array size.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26923",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: af_unix: Fix garbage collector racing against connect()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix garbage collector racing against connect()\n\nGarbage collector does not take into account the risk of embryo getting\nenqueued during the garbage collection. If such embryo has a peer that\ncarries SCM_RIGHTS, two consecutive passes of scan_children() may see a\ndifferent set of children. Leading to an incorrectly elevated inflight\ncount, and then a dangling pointer within the gc_inflight_list.\n\nsockets are AF_UNIX/SOCK_STREAM\nS is an unconnected socket\nL is a listening in-flight socket bound to addr, not in fdtable\nV's fd will be passed via sendmsg(), gets inflight count bumped\n\nconnect(S, addr)\tsendmsg(S, [V]); close(V)\t__unix_gc()\n----------------\t-------------------------\t-----------\n\nNS = unix_create1()\nskb1 = sock_wmalloc(NS)\nL = unix_find_other(addr)\nunix_state_lock(L)\nunix_peer(S) = NS\n\t\t\t// V count=1 inflight=0\n\n \t\t\tNS = unix_peer(S)\n \t\t\tskb2 = sock_alloc()\n\t\t\tskb_queue_tail(NS, skb2[V])\n\n\t\t\t// V became in-flight\n\t\t\t// V count=2 inflight=1\n\n\t\t\tclose(V)\n\n\t\t\t// V count=1 inflight=1\n\t\t\t// GC candidate condition met\n\n\t\t\t\t\t\tfor u in gc_inflight_list:\n\t\t\t\t\t\t  if (total_refs == inflight_refs)\n\t\t\t\t\t\t    add u to gc_candidates\n\n\t\t\t\t\t\t// gc_candidates={L, V}\n\n\t\t\t\t\t\tfor u in gc_candidates:\n\t\t\t\t\t\t  scan_children(u, dec_inflight)\n\n\t\t\t\t\t\t// embryo (skb1) was not\n\t\t\t\t\t\t// reachable from L yet, so V's\n\t\t\t\t\t\t// inflight remains unchanged\n__skb_queue_tail(L, skb1)\nunix_state_unlock(L)\n\t\t\t\t\t\tfor u in gc_candidates:\n\t\t\t\t\t\t  if (u.inflight)\n\t\t\t\t\t\t    scan_children(u, inc_inflight_move_tail)\n\n\t\t\t\t\t\t// V count=1 inflight=2 (!)\n\nIf there is a GC-candidate listening socket, lock/unlock its state. This\nmakes GC wait until the end of any ongoing connect() to that socket. After\nflipping the lock, a possibly SCM-laden embryo is already enqueued. And if\nthere is another embryo coming, it can not possibly carry SCM_RIGHTS. At\nthis point, unix_inflight() can not happen because unix_gc_lock is already\ntaken. Inflight graph remains unaffected.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26925",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: release mutex after nft_gc_seq_end from abort path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: release mutex after nft_gc_seq_end from abort path\n\nThe commit mutex should not be released during the critical section\nbetween nft_gc_seq_begin() and nft_gc_seq_end(), otherwise, async GC\nworker could collect expired objects and get the released commit lock\nwithin the same GC sequence.\n\nnf_tables_module_autoload() temporarily releases the mutex to load\nmodule dependencies, then it goes back to replay the transaction again.\nMove it at the end of the abort phase after nft_gc_seq_end() is called.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26928",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: potential use-after-free in cifs_debug_files_proc_show()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in cifs_debug_files_proc_show()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26930",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: qla2xxx: Fix double free of the ha-&gt;vp_map pointer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix double free of the ha->vp_map pointer\n\nCoverity scan reported potential risk of double free of the pointer\nha->vp_map.  ha->vp_map was freed in qla2x00_mem_alloc(), and again freed\nin function qla2x00_mem_free(ha).\n\nAssign NULL to vp_map and kfree take care of NULL.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26934",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: USB: core: Fix deadlock in usb_deauthorize_interface()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: core: Fix deadlock in usb_deauthorize_interface()\n\nAmong the attribute file callback routines in\ndrivers/usb/core/sysfs.c, the interface_authorized_store() function is\nthe only one which acquires a device lock on an ancestor device: It\ncalls usb_deauthorize_interface(), which locks the interface's parent\nUSB device.\n\nThe will lead to deadlock if another process already owns that lock\nand tries to remove the interface, whether through a configuration\nchange or because the device has been disconnected.  As part of the\nremoval procedure, device_del() waits for all ongoing sysfs attribute\ncallbacks to complete.  But usb_deauthorize_interface() can't complete\nuntil the device lock has been released, and the lock won't be\nreleased until the removal has finished.\n\nThe mechanism provided by sysfs to prevent this kind of deadlock is\nto use the sysfs_break_active_protection() function, which tells sysfs\nnot to wait for the attribute callback.\n\nReported-and-tested by: Yue Sun <samsun1006219@gmail.com>\nReported by: xingwei lee <xrivendell7@gmail.com>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26957",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: s390/zcrypt: fix reference counting on zcrypt card objects",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/zcrypt: fix reference counting on zcrypt card objects\n\nTests with hot-plugging crytpo cards on KVM guests with debug\nkernel build revealed an use after free for the load field of\nthe struct zcrypt_card. The reason was an incorrect reference\nhandling of the zcrypt card object which could lead to a free\nof the zcrypt card object while it was still in use.\n\nThis is an example of the slab message:\n\n    kernel: 0x00000000885a7512-0x00000000885a7513 @offset=1298. First byte 0x68 instead of 0x6b\n    kernel: Allocated in zcrypt_card_alloc+0x36/0x70 [zcrypt] age=18046 cpu=3 pid=43\n    kernel:  kmalloc_trace+0x3f2/0x470\n    kernel:  zcrypt_card_alloc+0x36/0x70 [zcrypt]\n    kernel:  zcrypt_cex4_card_probe+0x26/0x380 [zcrypt_cex4]\n    kernel:  ap_device_probe+0x15c/0x290\n    kernel:  really_probe+0xd2/0x468\n    kernel:  driver_probe_device+0x40/0xf0\n    kernel:  __device_attach_driver+0xc0/0x140\n    kernel:  bus_for_each_drv+0x8c/0xd0\n    kernel:  __device_attach+0x114/0x198\n    kernel:  bus_probe_device+0xb4/0xc8\n    kernel:  device_add+0x4d2/0x6e0\n    kernel:  ap_scan_adapter+0x3d0/0x7c0\n    kernel:  ap_scan_bus+0x5a/0x3b0\n    kernel:  ap_scan_bus_wq_callback+0x40/0x60\n    kernel:  process_one_work+0x26e/0x620\n    kernel:  worker_thread+0x21c/0x440\n    kernel: Freed in zcrypt_card_put+0x54/0x80 [zcrypt] age=9024 cpu=3 pid=43\n    kernel:  kfree+0x37e/0x418\n    kernel:  zcrypt_card_put+0x54/0x80 [zcrypt]\n    kernel:  ap_device_remove+0x4c/0xe0\n    kernel:  device_release_driver_internal+0x1c4/0x270\n    kernel:  bus_remove_device+0x100/0x188\n    kernel:  device_del+0x164/0x3c0\n    kernel:  device_unregister+0x30/0x90\n    kernel:  ap_scan_adapter+0xc8/0x7c0\n    kernel:  ap_scan_bus+0x5a/0x3b0\n    kernel:  ap_scan_bus_wq_callback+0x40/0x60\n    kernel:  process_one_work+0x26e/0x620\n    kernel:  worker_thread+0x21c/0x440\n    kernel:  kthread+0x150/0x168\n    kernel:  __ret_from_fork+0x3c/0x58\n    kernel:  ret_from_fork+0xa/0x30\n    kernel: Slab 0x00000372022169c0 objects=20 used=18 fp=0x00000000885a7c88 flags=0x3ffff00000000a00(workingset|slab|node=0|zone=1|lastcpupid=0x1ffff)\n    kernel: Object 0x00000000885a74b8 @offset=1208 fp=0x00000000885a7c88\n    kernel: Redzone  00000000885a74b0: bb bb bb bb bb bb bb bb                          ........\n    kernel: Object   00000000885a74b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74d8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74e8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a74f8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n    kernel: Object   00000000885a7508: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 68 4b 6b 6b 6b a5  kkkkkkkkkkhKkkk.\n    kernel: Redzone  00000000885a7518: bb bb bb bb bb bb bb bb                          ........\n    kernel: Padding  00000000885a756c: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a              ZZZZZZZZZZZZ\n    kernel: CPU: 0 PID: 387 Comm: systemd-udevd Not tainted 6.8.0-HF #2\n    kernel: Hardware name: IBM 3931 A01 704 (KVM/Linux)\n    kernel: Call Trace:\n    kernel:  [<00000000ca5ab5b8>] dump_stack_lvl+0x90/0x120\n    kernel:  [<00000000c99d78bc>] check_bytes_and_report+0x114/0x140\n    kernel:  [<00000000c99d53cc>] check_object+0x334/0x3f8\n    kernel:  [<00000000c99d820c>] alloc_debug_processing+0xc4/0x1f8\n    kernel:  [<00000000c99d852e>] get_partial_node.part.0+0x1ee/0x3e0\n    kernel:  [<00000000c99d94ec>] ___slab_alloc+0xaf4/0x13c8\n    kernel:  [<00000000c99d9e38>] __slab_alloc.constprop.0+0x78/0xb8\n    kernel:  [<00000000c99dc8dc>] __kmalloc+0x434/0x590\n    kernel:  [<00000000c9b4c0ce>] ext4_htree_store_dirent+0x4e/0x1c0\n    kernel:  [<00000000c9b908a2>] htree_dirblock_to_tree+0x17a/0x3f0\n    kernel: \n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26958",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfs: fix UAF in direct writes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfs: fix UAF in direct writes\n\nIn production we have been hitting the following warning consistently\n\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 17 PID: 1800359 at lib/refcount.c:28 refcount_warn_saturate+0x9c/0xe0\nWorkqueue: nfsiod nfs_direct_write_schedule_work [nfs]\nRIP: 0010:refcount_warn_saturate+0x9c/0xe0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __warn+0x9f/0x130\n ? refcount_warn_saturate+0x9c/0xe0\n ? report_bug+0xcc/0x150\n ? handle_bug+0x3d/0x70\n ? exc_invalid_op+0x16/0x40\n ? asm_exc_invalid_op+0x16/0x20\n ? refcount_warn_saturate+0x9c/0xe0\n nfs_direct_write_schedule_work+0x237/0x250 [nfs]\n process_one_work+0x12f/0x4a0\n worker_thread+0x14e/0x3b0\n ? ZSTD_getCParams_internal+0x220/0x220\n kthread+0xdc/0x120\n ? __btf_name_valid+0xa0/0xa0\n ret_from_fork+0x1f/0x30\n\nThis is because we're completing the nfs_direct_request twice in a row.\n\nThe source of this is when we have our commit requests to submit, we\nprocess them and send them off, and then in the completion path for the\ncommit requests we have\n\nif (nfs_commit_end(cinfo.mds))\n\tnfs_direct_write_complete(dreq);\n\nHowever since we're submitting asynchronous requests we sometimes have\none that completes before we submit the next one, so we end up calling\ncomplete on the nfs_direct_request twice.\n\nThe only other place we use nfs_generic_commit_list() is in\n__nfs_commit_inode, which wraps this call in a\n\nnfs_commit_begin();\nnfs_commit_end();\n\nWhich is a common pattern for this style of completion handling, one\nthat is also repeated in the direct code with get_dreq()/put_dreq()\ncalls around where we process events as well as in the completion paths.\n\nFix this by using the same pattern for the commit requests.\n\nBefore with my 200 node rocksdb stress running this warning would pop\nevery 10ish minutes.  With my patch the stress test has been running for\nseveral hours without popping.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26961",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mac802154: fix llsec key resources release in mac802154_llsec_key_del",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac802154: fix llsec key resources release in mac802154_llsec_key_del\n\nmac802154_llsec_key_del() can free resources of a key directly without\nfollowing the RCU rules for waiting before the end of a grace period. This\nmay lead to use-after-free in case llsec_lookup_key() is traversing the\nlist of keys in parallel with a key deletion:\n\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 4 PID: 16000 at lib/refcount.c:25 refcount_warn_saturate+0x162/0x2a0\nModules linked in:\nCPU: 4 PID: 16000 Comm: wpan-ping Not tainted 6.7.0 #19\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\nRIP: 0010:refcount_warn_saturate+0x162/0x2a0\nCall Trace:\n <TASK>\n llsec_lookup_key.isra.0+0x890/0x9e0\n mac802154_llsec_encrypt+0x30c/0x9c0\n ieee802154_subif_start_xmit+0x24/0x1e0\n dev_hard_start_xmit+0x13e/0x690\n sch_direct_xmit+0x2ae/0xbc0\n __dev_queue_xmit+0x11dd/0x3c20\n dgram_sendmsg+0x90b/0xd60\n __sys_sendto+0x466/0x4c0\n __x64_sys_sendto+0xe0/0x1c0\n do_syscall_64+0x45/0xf0\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\n\nAlso, ieee802154_llsec_key_entry structures are not freed by\nmac802154_llsec_key_del():\n\nunreferenced object 0xffff8880613b6980 (size 64):\n  comm \"iwpan\", pid 2176, jiffies 4294761134 (age 60.475s)\n  hex dump (first 32 bytes):\n    78 0d 8f 18 80 88 ff ff 22 01 00 00 00 00 ad de  x.......\".......\n    00 00 00 00 00 00 00 00 03 00 cd ab 00 00 00 00  ................\n  backtrace:\n    [<ffffffff81dcfa62>] __kmem_cache_alloc_node+0x1e2/0x2d0\n    [<ffffffff81c43865>] kmalloc_trace+0x25/0xc0\n    [<ffffffff88968b09>] mac802154_llsec_key_add+0xac9/0xcf0\n    [<ffffffff8896e41a>] ieee802154_add_llsec_key+0x5a/0x80\n    [<ffffffff8892adc6>] nl802154_add_llsec_key+0x426/0x5b0\n    [<ffffffff86ff293e>] genl_family_rcv_msg_doit+0x1fe/0x2f0\n    [<ffffffff86ff46d1>] genl_rcv_msg+0x531/0x7d0\n    [<ffffffff86fee7a9>] netlink_rcv_skb+0x169/0x440\n    [<ffffffff86ff1d88>] genl_rcv+0x28/0x40\n    [<ffffffff86fec15c>] netlink_unicast+0x53c/0x820\n    [<ffffffff86fecd8b>] netlink_sendmsg+0x93b/0xe60\n    [<ffffffff86b91b35>] ____sys_sendmsg+0xac5/0xca0\n    [<ffffffff86b9c3dd>] ___sys_sendmsg+0x11d/0x1c0\n    [<ffffffff86b9c65a>] __sys_sendmsg+0xfa/0x1d0\n    [<ffffffff88eadbf5>] do_syscall_64+0x45/0xf0\n    [<ffffffff890000ea>] entry_SYSCALL_64_after_hwframe+0x6e/0x76\n\nHandle the proper resource release in the RCU callback function\nmac802154_llsec_key_del_rcu().\n\nNote that if llsec_lookup_key() finds a key, it gets a refcount via\nllsec_key_get() and locally copies key id from key_entry (which is a\nlist element). So it's safe to call llsec_key_put() and free the list\nentry after the RCU grace period elapses.\n\nFound by Linux Verification Center (linuxtesting.org).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26974",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: qat - resolve race condition during AER recovery",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: qat - resolve race condition during AER recovery\n\nDuring the PCI AER system's error recovery process, the kernel driver\nmay encounter a race condition with freeing the reset_data structure's\nmemory. If the device restart will take more than 10 seconds the function\nscheduling that restart will exit due to a timeout, and the reset_data\nstructure will be freed. However, this data structure is used for\ncompletion notification after the restart is completed, which leads\nto a UAF bug.\n\nThis results in a KFENCE bug notice.\n\n  BUG: KFENCE: use-after-free read in adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  Use-after-free read at 0x00000000bc56fddf (in kfence-#142):\n  adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  process_one_work+0x173/0x340\n\nTo resolve this race condition, the memory associated to the container\nof the work_struct is freed on the worker if the timeout expired,\notherwise on the function that schedules the worker.\nThe timeout detection can be done by checking if the caller is\nstill waiting for completion or not by using completion_done() function.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26981",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix OOB in nilfs_set_de_type",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix OOB in nilfs_set_de_type\n\nThe size of the nilfs_type_by_mode array in the fs/nilfs2/dir.c file is\ndefined as \"S_IFMT >> S_SHIFT\", but the nilfs_set_de_type() function,\nwhich uses this array, specifies the index to read from the array in the\nsame way as \"(mode & S_IFMT) >> S_SHIFT\".\n\nstatic void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode\n *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\tde->file_type = nilfs_type_by_mode[(mode & S_IFMT)>>S_SHIFT]; // oob\n}\n\nHowever, when the index is determined this way, an out-of-bounds (OOB)\nerror occurs by referring to an index that is 1 larger than the array size\nwhen the condition \"mode & S_IFMT == S_IFMT\" is satisfied.  Therefore, a\npatch to resize the nilfs_type_by_mode array should be applied to prevent\nOOB errors.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26982",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Squashfs: check the inode number is not the invalid value of zero",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: check the inode number is not the invalid value of zero\n\nSyskiller has produced an out of bounds access in fill_meta_index().\n\nThat out of bounds access is ultimately caused because the inode\nhas an inode number with the invalid value of zero, which was not checked.\n\nThe reason this causes the out of bounds access is due to following\nsequence of events:\n\n1. Fill_meta_index() is called to allocate (via empty_meta_index())\n   and fill a metadata index.  It however suffers a data read error\n   and aborts, invalidating the newly returned empty metadata index.\n   It does this by setting the inode number of the index to zero,\n   which means unused (zero is not a valid inode number).\n\n2. When fill_meta_index() is subsequently called again on another\n   read operation, locate_meta_index() returns the previous index\n   because it matches the inode number of 0.  Because this index\n   has been returned it is expected to have been filled, and because\n   it hasn't been, an out of bounds access is performed.\n\nThis patch adds a sanity check which checks that the inode number\nis not zero when the inode is created and returns -EINVAL if it is.\n\n[phillip@squashfs.org.uk: whitespace fix]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-26996",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: gadget: f_ncm: Fix UAF ncm object at re-bind after usb ep transport error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_ncm: Fix UAF ncm object at re-bind after usb ep transport error\n\nWhen ncm function is working and then stop usb0 interface for link down,\neth_stop() is called. At this piont, accidentally if usb transport error\nshould happen in usb_ep_enable(), 'in_ep' and/or 'out_ep' may not be enabled.\n\nAfter that, ncm_disable() is called to disable for ncm unbind\nbut gether_disconnect() is never called since 'in_ep' is not enabled.\n\nAs the result, ncm object is released in ncm unbind\nbut 'dev->port_usb' associated to 'ncm->port' is not NULL.\n\nAnd when ncm bind again to recover netdev, ncm object is reallocated\nbut usb0 interface is already associated to previous released ncm object.\n\nTherefore, once usb0 interface is up and eth_start_xmit() is called,\nreleased ncm object is dereferrenced and it might cause use-after-free memory.\n\n[function unlink via configfs]\n  usb0: eth_stop dev->port_usb=ffffff9b179c3200\n  --> error happens in usb_ep_enable().\n  NCM: ncm_disable: ncm=ffffff9b179c3200\n  --> no gether_disconnect() since ncm->port.in_ep->enabled is false.\n  NCM: ncm_unbind: ncm unbind ncm=ffffff9b179c3200\n  NCM: ncm_free: ncm free ncm=ffffff9b179c3200   <-- released ncm\n\n[function link via configfs]\n  NCM: ncm_alloc: ncm alloc ncm=ffffff9ac4f8a000\n  NCM: ncm_bind: ncm bind ncm=ffffff9ac4f8a000\n  NCM: ncm_set_alt: ncm=ffffff9ac4f8a000 alt=0\n  usb0: eth_open dev->port_usb=ffffff9b179c3200  <-- previous released ncm\n  usb0: eth_start dev->port_usb=ffffff9b179c3200 <--\n  eth_start_xmit()\n  --> dev->wrap()\n  Unable to handle kernel paging request at virtual address dead00000000014f\n\nThis patch addresses the issue by checking if 'ncm->netdev' is not NULL at\nncm_disable() to call gether_disconnect() to deassociate 'dev->port_usb'.\nIt's more reasonable to check 'ncm->netdev' to call gether_connect/disconnect\nrather than check 'ncm->port.in_ep->enabled' since it might not be enabled\nbut the gether connection might be established.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27020",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: Fix potential data-race in __nft_expr_type_get()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: Fix potential data-race in __nft_expr_type_get()\n\nnft_unregister_expr() can concurrent with __nft_expr_type_get(),\nand there is not any protection when iterate over nf_tables_expressions\nlist in __nft_expr_type_get(). Therefore, there is potential data-race\nof nf_tables_expressions list entry.\n\nUse list_for_each_entry_rcu() to iterate over nf_tables_expressions\nlist in __nft_expr_type_get(), and use rcu_read_lock() in the caller\nnft_expr_type_get() to protect the entire type query process.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27024",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/rds: fix WARNING in rds_conn_connect_if_down",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/rds: fix WARNING in rds_conn_connect_if_down\n\nIf connection isn't established yet, get_mr() will fail, trigger connection after\nget_mr().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27043",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: edia: dvbdev: fix a use-after-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: edia: dvbdev: fix a use-after-free\n\nIn dvb_register_device, *pdvbdev is set equal to dvbdev, which is freed\nin several error-handling paths. However, *pdvbdev is not set to NULL\nafter dvbdev's deallocation, causing use-after-frees in many places,\nfor example, in the following call chain:\n\nbudget_register\n  |-> dvb_dmxdev_init\n        |-> dvb_register_device\n  |-> dvb_dmxdev_release\n        |-> dvb_unregister_device\n              |-> dvb_remove_device\n                    |-> dvb_device_put\n                          |-> kref_put\n\nWhen calling dvb_unregister_device, dmxdev->dvbdev (i.e. *pdvbdev in\ndvb_register_device) could point to memory that had been freed in\ndvb_register_device. Thereafter, this pointer is transferred to\nkref_put and triggering a use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27045",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix a potential buffer overflow in &#39;dp_dsc_clock_en_read()&#39;",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix a potential buffer overflow in 'dp_dsc_clock_en_read()'\n\nTell snprintf() to store at most 10 bytes in the output buffer\ninstead of 30.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_debugfs.c:1508 dp_dsc_clock_en_read() error: snprintf() is printing too much 30 vs 10",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27395",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: openvswitch: Fix Use-After-Free in ovs_ct_exit",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: Fix Use-After-Free in ovs_ct_exit\n\nSince kfree_rcu, which is called in the hlist_for_each_entry_rcu traversal\nof ovs_ct_limit_exit, is not part of the RCU read critical section, it\nis possible that the RCU grace period will pass during the traversal and\nthe key will be free.\n\nTo prevent this, it should be changed to hlist_for_each_entry_safe.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27396",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: gtp: Fix Use-After-Free in gtp_dellink",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: gtp: Fix Use-After-Free in gtp_dellink\n\nSince call_rcu, which is called in the hlist_for_each_entry_rcu traversal\nof gtp_dellink, is not part of the RCU read critical section, it\nis possible that the RCU grace period will pass during the traversal and\nthe key will be free.\n\nTo prevent this, it should be changed to hlist_for_each_entry_safe.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-27397",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: use timestamp to check for set element timeout",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: use timestamp to check for set element timeout\n\nAdd a timestamp field at the beginning of the transaction, store it\nin the nftables per-netns area.\n\nUpdate set backend .insert, .deactivate and sync gc path to use the\ntimestamp, this avoids that an element expires while control plane\ntransaction is still unfinished.\n\n.lookup and .update, which are used from packet path, still use the\ncurrent time to check if the element has expired. And .get path and dump\nalso since this runs lockless under rcu read size lock. Then, there is\nasync gc which also needs to check the current time since it runs\nasynchronously from a workqueue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35847",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: irqchip/gic-v3-its: Prevent double free on error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/gic-v3-its: Prevent double free on error\n\nThe error handling path in its_vpe_irq_domain_alloc() causes a double free\nwhen its_vpe_init() fails after successfully allocating at least one\ninterrupt. This happens because its_vpe_irq_domain_free() frees the\ninterrupts along with the area bitmap and the vprop_page and\nits_vpe_irq_domain_alloc() subsequently frees the area bitmap and the\nvprop_page again.\n\nFix this by unconditionally invoking its_vpe_irq_domain_free() which\nhandles all cases correctly and by removing the bitmap/vprop_page freeing\nfrom its_vpe_irq_domain_alloc().\n\n[ tglx: Massaged change log ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35849",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: fix information leak in btrfs_ioctl_logical_to_ino()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix information leak in btrfs_ioctl_logical_to_ino()\n\nSyzbot reported the following information leak for in\nbtrfs_ioctl_logical_to_ino():\n\n  BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  BUG: KMSAN: kernel-infoleak in _copy_to_user+0xbc/0x110 lib/usercopy.c:40\n   instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n   _copy_to_user+0xbc/0x110 lib/usercopy.c:40\n   copy_to_user include/linux/uaccess.h:191 [inline]\n   btrfs_ioctl_logical_to_ino+0x440/0x750 fs/btrfs/ioctl.c:3499\n   btrfs_ioctl+0x714/0x1260\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:904 [inline]\n   __se_sys_ioctl+0x261/0x450 fs/ioctl.c:890\n   __x64_sys_ioctl+0x96/0xe0 fs/ioctl.c:890\n   x64_sys_call+0x1883/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:17\n   do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n   do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n  Uninit was created at:\n   __kmalloc_large_node+0x231/0x370 mm/slub.c:3921\n   __do_kmalloc_node mm/slub.c:3954 [inline]\n   __kmalloc_node+0xb07/0x1060 mm/slub.c:3973\n   kmalloc_node include/linux/slab.h:648 [inline]\n   kvmalloc_node+0xc0/0x2d0 mm/util.c:634\n   kvmalloc include/linux/slab.h:766 [inline]\n   init_data_container+0x49/0x1e0 fs/btrfs/backref.c:2779\n   btrfs_ioctl_logical_to_ino+0x17c/0x750 fs/btrfs/ioctl.c:3480\n   btrfs_ioctl+0x714/0x1260\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:904 [inline]\n   __se_sys_ioctl+0x261/0x450 fs/ioctl.c:890\n   __x64_sys_ioctl+0x96/0xe0 fs/ioctl.c:890\n   x64_sys_call+0x1883/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:17\n   do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n   do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n  Bytes 40-65535 of 65536 are uninitialized\n  Memory access of size 65536 starts at ffff888045a40000\n\nThis happens, because we're copying a 'struct btrfs_data_container' back\nto user-space. This btrfs_data_container is allocated in\n'init_data_container()' via kvmalloc(), which does not zero-fill the\nmemory.\n\nFix this by using kvzalloc() which zeroes out the memory on allocation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35855",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mlxsw: spectrum_acl_tcam: Fix possible use-after-free during activity update",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix possible use-after-free during activity update\n\nThe rule activity update delayed work periodically traverses the list of\nconfigured rules and queries their activity from the device.\n\nAs part of this task it accesses the entry pointed by 'ventry->entry',\nbut this entry can be changed concurrently by the rehash delayed work,\nleading to a use-after-free [1].\n\nFix by closing the race and perform the activity query under the\n'vregion->lock' mutex.\n\n[1]\nBUG: KASAN: slab-use-after-free in mlxsw_sp_acl_tcam_flower_rule_activity_get+0x121/0x140\nRead of size 8 at addr ffff8881054ed808 by task kworker/0:18/181\n\nCPU: 0 PID: 181 Comm: kworker/0:18 Not tainted 6.9.0-rc2-custom-00781-gd5ab772d32f7 #2\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_rule_activity_update_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0xc6/0x120\n print_report+0xce/0x670\n kasan_report+0xd7/0x110\n mlxsw_sp_acl_tcam_flower_rule_activity_get+0x121/0x140\n mlxsw_sp_acl_rule_activity_update_work+0x219/0x400\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 1039:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x8f/0xa0\n __kmalloc+0x19c/0x360\n mlxsw_sp_acl_tcam_entry_create+0x7b/0x1f0\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x30d/0xb50\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n\nFreed by task 1039:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n poison_slab_object+0x102/0x170\n __kasan_slab_free+0x14/0x30\n kfree+0xc1/0x290\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x3d7/0xb50\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35861",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in cifs_signal_cifsd_for_reconnect()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in cifs_signal_cifsd_for_reconnect()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35862",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in smb2_is_network_name_deleted()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in smb2_is_network_name_deleted()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35863",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in is_valid_oplock_break()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in is_valid_oplock_break()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35864",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in smb2_is_valid_lease_break()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in smb2_is_valid_lease_break()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35866",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in cifs_dump_full_key()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in cifs_dump_full_key()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35867",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in cifs_stats_proc_show()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in cifs_stats_proc_show()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35868",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix potential UAF in cifs_stats_proc_write()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in cifs_stats_proc_write()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35887",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ax25: fix use-after-free bugs caused by ax25_ds_del_timer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: fix use-after-free bugs caused by ax25_ds_del_timer\n\nWhen the ax25 device is detaching, the ax25_dev_device_down()\ncalls ax25_ds_del_timer() to cleanup the slave_timer. When\nthe timer handler is running, the ax25_ds_del_timer() that\ncalls del_timer() in it will return directly. As a result,\nthe use-after-free bugs could happen, one of the scenarios\nis shown below:\n\n      (Thread 1)          |      (Thread 2)\n                          | ax25_ds_timeout()\nax25_dev_device_down()    |\n  ax25_ds_del_timer()     |\n    del_timer()           |\n  ax25_dev_put() //FREE   |\n                          |  ax25_dev-> //USE\n\nIn order to mitigate bugs, when the device is detaching, use\ntimer_shutdown_sync() to stop the timer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35896",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: validate user input for expected length",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: validate user input for expected length\n\nI got multiple syzbot reports showing old bugs exposed\nby BPF after commit 20f2505fb436 (\"bpf: Try to avoid kzalloc\nin cgroup/{s,g}etsockopt\")\n\nsetsockopt() @optlen argument should be taken into account\nbefore copying data.\n\n BUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\n BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline]\n BUG: KASAN: slab-out-of-bounds in do_replace net/ipv4/netfilter/ip_tables.c:1111 [inline]\n BUG: KASAN: slab-out-of-bounds in do_ipt_set_ctl+0x902/0x3dd0 net/ipv4/netfilter/ip_tables.c:1627\nRead of size 96 at addr ffff88802cd73da0 by task syz-executor.4/7238\n\nCPU: 1 PID: 7238 Comm: syz-executor.4 Not tainted 6.9.0-rc2-next-20240403-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  kasan_check_range+0x282/0x290 mm/kasan/generic.c:189\n  __asan_memcpy+0x29/0x70 mm/kasan/shadow.c:105\n  copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\n  copy_from_sockptr include/linux/sockptr.h:55 [inline]\n  do_replace net/ipv4/netfilter/ip_tables.c:1111 [inline]\n  do_ipt_set_ctl+0x902/0x3dd0 net/ipv4/netfilter/ip_tables.c:1627\n  nf_setsockopt+0x295/0x2c0 net/netfilter/nf_sockopt.c:101\n  do_sock_setsockopt+0x3af/0x720 net/socket.c:2311\n  __sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n  __do_sys_setsockopt net/socket.c:2343 [inline]\n  __se_sys_setsockopt net/socket.c:2340 [inline]\n  __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\n do_syscall_64+0xfb/0x240\n entry_SYSCALL_64_after_hwframe+0x72/0x7a\nRIP: 0033:0x7fd22067dde9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fd21f9ff0c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 00007fd2207abf80 RCX: 00007fd22067dde9\nRDX: 0000000000000040 RSI: 0000000000000000 RDI: 0000000000000003\nRBP: 00007fd2206ca47a R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000020000880 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007fd2207abf80 R15: 00007ffd2d0170d8\n </TASK>\n\nAllocated by task 7238:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  poison_kmalloc_redzone mm/kasan/common.c:370 [inline]\n  __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:387\n  kasan_kmalloc include/linux/kasan.h:211 [inline]\n  __do_kmalloc_node mm/slub.c:4069 [inline]\n  __kmalloc_noprof+0x200/0x410 mm/slub.c:4082\n  kmalloc_noprof include/linux/slab.h:664 [inline]\n  __cgroup_bpf_run_filter_setsockopt+0xd47/0x1050 kernel/bpf/cgroup.c:1869\n  do_sock_setsockopt+0x6b4/0x720 net/socket.c:2293\n  __sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n  __do_sys_setsockopt net/socket.c:2343 [inline]\n  __se_sys_setsockopt net/socket.c:2340 [inline]\n  __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\n do_syscall_64+0xfb/0x240\n entry_SYSCALL_64_after_hwframe+0x72/0x7a\n\nThe buggy address belongs to the object at ffff88802cd73da0\n which belongs to the cache kmalloc-8 of size 8\nThe buggy address is located 0 bytes inside of\n allocated 1-byte region [ffff88802cd73da0, ffff88802cd73da1)\n\nThe buggy address belongs to the physical page:\npage: refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff88802cd73020 pfn:0x2cd73\nflags: 0xfff80000000000(node=0|zone=1|lastcpupid=0xfff)\npage_type: 0xffffefff(slab)\nraw: 00fff80000000000 ffff888015041280 dead000000000100 dead000000000122\nraw: ffff88802cd73020 000000008080007f 00000001ffffefff 00\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35905",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.216-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Protect against int overflow for stack access size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Protect against int overflow for stack access size\n\nThis patch re-introduces protection against the size of access to stack\nmemory being negative; the access size can appear negative as a result\nof overflowing its signed int representation. This should not actually\nhappen, as there are other protections along the way, but we should\nprotect against it anyway. One code path was missing such protections\n(fixed in the previous patch in the series), causing out-of-bounds array\naccesses in check_stack_range_initialized(). This patch causes the\nverification of a program with such a non-sensical access size to fail.\n\nThis check used to exist in a more indirect way, but was inadvertendly\nremoved in a833a17aeac7.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35929",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: rcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock()\n\nFor the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y and\nCONFIG_RCU_LAZY=y, the following scenarios will trigger WARN_ON_ONCE()\nin the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions:\n\n        CPU2                                               CPU11\nkthread\nrcu_nocb_cb_kthread                                       ksys_write\nrcu_do_batch                                              vfs_write\nrcu_torture_timer_cb                                      proc_sys_write\n__kmem_cache_free                                         proc_sys_call_handler\nkmemleak_free                                             drop_caches_sysctl_handler\ndelete_object_full                                        drop_slab\n__delete_object                                           shrink_slab\nput_object                                                lazy_rcu_shrink_scan\ncall_rcu                                                  rcu_nocb_flush_bypass\n__call_rcu_commn                                            rcu_nocb_bypass_lock\n                                                            raw_spin_trylock(&rdp->nocb_bypass_lock) fail\n                                                            atomic_inc(&rdp->nocb_lock_contended);\nrcu_nocb_wait_contended                                     WARN_ON_ONCE(smp_processor_id() != rdp->cpu);\n WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended))                                          |\n                            |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __|\n\nReproduce this bug with \"echo 3 > /proc/sys/vm/drop_caches\".\n\nThis commit therefore uses rcu_nocb_try_flush_bypass() instead of\nrcu_nocb_flush_bypass() in lazy_rcu_shrink_scan().  If the nocb_bypass\nqueue is being flushed, then rcu_nocb_try_flush_bypass will return\ndirectly.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35932",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/vc4: don't check if plane->state->fb == state->fb",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/vc4: don't check if plane->state->fb == state->fb\n\nCurrently, when using non-blocking commits, we can see the following\nkernel warning:\n\n[  110.908514] ------------[ cut here ]------------\n[  110.908529] refcount_t: underflow; use-after-free.\n[  110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0\n[  110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6\n[  110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G         C         6.1.66-v8+ #32\n[  110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT)\n[  110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  110.909132] pc : refcount_dec_not_one+0xb8/0xc0\n[  110.909152] lr : refcount_dec_not_one+0xb4/0xc0\n[  110.909170] sp : ffffffc00913b9c0\n[  110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60\n[  110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480\n[  110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78\n[  110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000\n[  110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004\n[  110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003\n[  110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00\n[  110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572\n[  110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000\n[  110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001\n[  110.909434] Call trace:\n[  110.909441]  refcount_dec_not_one+0xb8/0xc0\n[  110.909461]  vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4]\n[  110.909903]  vc4_cleanup_fb+0x44/0x50 [vc4]\n[  110.910315]  drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper]\n[  110.910669]  vc4_atomic_commit_tail+0x390/0x9dc [vc4]\n[  110.911079]  commit_tail+0xb0/0x164 [drm_kms_helper]\n[  110.911397]  drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper]\n[  110.911716]  drm_atomic_commit+0xb0/0xdc [drm]\n[  110.912569]  drm_mode_atomic_ioctl+0x348/0x4b8 [drm]\n[  110.913330]  drm_ioctl_kernel+0xec/0x15c [drm]\n[  110.914091]  drm_ioctl+0x24c/0x3b0 [drm]\n[  110.914850]  __arm64_sys_ioctl+0x9c/0xd4\n[  110.914873]  invoke_syscall+0x4c/0x114\n[  110.914897]  el0_svc_common+0xd0/0x118\n[  110.914917]  do_el0_svc+0x38/0xd0\n[  110.914936]  el0_svc+0x30/0x8c\n[  110.914958]  el0t_64_sync_handler+0x84/0xf0\n[  110.914979]  el0t_64_sync+0x18c/0x190\n[  110.914996] ---[ end trace 0000000000000000 ]---\n\nThis happens because, although `prepare_fb` and `cleanup_fb` are\nperfectly balanced, we cannot guarantee consistency in the check\nplane->state->fb == state->fb. This means that sometimes we can increase\nthe refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. The\nopposite can also be true.\n\nIn fact, the struct drm_plane .state shouldn't be accessed directly\nbut instead, the `drm_atomic_get_new_plane_state()` helper function should\nbe used. So, we could stick to this check, but using\n`drm_atomic_get_new_plane_state()`. But actually, this check is not re\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35939",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dma-direct: Leak pages on dma_set_decrypted() failure",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndma-direct: Leak pages on dma_set_decrypted() failure\n\nOn TDX it is possible for the untrusted host to cause\nset_memory_encrypted() or set_memory_decrypted() to fail such that an\nerror is returned and the resulting memory is shared. Callers need to\ntake care to handle these errors to avoid returning decrypted (shared)\nmemory to the page allocator, which could lead to functional or security\nissues.\n\nDMA could free decrypted/shared pages if dma_set_decrypted() fails. This\nshould be a rare case. Just leak the pages in this case instead of\nfreeing them.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35965",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix not validating setsockopt user input",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix not validating setsockopt user input\n\nCheck user input length before copying data.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-35966",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: RFCOMM: Fix not validating setsockopt user input",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: RFCOMM: Fix not validating setsockopt user input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\nchecking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\ninclude/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\ninclude/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\nnet/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\nnet/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task syz-executor632/5064",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36013",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect()\n\nExtend a critical section to prevent chan from early freeing.\nAlso make the l2cap_connect() return type void. Nothing is using the\nreturned value but it is ugly to return a potentially freed pointer.\nMaking it void will help with backports because earlier kernels did use\nthe return value. Now the compile will break for kernels where this\npatch is not a complete fix.\n\nCall stack summary:\n\n[use]\nl2cap_bredr_sig_cmd\n  l2cap_connect\n  \u250c mutex_lock(&conn->chan_lock);\n  \u2502 chan = pchan->ops->new_connection(pchan); <- alloc chan\n  \u2502 __l2cap_chan_add(conn, chan);\n  \u2502   l2cap_chan_hold(chan);\n  \u2502   list_add(&chan->list, &conn->chan_l);   ... (1)\n  \u2514 mutex_unlock(&conn->chan_lock);\n    chan->conf_state              ... (4) <- use after free\n\n[free]\nl2cap_conn_del\n\u250c mutex_lock(&conn->chan_lock);\n\u2502 foreach chan in conn->chan_l:            ... (2)\n\u2502   l2cap_chan_put(chan);\n\u2502     l2cap_chan_destroy\n\u2502       kfree(chan)               ... (3) <- chan freed\n\u2514 mutex_unlock(&conn->chan_lock);\n\n==================================================================\nBUG: KASAN: slab-use-after-free in instrument_atomic_read\ninclude/linux/instrumented.h:68 [inline]\nBUG: KASAN: slab-use-after-free in _test_bit\ninclude/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]\nBUG: KASAN: slab-use-after-free in l2cap_connect+0xa67/0x11a0\nnet/bluetooth/l2cap_core.c:4260\nRead of size 8 at addr ffff88810bf040a0 by task kworker/u3:1/311",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36015",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ppdev: Add an error check in register_device",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nppdev: Add an error check in register_device\n\nIn register_device, the return value of ida_simple_get is unchecked,\nin witch ida_simple_get will use an invalid index value.\n\nTo address this issue, index should be checked after ida_simple_get. When\nthe index value is abnormal, a warning message should be printed, the port\nshould be dropped, and the value should be recorded.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36880",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: qca: add missing firmware sanity checks",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: qca: add missing firmware sanity checks\n\nAdd the missing sanity checks when parsing the firmware files before\ndownloading them to avoid accessing and corrupting memory beyond the\nvmalloced buffer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36883",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: fix out-of-bounds access in ops_init",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix out-of-bounds access in ops_init\n\nnet_alloc_generic is called by net_alloc, which is called without any\nlocking. It reads max_gen_ptrs, which is changed under pernet_ops_rwsem. It\nis read twice, first to allocate an array, then to set s.len, which is\nlater used to limit the bounds of the array access.\n\nIt is possible that the array is allocated and another thread is\nregistering a new pernet ops, increments max_gen_ptrs, which is then used\nto set s.len with a larger than allocated length for the variable array.\n\nFix it by reading max_gen_ptrs only once in net_alloc_generic. If\nmax_gen_ptrs is later incremented, it will be caught in net_assign_generic.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36886",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: TIPC message reassembly use-after-free remote code execution vulnerability",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: fix UAF in error path\n\nSam Page (sam4k) working with Trend Micro Zero Day Initiative reported\na UAF in the tipc_buf_append() error path:\n\nBUG: KASAN: slab-use-after-free in kfree_skb_list_reason+0x47e/0x4c0\nlinux/net/core/skbuff.c:1183\nRead of size 8 at addr ffff88804d2a7c80 by task poc/8034\n\nCPU: 1 PID: 8034 Comm: poc Not tainted 6.8.2 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.0-debian-1.16.0-5 04/01/2014\nCall Trace:\n <IRQ>\n __dump_stack linux/lib/dump_stack.c:88\n dump_stack_lvl+0xd9/0x1b0 linux/lib/dump_stack.c:106\n print_address_description linux/mm/kasan/report.c:377\n print_report+0xc4/0x620 linux/mm/kasan/report.c:488\n kasan_report+0xda/0x110 linux/mm/kasan/report.c:601\n kfree_skb_list_reason+0x47e/0x4c0 linux/net/core/skbuff.c:1183\n skb_release_data+0x5af/0x880 linux/net/core/skbuff.c:1026\n skb_release_all linux/net/core/skbuff.c:1094\n __kfree_skb linux/net/core/skbuff.c:1108\n kfree_skb_reason+0x12d/0x210 linux/net/core/skbuff.c:1144\n kfree_skb linux/./include/linux/skbuff.h:1244\n tipc_buf_append+0x425/0xb50 linux/net/tipc/msg.c:186\n tipc_link_input+0x224/0x7c0 linux/net/tipc/link.c:1324\n tipc_link_rcv+0x76e/0x2d70 linux/net/tipc/link.c:1824\n tipc_rcv+0x45f/0x10f0 linux/net/tipc/node.c:2159\n tipc_udp_recv+0x73b/0x8f0 linux/net/tipc/udp_media.c:390\n udp_queue_rcv_one_skb+0xad2/0x1850 linux/net/ipv4/udp.c:2108\n udp_queue_rcv_skb+0x131/0xb00 linux/net/ipv4/udp.c:2186\n udp_unicast_rcv_skb+0x165/0x3b0 linux/net/ipv4/udp.c:2346\n __udp4_lib_rcv+0x2594/0x3400 linux/net/ipv4/udp.c:2422\n ip_protocol_deliver_rcu+0x30c/0x4e0 linux/net/ipv4/ip_input.c:205\n ip_local_deliver_finish+0x2e4/0x520 linux/net/ipv4/ip_input.c:233\n NF_HOOK linux/./include/linux/netfilter.h:314\n NF_HOOK linux/./include/linux/netfilter.h:308\n ip_local_deliver+0x18e/0x1f0 linux/net/ipv4/ip_input.c:254\n dst_input linux/./include/net/dst.h:461\n ip_rcv_finish linux/net/ipv4/ip_input.c:449\n NF_HOOK linux/./include/linux/netfilter.h:314\n NF_HOOK linux/./include/linux/netfilter.h:308\n ip_rcv+0x2c5/0x5d0 linux/net/ipv4/ip_input.c:569\n __netif_receive_skb_one_core+0x199/0x1e0 linux/net/core/dev.c:5534\n __netif_receive_skb+0x1f/0x1c0 linux/net/core/dev.c:5648\n process_backlog+0x101/0x6b0 linux/net/core/dev.c:5976\n __napi_poll.constprop.0+0xba/0x550 linux/net/core/dev.c:6576\n napi_poll linux/net/core/dev.c:6645\n net_rx_action+0x95a/0xe90 linux/net/core/dev.c:6781\n __do_softirq+0x21f/0x8e7 linux/kernel/softirq.c:553\n do_softirq linux/kernel/softirq.c:454\n do_softirq+0xb2/0xf0 linux/kernel/softirq.c:441\n </IRQ>\n <TASK>\n __local_bh_enable_ip+0x100/0x120 linux/kernel/softirq.c:381\n local_bh_enable linux/./include/linux/bottom_half.h:33\n rcu_read_unlock_bh linux/./include/linux/rcupdate.h:851\n __dev_queue_xmit+0x871/0x3ee0 linux/net/core/dev.c:4378\n dev_queue_xmit linux/./include/linux/netdevice.h:3169\n neigh_hh_output linux/./include/net/neighbour.h:526\n neigh_output linux/./include/net/neighbour.h:540\n ip_finish_output2+0x169f/0x2550 linux/net/ipv4/ip_output.c:235\n __ip_finish_output linux/net/ipv4/ip_output.c:313\n __ip_finish_output+0x49e/0x950 linux/net/ipv4/ip_output.c:295\n ip_finish_output+0x31/0x310 linux/net/ipv4/ip_output.c:323\n NF_HOOK_COND linux/./include/linux/netfilter.h:303\n ip_output+0x13b/0x2a0 linux/net/ipv4/ip_output.c:433\n dst_output linux/./include/net/dst.h:451\n ip_local_out linux/net/ipv4/ip_output.c:129\n ip_send_skb+0x3e5/0x560 linux/net/ipv4/ip_output.c:1492\n udp_send_skb+0x73f/0x1530 linux/net/ipv4/udp.c:963\n udp_sendmsg+0x1a36/0x2b40 linux/net/ipv4/udp.c:1250\n inet_sendmsg+0x105/0x140 linux/net/ipv4/af_inet.c:850\n sock_sendmsg_nosec linux/net/socket.c:730\n __sock_sendmsg linux/net/socket.c:745\n __sys_sendto+0x42c/0x4e0 linux/net/socket.c:2191\n __do_sys_sendto linux/net/socket.c:2203\n __se_sys_sendto linux/net/socket.c:2199\n __x64_sys_sendto+0xe0/0x1c0 linux/net/socket.c:2199\n do_syscall_x64 linux/arch/x86/entry/common.c:52\n do_syscall_\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36898",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gpiolib: cdev: fix uninitialised kfifo",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpiolib: cdev: fix uninitialised kfifo\n\nIf a line is requested with debounce, and that results in debouncing\nin software, and the line is subsequently reconfigured to enable edge\ndetection then the allocation of the kfifo to contain edge events is\noverlooked.  This results in events being written to and read from an\nuninitialised kfifo.  Read events are returned to userspace.\n\nInitialise the kfifo in the case where the software debounce is\nalready active.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36899",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gpiolib: cdev: Fix use after free in lineinfo_changed_notify",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpiolib: cdev: Fix use after free in lineinfo_changed_notify\n\nThe use-after-free issue occurs as follows: when the GPIO chip device file\nis being closed by invoking gpio_chrdev_release(), watched_lines is freed\nby bitmap_free(), but the unregistration of lineinfo_changed_nb notifier\nchain failed due to waiting write rwsem. Additionally, one of the GPIO\nchip's lines is also in the release process and holds the notifier chain's\nread rwsem. Consequently, a race condition leads to the use-after-free of\nwatched_lines.\n\nHere is the typical stack when issue happened:\n\n[free]\ngpio_chrdev_release()\n  --> bitmap_free(cdev->watched_lines)                  <-- freed\n  --> blocking_notifier_chain_unregister()\n    --> down_write(&nh->rwsem)                          <-- waiting rwsem\n          --> __down_write_common()\n            --> rwsem_down_write_slowpath()\n                  --> schedule_preempt_disabled()\n                    --> schedule()\n\n[use]\nst54spi_gpio_dev_release()\n  --> gpio_free()\n    --> gpiod_free()\n      --> gpiod_free_commit()\n        --> gpiod_line_state_notify()\n          --> blocking_notifier_call_chain()\n            --> down_read(&nh->rwsem);                  <-- held rwsem\n            --> notifier_call_chain()\n              --> lineinfo_changed_notify()\n                --> test_bit(xxxx, cdev->watched_lines) <-- use after free\n\nThe side effect of the use-after-free issue is that a GPIO line event is\nbeing generated for userspace where it shouldn't. However, since the chrdev\nis being closed, userspace won't have the chance to read that event anyway.\n\nTo fix the issue, call the bitmap_free() function after the unregistration\nof lineinfo_changed_nb notifier chain.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36904",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcp: Use refcount_inc_not_zero() in tcp_twsk_unique().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: Use refcount_inc_not_zero() in tcp_twsk_unique().\n\nAnderson Nascimento reported a use-after-free splat in tcp_twsk_unique()\nwith nice analysis.\n\nSince commit ec94c2696f0b (\"tcp/dccp: avoid one atomic operation for\ntimewait hashdance\"), inet_twsk_hashdance() sets TIME-WAIT socket's\nsk_refcnt after putting it into ehash and releasing the bucket lock.\n\nThus, there is a small race window where other threads could try to\nreuse the port during connect() and call sock_hold() in tcp_twsk_unique()\nfor the TIME-WAIT socket with zero refcnt.\n\nIf that happens, the refcnt taken by tcp_twsk_unique() is overwritten\nand sock_put() will cause underflow, triggering a real use-after-free\nsomewhere else.\n\nTo avoid the use-after-free, we need to use refcount_inc_not_zero() in\ntcp_twsk_unique() and give up on reusing the port if it returns false.\n\n[0]:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 0 PID: 1039313 at lib/refcount.c:25 refcount_warn_saturate+0xe5/0x110\nCPU: 0 PID: 1039313 Comm: trigger Not tainted 6.8.6-200.fc39.x86_64 #1\nHardware name: VMware, Inc. VMware20,1/440BX Desktop Reference Platform, BIOS VMW201.00V.21805430.B64.2305221830 05/22/2023\nRIP: 0010:refcount_warn_saturate+0xe5/0x110\nCode: 42 8e ff 0f 0b c3 cc cc cc cc 80 3d aa 13 ea 01 00 0f 85 5e ff ff ff 48 c7 c7 f8 8e b7 82 c6 05 96 13 ea 01 01 e8 7b 42 8e ff <0f> 0b c3 cc cc cc cc 48 c7 c7 50 8f b7 82 c6 05 7a 13 ea 01 01 e8\nRSP: 0018:ffffc90006b43b60 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff888009bb3ef0 RCX: 0000000000000027\nRDX: ffff88807be218c8 RSI: 0000000000000001 RDI: ffff88807be218c0\nRBP: 0000000000069d70 R08: 0000000000000000 R09: ffffc90006b439f0\nR10: ffffc90006b439e8 R11: 0000000000000003 R12: ffff8880029ede84\nR13: 0000000000004e20 R14: ffffffff84356dc0 R15: ffff888009bb3ef0\nFS:  00007f62c10926c0(0000) GS:ffff88807be00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020ccb000 CR3: 000000004628c005 CR4: 0000000000f70ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? refcount_warn_saturate+0xe5/0x110\n ? __warn+0x81/0x130\n ? refcount_warn_saturate+0xe5/0x110\n ? report_bug+0x171/0x1a0\n ? refcount_warn_saturate+0xe5/0x110\n ? handle_bug+0x3c/0x80\n ? exc_invalid_op+0x17/0x70\n ? asm_exc_invalid_op+0x1a/0x20\n ? refcount_warn_saturate+0xe5/0x110\n tcp_twsk_unique+0x186/0x190\n __inet_check_established+0x176/0x2d0\n __inet_hash_connect+0x74/0x7d0\n ? __pfx___inet_check_established+0x10/0x10\n tcp_v4_connect+0x278/0x530\n __inet_stream_connect+0x10f/0x3d0\n inet_stream_connect+0x3a/0x60\n __sys_connect+0xa8/0xd0\n __x64_sys_connect+0x18/0x20\n do_syscall_64+0x83/0x170\n entry_SYSCALL_64_after_hwframe+0x78/0x80\nRIP: 0033:0x7f62c11a885d\nCode: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a3 45 0c 00 f7 d8 64 89 01 48\nRSP: 002b:00007f62c1091e58 EFLAGS: 00000296 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 0000000020ccb004 RCX: 00007f62c11a885d\nRDX: 0000000000000010 RSI: 0000000020ccb000 RDI: 0000000000000003\nRBP: 00007f62c1091e90 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000296 R12: 00007f62c10926c0\nR13: ffffffffffffff88 R14: 0000000000000000 R15: 00007ffe237885b0\n </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36914",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Skip on writeback when it&#39;s not applicable",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Skip on writeback when it's not applicable\n\n[WHY]\ndynamic memory safety error detector (KASAN) catches and generates error\nmessages \"BUG: KASAN: slab-out-of-bounds\" as writeback connector does not\nsupport certain features which are not initialized.\n\n[HOW]\nSkip them when connector type is DRM_MODE_CONNECTOR_WRITEBACK.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36915",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfc: llcp: fix nfc_llcp_setsockopt() unsafe copies",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfc: llcp: fix nfc_llcp_setsockopt() unsafe copies\n\nsyzbot reported unsafe calls to copy_from_sockptr() [1]\n\nUse copy_safe_from_sockptr() instead.\n\n[1]\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\n BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline]\n BUG: KASAN: slab-out-of-bounds in nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255\nRead of size 4 at addr ffff88801caa1ec3 by task syz-executor459/5078\n\nCPU: 0 PID: 5078 Comm: syz-executor459 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\n  copy_from_sockptr include/linux/sockptr.h:55 [inline]\n  nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255\n  do_sock_setsockopt+0x3b1/0x720 net/socket.c:2311\n  __sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n  __do_sys_setsockopt net/socket.c:2343 [inline]\n  __se_sys_setsockopt net/socket.c:2340 [inline]\n  __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\n do_syscall_64+0xfd/0x240\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\nRIP: 0033:0x7f7fac07fd89\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 91 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fff660eb788 EFLAGS: 00000246 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f7fac07fd89\nRDX: 0000000000000000 RSI: 0000000000000118 RDI: 0000000000000004\nRBP: 0000000000000000 R08: 0000000000000002 R09: 0000000000000000\nR10: 0000000020000a80 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36940",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pinctrl: core: delete incorrect free in pinctrl_enable()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: core: delete incorrect free in pinctrl_enable()\n\nThe \"pctldev\" struct is allocated in devm_pinctrl_register_and_init().\nIt's a devm_ managed pointer that is freed by devm_pinctrl_dev_release(),\nso freeing it in pinctrl_enable() will lead to a double free.\n\nThe devm_pinctrl_dev_release() function frees the pindescs and destroys\nthe mutex as well.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36946",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: phonet: fix rtm_phonet_notify() skb allocation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nphonet: fix rtm_phonet_notify() skb allocation\n\nfill_route() stores three components in the skb:\n\n- struct rtmsg\n- RTA_DST (u8)\n- RTA_OIF (u32)\n\nTherefore, rtm_phonet_notify() should use\n\nNLMSG_ALIGN(sizeof(struct rtmsg)) +\nnla_total_size(1) +\nnla_total_size(4)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36960",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.218-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/vmwgfx: Fix invalid reads in fence signaled events",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/vmwgfx: Fix invalid reads in fence signaled events\n\nCorrectly set the length of the drm_event to the size of the structure\nthat's actually used.\n\nThe length of the drm_event was set to the parent structure instead of\nto the drm_vmw_event_fence which is supposed to be read. drm_read\nuses the length parameter to copy the event to the user space thus\nresuling in oob reads.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36971",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: kernel: UAF in network route management",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix __dst_negative_advice() race\n\n__dst_negative_advice() does not enforce proper RCU rules when\nsk->dst_cache must be cleared, leading to possible UAF.\n\nRCU rules are that we must first clear sk->sk_dst_cache,\nthen call dst_release(old_dst).\n\nNote that sk_dst_reset(sk) is implementing this protocol correctly,\nwhile __dst_negative_advice() uses the wrong order.\n\nGiven that ip6_negative_advice() has special logic\nagainst RTF_CACHE, this means each of the three ->negative_advice()\nexisting methods must perform the sk_dst_reset() themselves.\n\nNote the check against NULL dst is centralized in\n__dst_negative_advice(), there is no need to duplicate\nit in various callbacks.\n\nMany thanks to Clement Lecigne for tracking this issue.\n\nThis old bug became visible after the blamed commit, using UDP sockets.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36974",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: taprio: always validate TCA_TAPRIO_ATTR_PRIOMAP",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: taprio: always validate TCA_TAPRIO_ATTR_PRIOMAP\n\nIf one TCA_TAPRIO_ATTR_PRIOMAP attribute has been provided,\ntaprio_parse_mqprio_opt() must validate it, or userspace\ncan inject arbitrary data to the kernel, the second time\ntaprio_change() is called.\n\nFirst call (with valid attributes) sets dev->num_tc\nto a non zero value.\n\nSecond call (with arbitrary mqprio attributes)\nreturns early from taprio_parse_mqprio_opt()\nand bad things can happen.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-36978",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: sched: sch_multiq: fix possible OOB write in multiq_tune()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: sch_multiq: fix possible OOB write in multiq_tune()\n\nq->bands will be assigned to qopt->bands to execute subsequent code logic\nafter kmalloc. So the old q->bands should not be used in kmalloc.\nOtherwise, an out-of-bounds write will occur.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-37078",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix potential kernel bug due to lack of writeback flag waiting",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix potential kernel bug due to lack of writeback flag waiting\n\nDestructive writes to a block device on which nilfs2 is mounted can cause\na kernel bug in the folio/page writeback start routine or writeback end\nroutine (__folio_start_writeback in the log below):\n\n kernel BUG at mm/page-writeback.c:3070!\n Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\n ...\n RIP: 0010:__folio_start_writeback+0xbaa/0x10e0\n Code: 25 ff 0f 00 00 0f 84 18 01 00 00 e8 40 ca c6 ff e9 17 f6 ff ff\n  e8 36 ca c6 ff 4c 89 f7 48 c7 c6 80 c0 12 84 e8 e7 b3 0f 00 90 <0f>\n  0b e8 1f ca c6 ff 4c 89 f7 48 c7 c6 a0 c6 12 84 e8 d0 b3 0f 00\n ...\n Call Trace:\n  <TASK>\n  nilfs_segctor_do_construct+0x4654/0x69d0 [nilfs2]\n  nilfs_segctor_construct+0x181/0x6b0 [nilfs2]\n  nilfs_segctor_thread+0x548/0x11c0 [nilfs2]\n  kthread+0x2f0/0x390\n  ret_from_fork+0x4b/0x80\n  ret_from_fork_asm+0x1a/0x30\n  </TASK>\n\nThis is because when the log writer starts a writeback for segment summary\nblocks or a super root block that use the backing device's page cache, it\ndoes not wait for the ongoing folio/page writeback, resulting in an\ninconsistent writeback state.\n\nFix this issue by waiting for ongoing writebacks when putting\nfolios/pages on the backing device into writeback state.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38381",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfc: nci: Fix uninit-value in nci_rx_work",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfc: nci: Fix uninit-value in nci_rx_work\n\nsyzbot reported the following uninit-value access issue [1]\n\nnci_rx_work() parses received packet from ndev->rx_q. It should be\nvalidated header size, payload size and total packet size before\nprocessing the packet. If an invalid packet is detected, it should be\nsilently discarded.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38538",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: bridge: xmit: make sure we have at least eth header len bytes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: xmit: make sure we have at least eth header len bytes\n\nsyzbot triggered an uninit value[1] error in bridge device's xmit path\nby sending a short (less than ETH_HLEN bytes) skb. To fix it check if\nwe can actually pull that amount instead of assuming.\n\nTested with dropwatch:\n drop at: br_dev_xmit+0xb93/0x12d0 [bridge] (0xffffffffc06739b3)\n origin: software\n timestamp: Mon May 13 11:31:53 2024 778214037 nsec\n protocol: 0x88a8\n length: 2\n original length: 2\n drop reason: PKT_TOO_SMALL\n\n[1]\nBUG: KMSAN: uninit-value in br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65\n br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65\n __netdev_start_xmit include/linux/netdevice.h:4903 [inline]\n netdev_start_xmit include/linux/netdevice.h:4917 [inline]\n xmit_one net/core/dev.c:3531 [inline]\n dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3547\n __dev_queue_xmit+0x34db/0x5350 net/core/dev.c:4341\n dev_queue_xmit include/linux/netdevice.h:3091 [inline]\n __bpf_tx_skb net/core/filter.c:2136 [inline]\n __bpf_redirect_common net/core/filter.c:2180 [inline]\n __bpf_redirect+0x14a6/0x1620 net/core/filter.c:2187\n ____bpf_clone_redirect net/core/filter.c:2460 [inline]\n bpf_clone_redirect+0x328/0x470 net/core/filter.c:2432\n ___bpf_prog_run+0x13fe/0xe0f0 kernel/bpf/core.c:1997\n __bpf_prog_run512+0xb5/0xe0 kernel/bpf/core.c:2238\n bpf_dispatcher_nop_func include/linux/bpf.h:1234 [inline]\n __bpf_prog_run include/linux/filter.h:657 [inline]\n bpf_prog_run include/linux/filter.h:664 [inline]\n bpf_test_run+0x499/0xc30 net/bpf/test_run.c:425\n bpf_prog_test_run_skb+0x14ea/0x1f20 net/bpf/test_run.c:1058\n bpf_prog_test_run+0x6b7/0xad0 kernel/bpf/syscall.c:4269\n __sys_bpf+0x6aa/0xd90 kernel/bpf/syscall.c:5678\n __do_sys_bpf kernel/bpf/syscall.c:5767 [inline]\n __se_sys_bpf kernel/bpf/syscall.c:5765 [inline]\n __x64_sys_bpf+0xa0/0xe0 kernel/bpf/syscall.c:5765\n x64_sys_call+0x96b/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:322\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38545",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/hns: Fix UAF for cq async event",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/hns: Fix UAF for cq async event\n\nThe refcount of CQ is not protected by locks. When CQ asynchronous\nevents and CQ destruction are concurrent, CQ may have been released,\nwhich will cause UAF.\n\nUse the xa_lock() to protect the CQ refcount.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38552",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix potential index out of bounds in color transformation function",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix potential index out of bounds in color transformation function\n\nFixes index out of bounds issue in the color transformation function.\nThe issue could occur when the index 'i' exceeds the number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a check to ensure 'i' is within bounds before accessing the\ntransfer function points. If 'i' is out of bounds, an error message is\nlogged and the function returns false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405 cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406 cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407 cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38555",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5: Discard command completions in internal error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Discard command completions in internal error\n\nFix use after free when FW completion arrives while device is in\ninternal error state. Avoid calling completion handler in this case,\nsince the device will flush the command interface and trigger all\ncompletions manually.\n\nKernel log:\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\n...\nRIP: 0010:refcount_warn_saturate+0xd8/0xe0\n...\nCall Trace:\n<IRQ>\n? __warn+0x79/0x120\n? refcount_warn_saturate+0xd8/0xe0\n? report_bug+0x17c/0x190\n? handle_bug+0x3c/0x60\n? exc_invalid_op+0x14/0x70\n? asm_exc_invalid_op+0x16/0x20\n? refcount_warn_saturate+0xd8/0xe0\ncmd_ent_put+0x13b/0x160 [mlx5_core]\nmlx5_cmd_comp_handler+0x5f9/0x670 [mlx5_core]\ncmd_comp_notifier+0x1f/0x30 [mlx5_core]\nnotifier_call_chain+0x35/0xb0\natomic_notifier_call_chain+0x16/0x20\nmlx5_eq_async_int+0xf6/0x290 [mlx5_core]\nnotifier_call_chain+0x35/0xb0\natomic_notifier_call_chain+0x16/0x20\nirq_int_handler+0x19/0x30 [mlx5_core]\n__handle_irq_event_percpu+0x4b/0x160\nhandle_irq_event+0x2e/0x80\nhandle_edge_irq+0x98/0x230\n__common_interrupt+0x3b/0xa0\ncommon_interrupt+0x7b/0xa0\n</IRQ>\n<TASK>\nasm_common_interrupt+0x22/0x40",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38556",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5: Add a timeout to acquire the command queue semaphore",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Add a timeout to acquire the command queue semaphore\n\nPrevent forced completion handling on an entry that has not yet been\nassigned an index, causing an out of bounds access on idx = -22.\nInstead of waiting indefinitely for the sem, blocking flow now waits for\nindex to be allocated or a sem acquisition timeout before beginning the\ntimer for FW completion.\n\nKernel log example:\nmlx5_core 0000:06:00.0: wait_func_handle_exec_timeout:1128:(pid 185911): cmd[-22]: CREATE_UCTX(0xa04) No done completion",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38560",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: bfa: Ensure the copied buf is NUL terminated",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: bfa: Ensure the copied buf is NUL terminated\n\nCurrently, we allocate a nbytes-sized kernel buffer and copy nbytes from\nuserspace to that buffer. Later, we use sscanf on this buffer but we don't\nensure that the string is terminated inside the buffer, this can lead to\nOOB read when using sscanf. Fix this issue by using memdup_user_nul instead\nof memdup_user.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38570",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gfs2: Fix potential glock use-after-free on unmount",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix potential glock use-after-free on unmount\n\nWhen a DLM lockspace is released and there ares still locks in that\nlockspace, DLM will unlock those locks automatically.  Commit\nfb6791d100d1b started exploiting this behavior to speed up filesystem\nunmount: gfs2 would simply free glocks it didn't want to unlock and then\nrelease the lockspace.  This didn't take the bast callbacks for\nasynchronous lock contention notifications into account, which remain\nactive until until a lock is unlocked or its lockspace is released.\n\nTo prevent those callbacks from accessing deallocated objects, put the\nglocks that should not be unlocked on the sd_dead_glocks list, release\nthe lockspace, and only then free those glocks.\n\nAs an additional measure, ignore unexpected ast and bast callbacks if\nthe receiving glock is dead.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38577",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: rcu-tasks: Fix show_rcu_tasks_trace_gp_kthread buffer overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrcu-tasks: Fix show_rcu_tasks_trace_gp_kthread buffer overflow\n\nThere is a possibility of buffer overflow in\nshow_rcu_tasks_trace_gp_kthread() if counters, passed\nto sprintf() are huge. Counter numbers, needed for this\nare unrealistically high, but buffer overflow is still\npossible.\n\nUse snprintf() with buffer size instead of sprintf().\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38578",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ecryptfs: Fix buffer size for tag 66 packet",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\necryptfs: Fix buffer size for tag 66 packet\n\nThe 'TAG 66 Packet Format' description is missing the cipher code and\nchecksum fields that are packed into the message packet. As a result,\nthe buffer allocated for the packet is 3 bytes too small and\nwrite_tag_66_packet() will write up to 3 bytes past the end of the\nbuffer.\n\nFix this by increasing the size of the allocation so the whole packet\nwill always fit in the buffer.\n\nThis fixes the below kasan slab-out-of-bounds bug:\n\n  BUG: KASAN: slab-out-of-bounds in ecryptfs_generate_key_packet_set+0x7d6/0xde0\n  Write of size 1 at addr ffff88800afbb2a5 by task touch/181\n\n  CPU: 0 PID: 181 Comm: touch Not tainted 6.6.13-gnu #1 4c9534092be820851bb687b82d1f92a426598dc6\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2/GNU Guix 04/01/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x4c/0x70\n   print_report+0xc5/0x610\n   ? ecryptfs_generate_key_packet_set+0x7d6/0xde0\n   ? kasan_complete_mode_report_info+0x44/0x210\n   ? ecryptfs_generate_key_packet_set+0x7d6/0xde0\n   kasan_report+0xc2/0x110\n   ? ecryptfs_generate_key_packet_set+0x7d6/0xde0\n   __asan_store1+0x62/0x80\n   ecryptfs_generate_key_packet_set+0x7d6/0xde0\n   ? __pfx_ecryptfs_generate_key_packet_set+0x10/0x10\n   ? __alloc_pages+0x2e2/0x540\n   ? __pfx_ovl_open+0x10/0x10 [overlay 30837f11141636a8e1793533a02e6e2e885dad1d]\n   ? dentry_open+0x8f/0xd0\n   ecryptfs_write_metadata+0x30a/0x550\n   ? __pfx_ecryptfs_write_metadata+0x10/0x10\n   ? ecryptfs_get_lower_file+0x6b/0x190\n   ecryptfs_initialize_file+0x77/0x150\n   ecryptfs_create+0x1c2/0x2f0\n   path_openat+0x17cf/0x1ba0\n   ? __pfx_path_openat+0x10/0x10\n   do_filp_open+0x15e/0x290\n   ? __pfx_do_filp_open+0x10/0x10\n   ? __kasan_check_write+0x18/0x30\n   ? _raw_spin_lock+0x86/0xf0\n   ? __pfx__raw_spin_lock+0x10/0x10\n   ? __kasan_check_write+0x18/0x30\n   ? alloc_fd+0xf4/0x330\n   do_sys_openat2+0x122/0x160\n   ? __pfx_do_sys_openat2+0x10/0x10\n   __x64_sys_openat+0xef/0x170\n   ? __pfx___x64_sys_openat+0x10/0x10\n   do_syscall_64+0x60/0xd0\n   entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n  RIP: 0033:0x7f00a703fd67\n  Code: 25 00 00 41 00 3d 00 00 41 00 74 37 64 8b 04 25 18 00 00 00 85 c0 75 5b 44 89 e2 48 89 ee bf 9c ff ff ff b8 01 01 00 00 0f 05 <48> 3d 00 f0 ff ff 0f 87 85 00 00 00 48 83 c4 68 5d 41 5c c3 0f 1f\n  RSP: 002b:00007ffc088e30b0 EFLAGS: 00000246 ORIG_RAX: 0000000000000101\n  RAX: ffffffffffffffda RBX: 00007ffc088e3368 RCX: 00007f00a703fd67\n  RDX: 0000000000000941 RSI: 00007ffc088e48d7 RDI: 00000000ffffff9c\n  RBP: 00007ffc088e48d7 R08: 0000000000000001 R09: 0000000000000000\n  R10: 00000000000001b6 R11: 0000000000000246 R12: 0000000000000941\n  R13: 0000000000000000 R14: 00007ffc088e48d7 R15: 00007f00a7180040\n   </TASK>\n\n  Allocated by task 181:\n   kasan_save_stack+0x2f/0x60\n   kasan_set_track+0x29/0x40\n   kasan_save_alloc_info+0x25/0x40\n   __kasan_kmalloc+0xc5/0xd0\n   __kmalloc+0x66/0x160\n   ecryptfs_generate_key_packet_set+0x6d2/0xde0\n   ecryptfs_write_metadata+0x30a/0x550\n   ecryptfs_initialize_file+0x77/0x150\n   ecryptfs_create+0x1c2/0x2f0\n   path_openat+0x17cf/0x1ba0\n   do_filp_open+0x15e/0x290\n   do_sys_openat2+0x122/0x160\n   __x64_sys_openat+0xef/0x170\n   do_syscall_64+0x60/0xd0\n   entry_SYSCALL_64_after_hwframe+0x6e/0xd8",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38581",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu/mes: fix use-after-free issue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu/mes: fix use-after-free issue\n\nDelete fence fallback timer to fix the ramdom\nuse-after-free issue.\n\nv2: move to amdgpu_mes.c",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38583",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix use-after-free of timer for log writer thread",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix use-after-free of timer for log writer thread\n\nPatch series \"nilfs2: fix log writer related issues\".\n\nThis bug fix series covers three nilfs2 log writer-related issues,\nincluding a timer use-after-free issue and potential deadlock issue on\nunmount, and a potential freeze issue in event synchronization found\nduring their analysis.  Details are described in each commit log.\n\n\nThis patch (of 3):\n\nA use-after-free issue has been reported regarding the timer sc_timer on\nthe nilfs_sc_info structure.\n\nThe problem is that even though it is used to wake up a sleeping log\nwriter thread, sc_timer is not shut down until the nilfs_sc_info structure\nis about to be freed, and is used regardless of the thread's lifetime.\n\nFix this issue by limiting the use of sc_timer only while the log writer\nthread is alive.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38586",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: r8169: Fix possible ring buffer corruption on fragmented Tx packets.",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nr8169: Fix possible ring buffer corruption on fragmented Tx packets.\n\nAn issue was found on the RTL8125b when transmitting small fragmented\npackets, whereby invalid entries were inserted into the transmit ring\nbuffer, subsequently leading to calls to dma_unmap_single() with a null\naddress.\n\nThis was caused by rtl8169_start_xmit() not noticing changes to nr_frags\nwhich may occur when small packets are padded (to work around hardware\nquirks) in rtl8169_tso_csum_v2().\n\nTo fix this, postpone inspecting nr_frags until after any padding has been\napplied.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38588",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ftrace: Fix possible use-after-free issue in ftrace_location()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix possible use-after-free issue in ftrace_location()\n\nKASAN reports a bug:\n\n  BUG: KASAN: use-after-free in ftrace_location+0x90/0x120\n  Read of size 8 at addr ffff888141d40010 by task insmod/424\n  CPU: 8 PID: 424 Comm: insmod Tainted: G        W          6.9.0-rc2+\n  [...]\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x68/0xa0\n   print_report+0xcf/0x610\n   kasan_report+0xb5/0xe0\n   ftrace_location+0x90/0x120\n   register_kprobe+0x14b/0xa40\n   kprobe_init+0x2d/0xff0 [kprobe_example]\n   do_one_initcall+0x8f/0x2d0\n   do_init_module+0x13a/0x3c0\n   load_module+0x3082/0x33d0\n   init_module_from_file+0xd2/0x130\n   __x64_sys_finit_module+0x306/0x440\n   do_syscall_64+0x68/0x140\n   entry_SYSCALL_64_after_hwframe+0x71/0x79\n\nThe root cause is that, in lookup_rec(), ftrace record of some address\nis being searched in ftrace pages of some module, but those ftrace pages\nat the same time is being freed in ftrace_release_mod() as the\ncorresponding module is being deleted:\n\n           CPU1                       |      CPU2\n  register_kprobes() {                | delete_module() {\n    check_kprobe_address_safe() {     |\n      arch_check_ftrace_location() {  |\n        ftrace_location() {           |\n          lookup_rec() // USE!        |   ftrace_release_mod() // Free!\n\nTo fix this issue:\n  1. Hold rcu lock as accessing ftrace pages in ftrace_location_range();\n  2. Use ftrace_location_range() instead of lookup_rec() in\n     ftrace_location();\n  3. Call synchronize_rcu() before freeing any ftrace pages both in\n     ftrace_process_locs()/ftrace_release_mod()/ftrace_free_mem().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38599",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jffs2: prevent xattr node from overflowing the eraseblock",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njffs2: prevent xattr node from overflowing the eraseblock\n\nAdd a check to make sure that the requested xattr node size is no larger\nthan the eraseblock minus the cleanmarker.\n\nUnlike the usual inode nodes, the xattr nodes aren't split into parts\nand spread across multiple eraseblocks, which means that a xattr node\nmust not occupy more than one eraseblock. If the requested xattr value is\ntoo large, the xattr node can spill onto the next eraseblock, overwriting\nthe nodes and causing errors such as:\n\njffs2: argh. node added in wrong place at 0x0000b050(2)\njffs2: nextblock 0x0000a000, expected at 0000b00c\njffs2: error: (823) do_verify_xattr_datum: node CRC failed at 0x01e050,\nread=0xfc892c93, calc=0x000000\njffs2: notice: (823) jffs2_get_inode_nodes: Node header CRC failed\nat 0x01e00c. {848f,2fc4,0fef511f,59a3d171}\njffs2: Node at 0x0000000c with length 0x00001044 would run over the\nend of the erase block\njffs2: Perhaps the file system was created with the wrong erase size?\njffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found\nat 0x00000010: 0x1044 instead\n\nThis breaks the filesystem and can lead to KASAN crashes such as:\n\nBUG: KASAN: slab-out-of-bounds in jffs2_sum_add_kvec+0x125e/0x15d0\nRead of size 4 at addr ffff88802c31e914 by task repro/830\nCPU: 0 PID: 830 Comm: repro Not tainted 6.9.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996),\nBIOS Arch Linux 1.16.3-1-1 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0xc6/0x120\n print_report+0xc4/0x620\n ? __virt_addr_valid+0x308/0x5b0\n kasan_report+0xc1/0xf0\n ? jffs2_sum_add_kvec+0x125e/0x15d0\n ? jffs2_sum_add_kvec+0x125e/0x15d0\n jffs2_sum_add_kvec+0x125e/0x15d0\n jffs2_flash_direct_writev+0xa8/0xd0\n jffs2_flash_writev+0x9c9/0xef0\n ? __x64_sys_setxattr+0xc4/0x160\n ? do_syscall_64+0x69/0x140\n ? entry_SYSCALL_64_after_hwframe+0x76/0x7e\n [...]\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38621",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: stk1160: fix bounds checking in stk1160_copy_video()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: stk1160: fix bounds checking in stk1160_copy_video()\n\nThe subtract in this condition is reversed.  The ->length is the length\nof the buffer.  The ->bytesused is how many bytes we have copied thus\nfar.  When the condition is reversed that means the result of the\nsubtraction is always negative but since it's unsigned then the result\nis a very high positive value.  That means the overflow check is never\ntrue.\n\nAdditionally, the ->bytesused doesn't actually work for this purpose\nbecause we're not writing to \"buf->mem + buf->bytesused\".  Instead, the\nmath to calculate the destination where we are writing is a bit\ninvolved.  You calculate the number of full lines already written,\nmultiply by two, skip a line if necessary so that we start on an odd\nnumbered line, and add the offset into the line.\n\nTo fix this buffer overflow, just take the actual destination where we\nare writing, if the offset is already out of bounds print an error and\nreturn.  Otherwise, write up to buf->length bytes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38627",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: stm class: Fix a double free in stm_register_device()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nstm class: Fix a double free in stm_register_device()\n\nThe put_device(&stm->dev) call will trigger stm_device_release() which\nfrees \"stm\" so the vfree(stm) on the next line is a double free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38630",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: watchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_trigger",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_trigger\n\nWhen the cpu5wdt module is removing, the origin code uses del_timer() to\nde-activate the timer. If the timer handler is running, del_timer() could\nnot stop it and will return directly. If the port region is released by\nrelease_region() and then the timer handler cpu5wdt_trigger() calls outb()\nto write into the region that is released, the use-after-free bug will\nhappen.\n\nChange del_timer() to timer_shutdown_sync() in order that the timer handler\ncould be finished before the port region is released.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38635",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: soundwire: cadence: fix invalid PDI offset",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoundwire: cadence: fix invalid PDI offset\n\nFor some reason, we add an offset to the PDI, presumably to skip the\nPDI0 and PDI1 which are reserved for BPT.\n\nThis code is however completely wrong and leads to an out-of-bounds\naccess. We were just lucky so far since we used only a couple of PDIs\nand remained within the PDI array bounds.\n\nA Fixes: tag is not provided since there are no known platforms where\nthe out-of-bounds would be accessed, and the initial code had problems\nas well.\n\nA follow-up patch completely removes this useless offset.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38659",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: enic: Validate length of nl attributes in enic_set_vf_port",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nenic: Validate length of nl attributes in enic_set_vf_port\n\nenic_set_vf_port assumes that the nl attribute IFLA_PORT_PROFILE\nis of length PORT_PROFILE_MAX and that the nl attributes\nIFLA_PORT_INSTANCE_UUID, IFLA_PORT_HOST_UUID are of length PORT_UUID_MAX.\nThese attributes are validated (in the function do_setlink in rtnetlink.c)\nusing the nla_policy ifla_port_policy. The policy defines IFLA_PORT_PROFILE\nas NLA_STRING, IFLA_PORT_INSTANCE_UUID as NLA_BINARY and\nIFLA_PORT_HOST_UUID as NLA_STRING. That means that the length validation\nusing the policy is for the max size of the attributes and not on exact\nsize so the length of these attributes might be less than the sizes that\nenic_set_vf_port expects. This might cause an out of bands\nread access in the memcpys of the data of these\nattributes in enic_set_vf_port.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-38667",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: riscv: prevent pt_regs corruption for secondary idle threads",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: prevent pt_regs corruption for secondary idle threads\n\nTop of the kernel thread stack should be reserved for pt_regs. However\nthis is not the case for the idle threads of the secondary boot harts.\nTheir stacks overlap with their pt_regs, so both may get corrupted.\n\nSimilar issue has been fixed for the primary hart, see c7cdd96eca28\n(\"riscv: prevent stack corruption by reserving task_pt_regs(p) early\").\nHowever that fix was not propagated to the secondary harts. The problem\nhas been noticed in some CPU hotplug tests with V enabled. The function\nsmp_callin stored several registers on stack, corrupting top of pt_regs\nstructure including status field. As a result, kernel attempted to save\nor restore inexistent V context.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39467",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to do sanity check on i_xattr_nid in sanity_check_inode()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to do sanity check on i_xattr_nid in sanity_check_inode()\n\nsyzbot reports a kernel bug as below:\n\nF2FS-fs (loop0): Mounted with checkpoint version = 48b305e4\n==================================================================\nBUG: KASAN: slab-out-of-bounds in f2fs_test_bit fs/f2fs/f2fs.h:2933 [inline]\nBUG: KASAN: slab-out-of-bounds in current_nat_addr fs/f2fs/node.h:213 [inline]\nBUG: KASAN: slab-out-of-bounds in f2fs_get_node_info+0xece/0x1200 fs/f2fs/node.c:600\nRead of size 1 at addr ffff88807a58c76c by task syz-executor280/5076\n\nCPU: 1 PID: 5076 Comm: syz-executor280 Not tainted 6.9.0-rc5-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n f2fs_test_bit fs/f2fs/f2fs.h:2933 [inline]\n current_nat_addr fs/f2fs/node.h:213 [inline]\n f2fs_get_node_info+0xece/0x1200 fs/f2fs/node.c:600\n f2fs_xattr_fiemap fs/f2fs/data.c:1848 [inline]\n f2fs_fiemap+0x55d/0x1ee0 fs/f2fs/data.c:1925\n ioctl_fiemap fs/ioctl.c:220 [inline]\n do_vfs_ioctl+0x1c07/0x2e50 fs/ioctl.c:838\n __do_sys_ioctl fs/ioctl.c:902 [inline]\n __se_sys_ioctl+0x81/0x170 fs/ioctl.c:890\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nThe root cause is we missed to do sanity check on i_xattr_nid during\nf2fs_iget(), so that in fiemap() path, current_nat_addr() will access\nnat_bitmap w/ offset from invalid i_xattr_nid, result in triggering\nkasan bug report, fix it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39469",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix nilfs_empty_dir() misjudgment and long loop on I/O errors",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix nilfs_empty_dir() misjudgment and long loop on I/O errors\n\nThe error handling in nilfs_empty_dir() when a directory folio/page read\nfails is incorrect, as in the old ext2 implementation, and if the\nfolio/page cannot be read or nilfs_check_folio() fails, it will falsely\ndetermine the directory as empty and corrupt the file system.\n\nIn addition, since nilfs_empty_dir() does not immediately return on a\nfailed folio/page read, but continues to loop, this can cause a long loop\nwith I/O if i_size of the directory's inode is also corrupted, causing the\nlog writer thread to wait and hang, as reported by syzbot.\n\nFix these issues by making nilfs_empty_dir() immediately return a false\nvalue (0) if it fails to get a directory folio/page.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39471",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: add error handle to avoid out-of-bounds",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: add error handle to avoid out-of-bounds\n\nif the sdma_v4_0_irq_id_to_seq return -EINVAL, the process should\nbe stop to avoid out-of-bounds read, so directly return -EINVAL.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39479",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/i915/hwmon: Get rid of devm",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/hwmon: Get rid of devm\n\nWhen both hwmon and hwmon drvdata (on which hwmon depends) are device\nmanaged resources, the expectation, on device unbind, is that hwmon will be\nreleased before drvdata. However, in i915 there are two separate code\npaths, which both release either drvdata or hwmon and either can be\nreleased before the other. These code paths (for device unbind) are as\nfollows (see also the bug referenced below):\n\nCall Trace:\nrelease_nodes+0x11/0x70\ndevres_release_group+0xb2/0x110\ncomponent_unbind_all+0x8d/0xa0\ncomponent_del+0xa5/0x140\nintel_pxp_tee_component_fini+0x29/0x40 [i915]\nintel_pxp_fini+0x33/0x80 [i915]\ni915_driver_remove+0x4c/0x120 [i915]\ni915_pci_remove+0x19/0x30 [i915]\npci_device_remove+0x32/0xa0\ndevice_release_driver_internal+0x19c/0x200\nunbind_store+0x9c/0xb0\n\nand\n\nCall Trace:\nrelease_nodes+0x11/0x70\ndevres_release_all+0x8a/0xc0\ndevice_unbind_cleanup+0x9/0x70\ndevice_release_driver_internal+0x1c1/0x200\nunbind_store+0x9c/0xb0\n\nThis means that in i915, if use devm, we cannot gurantee that hwmon will\nalways be released before drvdata. Which means that we have a uaf if hwmon\nsysfs is accessed when drvdata has been released but hwmon hasn't.\n\nThe only way out of this seems to be do get rid of devm_ and release/free\neverything explicitly during device unbind.\n\nv2: Change commit message and other minor code changes\nv3: Cleanup from i915_hwmon_register on error (Armin Wolf)\nv4: Eliminate potential static analyzer warning (Rodrigo)\n    Eliminate fetch_and_zero (Jani)\nv5: Restore previous logic for ddat_gt->hwmon_dev error return (Andi)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39480",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: kdb: Fix buffer overflow during tab-complete",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkdb: Fix buffer overflow during tab-complete\n\nCurrently, when the user attempts symbol completion with the Tab key, kdb\nwill use strncpy() to insert the completed symbol into the command buffer.\nUnfortunately it passes the size of the source buffer rather than the\ndestination to strncpy() with predictably horrible results. Most obviously\nif the command buffer is already full but cp, the cursor position, is in\nthe middle of the buffer, then we will write past the end of the supplied\nbuffer.\n\nFix this by replacing the dubious strncpy() calls with memmove()/memcpy()\ncalls plus explicit boundary checks to make sure we have enough space\nbefore we start moving characters around.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39487",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bonding: Fix out-of-bounds read in bond_option_arp_ip_targets_set()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbonding: Fix out-of-bounds read in bond_option_arp_ip_targets_set()\n\nIn function bond_option_arp_ip_targets_set(), if newval->string is an\nempty string, newval->string+1 will point to the byte after the\nstring, causing an out-of-bound read.\n\nBUG: KASAN: slab-out-of-bounds in strlen+0x7d/0xa0 lib/string.c:418\nRead of size 1 at addr ffff8881119c4781 by task syz-executor665/8107\nCPU: 1 PID: 8107 Comm: syz-executor665 Not tainted 6.7.0-rc7 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:364 [inline]\n print_report+0xc1/0x5e0 mm/kasan/report.c:475\n kasan_report+0xbe/0xf0 mm/kasan/report.c:588\n strlen+0x7d/0xa0 lib/string.c:418\n __fortify_strlen include/linux/fortify-string.h:210 [inline]\n in4_pton+0xa3/0x3f0 net/core/utils.c:130\n bond_option_arp_ip_targets_set+0xc2/0x910\ndrivers/net/bonding/bond_options.c:1201\n __bond_opt_set+0x2a4/0x1030 drivers/net/bonding/bond_options.c:767\n __bond_opt_set_notify+0x48/0x150 drivers/net/bonding/bond_options.c:792\n bond_opt_tryset_rtnl+0xda/0x160 drivers/net/bonding/bond_options.c:817\n bonding_sysfs_store_option+0xa1/0x120 drivers/net/bonding/bond_sysfs.c:156\n dev_attr_store+0x54/0x80 drivers/base/core.c:2366\n sysfs_kf_write+0x114/0x170 fs/sysfs/file.c:136\n kernfs_fop_write_iter+0x337/0x500 fs/kernfs/file.c:334\n call_write_iter include/linux/fs.h:2020 [inline]\n new_sync_write fs/read_write.c:491 [inline]\n vfs_write+0x96a/0xd80 fs/read_write.c:584\n ksys_write+0x122/0x250 fs/read_write.c:637\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0x40/0x110 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n---[ end trace ]---\n\nFix it by adding a check of string length before using it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39494",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ima: Fix use-after-free on a dentry's dname.name",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nima: Fix use-after-free on a dentry's dname.name\n\n->d_name.name can change on rename and the earlier value can be freed;\nthere are conditions sufficient to stabilize it (->d_lock on dentry,\n->d_lock on its parent, ->i_rwsem exclusive on the parent's inode,\nrename_lock), but none of those are met at any of the sites. Take a stable\nsnapshot of the name instead.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39495",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: greybus: Fix use-after-free bug in gb_interface_release due to race condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngreybus: Fix use-after-free bug in gb_interface_release due to race condition.\n\nIn gb_interface_create, &intf->mode_switch_completion is bound with\ngb_interface_mode_switch_work. Then it will be started by\ngb_interface_request_mode_switch. Here is the relevant code.\nif (!queue_work(system_long_wq, &intf->mode_switch_work)) {\n\t...\n}\n\nIf we call gb_interface_release to make cleanup, there may be an\nunfinished work. This function will call kfree to free the object\n\"intf\". However, if gb_interface_mode_switch_work is scheduled to\nrun after kfree, it may cause use-after-free error as\ngb_interface_mode_switch_work will use the object \"intf\".\nThe possible execution flow that may lead to the issue is as follows:\n\nCPU0                            CPU1\n\n                            |   gb_interface_create\n                            |   gb_interface_request_mode_switch\ngb_interface_release        |\nkfree(intf) (free)          |\n                            |   gb_interface_mode_switch_work\n                            |   mutex_lock(&intf->mutex) (use)\n\nFix it by canceling the work before kfree.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39499",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vmci: prevent speculation leaks by sanitizing event in event_deliver()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvmci: prevent speculation leaks by sanitizing event in event_deliver()\n\nCoverity spotted that event_msg is controlled by user-space,\nevent_msg->event_data.event is passed to event_deliver() and used\nas an index without sanitization.\n\nThis change ensures that the event index is sanitized to mitigate any\npossibility of speculative information leaks.\n\nThis bug was discovered and resolved using Coverity Static Analysis\nSecurity Testing (SAST) by Synopsys, Inc.\n\nOnly compile tested, no access to HW.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39502",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ionic: fix use after netif_napi_del()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nionic: fix use after netif_napi_del()\n\nWhen queues are started, netif_napi_add() and napi_enable() are called.\nIf there are 4 queues and only 3 queues are used for the current\nconfiguration, only 3 queues' napi should be registered and enabled.\nThe ionic_qcq_enable() checks whether the .poll pointer is not NULL for\nenabling only the using queue' napi. Unused queues' napi will not be\nregistered by netif_napi_add(), so the .poll pointer indicates NULL.\nBut it couldn't distinguish whether the napi was unregistered or not\nbecause netif_napi_del() doesn't reset the .poll pointer to NULL.\nSo, ionic_qcq_enable() calls napi_enable() for the queue, which was\nunregistered by netif_napi_del().\n\nReproducer:\n   ethtool -L <interface name> rx 1 tx 1 combined 0\n   ethtool -L <interface name> rx 0 tx 0 combined 1\n   ethtool -L <interface name> rx 0 tx 0 combined 4\n\nSplat looks like:\nkernel BUG at net/core/dev.c:6666!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 3 PID: 1057 Comm: kworker/3:3 Not tainted 6.10.0-rc2+ #16\nWorkqueue: events ionic_lif_deferred_work [ionic]\nRIP: 0010:napi_enable+0x3b/0x40\nCode: 48 89 c2 48 83 e2 f6 80 b9 61 09 00 00 00 74 0d 48 83 bf 60 01 00 00 00 74 03 80 ce 01 f0 4f\nRSP: 0018:ffffb6ed83227d48 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff97560cda0828 RCX: 0000000000000029\nRDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff97560cda0a28\nRBP: ffffb6ed83227d50 R08: 0000000000000400 R09: 0000000000000001\nR10: 0000000000000001 R11: 0000000000000001 R12: 0000000000000000\nR13: ffff97560ce3c1a0 R14: 0000000000000000 R15: ffff975613ba0a20\nFS:  0000000000000000(0000) GS:ffff975d5f780000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f8f734ee200 CR3: 0000000103e50000 CR4: 00000000007506f0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? die+0x33/0x90\n ? do_trap+0xd9/0x100\n ? napi_enable+0x3b/0x40\n ? do_error_trap+0x83/0xb0\n ? napi_enable+0x3b/0x40\n ? napi_enable+0x3b/0x40\n ? exc_invalid_op+0x4e/0x70\n ? napi_enable+0x3b/0x40\n ? asm_exc_invalid_op+0x16/0x20\n ? napi_enable+0x3b/0x40\n ionic_qcq_enable+0xb7/0x180 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\n ionic_start_queues+0xc4/0x290 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\n ionic_link_status_check+0x11c/0x170 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\n ionic_lif_deferred_work+0x129/0x280 [ionic 59bdfc8a035436e1c4224ff7d10789e3f14643f8]\n process_one_work+0x145/0x360\n worker_thread+0x2bb/0x3d0\n ? __pfx_worker_thread+0x10/0x10\n kthread+0xcc/0x100\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x2d/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-39503",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: ipset: Fix race between namespace cleanup and gc in the list:set type",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: ipset: Fix race between namespace cleanup and gc in the list:set type\n\nLion Ackermann reported that there is a race condition between namespace cleanup\nin ipset and the garbage collection of the list:set type. The namespace\ncleanup can destroy the list:set type of sets while the gc of the set type is\nwaiting to run in rcu cleanup. The latter uses data from the destroyed set which\nthus leads use after free. The patch contains the following parts:\n\n- When destroying all sets, first remove the garbage collectors, then wait\n  if needed and then destroy the sets.\n- Fix the badly ordered \"wait then remove gc\" for the destroy a single set\n  case.\n- Fix the missing rcu locking in the list:set type in the userspace test\n  case.\n- Use proper RCU list handlings in the list:set type.\n\nThe patch depends on c1193d9bbbd3 (netfilter: ipset: Add list flush to cancel_gc).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-40902",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: xattr: fix buffer overflow for invalid xattr",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: xattr: fix buffer overflow for invalid xattr\n\nWhen an xattr size is not what is expected, it is printed out to the\nkernel log in hex format as a form of debugging.  But when that xattr\nsize is bigger than the expected size, printing it out can cause an\naccess off the end of the buffer.\n\nFix this all up by properly restricting the size of the debug hex dump\nin the kernel log.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-40927",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: xhci: Handle TD clearing for multiple streams case",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxhci: Handle TD clearing for multiple streams case\n\nWhen multiple streams are in use, multiple TDs might be in flight when\nan endpoint is stopped. We need to issue a Set TR Dequeue Pointer for\neach, to ensure everything is reset properly and the caches cleared.\nChange the logic so that any N>1 TDs found active for different streams\nare deferred until after the first one is processed, calling\nxhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() to\nqueue another command until we are done with all of them. Also change\nthe error/\"should never happen\" paths to ensure we at least clear any\naffected TDs, even if we can't issue a command to clear the hardware\ncache, and complain loudly with an xhci_warn() if this ever happens.\n\nThis problem case dates back to commit e9df17eb1408 (\"USB: xhci: Correct\nassumptions about number of rings per endpoint.\") early on in the XHCI\ndriver's life, when stream support was first added.\nIt was then identified but not fixed nor made into a warning in commit\n674f8438c121 (\"xhci: split handling halted endpoints into two steps\"),\nwhich added a FIXME comment for the problem case (without materially\nchanging the behavior as far as I can tell, though the new logic made\nthe problem more obvious).\n\nThen later, in commit 94f339147fc3 (\"xhci: Fix failure to give back some\ncached cancelled URBs.\"), it was acknowledged again.\n\n[Mathias: commit 94f339147fc3 (\"xhci: Fix failure to give back some cached\ncancelled URBs.\") was a targeted regression fix to the previously mentioned\npatch. Users reported issues with usb stuck after unmounting/disconnecting\nUAS devices. This rolled back the TD clearing of multiple streams to its\noriginal state.]\n\nApparently the commit author was aware of the problem (yet still chose\nto submit it): It was still mentioned as a FIXME, an xhci_dbg() was\nadded to log the problem condition, and the remaining issue was mentioned\nin the commit description. The choice of making the log type xhci_dbg()\nfor what is, at this point, a completely unhandled and known broken\ncondition is puzzling and unfortunate, as it guarantees that no actual\nusers would see the log in production, thereby making it nigh\nundebuggable (indeed, even if you turn on DEBUG, the message doesn't\nreally hint at there being a problem at all).\n\nIt took me *months* of random xHC crashes to finally find a reliable\nrepro and be able to do a deep dive debug session, which could all have\nbeen avoided had this unhandled, broken condition been actually reported\nwith a warning, as it should have been as a bug intentionally left in\nunfixed (never mind that it shouldn't have been left in at all).\n\n> Another fix to solve clearing the caches of all stream rings with\n> cancelled TDs is needed, but not as urgent.\n\n3 years after that statement and 14 years after the original bug was\nintroduced, I think it's finally time to fix it. And maybe next time\nlet's not leave bugs unfixed (that are actually worse than the original\nbug), and let's actually get people to review kernel commits please.\n\nFixes xHC crashes and IOMMU faults with UAS devices when handling\nerrors/faults. Easiest repro is to use `hdparm` to mark an early sector\n(e.g. 1024) on a disk as bad, then `cat /dev/sdX > /dev/null` in a loop.\nAt least in the case of JMicron controllers, the read errors end up\nhaving to cancel two TDs (for two queued requests to different streams)\nand the one that didn't get cleared properly ends up faulting the xHC\nentirely when it tries to access DMA pages that have since been unmapped,\nreferred to by the stale TDs. This normally happens quickly (after two\nor three loops). After this fix, I left the `cat` in a loop running\novernight and experienced no xHC failures, with all read errors\nrecovered properly. Repro'd and tested on an Apple M1 Mac Mini\n(dwc3 host).\n\nOn systems without an IOMMU, this bug would instead silently corrupt\nfreed memory, making this a\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-40929",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: mvm: check n_ssids before accessing the ssids",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: check n_ssids before accessing the ssids\n\nIn some versions of cfg80211, the ssids poinet might be a valid one even\nthough n_ssids is 0. Accessing the pointer in this case will cuase an\nout-of-bound access. Fix this by checking n_ssids first.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-40958",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netns: Make get_net_ns() handle zero refcount net",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetns: Make get_net_ns() handle zero refcount net\n\nSyzkaller hit a warning:\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 3 PID: 7890 at lib/refcount.c:25 refcount_warn_saturate+0xdf/0x1d0\nModules linked in:\nCPU: 3 PID: 7890 Comm: tun Not tainted 6.10.0-rc3-00100-gcaa4f9578aba-dirty #310\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xdf/0x1d0\nCode: 41 49 04 31 ff 89 de e8 9f 1e cd fe 84 db 75 9c e8 76 26 cd fe c6 05 b6 41 49 04 01 90 48 c7 c7 b8 8e 25 86 e8 d2 05 b5 fe 90 <0f> 0b 90 90 e9 79 ff ff ff e8 53 26 cd fe 0f b6 1\nRSP: 0018:ffff8881067b7da0 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff811c72ac\nRDX: ffff8881026a2140 RSI: ffffffff811c72b5 RDI: 0000000000000001\nRBP: ffff8881067b7db0 R08: 0000000000000000 R09: 205b5d3730353139\nR10: 0000000000000000 R11: 205d303938375420 R12: ffff8881086500c4\nR13: ffff8881086500c4 R14: ffff8881086500b0 R15: ffff888108650040\nFS:  00007f5b2961a4c0(0000) GS:ffff88823bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055d7ed36fd18 CR3: 00000001482f6000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ? show_regs+0xa3/0xc0\n ? __warn+0xa5/0x1c0\n ? refcount_warn_saturate+0xdf/0x1d0\n ? report_bug+0x1fc/0x2d0\n ? refcount_warn_saturate+0xdf/0x1d0\n ? handle_bug+0xa1/0x110\n ? exc_invalid_op+0x3c/0xb0\n ? asm_exc_invalid_op+0x1f/0x30\n ? __warn_printk+0xcc/0x140\n ? __warn_printk+0xd5/0x140\n ? refcount_warn_saturate+0xdf/0x1d0\n get_net_ns+0xa4/0xc0\n ? __pfx_get_net_ns+0x10/0x10\n open_related_ns+0x5a/0x130\n __tun_chr_ioctl+0x1616/0x2370\n ? __sanitizer_cov_trace_switch+0x58/0xa0\n ? __sanitizer_cov_trace_const_cmp2+0x1c/0x30\n ? __pfx_tun_chr_ioctl+0x10/0x10\n tun_chr_ioctl+0x2f/0x40\n __x64_sys_ioctl+0x11b/0x160\n x64_sys_call+0x1211/0x20d0\n do_syscall_64+0x9e/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f5b28f165d7\nCode: b3 66 90 48 8b 05 b1 48 2d 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 81 48 2d 00 8\nRSP: 002b:00007ffc2b59c5e8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f5b28f165d7\nRDX: 0000000000000000 RSI: 00000000000054e3 RDI: 0000000000000003\nRBP: 00007ffc2b59c650 R08: 00007f5b291ed8c0 R09: 00007f5b2961a4c0\nR10: 0000000029690010 R11: 0000000000000246 R12: 0000000000400730\nR13: 00007ffc2b59cf40 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\nKernel panic - not syncing: kernel: panic_on_warn set ...\n\nThis is trigger as below:\n          ns0                                    ns1\ntun_set_iff() //dev is tun0\n   tun->dev = dev\n//ip link set tun0 netns ns1\n                                       put_net() //ref is 0\n__tun_chr_ioctl() //TUNGETDEVNETNS\n   net = dev_net(tun->dev);\n   open_related_ns(&net->ns, get_net_ns); //ns1\n     get_net_ns()\n        get_net() //addition on 0\n\nUse maybe_get_net() in get_net_ns in case net's ref is zero to fix this",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-40974",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: powerpc/pseries: Enforce hcall result buffer validity and size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/pseries: Enforce hcall result buffer validity and size\n\nplpar_hcall(), plpar_hcall9(), and related functions expect callers to\nprovide valid result buffers of certain minimum size. Currently this\nis communicated only through comments in the code and the compiler has\nno idea.\n\nFor example, if I write a bug like this:\n\n  long retbuf[PLPAR_HCALL_BUFSIZE]; // should be PLPAR_HCALL9_BUFSIZE\n  plpar_hcall9(H_ALLOCATE_VAS_WINDOW, retbuf, ...);\n\nThis compiles with no diagnostics emitted, but likely results in stack\ncorruption at runtime when plpar_hcall9() stores results past the end\nof the array. (To be clear this is a contrived example and I have not\nfound a real instance yet.)\n\nTo make this class of error less likely, we can use explicitly-sized\narray parameters instead of pointers in the declarations for the hcall\nAPIs. When compiled with -Warray-bounds[1], the code above now\nprovokes a diagnostic like this:\n\nerror: array argument is too small;\nis of size 32, callee requires at least 72 [-Werror,-Warray-bounds]\n   60 |                 plpar_hcall9(H_ALLOCATE_VAS_WINDOW, retbuf,\n      |                 ^                                   ~~~~~~\n\n[1] Enabled for LLVM builds but not GCC for now. See commit\n    0da6e5fd6c37 (\"gcc: disable '-Warray-bounds' for gcc-13 too\") and\n    related changes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-40978",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: qedi: Fix crash while reading debugfs attribute",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qedi: Fix crash while reading debugfs attribute\n\nThe qedi_dbg_do_not_recover_cmd_read() function invokes sprintf() directly\non a __user pointer, which results into the crash.\n\nTo fix this issue, use a small local stack buffer for sprintf() and then\ncall simple_read_from_buffer(), which in turns make the copy_to_user()\ncall.\n\nBUG: unable to handle page fault for address: 00007f4801111000\nPGD 8000000864df6067 P4D 8000000864df6067 PUD 864df7067 PMD 846028067 PTE 0\nOops: 0002 [#1] PREEMPT SMP PTI\nHardware name: HPE ProLiant DL380 Gen10/ProLiant DL380 Gen10, BIOS U30 06/15/2023\nRIP: 0010:memcpy_orig+0xcd/0x130\nRSP: 0018:ffffb7a18c3ffc40 EFLAGS: 00010202\nRAX: 00007f4801111000 RBX: 00007f4801111000 RCX: 000000000000000f\nRDX: 000000000000000f RSI: ffffffffc0bfd7a0 RDI: 00007f4801111000\nRBP: ffffffffc0bfd7a0 R08: 725f746f6e5f6f64 R09: 3d7265766f636572\nR10: ffffb7a18c3ffd08 R11: 0000000000000000 R12: 00007f4881110fff\nR13: 000000007fffffff R14: ffffb7a18c3ffca0 R15: ffffffffc0bfd7af\nFS:  00007f480118a740(0000) GS:ffff98e38af00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f4801111000 CR3: 0000000864b8e001 CR4: 00000000007706e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __die_body+0x1a/0x60\n ? page_fault_oops+0x183/0x510\n ? exc_page_fault+0x69/0x150\n ? asm_exc_page_fault+0x22/0x30\n ? memcpy_orig+0xcd/0x130\n vsnprintf+0x102/0x4c0\n sprintf+0x51/0x80\n qedi_dbg_do_not_recover_cmd_read+0x2f/0x50 [qedi 6bcfdeeecdea037da47069eca2ba717c84a77324]\n full_proxy_read+0x50/0x80\n vfs_read+0xa5/0x2e0\n ? folio_add_new_anon_rmap+0x44/0xa0\n ? set_pte_at+0x15/0x30\n ? do_pte_missing+0x426/0x7f0\n ksys_read+0xa5/0xe0\n do_syscall_64+0x58/0x80\n ? __count_memcg_events+0x46/0x90\n ? count_memcg_event_mm+0x3d/0x60\n ? handle_mm_fault+0x196/0x2f0\n ? do_user_addr_fault+0x267/0x890\n ? exc_page_fault+0x69/0x150\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x7f4800f20b4d",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41000",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: block/ioctl: prefer different overflow check",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock/ioctl: prefer different overflow check\n\nRunning syzkaller with the newly reintroduced signed integer overflow\nsanitizer shows this report:\n\n[   62.982337] ------------[ cut here ]------------\n[   62.985692] cgroup: Invalid name\n[   62.986211] UBSAN: signed-integer-overflow in ../block/ioctl.c:36:46\n[   62.989370] 9pnet_fd: p9_fd_create_tcp (7343): problem connecting socket to 127.0.0.1\n[   62.992992] 9223372036854775807 + 4095 cannot be represented in type 'long long'\n[   62.997827] 9pnet_fd: p9_fd_create_tcp (7345): problem connecting socket to 127.0.0.1\n[   62.999369] random: crng reseeded on system resumption\n[   63.000634] GUP no longer grows the stack in syz-executor.2 (7353): 20002000-20003000 (20001000)\n[   63.000668] CPU: 0 PID: 7353 Comm: syz-executor.2 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1\n[   63.000677] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   63.000682] Call Trace:\n[   63.000686]  <TASK>\n[   63.000731]  dump_stack_lvl+0x93/0xd0\n[   63.000919]  __get_user_pages+0x903/0xd30\n[   63.001030]  __gup_longterm_locked+0x153e/0x1ba0\n[   63.001041]  ? _raw_read_unlock_irqrestore+0x17/0x50\n[   63.001072]  ? try_get_folio+0x29c/0x2d0\n[   63.001083]  internal_get_user_pages_fast+0x1119/0x1530\n[   63.001109]  iov_iter_extract_pages+0x23b/0x580\n[   63.001206]  bio_iov_iter_get_pages+0x4de/0x1220\n[   63.001235]  iomap_dio_bio_iter+0x9b6/0x1410\n[   63.001297]  __iomap_dio_rw+0xab4/0x1810\n[   63.001316]  iomap_dio_rw+0x45/0xa0\n[   63.001328]  ext4_file_write_iter+0xdde/0x1390\n[   63.001372]  vfs_write+0x599/0xbd0\n[   63.001394]  ksys_write+0xc8/0x190\n[   63.001403]  do_syscall_64+0xd4/0x1b0\n[   63.001421]  ? arch_exit_to_user_mode_prepare+0x3a/0x60\n[   63.001479]  entry_SYSCALL_64_after_hwframe+0x6f/0x77\n[   63.001535] RIP: 0033:0x7f7fd3ebf539\n[   63.001551] Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\n[   63.001562] RSP: 002b:00007f7fd32570c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[   63.001584] RAX: ffffffffffffffda RBX: 00007f7fd3ff3f80 RCX: 00007f7fd3ebf539\n[   63.001590] RDX: 4db6d1e4f7e43360 RSI: 0000000020000000 RDI: 0000000000000004\n[   63.001595] RBP: 00007f7fd3f1e496 R08: 0000000000000000 R09: 0000000000000000\n[   63.001599] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n[   63.001604] R13: 0000000000000006 R14: 00007f7fd3ff3f80 R15: 00007ffd415ad2b8\n...\n[   63.018142] ---[ end trace ]---\n\nHistorically, the signed integer overflow sanitizer did not work in the\nkernel due to its interaction with `-fwrapv` but this has since been\nchanged [1] in the newest version of Clang; It was re-enabled in the\nkernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow\nsanitizer\").\n\nLet's rework this overflow checking logic to not actually perform an\noverflow during the check itself, thus avoiding the UBSAN splat.\n\n[1]: https://github.com/llvm/llvm-project/pull/82432",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41011",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdkfd: don't allow mapping the MMIO HDP page with large pages",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: don't allow mapping the MMIO HDP page with large pages\n\nWe don't get the right offset in that case.  The GPU has\nan unused 4K area of the register BAR space into which you can\nremap registers.  We remap the HDP flush registers into this\nspace to allow userspace (CPU or GPU) to flush the HDP when it\nupdates VRAM.  However, on systems with >4K pages, we end up\nexposing PAGE_SIZE of MMIO space.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41013",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: xfs: don&#39;t walk off the end of a directory data block",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfs: don't walk off the end of a directory data block\n\nThis adds sanity checks for xfs_dir2_data_unused and xfs_dir2_data_entry\nto make sure don't stray beyond valid memory region. Before patching, the\nloop simply checks that the start offset of the dup and dep is within the\nrange. So in a crafted image, if last entry is xfs_dir2_data_unused, we\ncan change dup->length to dup->length-1 and leave 1 byte of space. In the\nnext traversal, this space will be considered as dup or dep. We may\nencounter an out of bound read when accessing the fixed members.\n\nIn the patch, we make sure that the remaining bytes large enough to hold\nan unused entry before accessing xfs_dir2_data_unused and\nxfs_dir2_data_unused is XFS_DIR2_DATA_ALIGN byte aligned. We also make\nsure that the remaining bytes large enough to hold a dirent with a\nsingle-byte name before accessing xfs_dir2_data_entry.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41040",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Fix UAF when resolving a clash",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Fix UAF when resolving a clash\n\nKASAN reports the following UAF:\n\n BUG: KASAN: slab-use-after-free in tcf_ct_flow_table_process_conn+0x12b/0x380 [act_ct]\n Read of size 1 at addr ffff888c07603600 by task handler130/6469\n\n Call Trace:\n  <IRQ>\n  dump_stack_lvl+0x48/0x70\n  print_address_description.constprop.0+0x33/0x3d0\n  print_report+0xc0/0x2b0\n  kasan_report+0xd0/0x120\n  __asan_load1+0x6c/0x80\n  tcf_ct_flow_table_process_conn+0x12b/0x380 [act_ct]\n  tcf_ct_act+0x886/0x1350 [act_ct]\n  tcf_action_exec+0xf8/0x1f0\n  fl_classify+0x355/0x360 [cls_flower]\n  __tcf_classify+0x1fd/0x330\n  tcf_classify+0x21c/0x3c0\n  sch_handle_ingress.constprop.0+0x2c5/0x500\n  __netif_receive_skb_core.constprop.0+0xb25/0x1510\n  __netif_receive_skb_list_core+0x220/0x4c0\n  netif_receive_skb_list_internal+0x446/0x620\n  napi_complete_done+0x157/0x3d0\n  gro_cell_poll+0xcf/0x100\n  __napi_poll+0x65/0x310\n  net_rx_action+0x30c/0x5c0\n  __do_softirq+0x14f/0x491\n  __irq_exit_rcu+0x82/0xc0\n  irq_exit_rcu+0xe/0x20\n  common_interrupt+0xa1/0xb0\n  </IRQ>\n  <TASK>\n  asm_common_interrupt+0x27/0x40\n\n Allocated by task 6469:\n  kasan_save_stack+0x38/0x70\n  kasan_set_track+0x25/0x40\n  kasan_save_alloc_info+0x1e/0x40\n  __kasan_krealloc+0x133/0x190\n  krealloc+0xaa/0x130\n  nf_ct_ext_add+0xed/0x230 [nf_conntrack]\n  tcf_ct_act+0x1095/0x1350 [act_ct]\n  tcf_action_exec+0xf8/0x1f0\n  fl_classify+0x355/0x360 [cls_flower]\n  __tcf_classify+0x1fd/0x330\n  tcf_classify+0x21c/0x3c0\n  sch_handle_ingress.constprop.0+0x2c5/0x500\n  __netif_receive_skb_core.constprop.0+0xb25/0x1510\n  __netif_receive_skb_list_core+0x220/0x4c0\n  netif_receive_skb_list_internal+0x446/0x620\n  napi_complete_done+0x157/0x3d0\n  gro_cell_poll+0xcf/0x100\n  __napi_poll+0x65/0x310\n  net_rx_action+0x30c/0x5c0\n  __do_softirq+0x14f/0x491\n\n Freed by task 6469:\n  kasan_save_stack+0x38/0x70\n  kasan_set_track+0x25/0x40\n  kasan_save_free_info+0x2b/0x60\n  ____kasan_slab_free+0x180/0x1f0\n  __kasan_slab_free+0x12/0x30\n  slab_free_freelist_hook+0xd2/0x1a0\n  __kmem_cache_free+0x1a2/0x2f0\n  kfree+0x78/0x120\n  nf_conntrack_free+0x74/0x130 [nf_conntrack]\n  nf_ct_destroy+0xb2/0x140 [nf_conntrack]\n  __nf_ct_resolve_clash+0x529/0x5d0 [nf_conntrack]\n  nf_ct_resolve_clash+0xf6/0x490 [nf_conntrack]\n  __nf_conntrack_confirm+0x2c6/0x770 [nf_conntrack]\n  tcf_ct_act+0x12ad/0x1350 [act_ct]\n  tcf_action_exec+0xf8/0x1f0\n  fl_classify+0x355/0x360 [cls_flower]\n  __tcf_classify+0x1fd/0x330\n  tcf_classify+0x21c/0x3c0\n  sch_handle_ingress.constprop.0+0x2c5/0x500\n  __netif_receive_skb_core.constprop.0+0xb25/0x1510\n  __netif_receive_skb_list_core+0x220/0x4c0\n  netif_receive_skb_list_internal+0x446/0x620\n  napi_complete_done+0x157/0x3d0\n  gro_cell_poll+0xcf/0x100\n  __napi_poll+0x65/0x310\n  net_rx_action+0x30c/0x5c0\n  __do_softirq+0x14f/0x491\n\nThe ct may be dropped if a clash has been resolved but is still passed to\nthe tcf_ct_flow_table_process_conn function for further usage. This issue\ncan be fixed by retrieving ct from skb again after confirming conntrack.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41042",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nf_tables: prefer nft_chain_validate",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: prefer nft_chain_validate\n\nnft_chain_validate already performs loop detection because a cycle will\nresult in a call stack overflow (ctx->level >= NFT_JUMP_STACK_SIZE).\n\nIt also follows maps via ->validate callback in nft_lookup, so there\nappears no reason to iterate the maps again.\n\nnf_tables_check_loops() and all its helper functions can be removed.\nThis improves ruleset load time significantly, from 23s down to 12s.\n\nThis also fixes a crash bug. Old loop detection code can result in\nunbounded recursion:\n\nBUG: TASK stack guard page was hit at ....\nOops: stack guard page: 0000 [#1] PREEMPT SMP KASAN\nCPU: 4 PID: 1539 Comm: nft Not tainted 6.10.0-rc5+ #1\n[..]\n\nwith a suitable ruleset during validation of register stores.\n\nI can't see any actual reason to attempt to check for this from\nnft_validate_register_store(), at this point the transaction is still in\nprogress, so we don't have a full picture of the rule graph.\n\nFor nf-next it might make sense to either remove it or make this depend\non table->validate_state in case we could catch an error earlier\n(for improved error reporting to userspace).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41046",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: ethernet: lantiq_etop: fix double free in detach",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ethernet: lantiq_etop: fix double free in detach\n\nThe number of the currently released descriptor is never incremented\nwhich results in the same skb being released multiple times.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41049",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: filelock: fix potential use-after-free in posix_lock_inode",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfilelock: fix potential use-after-free in posix_lock_inode\n\nLight Hsieh reported a KASAN UAF warning in trace_posix_lock_inode().\nThe request pointer had been changed earlier to point to a lock entry\nthat was added to the inode's list. However, before the tracepoint could\nfire, another task raced in and freed that lock.\n\nFix this by moving the tracepoint inside the spinlock, which should\nensure that this doesn't happen.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41059",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hfsplus: fix uninit-value in copy_name",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: fix uninit-value in copy_name\n\n[syzbot reported]\nBUG: KMSAN: uninit-value in sized_strscpy+0xc4/0x160\n sized_strscpy+0xc4/0x160\n copy_name+0x2af/0x320 fs/hfsplus/xattr.c:411\n hfsplus_listxattr+0x11e9/0x1a50 fs/hfsplus/xattr.c:750\n vfs_listxattr fs/xattr.c:493 [inline]\n listxattr+0x1f3/0x6b0 fs/xattr.c:840\n path_listxattr fs/xattr.c:864 [inline]\n __do_sys_listxattr fs/xattr.c:876 [inline]\n __se_sys_listxattr fs/xattr.c:873 [inline]\n __x64_sys_listxattr+0x16b/0x2f0 fs/xattr.c:873\n x64_sys_call+0x2ba0/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:195\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was created at:\n slab_post_alloc_hook mm/slub.c:3877 [inline]\n slab_alloc_node mm/slub.c:3918 [inline]\n kmalloc_trace+0x57b/0xbe0 mm/slub.c:4065\n kmalloc include/linux/slab.h:628 [inline]\n hfsplus_listxattr+0x4cc/0x1a50 fs/hfsplus/xattr.c:699\n vfs_listxattr fs/xattr.c:493 [inline]\n listxattr+0x1f3/0x6b0 fs/xattr.c:840\n path_listxattr fs/xattr.c:864 [inline]\n __do_sys_listxattr fs/xattr.c:876 [inline]\n __se_sys_listxattr fs/xattr.c:873 [inline]\n __x64_sys_listxattr+0x16b/0x2f0 fs/xattr.c:873\n x64_sys_call+0x2ba0/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:195\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n[Fix]\nWhen allocating memory to strbuf, initialize memory to 0.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41069",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: topology: Fix references to freed memory",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: topology: Fix references to freed memory\n\nMost users after parsing a topology file, release memory used by it, so\nhaving pointer references directly into topology file contents is wrong.\nUse devm_kmemdup(), to allocate memory as needed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41070",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: PPC: Book3S HV: Prevent UAF in kvm_spapr_tce_attach_iommu_group()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: PPC: Book3S HV: Prevent UAF in kvm_spapr_tce_attach_iommu_group()\n\nAl reported a possible use-after-free (UAF) in kvm_spapr_tce_attach_iommu_group().\n\nIt looks up `stt` from tablefd, but then continues to use it after doing\nfdput() on the returned fd. After the fdput() the tablefd is free to be\nclosed by another thread. The close calls kvm_spapr_tce_release() and\nthen release_spapr_tce_table() (via call_rcu()) which frees `stt`.\n\nAlthough there are calls to rcu_read_lock() in\nkvm_spapr_tce_attach_iommu_group() they are not sufficient to prevent\nthe UAF, because `stt` is used outside the locked regions.\n\nWith an artifcial delay after the fdput() and a userspace program which\ntriggers the race, KASAN detects the UAF:\n\n  BUG: KASAN: slab-use-after-free in kvm_spapr_tce_attach_iommu_group+0x298/0x720 [kvm]\n  Read of size 4 at addr c000200027552c30 by task kvm-vfio/2505\n  CPU: 54 PID: 2505 Comm: kvm-vfio Not tainted 6.10.0-rc3-next-20240612-dirty #1\n  Hardware name: 8335-GTH POWER9 0x4e1202 opal:skiboot-v6.5.3-35-g1851b2a06 PowerNV\n  Call Trace:\n    dump_stack_lvl+0xb4/0x108 (unreliable)\n    print_report+0x2b4/0x6ec\n    kasan_report+0x118/0x2b0\n    __asan_load4+0xb8/0xd0\n    kvm_spapr_tce_attach_iommu_group+0x298/0x720 [kvm]\n    kvm_vfio_set_attr+0x524/0xac0 [kvm]\n    kvm_device_ioctl+0x144/0x240 [kvm]\n    sys_ioctl+0x62c/0x1810\n    system_call_exception+0x190/0x440\n    system_call_vectored_common+0x15c/0x2ec\n  ...\n  Freed by task 0:\n   ...\n   kfree+0xec/0x3e0\n   release_spapr_tce_table+0xd4/0x11c [kvm]\n   rcu_core+0x568/0x16a0\n   handle_softirqs+0x23c/0x920\n   do_softirq_own_stack+0x6c/0x90\n   do_softirq_own_stack+0x58/0x90\n   __irq_exit_rcu+0x218/0x2d0\n   irq_exit+0x30/0x80\n   arch_local_irq_restore+0x128/0x230\n   arch_local_irq_enable+0x1c/0x30\n   cpuidle_enter_state+0x134/0x5cc\n   cpuidle_enter+0x6c/0xb0\n   call_cpuidle+0x7c/0x100\n   do_idle+0x394/0x410\n   cpu_startup_entry+0x60/0x70\n   start_secondary+0x3fc/0x410\n   start_secondary_prolog+0x10/0x14\n\nFix it by delaying the fdput() until `stt` is no longer in use, which\nis effectively the entire function. To keep the patch minimal add a call\nto fdput() at each of the existing return paths. Future work can convert\nthe function to goto or __cleanup style cleanup.\n\nWith the fix in place the test case no longer triggers the UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41073",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nvme: avoid double free special payload",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme: avoid double free special payload\n\nIf a discard request needs to be retried, and that retry may fail before\na new special payload is added, a double free will result. Clear the\nRQF_SPECIAL_LOAD when the request is cleaned.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41087",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ata: libata-core: Fix double free on error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nata: libata-core: Fix double free on error\n\nIf e.g. the ata_port_alloc() call in ata_host_alloc() fails, we will jump\nto the err_out label, which will call devres_release_group().\ndevres_release_group() will trigger a call to ata_host_release().\nata_host_release() calls kfree(host), so executing the kfree(host) in\nata_host_alloc() will lead to a double free:\n\nkernel BUG at mm/slub.c:553!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 11 PID: 599 Comm: (udev-worker) Not tainted 6.10.0-rc5 #47\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014\nRIP: 0010:kfree+0x2cf/0x2f0\nCode: 5d 41 5e 41 5f 5d e9 80 d6 ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da\nRSP: 0018:ffffc90000f377f0 EFLAGS: 00010246\nRAX: ffff888112b1f2c0 RBX: ffff888112b1f2c0 RCX: ffff888112b1f320\nRDX: 000000000000400b RSI: ffffffffc02c9de5 RDI: ffff888112b1f2c0\nRBP: ffffc90000f37830 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffc90000f37610 R11: 617461203a736b6e R12: ffffea00044ac780\nR13: ffff888100046400 R14: ffffffffc02c9de5 R15: 0000000000000006\nFS:  00007f2f1cabe980(0000) GS:ffff88813b380000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f2f1c3acf75 CR3: 0000000111724000 CR4: 0000000000750ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __die_body.cold+0x19/0x27\n ? die+0x2e/0x50\n ? do_trap+0xca/0x110\n ? do_error_trap+0x6a/0x90\n ? kfree+0x2cf/0x2f0\n ? exc_invalid_op+0x50/0x70\n ? kfree+0x2cf/0x2f0\n ? asm_exc_invalid_op+0x1a/0x20\n ? ata_host_alloc+0xf5/0x120 [libata]\n ? ata_host_alloc+0xf5/0x120 [libata]\n ? kfree+0x2cf/0x2f0\n ata_host_alloc+0xf5/0x120 [libata]\n ata_host_alloc_pinfo+0x14/0xa0 [libata]\n ahci_init_one+0x6c9/0xd20 [ahci]\n\nEnsure that we will not call kfree(host) twice, by performing the kfree()\nonly if the devres_open_group() call failed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41090",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: virtio-net: tap: mlx5_core short frame denial of service",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntap: add missing verification for short frame\n\nThe cited commit missed to check against the validity of the frame length\nin the tap_get_user_xdp() path, which could cause a corrupted skb to be\nsent downstack. Even before the skb is transmitted, the\ntap_get_user_xdp()-->skb_set_network_header() may assume the size is more\nthan ETH_HLEN. Once transmitted, this could either cause out-of-bound\naccess beyond the actual length, or confuse the underlayer with incorrect\nor inconsistent header length in the skb metadata.\n\nIn the alternative path, tap_get_user() already prohibits short frame which\nhas the length less than Ethernet header size from being transmitted.\n\nThis is to drop any frame shorter than the Ethernet header size just like\nhow tap_get_user() does.\n\nCVE: CVE-2024-41090",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41091",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: virtio-net: tun: mlx5_core short frame denial of service",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntun: add missing verification for short frame\n\nThe cited commit missed to check against the validity of the frame length\nin the tun_xdp_one() path, which could cause a corrupted skb to be sent\ndownstack. Even before the skb is transmitted, the\ntun_xdp_one-->eth_type_trans() may access the Ethernet header although it\ncan be less than ETH_HLEN. Once transmitted, this could either cause\nout-of-bound access beyond the actual length, or confuse the underlayer\nwith incorrect or inconsistent header length in the skb metadata.\n\nIn the alternative path, tun_get_user() already prohibits short frame which\nhas the length less than Ethernet header size from being transmitted for\nIFF_TAP.\n\nThis is to drop any frame shorter than the Ethernet header size just like\nhow tun_get_user() does.\n\nCVE: CVE-2024-41091",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41092",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/i915/gt: Fix potential UAF by revoke of fence registers",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/gt: Fix potential UAF by revoke of fence registers\n\nCI has been sporadically reporting the following issue triggered by\nigt@i915_selftest@live@hangcheck on ADL-P and similar machines:\n\n<6> [414.049203] i915: Running intel_hangcheck_live_selftests/igt_reset_evict_fence\n...\n<6> [414.068804] i915 0000:00:02.0: [drm] GT0: GUC: submission enabled\n<6> [414.068812] i915 0000:00:02.0: [drm] GT0: GUC: SLPC enabled\n<3> [414.070354] Unable to pin Y-tiled fence; err:-4\n<3> [414.071282] i915_vma_revoke_fence:301 GEM_BUG_ON(!i915_active_is_idle(&fence->active))\n...\n<4>[  609.603992] ------------[ cut here ]------------\n<2>[  609.603995] kernel BUG at drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:301!\n<4>[  609.604003] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n<4>[  609.604006] CPU: 0 PID: 268 Comm: kworker/u64:3 Tainted: G     U  W          6.9.0-CI_DRM_14785-g1ba62f8cea9c+ #1\n<4>[  609.604008] Hardware name: Intel Corporation Alder Lake Client Platform/AlderLake-P DDR4 RVP, BIOS RPLPFWI1.R00.4035.A00.2301200723 01/20/2023\n<4>[  609.604010] Workqueue: i915 __i915_gem_free_work [i915]\n<4>[  609.604149] RIP: 0010:i915_vma_revoke_fence+0x187/0x1f0 [i915]\n...\n<4>[  609.604271] Call Trace:\n<4>[  609.604273]  <TASK>\n...\n<4>[  609.604716]  __i915_vma_evict+0x2e9/0x550 [i915]\n<4>[  609.604852]  __i915_vma_unbind+0x7c/0x160 [i915]\n<4>[  609.604977]  force_unbind+0x24/0xa0 [i915]\n<4>[  609.605098]  i915_vma_destroy+0x2f/0xa0 [i915]\n<4>[  609.605210]  __i915_gem_object_pages_fini+0x51/0x2f0 [i915]\n<4>[  609.605330]  __i915_gem_free_objects.isra.0+0x6a/0xc0 [i915]\n<4>[  609.605440]  process_scheduled_works+0x351/0x690\n...\n\nIn the past, there were similar failures reported by CI from other IGT\ntests, observed on other platforms.\n\nBefore commit 63baf4f3d587 (\"drm/i915/gt: Only wait for GPU activity\nbefore unbinding a GGTT fence\"), i915_vma_revoke_fence() was waiting for\nidleness of vma->active via fence_update().   That commit introduced\nvma->fence->active in order for the fence_update() to be able to wait\nselectively on that one instead of vma->active since only idleness of\nfence registers was needed.  But then, another commit 0d86ee35097a\n(\"drm/i915/gt: Make fence revocation unequivocal\") replaced the call to\nfence_update() in i915_vma_revoke_fence() with only fence_write(), and\nalso added that GEM_BUG_ON(!i915_active_is_idle(&fence->active)) in front.\nNo justification was provided on why we might then expect idleness of\nvma->fence->active without first waiting on it.\n\nThe issue can be potentially caused by a race among revocation of fence\nregisters on one side and sequential execution of signal callbacks invoked\non completion of a request that was using them on the other, still\nprocessed in parallel to revocation of those fence registers.  Fix it by\nwaiting for idleness of vma->fence->active in i915_vma_revoke_fence().\n\n(cherry picked from commit 24bb052d3dd499c5956abad5f7d8e4fd07da7fb1)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-41935",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to shrink read extent node in batches",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to shrink read extent node in batches\n\nWe use rwlock to protect core structure data of extent tree during\nits shrink, however, if there is a huge number of extent nodes in\nextent tree, during shrink of extent tree, it may hold rwlock for\na very long time, which may trigger kernel hang issue.\n\nThis patch fixes to shrink read extent node in batches, so that,\ncritical region of the rwlock can be shrunk to avoid its extreme\nlong time hold.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42086",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: chemical: bme680: Fix overflows in compensate() functions",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: chemical: bme680: Fix overflows in compensate() functions\n\nThere are cases in the compensate functions of the driver that\nthere could be overflows of variables due to bit shifting ops.\nThese implications were initially discussed here [1] and they\nwere mentioned in log message of Commit 1b3bd8592780 (\"iio:\nchemical: Add support for Bosch BME680 sensor\").\n\n[1]: https://lore.kernel.org/linux-iio/20180728114028.3c1bbe81@archlinux/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42092",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gpio: davinci: Validate the obtained number of IRQs",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpio: davinci: Validate the obtained number of IRQs\n\nValue of pdata->gpio_unbanked is taken from Device Tree. In case of broken\nDT due to any error this value can be any. Without this value validation\nthere can be out of chips->irqs array boundaries access in\ndavinci_gpio_probe().\n\nValidate the obtained nirq value so that it won't exceed the maximum\nnumber of IRQs per bank.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42093",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/dpaa2: Avoid explicit cpumask var allocation on stack",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/dpaa2: Avoid explicit cpumask var allocation on stack\n\nFor CONFIG_CPUMASK_OFFSTACK=y kernel, explicit allocation of cpumask\nvariable on stack is not recommended since it can cause potential stack\noverflow.\n\nInstead, kernel code should always use *cpumask_var API(s) to allocate\ncpumask var in config-neutral way, leaving allocation strategy to\nCONFIG_CPUMASK_OFFSTACK.\n\nUse *cpumask_var API(s) to address it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42094",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.221-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/iucv: Avoid explicit cpumask var allocation on stack",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/iucv: Avoid explicit cpumask var allocation on stack\n\nFor CONFIG_CPUMASK_OFFSTACK=y kernel, explicit allocation of cpumask\nvariable on stack is not recommended since it can cause potential stack\noverflow.\n\nInstead, kernel code should always use *cpumask_var API(s) to allocate\ncpumask var in config-neutral way, leaving allocation strategy to\nCONFIG_CPUMASK_OFFSTACK.\n\nUse *cpumask_var API(s) to address it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42104",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: add missing check for inode numbers on directory entries",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: add missing check for inode numbers on directory entries\n\nSyzbot reported that mounting and unmounting a specific pattern of\ncorrupted nilfs2 filesystem images causes a use-after-free of metadata\nfile inodes, which triggers a kernel bug in lru_add_fn().\n\nAs Jan Kara pointed out, this is because the link count of a metadata file\ngets corrupted to 0, and nilfs_evict_inode(), which is called from iput(),\ntries to delete that inode (ifile inode in this case).\n\nThe inconsistency occurs because directories containing the inode numbers\nof these metadata files that should not be visible in the namespace are\nread without checking.\n\nFix this issue by treating the inode numbers of these internal files as\nerrors in the sanity check helper when reading directory folios/pages.\n\nAlso thanks to Hillf Danton and Matthew Wilcox for their initial mm-layer\nanalysis.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42105",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix inode number range checks",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix inode number range checks\n\nPatch series \"nilfs2: fix potential issues related to reserved inodes\".\n\nThis series fixes one use-after-free issue reported by syzbot, caused by\nnilfs2's internal inode being exposed in the namespace on a corrupted\nfilesystem, and a couple of flaws that cause problems if the starting\nnumber of non-reserved inodes written in the on-disk super block is\nintentionally (or corruptly) changed from its default value.  \n\n\nThis patch (of 3):\n\nIn the current implementation of nilfs2, \"nilfs->ns_first_ino\", which\ngives the first non-reserved inode number, is read from the superblock,\nbut its lower limit is not checked.\n\nAs a result, if a number that overlaps with the inode number range of\nreserved inodes such as the root directory or metadata files is set in the\nsuper block parameter, the inode number test macros (NILFS_MDT_INODE and\nNILFS_VALID_INODE) will not function properly.\n\nIn addition, these test macros use left bit-shift calculations using with\nthe inode number as the shift count via the BIT macro, but the result of a\nshift calculation that exceeds the bit width of an integer is undefined in\nthe C specification, so if \"ns_first_ino\" is set to a large value other\nthan the default value NILFS_USER_INO (=11), the macros may potentially\nmalfunction depending on the environment.\n\nFix these issues by checking the lower bound of \"nilfs->ns_first_ino\" and\nby preventing bit shifts equal to or greater than the NILFS_USER_INO\nconstant in the inode number test macros.\n\nAlso, change the type of \"ns_first_ino\" from signed integer to unsigned\ninteger to avoid the need for type casting in comparisons such as the\nlower bound check introduced this time.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42118",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Do not return negative stream id for array",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Do not return negative stream id for array\n\n[WHY]\nresource_stream_to_stream_idx returns an array index and it return -1\nwhen not found; however, -1 is not a valid array index number.\n\n[HOW]\nWhen this happens, call ASSERT(), and return a zero instead.\n\nThis fixes an OVERRUN and an NEGATIVE_RETURNS issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42119",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Skip finding free audio for unknown engine_id",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Skip finding free audio for unknown engine_id\n\n[WHY]\nENGINE_ID_UNKNOWN = -1 and can not be used as an array index. Plus, it\nalso means it is uninitialized and does not need free audio.\n\n[HOW]\nSkip and return NULL.\n\nThis fixes 2 OVERRUN issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42120",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Check pipe offset before setting vblank",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check pipe offset before setting vblank\n\npipe_ctx has a size of MAX_PIPES so checking its index before accessing\nthe array.\n\nThis fixes an OVERRUN issue reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42121",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Check index msg_id before read or write",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check index msg_id before read or write\n\n[WHAT]\nmsg_id is used as an array index and it cannot be a negative value, and\ntherefore cannot be equal to MOD_HDCP_MESSAGE_ID_INVALID (-1).\n\n[HOW]\nCheck whether msg_id is valid before reading and setting.\n\nThis fixes 4 OVERRUN issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42147",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: hisilicon/debugfs - Fix debugfs uninit process issue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: hisilicon/debugfs - Fix debugfs uninit process issue\n\nDuring the zip probe process, the debugfs failure does not stop\nthe probe. When debugfs initialization fails, jumping to the\nerror branch will also release regs, in addition to its own\nrollback operation.\n\nAs a result, it may be released repeatedly during the regs\nuninit process. Therefore, the null check needs to be added to\nthe regs uninit process.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42148",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.223-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bnx2x: Fix multiple UBSAN array-index-out-of-bounds",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnx2x: Fix multiple UBSAN array-index-out-of-bounds\n\nFix UBSAN warnings that occur when using a system with 32 physical\ncpu cores or more, or when the user defines a number of Ethernet\nqueues greater than or equal to FP_SB_MAX_E1x using the num_queues\nmodule parameter.\n\nCurrently there is a read/write out of bounds that occurs on the array\n\"struct stats_query_entry query\" present inside the \"bnx2x_fw_stats_req\"\nstruct in \"drivers/net/ethernet/broadcom/bnx2x/bnx2x.h\".\nLooking at the definition of the \"struct stats_query_entry query\" array:\n\nstruct stats_query_entry query[FP_SB_MAX_E1x+\n         BNX2X_FIRST_QUEUE_QUERY_IDX];\n\nFP_SB_MAX_E1x is defined as the maximum number of fast path interrupts and\nhas a value of 16, while BNX2X_FIRST_QUEUE_QUERY_IDX has a value of 3\nmeaning the array has a total size of 19.\nSince accesses to \"struct stats_query_entry query\" are offset-ted by\nBNX2X_FIRST_QUEUE_QUERY_IDX, that means that the total number of Ethernet\nqueues should not exceed FP_SB_MAX_E1x (16). However one of these queues\nis reserved for FCOE and thus the number of Ethernet queues should be set\nto [FP_SB_MAX_E1x -1] (15) if FCOE is enabled or [FP_SB_MAX_E1x] (16) if\nit is not.\n\nThis is also described in a comment in the source code in\ndrivers/net/ethernet/broadcom/bnx2x/bnx2x.h just above the Macro definition\nof FP_SB_MAX_E1x. Below is the part of this explanation that it important\nfor this patch\n\n/*\n  * The total number of L2 queues, MSIX vectors and HW contexts (CIDs) is\n  * control by the number of fast-path status blocks supported by the\n  * device (HW/FW). Each fast-path status block (FP-SB) aka non-default\n  * status block represents an independent interrupts context that can\n  * serve a regular L2 networking queue. However special L2 queues such\n  * as the FCoE queue do not require a FP-SB and other components like\n  * the CNIC may consume FP-SB reducing the number of possible L2 queues\n  *\n  * If the maximum number of FP-SB available is X then:\n  * a. If CNIC is supported it consumes 1 FP-SB thus the max number of\n  *    regular L2 queues is Y=X-1\n  * b. In MF mode the actual number of L2 queues is Y= (X-1/MF_factor)\n  * c. If the FCoE L2 queue is supported the actual number of L2 queues\n  *    is Y+1\n  * d. The number of irqs (MSIX vectors) is either Y+1 (one extra for\n  *    slow-path interrupts) or Y+2 if CNIC is supported (one additional\n  *    FP interrupt context for the CNIC).\n  * e. The number of HW context (CID count) is always X or X+1 if FCoE\n  *    L2 queue is supported. The cid for the FCoE L2 queue is always X.\n  */\n\nHowever this driver also supports NICs that use the E2 controller which can\nhandle more queues due to having more FP-SB represented by FP_SB_MAX_E2.\nLooking at the commits when the E2 support was added, it was originally\nusing the E1x parameters: commit f2e0899f0f27 (\"bnx2x: Add 57712 support\").\nBack then FP_SB_MAX_E2 was set to 16 the same as E1x. However the driver\nwas later updated to take full advantage of the E2 instead of having it be\nlimited to the capabilities of the E1x. But as far as we can tell, the\narray \"stats_query_entry query\" was still limited to using the FP-SB\navailable to the E1x cards as part of an oversignt when the driver was\nupdated to take full advantage of the E2, and now with the driver being\naware of the greater queue size supported by E2 NICs, it causes the UBSAN\nwarnings seen in the stack traces below.\n\nThis patch increases the size of the \"stats_query_entry query\" array by\nreplacing FP_SB_MAX_E1x with FP_SB_MAX_E2 to be large enough to handle\nboth types of NICs.\n\nStack traces:\n\nUBSAN: array-index-out-of-bounds in\n       drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:1529:11\nindex 20 is out of range for type 'stats_query_entry [19]'\nCPU: 12 PID: 858 Comm: systemd-network Not tainted 6.9.0-060900rc7-generic\n\t     #202405052133\nHardware name: HP ProLiant DL360 Gen9/ProLiant DL360 \n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42160",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: check validation of fault attrs in f2fs_build_fault_attr()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: check validation of fault attrs in f2fs_build_fault_attr()\n\n- It missed to check validation of fault attrs in parse_options(),\nlet's fix to add check condition in f2fs_build_fault_attr().\n- Use f2fs_build_fault_attr() in __sbi_store() to clean up code.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42162",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gve: Account for stopped queues when reading NIC stats",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngve: Account for stopped queues when reading NIC stats\n\nWe now account for the fact that the NIC might send us stats for a\nsubset of queues. Without this change, gve_get_ethtool_stats might make\nan invalid access on the priv->stats_report->stats array.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42225",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mt76: replace skb_put with skb_put_zero",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: replace skb_put with skb_put_zero\n\nAvoid potentially reusing uninitialized data",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42228",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: Using uninitialized value *size when calling amdgpu_vce_cs_reloc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Using uninitialized value *size when calling amdgpu_vce_cs_reloc\n\nInitialize the size before calling amdgpu_vce_cs_reloc, such as case 0x03000001.\nV2: To really improve the handling we would actually\n   need to have a separate value of 0xffffffff.(Christian)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42271",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/iucv: fix use after free in iucv_sock_close()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/iucv: fix use after free in iucv_sock_close()\n\niucv_sever_path() is called from process context and from bh context.\niucv->path is used as indicator whether somebody else is taking care of\nsevering the path (or it is already removed / never existed).\nThis needs to be done with atomic compare and swap, otherwise there is a\nsmall window where iucv_sock_close() will try to work with a path that has\nalready been severed and freed by iucv_callback_connrej() called by\niucv_tasklet_fn().\n\nExample:\n[452744.123844] Call Trace:\n[452744.123845] ([<0000001e87f03880>] 0x1e87f03880)\n[452744.123966]  [<00000000d593001e>] iucv_path_sever+0x96/0x138\n[452744.124330]  [<000003ff801ddbca>] iucv_sever_path+0xc2/0xd0 [af_iucv]\n[452744.124336]  [<000003ff801e01b6>] iucv_sock_close+0xa6/0x310 [af_iucv]\n[452744.124341]  [<000003ff801e08cc>] iucv_sock_release+0x3c/0xd0 [af_iucv]\n[452744.124345]  [<00000000d574794e>] __sock_release+0x5e/0xe8\n[452744.124815]  [<00000000d5747a0c>] sock_close+0x34/0x48\n[452744.124820]  [<00000000d5421642>] __fput+0xba/0x268\n[452744.124826]  [<00000000d51b382c>] task_work_run+0xbc/0xf0\n[452744.124832]  [<00000000d5145710>] do_notify_resume+0x88/0x90\n[452744.124841]  [<00000000d5978096>] system_call+0xe2/0x2c8\n[452744.125319] Last Breaking-Event-Address:\n[452744.125321]  [<00000000d5930018>] iucv_path_sever+0x90/0x138\n[452744.125324]\n[452744.125325] Kernel panic - not syncing: Fatal exception in interrupt\n\nNote that bh_lock_sock() is not serializing the tasklet context against\nprocess context, because the check for sock_owned_by_user() and\ncorresponding handling is missing.\n\nIdeas for a future clean-up patch:\nA) Correct usage of bh_lock_sock() in tasklet context, as described in\nRe-enqueue, if needed. This may require adding return values to the\ntasklet functions and thus changes to all users of iucv.\n\nB) Change iucv tasklet into worker and use only lock_sock() in af_iucv.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42280",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mISDN: Fix a use after free in hfcmulti_tx()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmISDN: Fix a use after free in hfcmulti_tx()\n\nDon't dereference *sp after calling dev_kfree_skb(*sp).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42284",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tipc: Return non-zero value from tipc_udp_addr2str() on error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Return non-zero value from tipc_udp_addr2str() on error\n\ntipc_udp_addr2str() should return non-zero value if the UDP media\naddress is invalid. Otherwise, a buffer overflow access can occur in\ntipc_media_addr_printf(). Fix this by returning 1 on an invalid UDP\nmedia address.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42285",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/iwcm: Fix a use-after-free related to destroying CM IDs",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/iwcm: Fix a use-after-free related to destroying CM IDs\n\niw_conn_req_handler() associates a new struct rdma_id_private (conn_id) with\nan existing struct iw_cm_id (cm_id) as follows:\n\n        conn_id->cm_id.iw = cm_id;\n        cm_id->context = conn_id;\n        cm_id->cm_handler = cma_iw_handler;\n\nrdma_destroy_id() frees both the cm_id and the struct rdma_id_private. Make\nsure that cm_work_handler() does not trigger a use-after-free by only\nfreeing of the struct rdma_id_private after all pending work has finished.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42292",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: kobject_uevent: Fix OOB access within zap_modalias_env()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkobject_uevent: Fix OOB access within zap_modalias_env()\n\nzap_modalias_env() wrongly calculates size of memory block to move, so\nwill cause OOB memory access issue if variable MODALIAS is not the last\none within its @env parameter, fixed by correcting size to memmove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42301",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dev/parport: fix the array out-of-bounds risk",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndev/parport: fix the array out-of-bounds risk\n\nFixed array out-of-bounds issues caused by sprintf\nby replacing it with snprintf for safer data copying,\nensuring the destination buffer is not overflowed.\n\nBelow is the stack trace I encountered during the actual issue:\n\n[ 66.575408s] [pid:5118,cpu4,QThread,4]Kernel panic - not syncing: stack-protector:\nKernel stack is corrupted in: do_hardware_base_addr+0xcc/0xd0 [parport]\n[ 66.575408s] [pid:5118,cpu4,QThread,5]CPU: 4 PID: 5118 Comm:\nQThread Tainted: G S W O 5.10.97-arm64-desktop #7100.57021.2\n[ 66.575439s] [pid:5118,cpu4,QThread,6]TGID: 5087 Comm: EFileApp\n[ 66.575439s] [pid:5118,cpu4,QThread,7]Hardware name: HUAWEI HUAWEI QingYun\nPGUX-W515x-B081/SP1PANGUXM, BIOS 1.00.07 04/29/2024\n[ 66.575439s] [pid:5118,cpu4,QThread,8]Call trace:\n[ 66.575469s] [pid:5118,cpu4,QThread,9] dump_backtrace+0x0/0x1c0\n[ 66.575469s] [pid:5118,cpu4,QThread,0] show_stack+0x14/0x20\n[ 66.575469s] [pid:5118,cpu4,QThread,1] dump_stack+0xd4/0x10c\n[ 66.575500s] [pid:5118,cpu4,QThread,2] panic+0x1d8/0x3bc\n[ 66.575500s] [pid:5118,cpu4,QThread,3] __stack_chk_fail+0x2c/0x38\n[ 66.575500s] [pid:5118,cpu4,QThread,4] do_hardware_base_addr+0xcc/0xd0 [parport]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42302",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: PCI/DPC: Fix use-after-free on concurrent DPC and hot-removal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/DPC: Fix use-after-free on concurrent DPC and hot-removal\n\nKeith reports a use-after-free when a DPC event occurs concurrently to\nhot-removal of the same portion of the hierarchy:\n\nThe dpc_handler() awaits readiness of the secondary bus below the\nDownstream Port where the DPC event occurred.  To do so, it polls the\nconfig space of the first child device on the secondary bus.  If that\nchild device is concurrently removed, accesses to its struct pci_dev\ncause the kernel to oops.\n\nThat's because pci_bridge_wait_for_secondary_bus() neglects to hold a\nreference on the child device.  Before v6.3, the function was only\ncalled on resume from system sleep or on runtime resume.  Holding a\nreference wasn't necessary back then because the pciehp IRQ thread\ncould never run concurrently.  (On resume from system sleep, IRQs are\nnot enabled until after the resume_noirq phase.  And runtime resume is\nalways awaited before a PCI device is removed.)\n\nHowever starting with v6.3, pci_bridge_wait_for_secondary_bus() is also\ncalled on a DPC event.  Commit 53b54ad074de (\"PCI/DPC: Await readiness\nof secondary bus after reset\"), which introduced that, failed to\nappreciate that pci_bridge_wait_for_secondary_bus() now needs to hold a\nreference on the child device because dpc_handler() and pciehp may\nindeed run concurrently.  The commit was backported to v5.10+ stable\nkernels, so that's the oldest one affected.\n\nAdd the missing reference acquisition.\n\nAbridged stack trace:\n\n  BUG: unable to handle page fault for address: 00000000091400c0\n  CPU: 15 PID: 2464 Comm: irq/53-pcie-dpc 6.9.0\n  RIP: pci_bus_read_config_dword+0x17/0x50\n  pci_dev_wait()\n  pci_bridge_wait_for_secondary_bus()\n  dpc_reset_link()\n  pcie_do_recovery()\n  dpc_handler()",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-42313",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: venus: fix use after free in vdec_close",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: venus: fix use after free in vdec_close\n\nThere appears to be a possible use after free with vdec_close().\nThe firmware will add buffer release work to the work queue through\nHFI callbacks as a normal part of decoding. Randomly closing the\ndecoder device from userspace during normal decoding can incur\na read after free for inst.\n\nFix it by cancelling the work in vdec_close.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-43830",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: leds: trigger: Unregister sysfs attributes before calling deactivate()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nleds: trigger: Unregister sysfs attributes before calling deactivate()\n\nTriggers which have trigger specific sysfs attributes typically store\nrelated data in trigger-data allocated by the activate() callback and\nfreed by the deactivate() callback.\n\nCalling device_remove_groups() after calling deactivate() leaves a window\nwhere the sysfs attributes show/store functions could be called after\ndeactivation and then operate on the just freed trigger-data.\n\nMove the device_remove_groups() call to before deactivate() to close\nthis race window.\n\nThis also makes the deactivation path properly do things in reverse order\nof the activation path which calls the activate() callback before calling\ndevice_add_groups().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-43839",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bna: adjust 'name' buf size of bna_tcb and bna_ccb structures",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbna: adjust 'name' buf size of bna_tcb and bna_ccb structures\n\nTo have enough space to write all possible sprintf() args. Currently\n'name' size is 16, but the first '%s' specifier may already need at\nleast 16 characters, since 'bnad->netdev->name' is used there.\n\nFor '%d' specifiers, assume that they require:\n * 1 char for 'tx_id + tx_info->tcb[i]->id' sum, BNAD_MAX_TXQ_PER_TX is 8\n * 2 chars for 'rx_id + rx_info->rx_ctrl[i].ccb->id', BNAD_MAX_RXP_PER_RX\n   is 16\n\nAnd replace sprintf with snprintf.\n\nDetected using the static analysis tool - Svace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-43858",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: Fix array-index-out-of-bounds in diFree",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: Fix array-index-out-of-bounds in diFree",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-43882",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: exec: Fix ToCToU between perm check and set-uid/gid usage",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nexec: Fix ToCToU between perm check and set-uid/gid usage\n\nWhen opening a file for exec via do_filp_open(), permission checking is\ndone against the file's metadata at that moment, and on success, a file\npointer is passed back. Much later in the execve() code path, the file\nmetadata (specifically mode, uid, and gid) is used to determine if/how\nto set the uid and gid. However, those values may have changed since the\npermissions check, meaning the execution may gain unintended privileges.\n\nFor example, if a file could change permissions from executable and not\nset-id:\n\n---------x 1 root root 16048 Aug  7 13:16 target\n\nto set-id and non-executable:\n\n---S------ 1 root root 16048 Aug  7 13:16 target\n\nit is possible to gain root privileges when execution should have been\ndisallowed.\n\nWhile this race condition is rare in real-world scenarios, it has been\nobserved (and proven exploitable) when package managers are updating\nthe setuid bits of installed programs. Such files start with being\nworld-executable but then are adjusted to be group-exec with a set-uid\nbit. For example, \"chmod o-x,u+s target\" makes \"target\" executable only\nby uid \"root\" and gid \"cdrom\", while also becoming setuid-root:\n\n-rwxr-xr-x 1 root cdrom 16048 Aug  7 13:16 target\n\nbecomes:\n\n-rwsr-xr-- 1 root cdrom 16048 Aug  7 13:16 target\n\nBut racing the chmod means users without group \"cdrom\" membership can\nget the permission to execute \"target\" just before the chmod, and when\nthe chmod finishes, the exec reaches brpm_fill_uid(), and performs the\nsetuid to root, violating the expressed authorization of \"only cdrom\ngroup members can setuid to root\".\n\nRe-check that we still have execute permissions in case the metadata\nhas changed. It would be better to keep a copy from the perm-check time,\nbut until we can do that refactoring, the least-bad option is to do a\nfull inode_permission() call (under inode lock). It is understood that\nthis is safe against dead-locks, but hardly optimal.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-43883",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: vhci-hcd: Do not drop references before new references are gained",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: vhci-hcd: Do not drop references before new references are gained\n\nAt a few places the driver carries stale pointers\nto references that can still be used. Make sure that does not happen.\nThis strictly speaking closes ZDI-CAN-22273, though there may be\nsimilar races in the driver.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-43900",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: xc2028: avoid use-after-free in load_firmware_cb()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: xc2028: avoid use-after-free in load_firmware_cb()\n\nsyzkaller reported use-after-free in load_firmware_cb() [1].\nThe reason is because the module allocated a struct tuner in tuner_probe(),\nand then the module initialization failed, the struct tuner was released.\nA worker which created during module initialization accesses this struct\ntuner later, it caused use-after-free.\n\nThe process is as follows:\n\ntask-6504           worker_thread\ntuner_probe                             <= alloc dvb_frontend [2]\n...\nrequest_firmware_nowait                 <= create a worker\n...\ntuner_remove                            <= free dvb_frontend\n...\n                    request_firmware_work_func  <= the firmware is ready\n                    load_firmware_cb    <= but now the dvb_frontend has been freed\n\nTo fix the issue, check the dvd_frontend in load_firmware_cb(), if it is\nnull, report a warning and just return.\n\n[1]:\n    ==================================================================\n     BUG: KASAN: use-after-free in load_firmware_cb+0x1310/0x17a0\n     Read of size 8 at addr ffff8000d7ca2308 by task kworker/2:3/6504\n\n     Call trace:\n      load_firmware_cb+0x1310/0x17a0\n      request_firmware_work_func+0x128/0x220\n      process_one_work+0x770/0x1824\n      worker_thread+0x488/0xea0\n      kthread+0x300/0x430\n      ret_from_fork+0x10/0x20\n\n     Allocated by task 6504:\n      kzalloc\n      tuner_probe+0xb0/0x1430\n      i2c_device_probe+0x92c/0xaf0\n      really_probe+0x678/0xcd0\n      driver_probe_device+0x280/0x370\n      __device_attach_driver+0x220/0x330\n      bus_for_each_drv+0x134/0x1c0\n      __device_attach+0x1f4/0x410\n      device_initial_probe+0x20/0x30\n      bus_probe_device+0x184/0x200\n      device_add+0x924/0x12c0\n      device_register+0x24/0x30\n      i2c_new_device+0x4e0/0xc44\n      v4l2_i2c_new_subdev_board+0xbc/0x290\n      v4l2_i2c_new_subdev+0xc8/0x104\n      em28xx_v4l2_init+0x1dd0/0x3770\n\n     Freed by task 6504:\n      kfree+0x238/0x4e4\n      tuner_remove+0x144/0x1c0\n      i2c_device_remove+0xc8/0x290\n      __device_release_driver+0x314/0x5fc\n      device_release_driver+0x30/0x44\n      bus_remove_device+0x244/0x490\n      device_del+0x350/0x900\n      device_unregister+0x28/0xd0\n      i2c_unregister_device+0x174/0x1d0\n      v4l2_device_unregister+0x224/0x380\n      em28xx_v4l2_init+0x1d90/0x3770\n\n     The buggy address belongs to the object at ffff8000d7ca2000\n      which belongs to the cache kmalloc-2k of size 2048\n     The buggy address is located 776 bytes inside of\n      2048-byte region [ffff8000d7ca2000, ffff8000d7ca2800)\n     The buggy address belongs to the page:\n     page:ffff7fe00035f280 count:1 mapcount:0 mapping:ffff8000c001f000 index:0x0\n     flags: 0x7ff800000000100(slab)\n     raw: 07ff800000000100 ffff7fe00049d880 0000000300000003 ffff8000c001f000\n     raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000\n     page dumped because: kasan: bad access detected\n\n     Memory state around the buggy address:\n      ffff8000d7ca2200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n      ffff8000d7ca2280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n     >ffff8000d7ca2300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                           ^\n      ffff8000d7ca2380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n      ffff8000d7ca2400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n     ==================================================================\n\n[2]\n    Actually, it is allocated for struct tuner, and dvb_frontend is inside.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44934",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: bridge: mcast: wait for previous gc cycles when removing port",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: mcast: wait for previous gc cycles when removing port\n\nsyzbot hit a use-after-free[1] which is caused because the bridge doesn't\nmake sure that all previous garbage has been collected when removing a\nport. What happens is:\n      CPU 1                   CPU 2\n start gc cycle           remove port\n                         acquire gc lock first\n wait for lock\n                         call br_multicasg_gc() directly\n acquire lock now but    free port\n the port can be freed\n while grp timers still\n running\n\nMake sure all previous gc cycles have finished by using flush_work before\nfreeing the port.\n\n[1]\n  BUG: KASAN: slab-use-after-free in br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861\n  Read of size 8 at addr ffff888071d6d000 by task syz.5.1232/9699\n\n  CPU: 1 PID: 9699 Comm: syz.5.1232 Not tainted 6.10.0-rc5-syzkaller-00021-g24ca36a562d6 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/07/2024\n  Call Trace:\n   <IRQ>\n   __dump_stack lib/dump_stack.c:88 [inline]\n   dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114\n   print_address_description mm/kasan/report.c:377 [inline]\n   print_report+0xc3/0x620 mm/kasan/report.c:488\n   kasan_report+0xd9/0x110 mm/kasan/report.c:601\n   br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861\n   call_timer_fn+0x1a3/0x610 kernel/time/timer.c:1792\n   expire_timers kernel/time/timer.c:1843 [inline]\n   __run_timers+0x74b/0xaf0 kernel/time/timer.c:2417\n   __run_timer_base kernel/time/timer.c:2428 [inline]\n   __run_timer_base kernel/time/timer.c:2421 [inline]\n   run_timer_base+0x111/0x190 kernel/time/timer.c:2437",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44940",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fou: remove warn in gue_gro_receive on unsupported protocol",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfou: remove warn in gue_gro_receive on unsupported protocol\n\nDrop the WARN_ON_ONCE inn gue_gro_receive if the encapsulated type is\nnot known or does not have a GRO handler.\n\nSuch a packet is easily constructed. Syzbot generates them and sets\noff this warning.\n\nRemove the warning as it is expected and not actionable.\n\nThe warning was previously reduced from WARN_ON to WARN_ON_ONCE in\ncommit 270136613bf7 (\"fou: Do WARN_ON_ONCE in gue_gro_receive for bad\nproto callbacks\").",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44941",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to cover read extent cache access with lock",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to cover read extent cache access with lock\n\nsyzbot reports a f2fs bug as below:\n\nBUG: KASAN: slab-use-after-free in sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46\nRead of size 4 at addr ffff8880739ab220 by task syz-executor200/5097\n\nCPU: 0 PID: 5097 Comm: syz-executor200 Not tainted 6.9.0-rc6-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46\n do_read_inode fs/f2fs/inode.c:509 [inline]\n f2fs_iget+0x33e1/0x46e0 fs/f2fs/inode.c:560\n f2fs_nfs_get_inode+0x74/0x100 fs/f2fs/super.c:3237\n generic_fh_to_dentry+0x9f/0xf0 fs/libfs.c:1413\n exportfs_decode_fh_raw+0x152/0x5f0 fs/exportfs/expfs.c:444\n exportfs_decode_fh+0x3c/0x80 fs/exportfs/expfs.c:584\n do_handle_to_path fs/fhandle.c:155 [inline]\n handle_to_path fs/fhandle.c:210 [inline]\n do_handle_open+0x495/0x650 fs/fhandle.c:226\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nWe missed to cover sanity_check_extent_cache() w/ extent cache lock,\nso, below race case may happen, result in use after free issue.\n\n- f2fs_iget\n - do_read_inode\n  - f2fs_init_read_extent_tree\n  : add largest extent entry in to cache\n\t\t\t\t\t- shrink\n\t\t\t\t\t - f2fs_shrink_read_extent_tree\n\t\t\t\t\t  - __shrink_extent_tree\n\t\t\t\t\t   - __detach_extent_node\n\t\t\t\t\t   : drop largest extent entry\n  - sanity_check_extent_cache\n  : access et->largest w/o lock\n\nlet's refactor sanity_check_extent_cache() to avoid extent cache access\nand call it before f2fs_init_read_extent_tree() to fix this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44942",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GC",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GC\n\nsyzbot reports a f2fs bug as below:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/inline.c:258!\nCPU: 1 PID: 34 Comm: kworker/u8:2 Not tainted 6.9.0-rc6-syzkaller-00012-g9e4bc4bcae01 #0\nRIP: 0010:f2fs_write_inline_data+0x781/0x790 fs/f2fs/inline.c:258\nCall Trace:\n f2fs_write_single_data_page+0xb65/0x1d60 fs/f2fs/data.c:2834\n f2fs_write_cache_pages fs/f2fs/data.c:3133 [inline]\n __f2fs_write_data_pages fs/f2fs/data.c:3288 [inline]\n f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3315\n do_writepages+0x35b/0x870 mm/page-writeback.c:2612\n __writeback_single_inode+0x165/0x10b0 fs/fs-writeback.c:1650\n writeback_sb_inodes+0x905/0x1260 fs/fs-writeback.c:1941\n wb_writeback+0x457/0xce0 fs/fs-writeback.c:2117\n wb_do_writeback fs/fs-writeback.c:2264 [inline]\n wb_workfn+0x410/0x1090 fs/fs-writeback.c:2304\n process_one_work kernel/workqueue.c:3254 [inline]\n process_scheduled_works+0xa12/0x17c0 kernel/workqueue.c:3335\n worker_thread+0x86d/0xd70 kernel/workqueue.c:3416\n kthread+0x2f2/0x390 kernel/kthread.c:388\n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nThe root cause is: inline_data inode can be fuzzed, so that there may\nbe valid blkaddr in its direct node, once f2fs triggers background GC\nto migrate the block, it will hit f2fs_bug_on() during dirty page\nwriteback.\n\nLet's add sanity check on F2FS_INLINE_DATA flag in inode during GC,\nso that, it can forbid migrating inline_data inode's data block for\nfixing.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44949",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: parisc: fix a possible DMA corruption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: fix a possible DMA corruption\n\nARCH_DMA_MINALIGN was defined as 16 - this is too small - it may be\npossible that two unrelated 16-byte allocations share a cache line. If\none of these allocations is written using DMA and the other is written\nusing cached write, the value that was written with DMA may be\ncorrupted.\n\nThis commit changes ARCH_DMA_MINALIGN to be 128 on PA20 and 32 on PA1.1 -\nthat's the largest possible cache line size.\n\nAs different parisc microarchitectures have different cache line size, we\ndefine arch_slab_minalign(), cache_line_size() and\ndma_get_cache_alignment() so that the kernel may tune slab cache\nparameters dynamically, based on the detected cache line size.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44974",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mptcp: pm: avoid possible UaF when selecting endp",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: pm: avoid possible UaF when selecting endp\n\nselect_local_address() and select_signal_address() both select an\nendpoint entry from the list inside an RCU protected section, but return\na reference to it, to be read later on. If the entry is dereferenced\nafter the RCU unlock, reading info could cause a Use-after-Free.\n\nA simple solution is to copy the required info while inside the RCU\nprotected section to avoid any risk of UaF later. The address ID might\nneed to be modified later to handle the ID0 case later, so a copy seems\nOK to deal with.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44986",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv6: fix possible UAF in ip6_finish_output2()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: fix possible UAF in ip6_finish_output2()\n\nIf skb_expand_head() returns NULL, skb has been freed\nand associated dst/idev could also have been freed.\n\nWe need to hold rcu_read_lock() to make sure the dst and\nassociated idev are alive.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44987",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv6: prevent UAF in ip6_send_skb()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: prevent UAF in ip6_send_skb()\n\nsyzbot reported an UAF in ip6_send_skb() [1]\n\nAfter ip6_local_out() has returned, we no longer can safely\ndereference rt, unless we hold rcu_read_lock().\n\nA similar issue has been fixed in commit\na688caa34beb (\"ipv6: take rcu lock in rawv6_send_hdrinc()\")\n\nAnother potential issue in ip6_finish_output2() is handled in a\nseparate patch.\n\n[1]\n BUG: KASAN: slab-use-after-free in ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964\nRead of size 8 at addr ffff88806dde4858 by task syz.1.380/6530\n\nCPU: 1 UID: 0 PID: 6530 Comm: syz.1.380 Not tainted 6.11.0-rc3-syzkaller-00306-gdf6cbc62cc9b #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:93 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964\n  rawv6_push_pending_frames+0x75c/0x9e0 net/ipv6/raw.c:588\n  rawv6_sendmsg+0x19c7/0x23c0 net/ipv6/raw.c:926\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x1a6/0x270 net/socket.c:745\n  sock_write_iter+0x2dd/0x400 net/socket.c:1160\n do_iter_readv_writev+0x60a/0x890\n  vfs_writev+0x37c/0xbb0 fs/read_write.c:971\n  do_writev+0x1b1/0x350 fs/read_write.c:1018\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f936bf79e79\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f936cd7f038 EFLAGS: 00000246 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: 00007f936c115f80 RCX: 00007f936bf79e79\nRDX: 0000000000000001 RSI: 0000000020000040 RDI: 0000000000000004\nRBP: 00007f936bfe7916 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007f936c115f80 R15: 00007fff2860a7a8\n </TASK>\n\nAllocated by task 6530:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  unpoison_slab_object mm/kasan/common.c:312 [inline]\n  __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:338\n  kasan_slab_alloc include/linux/kasan.h:201 [inline]\n  slab_post_alloc_hook mm/slub.c:3988 [inline]\n  slab_alloc_node mm/slub.c:4037 [inline]\n  kmem_cache_alloc_noprof+0x135/0x2a0 mm/slub.c:4044\n  dst_alloc+0x12b/0x190 net/core/dst.c:89\n  ip6_blackhole_route+0x59/0x340 net/ipv6/route.c:2670\n  make_blackhole net/xfrm/xfrm_policy.c:3120 [inline]\n  xfrm_lookup_route+0xd1/0x1c0 net/xfrm/xfrm_policy.c:3313\n  ip6_dst_lookup_flow+0x13e/0x180 net/ipv6/ip6_output.c:1257\n  rawv6_sendmsg+0x1283/0x23c0 net/ipv6/raw.c:898\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x1a6/0x270 net/socket.c:745\n  ____sys_sendmsg+0x525/0x7d0 net/socket.c:2597\n  ___sys_sendmsg net/socket.c:2651 [inline]\n  __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2680\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 45:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n  poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n  __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256\n  kasan_slab_free include/linux/kasan.h:184 [inline]\n  slab_free_hook mm/slub.c:2252 [inline]\n  slab_free mm/slub.c:4473 [inline]\n  kmem_cache_free+0x145/0x350 mm/slub.c:4548\n  dst_destroy+0x2ac/0x460 net/core/dst.c:124\n  rcu_do_batch kernel/rcu/tree.c:2569 [inline]\n  rcu_core+0xafd/0x1830 kernel/rcu/tree.\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44998",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: atm: idt77252: prevent use after free in dequeue_rx()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: idt77252: prevent use after free in dequeue_rx()\n\nWe can't dereference \"skb\" after calling vcc->push() because the skb\nis released.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-44999",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: gtp: pull network headers in gtp_dev_xmit()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngtp: pull network headers in gtp_dev_xmit()\n\nsyzbot/KMSAN reported use of uninit-value in get_dev_xmit() [1]\n\nWe must make sure the IPv4 or Ipv6 header is pulled in skb->head\nbefore accessing fields in them.\n\nUse pskb_inet_may_pull() to fix this issue.\n\n[1]\nBUG: KMSAN: uninit-value in ipv6_pdp_find drivers/net/gtp.c:220 [inline]\n BUG: KMSAN: uninit-value in gtp_build_skb_ip6 drivers/net/gtp.c:1229 [inline]\n BUG: KMSAN: uninit-value in gtp_dev_xmit+0x1424/0x2540 drivers/net/gtp.c:1281\n  ipv6_pdp_find drivers/net/gtp.c:220 [inline]\n  gtp_build_skb_ip6 drivers/net/gtp.c:1229 [inline]\n  gtp_dev_xmit+0x1424/0x2540 drivers/net/gtp.c:1281\n  __netdev_start_xmit include/linux/netdevice.h:4913 [inline]\n  netdev_start_xmit include/linux/netdevice.h:4922 [inline]\n  xmit_one net/core/dev.c:3580 [inline]\n  dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3596\n  __dev_queue_xmit+0x358c/0x5610 net/core/dev.c:4423\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276\n  packet_snd net/packet/af_packet.c:3145 [inline]\n  packet_sendmsg+0x90e3/0xa3a0 net/packet/af_packet.c:3177\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  __sys_sendto+0x685/0x830 net/socket.c:2204\n  __do_sys_sendto net/socket.c:2216 [inline]\n  __se_sys_sendto net/socket.c:2212 [inline]\n  __x64_sys_sendto+0x125/0x1d0 net/socket.c:2212\n  x64_sys_call+0x3799/0x3c10 arch/x86/include/generated/asm/syscalls_64.h:45\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:3994 [inline]\n  slab_alloc_node mm/slub.c:4037 [inline]\n  kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4080\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:583\n  __alloc_skb+0x363/0x7b0 net/core/skbuff.c:674\n  alloc_skb include/linux/skbuff.h:1320 [inline]\n  alloc_skb_with_frags+0xc8/0xbf0 net/core/skbuff.c:6526\n  sock_alloc_send_pskb+0xa81/0xbf0 net/core/sock.c:2815\n  packet_alloc_skb net/packet/af_packet.c:2994 [inline]\n  packet_snd net/packet/af_packet.c:3088 [inline]\n  packet_sendmsg+0x749c/0xa3a0 net/packet/af_packet.c:3177\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  __sys_sendto+0x685/0x830 net/socket.c:2204\n  __do_sys_sendto net/socket.c:2216 [inline]\n  __se_sys_sendto net/socket.c:2212 [inline]\n  __x64_sys_sendto+0x125/0x1d0 net/socket.c:2212\n  x64_sys_call+0x3799/0x3c10 arch/x86/include/generated/asm/syscalls_64.h:45\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCPU: 0 UID: 0 PID: 7115 Comm: syz.1.515 Not tainted 6.11.0-rc1-syzkaller-00043-g94ede2a3e913 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-45026",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: s390/dasd: fix error recovery leading to data corruption on ESE devices",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/dasd: fix error recovery leading to data corruption on ESE devices\n\nExtent Space Efficient (ESE) or thin provisioned volumes need to be\nformatted on demand during usual IO processing.\n\nThe dasd_ese_needs_format function checks for error codes that signal\nthe non existence of a proper track format.\n\nThe check for incorrect length is to imprecise since other error cases\nleading to transport of insufficient data also have this flag set.\nThis might lead to data corruption in certain error cases for example\nduring a storage server warmstart.\n\nFix by removing the check for incorrect length and replacing by\nexplicitly checking for invalid track format in transport mode.\n\nAlso remove the check for file protected since this is not a valid\nESE handling case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46673",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: aacraid: Fix double-free on probe failure",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: aacraid: Fix double-free on probe failure\n\naac_probe_one() calls hardware-specific init functions through the\naac_driver_ident::init pointer, all of which eventually call down to\naac_init_adapter().\n\nIf aac_init_adapter() fails after allocating memory for aac_dev::queues,\nit frees the memory but does not clear that member.\n\nAfter the hardware-specific init function returns an error,\naac_probe_one() goes down an error path that frees the memory pointed to\nby aac_dev::queues, resulting.in a double-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46674",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: dwc3: st: fix probed platform device ref count on probe error path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: st: fix probed platform device ref count on probe error path\n\nThe probe function never performs any paltform device allocation, thus\nerror path \"undo_platform_dev_alloc\" is entirely bogus.  It drops the\nreference count from the platform device being probed.  If error path is\ntriggered, this will lead to unbalanced device reference counts and\npremature release of device resources, thus possible use-after-free when\nreleasing remaining devm-managed resources.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46713",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf/aux: Fix AUX buffer serialization",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/aux: Fix AUX buffer serialization\n\nOle reported that event->mmap_mutex is strictly insufficient to\nserialize the AUX buffer, add a per RB mutex to fully serialize it.\n\nNote that in the lock order comment the perf_event::mmap_mutex order\nwas already wrong, that is, it nesting under mmap_lock is not new with\nthis patch.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46722",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: fix mc_data out-of-bounds read warning",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix mc_data out-of-bounds read warning\n\nClear warning that read mc_data[i-1] may out-of-bounds.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46723",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: fix ucode out-of-bounds read warning",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix ucode out-of-bounds read warning\n\nClear warning that read ucode[] may out-of-bounds.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46724",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: Fix out-of-bounds read of df_v1_7_channel_number",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix out-of-bounds read of df_v1_7_channel_number\n\nCheck the fb_channel_number range to avoid the array out-of-bounds\nread error",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46725",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: Fix out-of-bounds write warning",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix out-of-bounds write warning\n\nCheck the ring type value to fix the out-of-bounds\nwrite warning",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46729",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix incorrect size calculation for loop",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix incorrect size calculation for loop\n\n[WHY]\nfe_clk_en has size of 5 but sizeof(fe_clk_en) has byte size 20 which is\nlager than the array size.\n\n[HOW]\nDivide byte size 20 by its element size.\n\nThis fixes 2 OVERRUN issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46731",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/pm: fix the Out-of-bounds read warning",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/pm: fix the Out-of-bounds read warning\n\nusing index i - 1U may beyond element index\nfor mc_data[] when i = 0.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46738",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: VMCI: Fix use-after-free when removing resource in vmci_resource_remove()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nVMCI: Fix use-after-free when removing resource in vmci_resource_remove()\n\nWhen removing a resource from vmci_resource_table in\nvmci_resource_remove(), the search is performed using the resource\nhandle by comparing context and resource fields.\n\nIt is possible though to create two resources with different types\nbut same handle (same context and resource fields).\n\nWhen trying to remove one of the resources, vmci_resource_remove()\nmay not remove the intended one, but the object will still be freed\nas in the case of the datagram type in vmci_datagram_destroy_handle().\nvmci_resource_table will still hold a pointer to this freed resource\nleading to a use-after-free vulnerability.\n\nBUG: KASAN: use-after-free in vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline]\nBUG: KASAN: use-after-free in vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147\nRead of size 4 at addr ffff88801c16d800 by task syz-executor197/1592\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x82/0xa9 lib/dump_stack.c:106\n print_address_description.constprop.0+0x21/0x366 mm/kasan/report.c:239\n __kasan_report.cold+0x7f/0x132 mm/kasan/report.c:425\n kasan_report+0x38/0x51 mm/kasan/report.c:442\n vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline]\n vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147\n vmci_qp_broker_detach+0x89a/0x11b9 drivers/misc/vmw_vmci/vmci_queue_pair.c:2182\n ctx_free_ctx+0x473/0xbe1 drivers/misc/vmw_vmci/vmci_context.c:444\n kref_put include/linux/kref.h:65 [inline]\n vmci_ctx_put drivers/misc/vmw_vmci/vmci_context.c:497 [inline]\n vmci_ctx_destroy+0x170/0x1d6 drivers/misc/vmw_vmci/vmci_context.c:195\n vmci_host_close+0x125/0x1ac drivers/misc/vmw_vmci/vmci_host.c:143\n __fput+0x261/0xa34 fs/file_table.c:282\n task_work_run+0xf0/0x194 kernel/task_work.c:164\n tracehook_notify_resume include/linux/tracehook.h:189 [inline]\n exit_to_user_mode_loop+0x184/0x189 kernel/entry/common.c:187\n exit_to_user_mode_prepare+0x11b/0x123 kernel/entry/common.c:220\n __syscall_exit_to_user_mode_work kernel/entry/common.c:302 [inline]\n syscall_exit_to_user_mode+0x18/0x42 kernel/entry/common.c:313\n do_syscall_64+0x41/0x85 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x6e/0x0\n\nThis change ensures the type is also checked when removing\nthe resource from vmci_resource_table in vmci_resource_remove().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46740",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: binder: fix UAF caused by offsets overwrite",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbinder: fix UAF caused by offsets overwrite\n\nBinder objects are processed and copied individually into the target\nbuffer during transactions. Any raw data in-between these objects is\ncopied as well. However, this raw data copy lacks an out-of-bounds\ncheck. If the raw data exceeds the data section size then the copy\noverwrites the offsets section. This eventually triggers an error that\nattempts to unwind the processed objects. However, at this point the\noffsets used to index these objects are now corrupted.\n\nUnwinding with corrupted offsets can result in decrements of arbitrary\nnodes and lead to their premature release. Other users of such nodes are\nleft with a dangling pointer triggering a use-after-free. This issue is\nmade evident by the following KASAN report (trimmed):\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in _raw_spin_lock+0xe4/0x19c\n  Write of size 4 at addr ffff47fc91598f04 by task binder-util/743\n\n  CPU: 9 UID: 0 PID: 743 Comm: binder-util Not tainted 6.11.0-rc4 #1\n  Hardware name: linux,dummy-virt (DT)\n  Call trace:\n   _raw_spin_lock+0xe4/0x19c\n   binder_free_buf+0x128/0x434\n   binder_thread_write+0x8a4/0x3260\n   binder_ioctl+0x18f0/0x258c\n  [...]\n\n  Allocated by task 743:\n   __kmalloc_cache_noprof+0x110/0x270\n   binder_new_node+0x50/0x700\n   binder_transaction+0x413c/0x6da8\n   binder_thread_write+0x978/0x3260\n   binder_ioctl+0x18f0/0x258c\n  [...]\n\n  Freed by task 745:\n   kfree+0xbc/0x208\n   binder_thread_read+0x1c5c/0x37d4\n   binder_ioctl+0x16d8/0x258c\n  [...]\n  ==================================================================\n\nTo avoid this issue, let's check that the raw data copy is within the\nboundaries of the data section.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46743",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: of/irq: Prevent device address out-of-bounds read in interrupt map walk",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nof/irq: Prevent device address out-of-bounds read in interrupt map walk\n\nWhen of_irq_parse_raw() is invoked with a device address smaller than\nthe interrupt parent node (from #address-cells property), KASAN detects\nthe following out-of-bounds read when populating the initial match table\n(dyndbg=\"func of_irq_parse_* +p\"):\n\n  OF: of_irq_parse_one: dev=/soc@0/picasso/watchdog, index=0\n  OF:  parent=/soc@0/pci@878000000000/gpio0@17,0, intsize=2\n  OF:  intspec=4\n  OF: of_irq_parse_raw: ipar=/soc@0/pci@878000000000/gpio0@17,0, size=2\n  OF:  -> addrsize=3\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in of_irq_parse_raw+0x2b8/0x8d0\n  Read of size 4 at addr ffffff81beca5608 by task bash/764\n\n  CPU: 1 PID: 764 Comm: bash Tainted: G           O       6.1.67-484c613561-nokia_sm_arm64 #1\n  Hardware name: Unknown Unknown Product/Unknown Product, BIOS 2023.01-12.24.03-dirty 01/01/2023\n  Call trace:\n   dump_backtrace+0xdc/0x130\n   show_stack+0x1c/0x30\n   dump_stack_lvl+0x6c/0x84\n   print_report+0x150/0x448\n   kasan_report+0x98/0x140\n   __asan_load4+0x78/0xa0\n   of_irq_parse_raw+0x2b8/0x8d0\n   of_irq_parse_one+0x24c/0x270\n   parse_interrupts+0xc0/0x120\n   of_fwnode_add_links+0x100/0x2d0\n   fw_devlink_parse_fwtree+0x64/0xc0\n   device_add+0xb38/0xc30\n   of_device_add+0x64/0x90\n   of_platform_device_create_pdata+0xd0/0x170\n   of_platform_bus_create+0x244/0x600\n   of_platform_notify+0x1b0/0x254\n   blocking_notifier_call_chain+0x9c/0xd0\n   __of_changeset_entry_notify+0x1b8/0x230\n   __of_changeset_apply_notify+0x54/0xe4\n   of_overlay_fdt_apply+0xc04/0xd94\n   ...\n\n  The buggy address belongs to the object at ffffff81beca5600\n   which belongs to the cache kmalloc-128 of size 128\n  The buggy address is located 8 bytes inside of\n   128-byte region [ffffff81beca5600, ffffff81beca5680)\n\n  The buggy address belongs to the physical page:\n  page:00000000230d3d03 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1beca4\n  head:00000000230d3d03 order:1 compound_mapcount:0 compound_pincount:0\n  flags: 0x8000000000010200(slab|head|zone=2)\n  raw: 8000000000010200 0000000000000000 dead000000000122 ffffff810000c300\n  raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000\n  page dumped because: kasan: bad access detected\n\n  Memory state around the buggy address:\n   ffffff81beca5500: 04 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n   ffffff81beca5580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n  >ffffff81beca5600: 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                        ^\n   ffffff81beca5680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n   ffffff81beca5700: 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc\n  ==================================================================\n  OF:  -> got it !\n\nPrevent the out-of-bounds read by copying the device address into a\nbuffer of sufficient size.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46744",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Squashfs: sanity check symbolic link size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: sanity check symbolic link size\n\nSyzkiller reports a \"KMSAN: uninit-value in pick_link\" bug.\n\nThis is caused by an uninitialised page, which is ultimately caused\nby a corrupted symbolic link size read from disk.\n\nThe reason why the corrupted symlink size causes an uninitialised\npage is due to the following sequence of events:\n\n1. squashfs_read_inode() is called to read the symbolic\n   link from disk.  This assigns the corrupted value\n   3875536935 to inode->i_size.\n\n2. Later squashfs_symlink_read_folio() is called, which assigns\n   this corrupted value to the length variable, which being a\n   signed int, overflows producing a negative number.\n\n3. The following loop that fills in the page contents checks that\n   the copied bytes is less than length, which being negative means\n   the loop is skipped, producing an uninitialised page.\n\nThis patch adds a sanity check which checks that the symbolic\nlink size is not larger than expected.\n\n--\n\nV2: fix spelling mistake.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46747",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: HID: cougar: fix slab-out-of-bounds Read in cougar_report_fixup",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: cougar: fix slab-out-of-bounds Read in cougar_report_fixup\n\nreport_fixup for the Cougar 500k Gaming Keyboard was not verifying\nthat the report descriptor size was correct before accessing it",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46759",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hwmon: (adc128d818) Fix underflows seen when writing limit attributes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (adc128d818) Fix underflows seen when writing limit attributes\n\nDIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large\nnegative number such as -9223372036854775808 is provided by the user.\nFix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46774",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: powerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas()\n\nSmatch warns:\n\n  arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potential\n  spectre issue 'args.args' [r] (local cap)\n\nThe 'nargs' and 'nret' locals come directly from a user-supplied\nbuffer and are used as indexes into a small stack-based array and as\ninputs to copy_to_user() after they are subject to bounds checks.\n\nUse array_index_nospec() after the bounds checks to clamp these values\nfor speculative execution.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46782",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ila: call nf_unregister_net_hooks() sooner",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nila: call nf_unregister_net_hooks() sooner\n\nsyzbot found an use-after-free Read in ila_nf_input [1]\n\nIssue here is that ila_xlat_exit_net() frees the rhashtable,\nthen call nf_unregister_net_hooks().\n\nIt should be done in the reverse way, with a synchronize_rcu().\n\nThis is a good match for a pre_exit() method.\n\n[1]\n BUG: KASAN: use-after-free in rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n BUG: KASAN: use-after-free in __rhashtable_lookup include/linux/rhashtable.h:604 [inline]\n BUG: KASAN: use-after-free in rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n BUG: KASAN: use-after-free in rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672\nRead of size 4 at addr ffff888064620008 by task ksoftirqd/0/16\n\nCPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.11.0-rc4-syzkaller-00238-g2ad6d23f465a #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:93 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n  __rhashtable_lookup include/linux/rhashtable.h:604 [inline]\n  rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n  rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672\n  ila_lookup_wildcards net/ipv6/ila/ila_xlat.c:132 [inline]\n  ila_xlat_addr net/ipv6/ila/ila_xlat.c:652 [inline]\n  ila_nf_input+0x1fe/0x3c0 net/ipv6/ila/ila_xlat.c:190\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xc3/0x220 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK+0x29e/0x450 include/linux/netfilter.h:312\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1ea/0x650 net/core/dev.c:5775\n  process_backlog+0x662/0x15b0 net/core/dev.c:6108\n  __napi_poll+0xcb/0x490 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0x89b/0x1240 net/core/dev.c:6963\n  handle_softirqs+0x2c4/0x970 kernel/softirq.c:554\n  run_ksoftirqd+0xca/0x130 kernel/softirq.c:928\n  smpboot_thread_fn+0x544/0xa30 kernel/smpboot.c:164\n  kthread+0x2f0/0x390 kernel/kthread.c:389\n  ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x64620\nflags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff)\npage_type: 0xbfffffff(buddy)\nraw: 00fff00000000000 ffffea0000959608 ffffea00019d9408 0000000000000000\nraw: 0000000000000000 0000000000000003 00000000bfffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as freed\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0x52dc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_ZERO), pid 5242, tgid 5242 (syz-executor), ts 73611328570, free_ts 618981657187\n  set_page_owner include/linux/page_owner.h:32 [inline]\n  post_alloc_hook+0x1f3/0x230 mm/page_alloc.c:1493\n  prep_new_page mm/page_alloc.c:1501 [inline]\n  get_page_from_freelist+0x2e4c/0x2f10 mm/page_alloc.c:3439\n  __alloc_pages_noprof+0x256/0x6c0 mm/page_alloc.c:4695\n  __alloc_pages_node_noprof include/linux/gfp.h:269 [inline]\n  alloc_pages_node_noprof include/linux/gfp.h:296 [inline]\n  ___kmalloc_large_node+0x8b/0x1d0 mm/slub.c:4103\n  __kmalloc_large_node_noprof+0x1a/0x80 mm/slub.c:4130\n  __do_kmalloc_node mm/slub.c:4146 [inline]\n  __kmalloc_node_noprof+0x2d2/0x440 mm/slub.c:4164\n  __kvmalloc_node_noprof+0x72/0x190 mm/util.c:650\n  bucket_table_alloc lib/rhashtable.c:186 [inline]\n  rhashtable_init_noprof+0x534/0xa60 lib/rhashtable.c:1071\n  ila_xlat_init_net+0xa0/0x110 net/ipv6/ila/ila_xlat.c:613\n  ops_ini\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46798",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: dapm: Fix UAF for snd_soc_pcm_runtime object",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: dapm: Fix UAF for snd_soc_pcm_runtime object\n\nWhen using kernel with the following extra config,\n\n  - CONFIG_KASAN=y\n  - CONFIG_KASAN_GENERIC=y\n  - CONFIG_KASAN_INLINE=y\n  - CONFIG_KASAN_VMALLOC=y\n  - CONFIG_FRAME_WARN=4096\n\nkernel detects that snd_pcm_suspend_all() access a freed\n'snd_soc_pcm_runtime' object when the system is suspended, which\nleads to a use-after-free bug:\n\n[   52.047746] BUG: KASAN: use-after-free in snd_pcm_suspend_all+0x1a8/0x270\n[   52.047765] Read of size 1 at addr ffff0000b9434d50 by task systemd-sleep/2330\n\n[   52.047785] Call trace:\n[   52.047787]  dump_backtrace+0x0/0x3c0\n[   52.047794]  show_stack+0x34/0x50\n[   52.047797]  dump_stack_lvl+0x68/0x8c\n[   52.047802]  print_address_description.constprop.0+0x74/0x2c0\n[   52.047809]  kasan_report+0x210/0x230\n[   52.047815]  __asan_report_load1_noabort+0x3c/0x50\n[   52.047820]  snd_pcm_suspend_all+0x1a8/0x270\n[   52.047824]  snd_soc_suspend+0x19c/0x4e0\n\nThe snd_pcm_sync_stop() has a NULL check on 'substream->runtime' before\nmaking any access. So we need to always set 'substream->runtime' to NULL\neverytime we kfree() it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46800",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sch/netem: fix use after free in netem_dequeue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsch/netem: fix use after free in netem_dequeue\n\nIf netem_dequeue() enqueues packet to inner qdisc and that qdisc\nreturns __NET_XMIT_STOLEN. The packet is dropped but\nqdisc_tree_reduce_backlog() is not called to update the parent's\nq.qlen, leading to the similar use-after-free as Commit\ne04991a48dbaf382 (\"netem: fix return value if duplicate enqueue\nfails\")\n\nCommands to trigger KASAN UaF:\n\nip link add type dummy\nip link set lo up\nip link set dummy0 up\ntc qdisc add dev lo parent root handle 1: drr\ntc filter add dev lo parent 1: basic classid 1:1\ntc class add dev lo classid 1:1 drr\ntc qdisc add dev lo parent 1:1 handle 2: netem\ntc qdisc add dev lo parent 2: handle 3: drr\ntc filter add dev lo parent 3: basic classid 3:1 action mirred egress\nredirect dev dummy0\ntc class add dev lo classid 3:1 drr\nping -c1 -W0.01 localhost # Trigger bug\ntc class del dev lo classid 1:1\ntc class add dev lo classid 1:1 drr\nping -c1 -W0.01 localhost # UaF",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46804",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Add array index check for hdcp ddc access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Add array index check for hdcp ddc access\n\n[Why]\nCoverity reports OVERRUN warning. Do not check if array\nindex valid.\n\n[How]\nCheck msg_id valid and valid array index.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46811",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_box",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_box\n\n[Why]\nCoverity reports OVERRUN warning. soc.num_states could\nbe 40. But array range of bw_params->clk_table.entries is 8.\n\n[How]\nAssert if soc.num_states greater than 8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46812",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Skip inactive planes within ModeSupportAndSystemConfiguration",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Skip inactive planes within ModeSupportAndSystemConfiguration\n\n[Why]\nCoverity reports Memory - illegal accesses.\n\n[How]\nSkip inactive planes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46813",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Check link_index before accessing dc-&gt;links[]",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check link_index before accessing dc->links[]\n\n[WHY & HOW]\ndc->links[] has max size of MAX_LINKS and NULL is return when trying to\naccess with out-of-bound index.\n\nThis fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46814",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Check msg_id before processing transcation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check msg_id before processing transcation\n\n[WHY & HOW]\nHDCP_MESSAGE_ID_INVALID (-1) is not a valid msg_id nor is it a valid\narray index, and it needs checking before used.\n\nThis fixes 4 OVERRUN issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46815",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Check num_valid_sets before accessing reader_wm_sets[]",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check num_valid_sets before accessing reader_wm_sets[]\n\n[WHY & HOW]\nnum_valid_sets needs to be checked to avoid a negative index when\naccessing reader_wm_sets[num_valid_sets - 1].\n\nThis fixes an OVERRUN issue reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46818",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Check gpio_id before used as array index",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check gpio_id before used as array index\n\n[WHY & HOW]\nGPIO_ID_UNKNOWN (-1) is not a valid value for array index and therefore\nshould be checked in advance.\n\nThis fixes 5 OVERRUN issues reported by Coverity.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46821",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/pm: Fix negative array index read",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/pm: Fix negative array index read\n\nAvoid using the negative values\nfor clk_idex as an index into an array pptable->DpmDescriptor.\n\nV2: fix clk_index return check (Tim Huang)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46828",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sched: sch_cake: fix bulk flow accounting logic for host fairness",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched: sch_cake: fix bulk flow accounting logic for host fairness\n\nIn sch_cake, we keep track of the count of active bulk flows per host,\nwhen running in dst/src host fairness mode, which is used as the\nround-robin weight when iterating through flows. The count of active\nbulk flows is updated whenever a flow changes state.\n\nThis has a peculiar interaction with the hash collision handling: when a\nhash collision occurs (after the set-associative hashing), the state of\nthe hash bucket is simply updated to match the new packet that collided,\nand if host fairness is enabled, that also means assigning new per-host\nstate to the flow. For this reason, the bulk flow counters of the\nhost(s) assigned to the flow are decremented, before new state is\nassigned (and the counters, which may not belong to the same host\nanymore, are incremented again).\n\nBack when this code was introduced, the host fairness mode was always\nenabled, so the decrement was unconditional. When the configuration\nflags were introduced the *increment* was made conditional, but\nthe *decrement* was not. Which of course can lead to a spurious\ndecrement (and associated wrap-around to U16_MAX).\n\nAFAICT, when host fairness is disabled, the decrement and wrap-around\nhappens as soon as a hash collision occurs (which is not that common in\nitself, due to the set-associative hashing). However, in most cases this\nis harmless, as the value is only used when host fairness mode is\nenabled. So in order to trigger an array overflow, sch_cake has to first\nbe configured with host fairness disabled, and while running in this\nmode, a hash collision has to occur to cause the overflow. Then, the\nqdisc has to be reconfigured to enable host fairness, which leads to the\narray out-of-bounds because the wrapped-around value is retained and\nused as an array index. It seems that syzbot managed to trigger this,\nwhich is quite impressive in its own right.\n\nThis patch fixes the issue by introducing the same conditional check on\ndecrement as is used on increment.\n\nThe original bug predates the upstreaming of cake, but the commit listed\nin the Fixes tag touched that code, meaning that this patch won't apply\nbefore that.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46830",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: x86: Acquire kvm-&gt;srcu when handling KVM_SET_VCPU_EVENTS",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Acquire kvm->srcu when handling KVM_SET_VCPU_EVENTS\n\nGrab kvm->srcu when processing KVM_SET_VCPU_EVENTS, as KVM will forcibly\nleave nested VMX/SVM if SMM mode is being toggled, and leaving nested VMX\nreads guest memory.\n\nNote, kvm_vcpu_ioctl_x86_set_vcpu_events() can also be called from KVM_RUN\nvia sync_regs(), which already holds SRCU.  I.e. trying to precisely use\nkvm_vcpu_srcu_read_lock() around the problematic SMM code would cause\nproblems.  Acquiring SRCU isn't all that expensive, so for simplicity,\ngrab it unconditionally for KVM_SET_VCPU_EVENTS.\n\n =============================\n WARNING: suspicious RCU usage\n 6.10.0-rc7-332d2c1d713e-next-vm #552 Not tainted\n -----------------------------\n include/linux/kvm_host.h:1027 suspicious rcu_dereference_check() usage!\n\n other info that might help us debug this:\n\n rcu_scheduler_active = 2, debug_locks = 1\n 1 lock held by repro/1071:\n  #0: ffff88811e424430 (&vcpu->mutex){+.+.}-{3:3}, at: kvm_vcpu_ioctl+0x7d/0x970 [kvm]\n\n stack backtrace:\n CPU: 15 PID: 1071 Comm: repro Not tainted 6.10.0-rc7-332d2c1d713e-next-vm #552\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x7f/0x90\n  lockdep_rcu_suspicious+0x13f/0x1a0\n  kvm_vcpu_gfn_to_memslot+0x168/0x190 [kvm]\n  kvm_vcpu_read_guest+0x3e/0x90 [kvm]\n  nested_vmx_load_msr+0x6b/0x1d0 [kvm_intel]\n  load_vmcs12_host_state+0x432/0xb40 [kvm_intel]\n  vmx_leave_nested+0x30/0x40 [kvm_intel]\n  kvm_vcpu_ioctl_x86_set_vcpu_events+0x15d/0x2b0 [kvm]\n  kvm_arch_vcpu_ioctl+0x1107/0x1750 [kvm]\n  ? mark_held_locks+0x49/0x70\n  ? kvm_vcpu_ioctl+0x7d/0x970 [kvm]\n  ? kvm_vcpu_ioctl+0x497/0x970 [kvm]\n  kvm_vcpu_ioctl+0x497/0x970 [kvm]\n  ? lock_acquire+0xba/0x2d0\n  ? find_held_lock+0x2b/0x80\n  ? do_user_addr_fault+0x40c/0x6f0\n  ? lock_release+0xb7/0x270\n  __x64_sys_ioctl+0x82/0xb0\n  do_syscall_64+0x6c/0x170\n  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n RIP: 0033:0x7ff11eb1b539\n  </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46844",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.226-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: um: line: always fill *error_out in setup_one_line()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\num: line: always fill *error_out in setup_one_line()\n\nThe pointer isn't initialized by callers, but I have\nencountered cases where it's still printed; initialize\nit in all possible cases in setup_one_line().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46849",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ASoC: meson: axg-card: fix &#39;use-after-free&#39;",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: meson: axg-card: fix 'use-after-free'\n\nBuffer 'card->dai_link' is reallocated in 'meson_card_reallocate_links()',\nso move 'pad' pointer initialization after this function when memory is\nalready reallocated.\n\nKasan bug report:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in axg_card_add_link+0x76c/0x9bc\nRead of size 8 at addr ffff000000e8b260 by task modprobe/356\n\nCPU: 0 PID: 356 Comm: modprobe Tainted: G O 6.9.12-sdkernel #1\nCall trace:\n dump_backtrace+0x94/0xec\n show_stack+0x18/0x24\n dump_stack_lvl+0x78/0x90\n print_report+0xfc/0x5c0\n kasan_report+0xb8/0xfc\n __asan_load8+0x9c/0xb8\n axg_card_add_link+0x76c/0x9bc [snd_soc_meson_axg_sound_card]\n meson_card_probe+0x344/0x3b8 [snd_soc_meson_card_utils]\n platform_probe+0x8c/0xf4\n really_probe+0x110/0x39c\n __driver_probe_device+0xb8/0x18c\n driver_probe_device+0x108/0x1d8\n __driver_attach+0xd0/0x25c\n bus_for_each_dev+0xe0/0x154\n driver_attach+0x34/0x44\n bus_add_driver+0x134/0x294\n driver_register+0xa8/0x1e8\n __platform_driver_register+0x44/0x54\n axg_card_pdrv_init+0x20/0x1000 [snd_soc_meson_axg_sound_card]\n do_one_initcall+0xdc/0x25c\n do_init_module+0x10c/0x334\n load_module+0x24c4/0x26cc\n init_module_from_file+0xd4/0x128\n __arm64_sys_finit_module+0x1f4/0x41c\n invoke_syscall+0x60/0x188\n el0_svc_common.constprop.0+0x78/0x13c\n do_el0_svc+0x30/0x40\n el0_svc+0x38/0x78\n el0t_64_sync_handler+0x100/0x12c\n el0t_64_sync+0x190/0x194",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46853",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: spi: nxp-fspi: fix the KASAN report out-of-bounds bug",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: nxp-fspi: fix the KASAN report out-of-bounds bug\n\nChange the memcpy length to fix the out-of-bounds issue when writing the\ndata that is not 4 byte aligned to TX FIFO.\n\nTo reproduce the issue, write 3 bytes data to NOR chip.\n\ndd if=3b of=/dev/mtd0\n[   36.926103] ==================================================================\n[   36.933409] BUG: KASAN: slab-out-of-bounds in nxp_fspi_exec_op+0x26ec/0x2838\n[   36.940514] Read of size 4 at addr ffff00081037c2a0 by task dd/455\n[   36.946721]\n[   36.948235] CPU: 3 UID: 0 PID: 455 Comm: dd Not tainted 6.11.0-rc5-gc7b0e37c8434 #1070\n[   36.956185] Hardware name: Freescale i.MX8QM MEK (DT)\n[   36.961260] Call trace:\n[   36.963723]  dump_backtrace+0x90/0xe8\n[   36.967414]  show_stack+0x18/0x24\n[   36.970749]  dump_stack_lvl+0x78/0x90\n[   36.974451]  print_report+0x114/0x5cc\n[   36.978151]  kasan_report+0xa4/0xf0\n[   36.981670]  __asan_report_load_n_noabort+0x1c/0x28\n[   36.986587]  nxp_fspi_exec_op+0x26ec/0x2838\n[   36.990800]  spi_mem_exec_op+0x8ec/0xd30\n[   36.994762]  spi_mem_no_dirmap_read+0x190/0x1e0\n[   36.999323]  spi_mem_dirmap_write+0x238/0x32c\n[   37.003710]  spi_nor_write_data+0x220/0x374\n[   37.007932]  spi_nor_write+0x110/0x2e8\n[   37.011711]  mtd_write_oob_std+0x154/0x1f0\n[   37.015838]  mtd_write_oob+0x104/0x1d0\n[   37.019617]  mtd_write+0xb8/0x12c\n[   37.022953]  mtdchar_write+0x224/0x47c\n[   37.026732]  vfs_write+0x1e4/0x8c8\n[   37.030163]  ksys_write+0xec/0x1d0\n[   37.033586]  __arm64_sys_write+0x6c/0x9c\n[   37.037539]  invoke_syscall+0x6c/0x258\n[   37.041327]  el0_svc_common.constprop.0+0x160/0x22c\n[   37.046244]  do_el0_svc+0x44/0x5c\n[   37.049589]  el0_svc+0x38/0x78\n[   37.052681]  el0t_64_sync_handler+0x13c/0x158\n[   37.057077]  el0t_64_sync+0x190/0x194\n[   37.060775]\n[   37.062274] Allocated by task 455:\n[   37.065701]  kasan_save_stack+0x2c/0x54\n[   37.069570]  kasan_save_track+0x20/0x3c\n[   37.073438]  kasan_save_alloc_info+0x40/0x54\n[   37.077736]  __kasan_kmalloc+0xa0/0xb8\n[   37.081515]  __kmalloc_noprof+0x158/0x2f8\n[   37.085563]  mtd_kmalloc_up_to+0x120/0x154\n[   37.089690]  mtdchar_write+0x130/0x47c\n[   37.093469]  vfs_write+0x1e4/0x8c8\n[   37.096901]  ksys_write+0xec/0x1d0\n[   37.100332]  __arm64_sys_write+0x6c/0x9c\n[   37.104287]  invoke_syscall+0x6c/0x258\n[   37.108064]  el0_svc_common.constprop.0+0x160/0x22c\n[   37.112972]  do_el0_svc+0x44/0x5c\n[   37.116319]  el0_svc+0x38/0x78\n[   37.119401]  el0t_64_sync_handler+0x13c/0x158\n[   37.123788]  el0t_64_sync+0x190/0x194\n[   37.127474]\n[   37.128977] The buggy address belongs to the object at ffff00081037c2a0\n[   37.128977]  which belongs to the cache kmalloc-8 of size 8\n[   37.141177] The buggy address is located 0 bytes inside of\n[   37.141177]  allocated 3-byte region [ffff00081037c2a0, ffff00081037c2a3)\n[   37.153465]\n[   37.154971] The buggy address belongs to the physical page:\n[   37.160559] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x89037c\n[   37.168596] flags: 0xbfffe0000000000(node=0|zone=2|lastcpupid=0x1ffff)\n[   37.175149] page_type: 0xfdffffff(slab)\n[   37.179021] raw: 0bfffe0000000000 ffff000800002500 dead000000000122 0000000000000000\n[   37.186788] raw: 0000000000000000 0000000080800080 00000001fdffffff 0000000000000000\n[   37.194553] page dumped because: kasan: bad access detected\n[   37.200144]\n[   37.201647] Memory state around the buggy address:\n[   37.206460]  ffff00081037c180: fa fc fc fc fa fc fc fc fa fc fc fc fa fc fc fc\n[   37.213701]  ffff00081037c200: fa fc fc fc 05 fc fc fc 03 fc fc fc 02 fc fc fc\n[   37.220946] >ffff00081037c280: 06 fc fc fc 03 fc fc fc fc fc fc fc fc fc fc fc\n[   37.228186]                                ^\n[   37.232473]  ffff00081037c300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   37.239718]  ffff00081037c380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   37.246962] ==============================================================\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46854",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: dpaa: Pad packets to ETH_ZLEN",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dpaa: Pad packets to ETH_ZLEN\n\nWhen sending packets under 60 bytes, up to three bytes of the buffer\nfollowing the data may be leaked. Avoid this by extending all packets to\nETH_ZLEN, ensuring nothing is leaked in the padding. This bug can be\nreproduced by running\n\n\t$ ping -s 11 destination",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46858",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mptcp: pm: Fix uaf in __timer_delete_sync",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: pm: Fix uaf in __timer_delete_sync\n\nThere are two paths to access mptcp_pm_del_add_timer, result in a race\ncondition:\n\n     CPU1\t\t\t\tCPU2\n     ====                               ====\n     net_rx_action\n     napi_poll                          netlink_sendmsg\n     __napi_poll                        netlink_unicast\n     process_backlog                    netlink_unicast_kernel\n     __netif_receive_skb                genl_rcv\n     __netif_receive_skb_one_core       netlink_rcv_skb\n     NF_HOOK                            genl_rcv_msg\n     ip_local_deliver_finish            genl_family_rcv_msg\n     ip_protocol_deliver_rcu            genl_family_rcv_msg_doit\n     tcp_v4_rcv                         mptcp_pm_nl_flush_addrs_doit\n     tcp_v4_do_rcv                      mptcp_nl_remove_addrs_list\n     tcp_rcv_established                mptcp_pm_remove_addrs_and_subflows\n     tcp_data_queue                     remove_anno_list_by_saddr\n     mptcp_incoming_options             mptcp_pm_del_add_timer\n     mptcp_pm_del_add_timer             kfree(entry)\n\nIn remove_anno_list_by_saddr(running on CPU2), after leaving the critical\nzone protected by \"pm.lock\", the entry will be released, which leads to the\noccurrence of uaf in the mptcp_pm_del_add_timer(running on CPU1).\n\nKeeping a reference to add_timer inside the lock, and calling\nsk_stop_timer_sync() with this reference, instead of \"entry->add_timer\".\n\nMove list_del(&entry->list) to mptcp_pm_del_add_timer and inside the pm lock,\ndo not directly access any members of the entry outside the pm lock, which\ncan avoid similar \"entry->x\" uaf.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46859",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: platform/x86: panasonic-laptop: Fix SINF array out of bounds accesses",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: panasonic-laptop: Fix SINF array out of bounds accesses\n\nThe panasonic laptop code in various places uses the SINF array with index\nvalues of 0 - SINF_CUR_BRIGHT(0x0d) without checking that the SINF array\nis big enough.\n\nNot all panasonic laptops have this many SINF array entries, for example\nthe Toughbook CF-18 model only has 10 SINF array entries. So it only\nsupports the AC+DC brightness entries and mute.\n\nCheck that the SINF array has a minimum size which covers all AC+DC\nbrightness entries and refuse to load if the SINF array is smaller.\n\nFor higher SINF indexes hide the sysfs attributes when the SINF array\ndoes not contain an entry for that attribute, avoiding show()/store()\naccessing the array out of bounds and add bounds checking to the probe()\nand resume() code accessing these.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46865",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fou: fix initialization of grc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfou: fix initialization of grc\n\nThe grc must be initialize first. There can be a condition where if\nfou is NULL, goto out will be executed and grc would be used\nuninitialized.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-46871",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Correct the defined value for AMDGPU_DMUB_NOTIFICATION_MAX",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Correct the defined value for AMDGPU_DMUB_NOTIFICATION_MAX\n\n[Why & How]\nIt actually exposes '6' types in enum dmub_notification_type. Not 5. Using smaller\nnumber to create array dmub_callback & dmub_thread_offload has potential to access\nitem out of array bound. Fix it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47659",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smack: tcp: ipv4, fix incorrect labeling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmack: tcp: ipv4, fix incorrect labeling\n\nCurrently, Smack mirrors the label of incoming tcp/ipv4 connections:\nwhen a label 'foo' connects to a label 'bar' with tcp/ipv4,\n'foo' always gets 'foo' in returned ipv4 packets. So,\n1) returned packets are incorrectly labeled ('foo' instead of 'bar')\n2) 'bar' can write to 'foo' without being authorized to write.\n\nHere is a scenario how to see this:\n\n* Take two machines, let's call them C and S,\n   with active Smack in the default state\n   (no settings, no rules, no labeled hosts, only builtin labels)\n\n* At S, add Smack rule 'foo bar w'\n   (labels 'foo' and 'bar' are instantiated at S at this moment)\n\n* At S, at label 'bar', launch a program\n   that listens for incoming tcp/ipv4 connections\n\n* From C, at label 'foo', connect to the listener at S.\n   (label 'foo' is instantiated at C at this moment)\n   Connection succeedes and works.\n\n* Send some data in both directions.\n* Collect network traffic of this connection.\n\nAll packets in both directions are labeled with the CIPSO\nof the label 'foo'. Hence, label 'bar' writes to 'foo' without\nbeing authorized, and even without ever being known at C.\n\nIf anybody cares: exactly the same happens with DCCP.\n\nThis behavior 1st manifested in release 2.6.29.4 (see Fixes below)\nand it looks unintentional. At least, no explanation was provided.\n\nI changed returned packes label into the 'bar',\nto bring it into line with the Smack documentation claims.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47670",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ocfs2: add bounds checking to ocfs2_xattr_find_entry()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: add bounds checking to ocfs2_xattr_find_entry()\n\nAdd a paranoia check to make sure it doesn't stray beyond valid memory\nregion containing ocfs2 xattr entries when scanning for a match.  It will\nprevent out-of-bound access in case of crafted images.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47691",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()\n\nsyzbot reports a f2fs bug as below:\n\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n print_report+0xe8/0x550 mm/kasan/report.c:491\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n kasan_check_range+0x282/0x290 mm/kasan/generic.c:189\n instrument_atomic_read_write include/linux/instrumented.h:96 [inline]\n atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:252 [inline]\n __refcount_add include/linux/refcount.h:184 [inline]\n __refcount_inc include/linux/refcount.h:241 [inline]\n refcount_inc include/linux/refcount.h:258 [inline]\n get_task_struct include/linux/sched/task.h:118 [inline]\n kthread_stop+0xca/0x630 kernel/kthread.c:704\n f2fs_stop_gc_thread+0x65/0xb0 fs/f2fs/gc.c:210\n f2fs_do_shutdown+0x192/0x540 fs/f2fs/file.c:2283\n f2fs_ioc_shutdown fs/f2fs/file.c:2325 [inline]\n __f2fs_ioctl+0x443a/0xbe60 fs/f2fs/file.c:4325\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nThe root cause is below race condition, it may cause use-after-free\nissue in sbi->gc_th pointer.\n\n- remount\n - f2fs_remount\n  - f2fs_stop_gc_thread\n   - kfree(gc_th)\n\t\t\t\t- f2fs_ioc_shutdown\n\t\t\t\t - f2fs_do_shutdown\n\t\t\t\t  - f2fs_stop_gc_thread\n\t\t\t\t   - kthread_stop(gc_th->f2fs_gc_task)\n   : sbi->gc_thread = NULL;\n\nWe will call f2fs_do_shutdown() in two paths:\n- for f2fs_ioc_shutdown() path, we should grab sb->s_umount semaphore\nfor fixing.\n- for f2fs_shutdown() path, it's safe since caller has already grabbed\nsb->s_umount semaphore.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47695",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/rtrs-clt: Reset cid to con_num - 1 to stay in bounds",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rtrs-clt: Reset cid to con_num - 1 to stay in bounds\n\nIn the function init_conns(), after the create_con() and create_cm() for\nloop if something fails. In the cleanup for loop after the destroy tag, we\naccess out of bound memory because cid is set to clt_path->s.con_num.\n\nThis commits resets the cid to clt_path->s.con_num - 1, to stay in bounds\nin the cleanup loop later.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47696",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/iwcm: Fix WARNING:at_kernel/workqueue.c:#check_flush_dependency",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/iwcm: Fix WARNING:at_kernel/workqueue.c:#check_flush_dependency\n\nIn the commit aee2424246f9 (\"RDMA/iwcm: Fix a use-after-free related to\ndestroying CM IDs\"), the function flush_workqueue is invoked to flush the\nwork queue iwcm_wq.\n\nBut at that time, the work queue iwcm_wq was created via the function\nalloc_ordered_workqueue without the flag WQ_MEM_RECLAIM.\n\nBecause the current process is trying to flush the whole iwcm_wq, if\niwcm_wq doesn't have the flag WQ_MEM_RECLAIM, verify that the current\nprocess is not reclaiming memory or running on a workqueue which doesn't\nhave the flag WQ_MEM_RECLAIM as that can break forward-progress guarantee\nleading to a deadlock.\n\nThe call trace is as below:\n\n[  125.350876][ T1430] Call Trace:\n[  125.356281][ T1430]  <TASK>\n[ 125.361285][ T1430] ? __warn (kernel/panic.c:693)\n[ 125.367640][ T1430] ? check_flush_dependency (kernel/workqueue.c:3706 (discriminator 9))\n[ 125.375689][ T1430] ? report_bug (lib/bug.c:180 lib/bug.c:219)\n[ 125.382505][ T1430] ? handle_bug (arch/x86/kernel/traps.c:239)\n[ 125.388987][ T1430] ? exc_invalid_op (arch/x86/kernel/traps.c:260 (discriminator 1))\n[ 125.395831][ T1430] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h:621)\n[ 125.403125][ T1430] ? check_flush_dependency (kernel/workqueue.c:3706 (discriminator 9))\n[ 125.410984][ T1430] ? check_flush_dependency (kernel/workqueue.c:3706 (discriminator 9))\n[ 125.418764][ T1430] __flush_workqueue (kernel/workqueue.c:3970)\n[ 125.426021][ T1430] ? __pfx___might_resched (kernel/sched/core.c:10151)\n[ 125.433431][ T1430] ? destroy_cm_id (drivers/infiniband/core/iwcm.c:375) iw_cm\n[ 125.441209][ T1430] ? __pfx___flush_workqueue (kernel/workqueue.c:3910)\n[ 125.473900][ T1430] ? _raw_spin_lock_irqsave (arch/x86/include/asm/atomic.h:107 include/linux/atomic/atomic-arch-fallback.h:2170 include/linux/atomic/atomic-instrumented.h:1302 include/asm-generic/qspinlock.h:111 include/linux/spinlock.h:187 include/linux/spinlock_api_smp.h:111 kernel/locking/spinlock.c:162)\n[ 125.473909][ T1430] ? __pfx__raw_spin_lock_irqsave (kernel/locking/spinlock.c:161)\n[ 125.482537][ T1430] _destroy_id (drivers/infiniband/core/cma.c:2044) rdma_cm\n[ 125.495072][ T1430] nvme_rdma_free_queue (drivers/nvme/host/rdma.c:656 drivers/nvme/host/rdma.c:650) nvme_rdma\n[ 125.505827][ T1430] nvme_rdma_reset_ctrl_work (drivers/nvme/host/rdma.c:2180) nvme_rdma\n[ 125.505831][ T1430] process_one_work (kernel/workqueue.c:3231)\n[ 125.515122][ T1430] worker_thread (kernel/workqueue.c:3306 kernel/workqueue.c:3393)\n[ 125.515127][ T1430] ? __pfx_worker_thread (kernel/workqueue.c:3339)\n[ 125.531837][ T1430] kthread (kernel/kthread.c:389)\n[ 125.539864][ T1430] ? __pfx_kthread (kernel/kthread.c:342)\n[ 125.550628][ T1430] ret_from_fork (arch/x86/kernel/process.c:147)\n[ 125.558840][ T1430] ? __pfx_kthread (kernel/kthread.c:342)\n[ 125.558844][ T1430] ret_from_fork_asm (arch/x86/entry/entry_64.S:257)\n[  125.566487][ T1430]  </TASK>\n[  125.566488][ T1430] ---[ end trace 0000000000000000 ]---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47697",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drivers: media: dvb-frontends/rtl2830: fix an out-of-bounds write error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: media: dvb-frontends/rtl2830: fix an out-of-bounds write error\n\nEnsure index in rtl2830_pid_filter does not exceed 31 to prevent\nout-of-bounds access.\n\ndev->filters is a 32-bit value, so set_bit and clear_bit functions should\nonly operate on indices from 0 to 31. If index is 32, it will attempt to\naccess a non-existent 33rd bit, leading to out-of-bounds access.\nChange the boundary check from index > 32 to index >= 32 to resolve this\nissue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47698",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drivers: media: dvb-frontends/rtl2832: fix an out-of-bounds write error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: media: dvb-frontends/rtl2832: fix an out-of-bounds write error\n\nEnsure index in rtl2832_pid_filter does not exceed 31 to prevent\nout-of-bounds access.\n\ndev->filters is a 32-bit value, so set_bit and clear_bit functions should\nonly operate on indices from 0 to 31. If index is 32, it will attempt to\naccess a non-existent 33rd bit, leading to out-of-bounds access.\nChange the boundary check from index > 32 to index >= 32 to resolve this\nissue.\n\n[hverkuil: added fixes tag, rtl2830_pid_filter -> rtl2832_pid_filter in logmsg]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47701",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: avoid OOB when system.data xattr changes underneath the filesystem",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid OOB when system.data xattr changes underneath the filesystem\n\nWhen looking up for an entry in an inlined directory, if e_value_offs is\nchanged underneath the filesystem by some change in the block device, it\nwill lead to an out-of-bounds access that KASAN detects as an UAF.\n\nEXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 r/w without journal. Quota mode: none.\nloop0: detected capacity change from 2048 to 2047\n==================================================================\nBUG: KASAN: use-after-free in ext4_search_dir+0xf2/0x1c0 fs/ext4/namei.c:1500\nRead of size 1 at addr ffff88803e91130f by task syz-executor269/5103\n\nCPU: 0 UID: 0 PID: 5103 Comm: syz-executor269 Not tainted 6.11.0-rc4-syzkaller #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n ext4_search_dir+0xf2/0x1c0 fs/ext4/namei.c:1500\n ext4_find_inline_entry+0x4be/0x5e0 fs/ext4/inline.c:1697\n __ext4_find_entry+0x2b4/0x1b30 fs/ext4/namei.c:1573\n ext4_lookup_entry fs/ext4/namei.c:1727 [inline]\n ext4_lookup+0x15f/0x750 fs/ext4/namei.c:1795\n lookup_one_qstr_excl+0x11f/0x260 fs/namei.c:1633\n filename_create+0x297/0x540 fs/namei.c:3980\n do_symlinkat+0xf9/0x3a0 fs/namei.c:4587\n __do_sys_symlinkat fs/namei.c:4610 [inline]\n __se_sys_symlinkat fs/namei.c:4607 [inline]\n __x64_sys_symlinkat+0x95/0xb0 fs/namei.c:4607\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f3e73ced469\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 21 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fff4d40c258 EFLAGS: 00000246 ORIG_RAX: 000000000000010a\nRAX: ffffffffffffffda RBX: 0032656c69662f2e RCX: 00007f3e73ced469\nRDX: 0000000020000200 RSI: 00000000ffffff9c RDI: 00000000200001c0\nRBP: 0000000000000000 R08: 00007fff4d40c290 R09: 00007fff4d40c290\nR10: 0023706f6f6c2f76 R11: 0000000000000246 R12: 00007fff4d40c27c\nR13: 0000000000000003 R14: 431bde82d7b634db R15: 00007fff4d40c2b0\n </TASK>\n\nCalling ext4_xattr_ibody_find right after reading the inode with\next4_get_inode_loc will lead to a check of the validity of the xattrs,\navoiding this problem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47718",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: rtw88: always wait for both firmware loading attempts",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw88: always wait for both firmware loading attempts\n\nIn 'rtw_wait_firmware_completion()', always wait for both (regular and\nwowlan) firmware loading attempts. Otherwise if 'rtw_usb_intf_init()'\nhas failed in 'rtw_usb_probe()', 'rtw_usb_disconnect()' may issue\n'ieee80211_free_hw()' when one of 'rtw_load_firmware_cb()' (usually\nthe wowlan one) is still in progress, causing UAF detected by KASAN.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47723",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix out-of-bounds in dbNextAG() and diAlloc()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix out-of-bounds in dbNextAG() and diAlloc()\n\nIn dbNextAG() , there is no check for the case where bmp->db_numag is\ngreater or same than MAXAG due to a polluted image, which causes an\nout-of-bounds. Therefore, a bounds check should be added in dbMount().\n\nAnd in dbNextAG(), a check for the case where agpref is greater than\nbmp->db_numag should be added, so an out-of-bounds exception should be\nprevented.\n\nAdditionally, a check for the case where agno is greater or same than\nMAXAG should be added in diAlloc() to prevent out-of-bounds.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47730",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: hisilicon/qm - inject error before stopping queue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: hisilicon/qm - inject error before stopping queue\n\nThe master ooo cannot be completely closed when the\naccelerator core reports memory error. Therefore, the driver\nneeds to inject the qm error to close the master ooo. Currently,\nthe qm error is injected after stopping queue, memory may be\nreleased immediately after stopping queue, causing the device to\naccess the released memory. Therefore, error is injected to close master\nooo before stopping queue to ensure that the device does not access\nthe released memory.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47742",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: firmware_loader: Block path traversal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware_loader: Block path traversal\n\nMost firmware names are hardcoded strings, or are constructed from fairly\nconstrained format strings where the dynamic parts are just some hex\nnumbers or such.\n\nHowever, there are a couple codepaths in the kernel where firmware file\nnames contain string components that are passed through from a device or\nsemi-privileged userspace; the ones I could find (not counting interfaces\nthat require root privileges) are:\n\n - lpfc_sli4_request_firmware_update() seems to construct the firmware\n   filename from \"ModelName\", a string that was previously parsed out of\n   some descriptor (\"Vital Product Data\") in lpfc_fill_vpd()\n - nfp_net_fw_find() seems to construct a firmware filename from a model\n   name coming from nfp_hwinfo_lookup(pf->hwinfo, \"nffw.partno\"), which I\n   think parses some descriptor that was read from the device.\n   (But this case likely isn't exploitable because the format string looks\n   like \"netronome/nic_%s\", and there shouldn't be any *folders* starting\n   with \"netronome/nic_\". The previous case was different because there,\n   the \"%s\" is *at the start* of the format string.)\n - module_flash_fw_schedule() is reachable from the\n   ETHTOOL_MSG_MODULE_FW_FLASH_ACT netlink command, which is marked as\n   GENL_UNS_ADMIN_PERM (meaning CAP_NET_ADMIN inside a user namespace is\n   enough to pass the privilege check), and takes a userspace-provided\n   firmware name.\n   (But I think to reach this case, you need to have CAP_NET_ADMIN over a\n   network namespace that a special kind of ethernet device is mapped into,\n   so I think this is not a viable attack path in practice.)\n\nFix it by rejecting any firmware names containing \"..\" path components.\n\nFor what it's worth, I went looking and haven't found any USB device\ndrivers that use the firmware loader dangerously.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47745",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm: call the security_mmap_file() LSM hook in remap_file_pages()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: call the security_mmap_file() LSM hook in remap_file_pages()\n\nThe remap_file_pages syscall handler calls do_mmap() directly, which\ndoesn't contain the LSM security check. And if the process has called\npersonality(READ_IMPLIES_EXEC) before and remap_file_pages() is called for\nRW pages, this will actually result in remapping the pages to RWX,\nbypassing a W^X policy enforced by SELinux.\n\nSo we should check prot by security_mmap_file LSM hook in the\nremap_file_pages syscall handler before do_mmap() is called. Otherwise, it\npotentially permits an attacker to bypass a W^X policy enforced by\nSELinux.\n\nThe bypass is similar to CVE-2016-10044, which bypass the same thing via\nAIO and can be found in [1].\n\nThe PoC:\n\n$ cat > test.c\n\nint main(void) {\n\tsize_t pagesz = sysconf(_SC_PAGE_SIZE);\n\tint mfd = syscall(SYS_memfd_create, \"test\", 0);\n\tconst char *buf = mmap(NULL, 4 * pagesz, PROT_READ | PROT_WRITE,\n\t\tMAP_SHARED, mfd, 0);\n\tunsigned int old = syscall(SYS_personality, 0xffffffff);\n\tsyscall(SYS_personality, READ_IMPLIES_EXEC | old);\n\tsyscall(SYS_remap_file_pages, buf, pagesz, 0, 2, 0);\n\tsyscall(SYS_personality, old);\n\t// show the RWX page exists even if W^X policy is enforced\n\tint fd = open(\"/proc/self/maps\", O_RDONLY);\n\tunsigned char buf2[1024];\n\twhile (1) {\n\t\tint ret = read(fd, buf2, 1024);\n\t\tif (ret <= 0) break;\n\t\twrite(1, buf2, ret);\n\t}\n\tclose(fd);\n}\n\n$ gcc test.c -o test\n$ ./test | grep rwx\n7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted)\n\n[PM: subject line tweaks]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47747",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: seeq: Fix use after free vulnerability in ether3 Driver Due to Race Condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: seeq: Fix use after free vulnerability in ether3 Driver Due to Race Condition\n\nIn the ether3_probe function, a timer is initialized with a callback\nfunction ether3_ledoff, bound to &prev(dev)->timer. Once the timer is\nstarted, there is a risk of a race condition if the module or device\nis removed, triggering the ether3_remove function to perform cleanup.\nThe sequence of operations that may lead to a UAF bug is as follows:\n\nCPU0                                    CPU1\n\n                      |  ether3_ledoff\nether3_remove         |\n  free_netdev(dev);   |\n  put_devic           |\n  kfree(dev);         |\n |  ether3_outw(priv(dev)->regs.config2 |= CFG2_CTRLO, REG_CONFIG2);\n                      | // use dev\n\nFix it by ensuring that the timer is canceled before proceeding with\nthe cleanup in ether3_remove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47748",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vhost_vdpa: assign irq bypass producer token correctly",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvhost_vdpa: assign irq bypass producer token correctly\n\nWe used to call irq_bypass_unregister_producer() in\nvhost_vdpa_setup_vq_irq() which is problematic as we don't know if the\ntoken pointer is still valid or not.\n\nActually, we use the eventfd_ctx as the token so the life cycle of the\ntoken should be bound to the VHOST_SET_VRING_CALL instead of\nvhost_vdpa_setup_vq_irq() which could be called by set_status().\n\nFixing this by setting up irq bypass producer's token when handling\nVHOST_SET_VRING_CALL and un-registering the producer before calling\nvhost_vring_ioctl() to prevent a possible use after free as eventfd\ncould have been released in vhost_vring_ioctl(). And such registering\nand unregistering will only be done if DRIVER_OK is set.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-47757",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix potential oob read in nilfs_btree_check_delete()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix potential oob read in nilfs_btree_check_delete()\n\nThe function nilfs_btree_check_delete(), which checks whether degeneration\nto direct mapping occurs before deleting a b-tree entry, causes memory\naccess outside the block buffer when retrieving the maximum key if the\nroot node has no entries.\n\nThis does not usually happen because b-tree mappings with 0 child nodes\nare never created by mkfs.nilfs2 or nilfs2 itself.  However, it can happen\nif the b-tree root node read from a device is configured that way, so fix\nthis potential issue by adding a check for that case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49854",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: block, bfq: fix uaf for accessing waker_bfqq after splitting",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock, bfq: fix uaf for accessing waker_bfqq after splitting\n\nAfter commit 42c306ed7233 (\"block, bfq: don't break merge chain in\nbfq_split_bfqq()\"), if the current procress is the last holder of bfqq,\nthe bfqq can be freed after bfq_split_bfqq(). Hence recored the bfqq and\nthen access bfqq->waker_bfqq may trigger UAF. What's more, the waker_bfqq\nmay in the merge chain of bfqq, hence just recored waker_bfqq is still\nnot safe.\n\nFix the problem by adding a helper bfq_waker_bfqq() to check if\nbfqq->waker_bfqq is in the merge chain, and current procress is the only\nholder.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49860",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ACPI: sysfs: validate return type of _STR method",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: sysfs: validate return type of _STR method\n\nOnly buffer objects are valid return values of _STR.\n\nIf something else is returned description_show() will access invalid\nmemory.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49861",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Fix helper writes to read-only maps",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix helper writes to read-only maps\n\nLonial found an issue that despite user- and BPF-side frozen BPF map\n(like in case of .rodata), it was still possible to write into it from\na BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT}\nas arguments.\n\nIn check_func_arg() when the argument is as mentioned, the meta->raw_mode\nis never set. Later, check_helper_mem_access(), under the case of\nPTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the\nsubsequent call to check_map_access_type() and given the BPF map is\nread-only it succeeds.\n\nThe helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT\nwhen results are written into them as opposed to read out of them. The\nlatter indicates that it's okay to pass a pointer to uninitialized memory\nas the memory is written to anyway.\n\nHowever, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM\njust with additional alignment requirement. So it is better to just get\nrid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the\nfixed size memory types. For this, add MEM_ALIGNED to additionally ensure\nalignment given these helpers write directly into the args via *<ptr> = val.\nThe .arg*_size has been initialized reflecting the actual sizeof(*<ptr>).\n\nMEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated\nargument types, since in !MEM_FIXED_SIZE cases the verifier does not know\nthe buffer size a priori and therefore cannot blindly write *<ptr> = val.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49882",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix double brelse() the buffer of the extents path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix double brelse() the buffer of the extents path\n\nIn ext4_ext_try_to_merge_up(), set path[1].p_bh to NULL after it has been\nreleased, otherwise it may be released twice. An example of what triggers\nthis is as follows:\n\n  split2    map    split1\n|--------|-------|--------|\n\next4_ext_map_blocks\n ext4_ext_handle_unwritten_extents\n  ext4_split_convert_extents\n   // path->p_depth == 0\n   ext4_split_extent\n     // 1. do split1\n     ext4_split_extent_at\n       |ext4_ext_insert_extent\n       |  ext4_ext_create_new_leaf\n       |    ext4_ext_grow_indepth\n       |      le16_add_cpu(&neh->eh_depth, 1)\n       |    ext4_find_extent\n       |      // return -ENOMEM\n       |// get error and try zeroout\n       |path = ext4_find_extent\n       |  path->p_depth = 1\n       |ext4_ext_try_to_merge\n       |  ext4_ext_try_to_merge_up\n       |    path->p_depth = 0\n       |    brelse(path[1].p_bh)  ---> not set to NULL here\n       |// zeroout success\n     // 2. update path\n     ext4_find_extent\n     // 3. do split2\n     ext4_split_extent_at\n       ext4_ext_insert_extent\n         ext4_ext_create_new_leaf\n           ext4_ext_grow_indepth\n             le16_add_cpu(&neh->eh_depth, 1)\n           ext4_find_extent\n             path[0].p_bh = NULL;\n             path->p_depth = 1\n             read_extent_tree_block  ---> return err\n             // path[1].p_bh is still the old value\n             ext4_free_ext_path\n               ext4_ext_drop_refs\n                 // path->p_depth == 1\n                 brelse(path[1].p_bh)  ---> brelse a buffer twice\n\nFinally got the following WARRNING when removing the buffer from lru:\n\n============================================\nVFS: brelse: Trying to free free buffer\nWARNING: CPU: 2 PID: 72 at fs/buffer.c:1241 __brelse+0x58/0x90\nCPU: 2 PID: 72 Comm: kworker/u19:1 Not tainted 6.9.0-dirty #716\nRIP: 0010:__brelse+0x58/0x90\nCall Trace:\n <TASK>\n __find_get_block+0x6e7/0x810\n bdev_getblk+0x2b/0x480\n __ext4_get_inode_loc+0x48a/0x1240\n ext4_get_inode_loc+0xb2/0x150\n ext4_reserve_inode_write+0xb7/0x230\n __ext4_mark_inode_dirty+0x144/0x6a0\n ext4_ext_insert_extent+0x9c8/0x3230\n ext4_ext_map_blocks+0xf45/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n============================================",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49883",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: aovid use-after-free in ext4_ext_insert_extent()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: aovid use-after-free in ext4_ext_insert_extent()\n\nAs Ojaswin mentioned in Link, in ext4_ext_insert_extent(), if the path is\nreallocated in ext4_ext_create_new_leaf(), we'll use the stale path and\ncause UAF. Below is a sample trace with dummy values:\n\next4_ext_insert_extent\n  path = *ppath = 2000\n  ext4_ext_create_new_leaf(ppath)\n    ext4_find_extent(ppath)\n      path = *ppath = 2000\n      if (depth > path[0].p_maxdepth)\n            kfree(path = 2000);\n            *ppath = path = NULL;\n      path = kcalloc() = 3000\n      *ppath = 3000;\n      return path;\n  /* here path is still 2000, UAF! */\n  eh = path[depth].p_hdr\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_ext_insert_extent+0x26d4/0x3330\nRead of size 8 at addr ffff8881027bf7d0 by task kworker/u36:1/179\nCPU: 3 UID: 0 PID: 179 Comm: kworker/u6:1 Not tainted 6.11.0-rc2-dirty #866\nCall Trace:\n <TASK>\n ext4_ext_insert_extent+0x26d4/0x3330\n ext4_ext_map_blocks+0xe22/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n[...]\n\nAllocated by task 179:\n ext4_find_extent+0x81c/0x1f70\n ext4_ext_map_blocks+0x146/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n ext4_writepages+0x26d/0x4e0\n do_writepages+0x175/0x700\n[...]\n\nFreed by task 179:\n kfree+0xcb/0x240\n ext4_find_extent+0x7c0/0x1f70\n ext4_ext_insert_extent+0xa26/0x3330\n ext4_ext_map_blocks+0xe22/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n ext4_writepages+0x26d/0x4e0\n do_writepages+0x175/0x700\n[...]\n==================================================================\n\nSo use *ppath to update the path to avoid the above problem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49884",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix slab-use-after-free in ext4_split_extent_at()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix slab-use-after-free in ext4_split_extent_at()\n\nWe hit the following use-after-free:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_split_extent_at+0xba8/0xcc0\nRead of size 2 at addr ffff88810548ed08 by task kworker/u20:0/40\nCPU: 0 PID: 40 Comm: kworker/u20:0 Not tainted 6.9.0-dirty #724\nCall Trace:\n <TASK>\n kasan_report+0x93/0xc0\n ext4_split_extent_at+0xba8/0xcc0\n ext4_split_extent.isra.0+0x18f/0x500\n ext4_split_convert_extents+0x275/0x750\n ext4_ext_handle_unwritten_extents+0x73e/0x1580\n ext4_ext_map_blocks+0xe20/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n\nAllocated by task 40:\n __kmalloc_noprof+0x1ac/0x480\n ext4_find_extent+0xf3b/0x1e70\n ext4_ext_map_blocks+0x188/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n\nFreed by task 40:\n kfree+0xf1/0x2b0\n ext4_find_extent+0xa71/0x1e70\n ext4_ext_insert_extent+0xa22/0x3260\n ext4_split_extent_at+0x3ef/0xcc0\n ext4_split_extent.isra.0+0x18f/0x500\n ext4_split_convert_extents+0x275/0x750\n ext4_ext_handle_unwritten_extents+0x73e/0x1580\n ext4_ext_map_blocks+0xe20/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n==================================================================\n\nThe flow of issue triggering is as follows:\n\next4_split_extent_at\n  path = *ppath\n  ext4_ext_insert_extent(ppath)\n    ext4_ext_create_new_leaf(ppath)\n      ext4_find_extent(orig_path)\n        path = *orig_path\n        read_extent_tree_block\n          // return -ENOMEM or -EIO\n        ext4_free_ext_path(path)\n          kfree(path)\n        *orig_path = NULL\n  a. If err is -ENOMEM:\n  ext4_ext_dirty(path + path->p_depth)\n  // path use-after-free !!!\n  b. If err is -EIO and we have EXT_DEBUG defined:\n  ext4_ext_show_leaf(path)\n    eh = path[depth].p_hdr\n    // path also use-after-free !!!\n\nSo when trying to zeroout or fix the extent length, call ext4_find_extent()\nto update the path.\n\nIn addition we use *ppath directly as an ext4_ext_show_leaf() input to\navoid possible use-after-free when EXT_DEBUG is defined, and to avoid\nunnecessary path updates.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49889",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: avoid use-after-free in ext4_ext_show_leaf()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid use-after-free in ext4_ext_show_leaf()\n\nIn ext4_find_extent(), path may be freed by error or be reallocated, so\nusing a previously saved *ppath may have been freed and thus may trigger\nuse-after-free, as follows:\n\next4_split_extent\n  path = *ppath;\n  ext4_split_extent_at(ppath)\n  path = ext4_find_extent(ppath)\n  ext4_split_extent_at(ppath)\n    // ext4_find_extent fails to free path\n    // but zeroout succeeds\n  ext4_ext_show_leaf(inode, path)\n    eh = path[depth].p_hdr\n    // path use-after-free !!!\n\nSimilar to ext4_split_extent_at(), we use *ppath directly as an input to\next4_ext_show_leaf(). Fix a spelling error by the way.\n\nSame problem in ext4_ext_handle_unwritten_extents(). Since 'path' is only\nused in ext4_ext_show_leaf(), remove 'path' and use *ppath directly.\n\nThis issue is triggered only when EXT_DEBUG is defined and therefore does\nnot affect functionality.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49894",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix index out of bounds in degamma hardware format translation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix index out of bounds in degamma hardware format translation\n\nFixes index out of bounds issue in\n`cm_helper_translate_curve_to_degamma_hw_format` function. The issue\ncould occur when the index 'i' exceeds the number of transfer function\npoints (TRANSFER_FUNC_POINTS).\n\nThe fix adds a check to ensure 'i' is within bounds before accessing the\ntransfer function points. If 'i' is out of bounds the function returns\nfalse to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:594 cm_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:595 cm_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:596 cm_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49895",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix index out of bounds in DCN30 degamma hardware format translation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix index out of bounds in DCN30 degamma hardware format translation\n\nThis commit addresses a potential index out of bounds issue in the\n`cm3_helper_translate_curve_to_degamma_hw_format` function in the DCN30\ncolor  management module. The issue could occur when the index 'i'\nexceeds the  number of transfer function points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a check to ensure 'i' is within bounds before accessing the\ntransfer function points. If 'i' is out of bounds, the function returns\nfalse to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:338 cm3_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:339 cm3_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:340 cm3_helper_translate_curve_to_degamma_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49900",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: Fix uninit-value access of new_ea in ea_buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: Fix uninit-value access of new_ea in ea_buffer\n\nsyzbot reports that lzo1x_1_do_compress is using uninit-value:\n\n=====================================================\nBUG: KMSAN: uninit-value in lzo1x_1_do_compress+0x19f9/0x2510 lib/lzo/lzo1x_compress.c:178\n\n...\n\nUninit was stored to memory at:\n ea_put fs/jfs/xattr.c:639 [inline]\n\n...\n\nLocal variable ea_buf created at:\n __jfs_setxattr+0x5d/0x1ae0 fs/jfs/xattr.c:662\n __jfs_xattr_set+0xe6/0x1f0 fs/jfs/xattr.c:934\n\n=====================================================\n\nThe reason is ea_buf->new_ea is not initialized properly.\n\nFix this by using memset to empty its content at the beginning\nin ea_get().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49903",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: Fix uaf in dbFreeBits",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: Fix uaf in dbFreeBits\n\n[syzbot reported]\n==================================================================\nBUG: KASAN: slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c:587 [inline]\nBUG: KASAN: slab-use-after-free in __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c:752\nRead of size 8 at addr ffff8880229254b0 by task syz-executor357/5216\n\nCPU: 0 UID: 0 PID: 5216 Comm: syz-executor357 Not tainted 6.11.0-rc3-syzkaller-00156-gd7a5aa4b3c00 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n __mutex_lock_common kernel/locking/mutex.c:587 [inline]\n __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c:752\n dbFreeBits+0x7ea/0xd90 fs/jfs/jfs_dmap.c:2390\n dbFreeDmap fs/jfs/jfs_dmap.c:2089 [inline]\n dbFree+0x35b/0x680 fs/jfs/jfs_dmap.c:409\n dbDiscardAG+0x8a9/0xa20 fs/jfs/jfs_dmap.c:1650\n jfs_ioc_trim+0x433/0x670 fs/jfs/jfs_discard.c:100\n jfs_ioctl+0x2d0/0x3e0 fs/jfs/ioctl.c:131\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n\nFreed by task 5218:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256\n kasan_slab_free include/linux/kasan.h:184 [inline]\n slab_free_hook mm/slub.c:2252 [inline]\n slab_free mm/slub.c:4473 [inline]\n kfree+0x149/0x360 mm/slub.c:4594\n dbUnmount+0x11d/0x190 fs/jfs/jfs_dmap.c:278\n jfs_mount_rw+0x4ac/0x6a0 fs/jfs/jfs_mount.c:247\n jfs_remount+0x3d1/0x6b0 fs/jfs/super.c:454\n reconfigure_super+0x445/0x880 fs/super.c:1083\n vfs_cmd_reconfigure fs/fsopen.c:263 [inline]\n vfs_fsconfig_locked fs/fsopen.c:292 [inline]\n __do_sys_fsconfig fs/fsopen.c:473 [inline]\n __se_sys_fsconfig+0xb6e/0xf80 fs/fsopen.c:345\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n[Analysis]\nThere are two paths (dbUnmount and jfs_ioc_trim) that generate race\ncondition when accessing bmap, which leads to the occurrence of uaf.\n\nUse the lock s_umount to synchronize them, in order to avoid uaf caused\nby race condition.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49924",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fbdev: pxafb: Fix possible use after free in pxafb_task()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: pxafb: Fix possible use after free in pxafb_task()\n\nIn the pxafb_probe function, it calls the pxafb_init_fbinfo function,\nafter which &fbi->task is associated with pxafb_task. Moreover,\nwithin this pxafb_init_fbinfo function, the pxafb_blank function\nwithin the &pxafb_ops struct is capable of scheduling work.\n\nIf we remove the module which will call pxafb_remove to make cleanup,\nit will call unregister_framebuffer function which can call\ndo_unregister_framebuffer to free fbi->fb through\nput_fb_info(fb_info), while the work mentioned above will be used.\nThe sequence of operations that may lead to a UAF bug is as follows:\n\nCPU0                                                CPU1\n\n                                   | pxafb_task\npxafb_remove                       |\nunregister_framebuffer(info)       |\ndo_unregister_framebuffer(fb_info) |\nput_fb_info(fb_info)               |\n// free fbi->fb                    | set_ctrlr_state(fbi, state)\n                                   | __pxafb_lcd_power(fbi, 0)\n                                   | fbi->lcd_power(on, &fbi->fb.var)\n                                   | //use fbi->fb\n\nFix it by ensuring that the work is canceled before proceeding\nwith the cleanup in pxafb_remove.\n\nNote that only root user can remove the driver at runtime.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49930",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath11k: fix array out-of-bound access in SoC stats",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix array out-of-bound access in SoC stats\n\nCurrently, the ath11k_soc_dp_stats::hal_reo_error array is defined with a\nmaximum size of DP_REO_DST_RING_MAX. However, the ath11k_dp_process_rx()\nfunction access ath11k_soc_dp_stats::hal_reo_error using the REO\ndestination SRNG ring ID, which is incorrect. SRNG ring ID differ from\nnormal ring ID, and this usage leads to out-of-bounds array access. To fix\nthis issue, modify ath11k_dp_process_rx() to use the normal ring ID\ndirectly instead of the SRNG ring ID to avoid out-of-bounds array access.\n\nTested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49936",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/xen-netback: prevent UAF in xenvif_flush_hash()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/xen-netback: prevent UAF in xenvif_flush_hash()\n\nDuring the list_for_each_entry_rcu iteration call of xenvif_flush_hash,\nkfree_rcu does not exist inside the rcu read critical section, so if\nkfree_rcu is called when the rcu grace period ends during the iteration,\nUAF occurs when accessing head->next after the entry becomes free.\n\nTherefore, to solve this, you need to change it to list_for_each_entry_safe.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49950",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix uaf in l2cap_connect",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix uaf in l2cap_connect\n\n[Syzbot reported]\nBUG: KASAN: slab-use-after-free in l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949\nRead of size 8 at addr ffff8880241e9800 by task kworker/u9:0/54\n\nCPU: 0 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-00268-g788220eee30d #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nWorkqueue: hci2 hci_rx_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0xc3/0x620 mm/kasan/report.c:488\n kasan_report+0xd9/0x110 mm/kasan/report.c:601\n l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949\n l2cap_connect_req net/bluetooth/l2cap_core.c:4080 [inline]\n l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:4772 [inline]\n l2cap_sig_channel net/bluetooth/l2cap_core.c:5543 [inline]\n l2cap_recv_frame+0xf0b/0x8eb0 net/bluetooth/l2cap_core.c:6825\n l2cap_recv_acldata+0x9b4/0xb70 net/bluetooth/l2cap_core.c:7514\n hci_acldata_packet net/bluetooth/hci_core.c:3791 [inline]\n hci_rx_work+0xaab/0x1610 net/bluetooth/hci_core.c:4028\n process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231\n process_scheduled_works kernel/workqueue.c:3312 [inline]\n worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389\n kthread+0x2c1/0x3a0 kernel/kthread.c:389\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n...\n\nFreed by task 5245:\n kasan_save_stack+0x33/0x60 mm/kasan/common.c:47\n kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:579\n poison_slab_object+0xf7/0x160 mm/kasan/common.c:240\n __kasan_slab_free+0x32/0x50 mm/kasan/common.c:256\n kasan_slab_free include/linux/kasan.h:184 [inline]\n slab_free_hook mm/slub.c:2256 [inline]\n slab_free mm/slub.c:4477 [inline]\n kfree+0x12a/0x3b0 mm/slub.c:4598\n l2cap_conn_free net/bluetooth/l2cap_core.c:1810 [inline]\n kref_put include/linux/kref.h:65 [inline]\n l2cap_conn_put net/bluetooth/l2cap_core.c:1822 [inline]\n l2cap_conn_del+0x59d/0x730 net/bluetooth/l2cap_core.c:1802\n l2cap_connect_cfm+0x9e6/0xf80 net/bluetooth/l2cap_core.c:7241\n hci_connect_cfm include/net/bluetooth/hci_core.h:1960 [inline]\n hci_conn_failed+0x1c3/0x370 net/bluetooth/hci_conn.c:1265\n hci_abort_conn_sync+0x75a/0xb50 net/bluetooth/hci_sync.c:5583\n abort_conn_sync+0x197/0x360 net/bluetooth/hci_conn.c:2917\n hci_cmd_sync_work+0x1a4/0x410 net/bluetooth/hci_sync.c:328\n process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231\n process_scheduled_works kernel/workqueue.c:3312 [inline]\n worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389\n kthread+0x2c1/0x3a0 kernel/kthread.c:389\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49960",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix timer use-after-free on failed mount",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix timer use-after-free on failed mount\n\nSyzbot has found an ODEBUG bug in ext4_fill_super\n\nThe del_timer_sync function cancels the s_err_report timer,\nwhich reminds about filesystem errors daily. We should\nguarantee the timer is no longer active before kfree(sbi).\n\nWhen filesystem mounting fails, the flow goes to failed_mount3,\nwhere an error occurs when ext4_stop_mmpd is called, causing\na read I/O failure. This triggers the ext4_handle_error function\nthat ultimately re-arms the timer,\nleaving the s_err_report timer active before kfree(sbi) is called.\n\nFix the issue by canceling the s_err_report timer after calling ext4_stop_mmpd.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49966",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ocfs2: cancel dqi_sync_work before freeing oinfo",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: cancel dqi_sync_work before freeing oinfo\n\nocfs2_global_read_info() will initialize and schedule dqi_sync_work at the\nend, if error occurs after successfully reading global quota, it will\ntrigger the following warning with CONFIG_DEBUG_OBJECTS_* enabled:\n\nODEBUG: free active (active state 0) object: 00000000d8b0ce28 object type: timer_list hint: qsync_work_fn+0x0/0x16c\n\nThis reports that there is an active delayed work when freeing oinfo in\nerror handling, so cancel dqi_sync_work first.  BTW, return status instead\nof -1 when .read_file_info fails.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49969",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix index out of bounds in DCN30 color transformation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix index out of bounds in DCN30 color transformation\n\nThis commit addresses a potential index out of bounds issue in the\n`cm3_helper_translate_curve_to_hw_format` function in the DCN30 color\nmanagement module. The issue could occur when the index 'i' exceeds the\nnumber of transfer function points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a check to ensure 'i' is within bounds before accessing the\ntransfer function points. If 'i' is out of bounds, the function returns\nfalse to indicate an error.\n\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:180 cm3_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:181 cm3_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green' 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn30/dcn30_cm_common.c:182 cm3_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue' 1025 <= s32max",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49981",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: venus: fix use after free bug in venus_remove due to race condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: venus: fix use after free bug in venus_remove due to race condition\n\nin venus_probe, core->work is bound with venus_sys_error_handler, which is\nused to handle error. The code use core->sys_err_done to make sync work.\nThe core->work is started in venus_event_notify.\n\nIf we call venus_remove, there might be an unfished work. The possible\nsequence is as follows:\n\nCPU0                  CPU1\n\n                     |venus_sys_error_handler\nvenus_remove         |\nhfi_destroy\t \t\t |\nvenus_hfi_destroy\t |\nkfree(hdev);\t     |\n                     |hfi_reinit\n\t\t\t\t\t |venus_hfi_queues_reinit\n                     |//use hdev\n\nFix it by canceling the work in venus_remove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49982",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: aoe: fix the potential use-after-free problem in more places",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naoe: fix the potential use-after-free problem in more places\n\nFor fixing CVE-2023-6270, f98364e92662 (\"aoe: fix the potential\nuse-after-free problem in aoecmd_cfg_pkts\") makes tx() calling dev_put()\ninstead of doing in aoecmd_cfg_pkts(). It avoids that the tx() runs\ninto use-after-free.\n\nThen Nicolai Stange found more places in aoe have potential use-after-free\nproblem with tx(). e.g. revalidate(), aoecmd_ata_rw(), resend(), probe()\nand aoecmd_cfg_rsp(). Those functions also use aoenet_xmit() to push\npacket to tx queue. So they should also use dev_hold() to increase the\nrefcnt of skb->dev.\n\nOn the other hand, moving dev_put() to tx() causes that the refcnt of\nskb->dev be reduced to a negative value, because corresponding\ndev_hold() are not called in revalidate(), aoecmd_ata_rw(), resend(),\nprobe(), and aoecmd_cfg_rsp(). This patch fixed this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49983",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: drop ppath from ext4_ext_replay_update_ex() to avoid double-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: drop ppath from ext4_ext_replay_update_ex() to avoid double-free\n\nWhen calling ext4_force_split_extent_at() in ext4_ext_replay_update_ex(),\nthe 'ppath' is updated but it is the 'path' that is freed, thus potentially\ntriggering a double-free in the following process:\n\next4_ext_replay_update_ex\n  ppath = path\n  ext4_force_split_extent_at(&ppath)\n    ext4_split_extent_at\n      ext4_ext_insert_extent\n        ext4_ext_create_new_leaf\n          ext4_ext_grow_indepth\n            ext4_find_extent\n              if (depth > path[0].p_maxdepth)\n                kfree(path)                 ---> path First freed\n                *orig_path = path = NULL    ---> null ppath\n  kfree(path)                               ---> path double-free !!!\n\nSo drop the unnecessary ppath and use path directly to avoid this problem.\nAnd use ext4_find_extent() directly to update path, avoiding unnecessary\nmemory allocation and freeing. Also, propagate the error returned by\next4_find_extent() instead of using strange error codes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49989",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: fix double free issue during amdgpu module unload",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: fix double free issue during amdgpu module unload\n\nFlexible endpoints use DIGs from available inflexible endpoints,\nso only the encoders of inflexible links need to be freed.\nOtherwise, a double free issue may occur when unloading the\namdgpu module.\n\n[  279.190523] RIP: 0010:__slab_free+0x152/0x2f0\n[  279.190577] Call Trace:\n[  279.190580]  <TASK>\n[  279.190582]  ? show_regs+0x69/0x80\n[  279.190590]  ? die+0x3b/0x90\n[  279.190595]  ? do_trap+0xc8/0xe0\n[  279.190601]  ? do_error_trap+0x73/0xa0\n[  279.190605]  ? __slab_free+0x152/0x2f0\n[  279.190609]  ? exc_invalid_op+0x56/0x70\n[  279.190616]  ? __slab_free+0x152/0x2f0\n[  279.190642]  ? asm_exc_invalid_op+0x1f/0x30\n[  279.190648]  ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]\n[  279.191096]  ? __slab_free+0x152/0x2f0\n[  279.191102]  ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]\n[  279.191469]  kfree+0x260/0x2b0\n[  279.191474]  dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]\n[  279.191821]  link_destroy+0xd7/0x130 [amdgpu]\n[  279.192248]  dc_destruct+0x90/0x270 [amdgpu]\n[  279.192666]  dc_destroy+0x19/0x40 [amdgpu]\n[  279.193020]  amdgpu_dm_fini+0x16e/0x200 [amdgpu]\n[  279.193432]  dm_hw_fini+0x26/0x40 [amdgpu]\n[  279.193795]  amdgpu_device_fini_hw+0x24c/0x400 [amdgpu]\n[  279.194108]  amdgpu_driver_unload_kms+0x4f/0x70 [amdgpu]\n[  279.194436]  amdgpu_pci_remove+0x40/0x80 [amdgpu]\n[  279.194632]  pci_device_remove+0x3a/0xa0\n[  279.194638]  device_remove+0x40/0x70\n[  279.194642]  device_release_driver_internal+0x1ad/0x210\n[  279.194647]  driver_detach+0x4e/0xa0\n[  279.194650]  bus_remove_driver+0x6f/0xf0\n[  279.194653]  driver_unregister+0x33/0x60\n[  279.194657]  pci_unregister_driver+0x44/0x90\n[  279.194662]  amdgpu_exit+0x19/0x1f0 [amdgpu]\n[  279.194939]  __do_sys_delete_module.isra.0+0x198/0x2f0\n[  279.194946]  __x64_sys_delete_module+0x16/0x20\n[  279.194950]  do_syscall_64+0x58/0x120\n[  279.194954]  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n[  279.194980]  </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49991",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdkfd: amdkfd_free_gtt_mem clear the correct pointer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: amdkfd_free_gtt_mem clear the correct pointer\n\nPass pointer reference to amdgpu_bo_unref to clear the correct pointer,\notherwise amdgpu_bo_unref clear the local variable, the original pointer\nnot set to NULL, this could cause use-after-free bug.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49992",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/stm: Avoid use-after-free issues with crtc and plane",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/stm: Avoid use-after-free issues with crtc and plane\n\nltdc_load() calls functions drm_crtc_init_with_planes(),\ndrm_universal_plane_init() and drm_encoder_init(). These functions\nshould not be called with parameters allocated with devm_kzalloc()\nto avoid use-after-free issues [1].\n\nUse allocations managed by the DRM framework.\n\nFound by Linux Verification Center (linuxtesting.org).\n\n[1]\nhttps://lore.kernel.org/lkml/u366i76e3qhh3ra5oxrtngjtm2u5lterkekcz6y2jkndhuxzli@diujon4h7qwb/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49996",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: cifs: Fix buffer overflow when parsing NFS reparse points",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix buffer overflow when parsing NFS reparse points\n\nReparseDataLength is sum of the InodeType size and DataBuffer size.\nSo to get DataBuffer size it is needed to subtract InodeType's size from\nReparseDataLength.\n\nFunction cifs_strndup_from_utf16() is currentlly accessing buf->DataBuffer\nat position after the end of the buffer because it does not subtract\nInodeType size from the length. Fix this problem and correctly subtract\nvariable len.\n\nMember InodeType is present only when reparse buffer is large enough. Check\nfor ReparseDataLength before accessing InodeType to prevent another invalid\nmemory access.\n\nMajor and minor rdev values are present also only when reparse buffer is\nlarge enough. Check for reparse buffer size before calling reparse_mkdev().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-49997",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: ethernet: lantiq_etop: fix memory disclosure",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ethernet: lantiq_etop: fix memory disclosure\n\nWhen applying padding, the buffer is not zeroed, which results in memory\ndisclosure. The mentioned data is observed on the wire. This patch uses\nskb_put_padto() to pad Ethernet frames properly. The mentioned function\nzeroes the expanded buffer.\n\nIn case the packet cannot be padded it is silently dropped. Statistics\nare also not incremented. This driver does not support statistics in the\nold 32-bit format or the new 64-bit format. These will be added in the\nfuture. In its current form, the patch should be easily backported to\nstable versions.\n\nEthernet MACs on Amazon-SE and Danube cannot do padding of the packets\nin hardware, so software padding must be applied.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50007",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: asihpi: Fix potential OOB array access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: asihpi: Fix potential OOB array access\n\nASIHPI driver stores some values in the static array upon a response\nfrom the driver, and its index depends on the firmware.  We shouldn't\ntrust it blindly.\n\nThis patch adds a sanity check of the array index to fit in the array\nsize.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50033",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: slip: make slhc_remember() more robust against malicious packets",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nslip: make slhc_remember() more robust against malicious packets\n\nsyzbot found that slhc_remember() was missing checks against\nmalicious packets [1].\n\nslhc_remember() only checked the size of the packet was at least 20,\nwhich is not good enough.\n\nWe need to make sure the packet includes the IPv4 and TCP header\nthat are supposed to be carried.\n\nAdd iph and th pointers to make the code more readable.\n\n[1]\n\nBUG: KMSAN: uninit-value in slhc_remember+0x2e8/0x7b0 drivers/net/slip/slhc.c:666\n  slhc_remember+0x2e8/0x7b0 drivers/net/slip/slhc.c:666\n  ppp_receive_nonmp_frame+0xe45/0x35e0 drivers/net/ppp/ppp_generic.c:2455\n  ppp_receive_frame drivers/net/ppp/ppp_generic.c:2372 [inline]\n  ppp_do_recv+0x65f/0x40d0 drivers/net/ppp/ppp_generic.c:2212\n  ppp_input+0x7dc/0xe60 drivers/net/ppp/ppp_generic.c:2327\n  pppoe_rcv_core+0x1d3/0x720 drivers/net/ppp/pppoe.c:379\n  sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1113\n  __release_sock+0x1da/0x330 net/core/sock.c:3072\n  release_sock+0x6b/0x250 net/core/sock.c:3626\n  pppoe_sendmsg+0x2b8/0xb90 drivers/net/ppp/pppoe.c:903\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:4091 [inline]\n  slab_alloc_node mm/slub.c:4134 [inline]\n  kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4186\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:587\n  __alloc_skb+0x363/0x7b0 net/core/skbuff.c:678\n  alloc_skb include/linux/skbuff.h:1322 [inline]\n  sock_wmalloc+0xfe/0x1a0 net/core/sock.c:2732\n  pppoe_sendmsg+0x3a7/0xb90 drivers/net/ppp/pppoe.c:867\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCPU: 0 UID: 0 PID: 5460 Comm: syz.2.33 Not tainted 6.12.0-rc2-syzkaller-00006-g87d6aab2389e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50035",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ppp: fix ppp_async_encode() illegal access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nppp: fix ppp_async_encode() illegal access\n\nsyzbot reported an issue in ppp_async_encode() [1]\n\nIn this case, pppoe_sendmsg() is called with a zero size.\nThen ppp_async_encode() is called with an empty skb.\n\nBUG: KMSAN: uninit-value in ppp_async_encode drivers/net/ppp/ppp_async.c:545 [inline]\n BUG: KMSAN: uninit-value in ppp_async_push+0xb4f/0x2660 drivers/net/ppp/ppp_async.c:675\n  ppp_async_encode drivers/net/ppp/ppp_async.c:545 [inline]\n  ppp_async_push+0xb4f/0x2660 drivers/net/ppp/ppp_async.c:675\n  ppp_async_send+0x130/0x1b0 drivers/net/ppp/ppp_async.c:634\n  ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2280 [inline]\n  ppp_input+0x1f1/0xe60 drivers/net/ppp/ppp_generic.c:2304\n  pppoe_rcv_core+0x1d3/0x720 drivers/net/ppp/pppoe.c:379\n  sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1113\n  __release_sock+0x1da/0x330 net/core/sock.c:3072\n  release_sock+0x6b/0x250 net/core/sock.c:3626\n  pppoe_sendmsg+0x2b8/0xb90 drivers/net/ppp/pppoe.c:903\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:4092 [inline]\n  slab_alloc_node mm/slub.c:4135 [inline]\n  kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4187\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:587\n  __alloc_skb+0x363/0x7b0 net/core/skbuff.c:678\n  alloc_skb include/linux/skbuff.h:1322 [inline]\n  sock_wmalloc+0xfe/0x1a0 net/core/sock.c:2732\n  pppoe_sendmsg+0x3a7/0xb90 drivers/net/ppp/pppoe.c:867\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCPU: 1 UID: 0 PID: 5411 Comm: syz.1.14 Not tainted 6.12.0-rc1-syzkaller-00165-g360c1f1f24c6 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50036",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: do not delay dst_entries_add() in dst_release()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: do not delay dst_entries_add() in dst_release()\n\ndst_entries_add() uses per-cpu data that might be freed at netns\ndismantle from ip6_route_net_exit() calling dst_entries_destroy()\n\nBefore ip6_route_net_exit() can be called, we release all\nthe dsts associated with this netns, via calls to dst_release(),\nwhich waits an rcu grace period before calling dst_destroy()\n\ndst_entries_add() use in dst_destroy() is racy, because\ndst_entries_destroy() could have been called already.\n\nDecrementing the number of dsts must happen sooner.\n\nNotes:\n\n1) in CONFIG_XFRM case, dst_destroy() can call\n   dst_release_immediate(child), this might also cause UAF\n   if the child does not have DST_NOCOUNT set.\n   IPSEC maintainers might take a look and see how to address this.\n\n2) There is also discussion about removing this count of dst,\n   which might happen in future kernels.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50047",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix UAF in async decryption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix UAF in async decryption\n\nDoing an async decryption (large read) crashes with a\nslab-use-after-free way down in the crypto API.\n\nReproducer:\n    # mount.cifs -o ...,seal,esize=1 //srv/share /mnt\n    # dd if=/mnt/largefile of=/dev/null\n    ...\n    [  194.196391] ==================================================================\n    [  194.196844] BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xc1/0x110\n    [  194.197269] Read of size 8 at addr ffff888112bd0448 by task kworker/u77:2/899\n    [  194.197707]\n    [  194.197818] CPU: 12 UID: 0 PID: 899 Comm: kworker/u77:2 Not tainted 6.11.0-lku-00028-gfca3ca14a17a-dirty #43\n    [  194.198400] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014\n    [  194.199046] Workqueue: smb3decryptd smb2_decrypt_offload [cifs]\n    [  194.200032] Call Trace:\n    [  194.200191]  <TASK>\n    [  194.200327]  dump_stack_lvl+0x4e/0x70\n    [  194.200558]  ? gf128mul_4k_lle+0xc1/0x110\n    [  194.200809]  print_report+0x174/0x505\n    [  194.201040]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n    [  194.201352]  ? srso_return_thunk+0x5/0x5f\n    [  194.201604]  ? __virt_addr_valid+0xdf/0x1c0\n    [  194.201868]  ? gf128mul_4k_lle+0xc1/0x110\n    [  194.202128]  kasan_report+0xc8/0x150\n    [  194.202361]  ? gf128mul_4k_lle+0xc1/0x110\n    [  194.202616]  gf128mul_4k_lle+0xc1/0x110\n    [  194.202863]  ghash_update+0x184/0x210\n    [  194.203103]  shash_ahash_update+0x184/0x2a0\n    [  194.203377]  ? __pfx_shash_ahash_update+0x10/0x10\n    [  194.203651]  ? srso_return_thunk+0x5/0x5f\n    [  194.203877]  ? crypto_gcm_init_common+0x1ba/0x340\n    [  194.204142]  gcm_hash_assoc_remain_continue+0x10a/0x140\n    [  194.204434]  crypt_message+0xec1/0x10a0 [cifs]\n    [  194.206489]  ? __pfx_crypt_message+0x10/0x10 [cifs]\n    [  194.208507]  ? srso_return_thunk+0x5/0x5f\n    [  194.209205]  ? srso_return_thunk+0x5/0x5f\n    [  194.209925]  ? srso_return_thunk+0x5/0x5f\n    [  194.210443]  ? srso_return_thunk+0x5/0x5f\n    [  194.211037]  decrypt_raw_data+0x15f/0x250 [cifs]\n    [  194.212906]  ? __pfx_decrypt_raw_data+0x10/0x10 [cifs]\n    [  194.214670]  ? srso_return_thunk+0x5/0x5f\n    [  194.215193]  smb2_decrypt_offload+0x12a/0x6c0 [cifs]\n\nThis is because TFM is being used in parallel.\n\nFix this by allocating a new AEAD TFM for async decryption, but keep\nthe existing one for synchronous READ cases (similar to what is done\nin smb3_calc_signature()).\n\nAlso remove the calls to aead_request_set_callback() and\ncrypto_wait_req() since it's always going to be a synchronous operation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50051",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: spi: mpc52xx: Add cancel_work_sync before module remove",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: mpc52xx: Add cancel_work_sync before module remove\n\nIf we remove the module which will call mpc52xx_spi_remove\nit will free 'ms' through spi_unregister_controller.\nwhile the work ms->work will be used. The sequence of operations\nthat may lead to a UAF bug.\n\nFix it by ensuring that the work is canceled before proceeding with\nthe cleanup in mpc52xx_spi_remove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50055",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: driver core: bus: Fix double free in driver API bus_register()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: bus: Fix double free in driver API bus_register()\n\nFor bus_register(), any error which happens after kset_register() will\ncause that @priv are freed twice, fixed by setting @priv with NULL after\nthe first free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50059",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ntb: ntb_hw_switchtec: Fix use after free vulnerability in switchtec_ntb_remove due to race condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nntb: ntb_hw_switchtec: Fix use after free vulnerability in switchtec_ntb_remove due to race condition\n\nIn the switchtec_ntb_add function, it can call switchtec_ntb_init_sndev\nfunction, then &sndev->check_link_status_work is bound with\ncheck_link_status_work. switchtec_ntb_link_notification may be called\nto start the work.\n\nIf we remove the module which will call switchtec_ntb_remove to make\ncleanup, it will free sndev through kfree(sndev), while the work\nmentioned above will be used. The sequence of operations that may lead\nto a UAF bug is as follows:\n\nCPU0                                 CPU1\n\n                        | check_link_status_work\nswitchtec_ntb_remove    |\nkfree(sndev);           |\n                        | if (sndev->link_force_down)\n                        | // use sndev\n\nFix it by ensuring that the work is canceled before proceeding with\nthe cleanup in switchtec_ntb_remove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50061",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i3c: master: cdns: Fix use after free vulnerability in cdns_i3c_master Driver Due to Race Condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni3c: master: cdns: Fix use after free vulnerability in cdns_i3c_master Driver Due to Race Condition\n\nIn the cdns_i3c_master_probe function, &master->hj_work is bound with\ncdns_i3c_master_hj. And cdns_i3c_master_interrupt can call\ncnds_i3c_master_demux_ibis function to start the work.\n\nIf we remove the module which will call cdns_i3c_master_remove to\nmake cleanup, it will free master->base through i3c_master_unregister\nwhile the work mentioned above will be used. The sequence of operations\nthat may lead to a UAF bug is as follows:\n\nCPU0                                      CPU1\n\n                                     | cdns_i3c_master_hj\ncdns_i3c_master_remove               |\ni3c_master_unregister(&master->base) |\ndevice_unregister(&master->dev)      |\ndevice_release                       |\n//free master->base                  |\n                                     | i3c_master_do_daa(&master->base)\n                                     | //use master->base\n\nFix it by ensuring that the work is canceled before proceeding with\nthe cleanup in cdns_i3c_master_remove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50063",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Prevent tail call between progs attached to different hooks",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Prevent tail call between progs attached to different hooks\n\nbpf progs can be attached to kernel functions, and the attached functions\ncan take different parameters or return different return values. If\nprog attached to one kernel function tail calls prog attached to another\nkernel function, the ctx access or return value verification could be\nbypassed.\n\nFor example, if prog1 is attached to func1 which takes only 1 parameter\nand prog2 is attached to func2 which takes two parameters. Since verifier\nassumes the bpf ctx passed to prog2 is constructed based on func2's\nprototype, verifier allows prog2 to access the second parameter from\nthe bpf ctx passed to it. The problem is that verifier does not prevent\nprog1 from passing its bpf ctx to prog2 via tail call. In this case,\nthe bpf ctx passed to prog2 is constructed from func1 instead of func2,\nthat is, the assumption for ctx access verification is bypassed.\n\nAnother example, if BPF LSM prog1 is attached to hook file_alloc_security,\nand BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifier\nknows the return value rules for these two hooks, e.g. it is legal for\nbpf_lsm_audit_rule_known to return positive number 1, and it is illegal\nfor file_alloc_security to return positive number. So verifier allows\nprog2 to return positive number 1, but does not allow prog1 to return\npositive number. The problem is that verifier does not prevent prog1\nfrom calling prog2 via tail call. In this case, prog2's return value 1\nwill be used as the return value for prog1's hook file_alloc_security.\nThat is, the return value rule is bypassed.\n\nThis patch adds restriction for tail call to prevent such bypasses.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50067",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: uprobe: avoid out-of-bounds memory access of fetching args",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuprobe: avoid out-of-bounds memory access of fetching args\n\nUprobe needs to fetch args into a percpu buffer, and then copy to ring\nbuffer to avoid non-atomic context problem.\n\nSometimes user-space strings, arrays can be very large, but the size of\npercpu buffer is only page size. And store_trace_args() won't check\nwhether these data exceeds a single page or not, caused out-of-bounds\nmemory access.\n\nIt could be reproduced by following steps:\n1. build kernel with CONFIG_KASAN enabled\n2. save follow program as test.c\n\n```\n\\#include <stdio.h>\n\\#include <stdlib.h>\n\\#include <string.h>\n\n// If string length large than MAX_STRING_SIZE, the fetch_store_strlen()\n// will return 0, cause __get_data_size() return shorter size, and\n// store_trace_args() will not trigger out-of-bounds access.\n// So make string length less than 4096.\n\\#define STRLEN 4093\n\nvoid generate_string(char *str, int n)\n{\n    int i;\n    for (i = 0; i < n; ++i)\n    {\n        char c = i % 26 + 'a';\n        str[i] = c;\n    }\n    str[n-1] = '\\0';\n}\n\nvoid print_string(char *str)\n{\n    printf(\"%s\\n\", str);\n}\n\nint main()\n{\n    char tmp[STRLEN];\n\n    generate_string(tmp, STRLEN);\n    print_string(tmp);\n\n    return 0;\n}\n```\n3. compile program\n`gcc -o test test.c`\n\n4. get the offset of `print_string()`\n```\nobjdump -t test | grep -w print_string\n0000000000401199 g     F .text  000000000000001b              print_string\n```\n\n5. configure uprobe with offset 0x1199\n```\noff=0x1199\n\ncd /sys/kernel/debug/tracing/\necho \"p /root/test:${off} arg1=+0(%di):ustring arg2=\\$comm arg3=+0(%di):ustring\"\n > uprobe_events\necho 1 > events/uprobes/enable\necho 1 > tracing_on\n```\n\n6. run `test`, and kasan will report error.\n==================================================================\nBUG: KASAN: use-after-free in strncpy_from_user+0x1d6/0x1f0\nWrite of size 8 at addr ffff88812311c004 by task test/499CPU: 0 UID: 0 PID: 499 Comm: test Not tainted 6.12.0-rc3+ #18\nHardware name: Red Hat KVM, BIOS 1.16.0-4.al8 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x55/0x70\n print_address_description.constprop.0+0x27/0x310\n kasan_report+0x10f/0x120\n ? strncpy_from_user+0x1d6/0x1f0\n strncpy_from_user+0x1d6/0x1f0\n ? rmqueue.constprop.0+0x70d/0x2ad0\n process_fetch_insn+0xb26/0x1470\n ? __pfx_process_fetch_insn+0x10/0x10\n ? _raw_spin_lock+0x85/0xe0\n ? __pfx__raw_spin_lock+0x10/0x10\n ? __pte_offset_map+0x1f/0x2d0\n ? unwind_next_frame+0xc5f/0x1f80\n ? arch_stack_walk+0x68/0xf0\n ? is_bpf_text_address+0x23/0x30\n ? kernel_text_address.part.0+0xbb/0xd0\n ? __kernel_text_address+0x66/0xb0\n ? unwind_get_return_address+0x5e/0xa0\n ? __pfx_stack_trace_consume_entry+0x10/0x10\n ? arch_stack_walk+0xa2/0xf0\n ? _raw_spin_lock_irqsave+0x8b/0xf0\n ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n ? depot_alloc_stack+0x4c/0x1f0\n ? _raw_spin_unlock_irqrestore+0xe/0x30\n ? stack_depot_save_flags+0x35d/0x4f0\n ? kasan_save_stack+0x34/0x50\n ? kasan_save_stack+0x24/0x50\n ? mutex_lock+0x91/0xe0\n ? __pfx_mutex_lock+0x10/0x10\n prepare_uprobe_buffer.part.0+0x2cd/0x500\n uprobe_dispatcher+0x2c3/0x6a0\n ? __pfx_uprobe_dispatcher+0x10/0x10\n ? __kasan_slab_alloc+0x4d/0x90\n handler_chain+0xdd/0x3e0\n handle_swbp+0x26e/0x3d0\n ? __pfx_handle_swbp+0x10/0x10\n ? uprobe_pre_sstep_notifier+0x151/0x1b0\n irqentry_exit_to_user_mode+0xe2/0x1b0\n asm_exc_int3+0x39/0x40\nRIP: 0033:0x401199\nCode: 01 c2 0f b6 45 fb 88 02 83 45 fc 01 8b 45 fc 3b 45 e4 7c b7 8b 45 e4 48 98 48 8d 50 ff 48 8b 45 e8 48 01 d0 ce\nRSP: 002b:00007ffdf00576a8 EFLAGS: 00000206\nRAX: 00007ffdf00576b0 RBX: 0000000000000000 RCX: 0000000000000ff2\nRDX: 0000000000000ffc RSI: 0000000000000ffd RDI: 00007ffdf00576b0\nRBP: 00007ffdf00586b0 R08: 00007feb2f9c0d20 R09: 00007feb2f9c0d20\nR10: 0000000000000001 R11: 0000000000000202 R12: 0000000000401040\nR13: 00007ffdf0058780 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nThis commit enforces the buffer's maxlen less than a page-size to avoid\nstore_trace_args() out-of-memory access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50073",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tty: n_gsm: Fix use-after-free in gsm_cleanup_mux",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: n_gsm: Fix use-after-free in gsm_cleanup_mux\n\nBUG: KASAN: slab-use-after-free in gsm_cleanup_mux+0x77b/0x7b0\ndrivers/tty/n_gsm.c:3160 [n_gsm]\nRead of size 8 at addr ffff88815fe99c00 by task poc/3379\nCPU: 0 UID: 0 PID: 3379 Comm: poc Not tainted 6.11.0+ #56\nHardware name: VMware, Inc. VMware Virtual Platform/440BX\nDesktop Reference Platform, BIOS 6.00 11/12/2020\nCall Trace:\n <TASK>\n gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm]\n __pfx_gsm_cleanup_mux+0x10/0x10 drivers/tty/n_gsm.c:3124 [n_gsm]\n __pfx_sched_clock_cpu+0x10/0x10 kernel/sched/clock.c:389\n update_load_avg+0x1c1/0x27b0 kernel/sched/fair.c:4500\n __pfx_min_vruntime_cb_rotate+0x10/0x10 kernel/sched/fair.c:846\n __rb_insert_augmented+0x492/0xbf0 lib/rbtree.c:161\n gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm]\n _raw_spin_lock_irqsave+0x92/0xf0 arch/x86/include/asm/atomic.h:107\n __pfx_gsmld_ioctl+0x10/0x10 drivers/tty/n_gsm.c:3822 [n_gsm]\n ktime_get+0x5e/0x140 kernel/time/timekeeping.c:195\n ldsem_down_read+0x94/0x4e0 arch/x86/include/asm/atomic64_64.h:79\n __pfx_ldsem_down_read+0x10/0x10 drivers/tty/tty_ldsem.c:338\n __pfx_do_vfs_ioctl+0x10/0x10 fs/ioctl.c:805\n tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818\n\nAllocated by task 65:\n gsm_data_alloc.constprop.0+0x27/0x190 drivers/tty/n_gsm.c:926 [n_gsm]\n gsm_send+0x2c/0x580 drivers/tty/n_gsm.c:819 [n_gsm]\n gsm1_receive+0x547/0xad0 drivers/tty/n_gsm.c:3038 [n_gsm]\n gsmld_receive_buf+0x176/0x280 drivers/tty/n_gsm.c:3609 [n_gsm]\n tty_ldisc_receive_buf+0x101/0x1e0 drivers/tty/tty_buffer.c:391\n tty_port_default_receive_buf+0x61/0xa0 drivers/tty/tty_port.c:39\n flush_to_ldisc+0x1b0/0x750 drivers/tty/tty_buffer.c:445\n process_scheduled_works+0x2b0/0x10d0 kernel/workqueue.c:3229\n worker_thread+0x3dc/0x950 kernel/workqueue.c:3391\n kthread+0x2a3/0x370 kernel/kthread.c:389\n ret_from_fork+0x2d/0x70 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:257\n\nFreed by task 3367:\n kfree+0x126/0x420 mm/slub.c:4580\n gsm_cleanup_mux+0x36c/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm]\n gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm]\n tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818\n\n[Analysis]\ngsm_msg on the tx_ctrl_list or tx_data_list of gsm_mux\ncan be freed by multi threads through ioctl,which leads\nto the occurrence of uaf. Protect it by gsm tx lock.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50074",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: parport: Proper fix for array out-of-bounds access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nparport: Proper fix for array out-of-bounds access\n\nThe recent fix for array out-of-bounds accesses replaced sprintf()\ncalls blindly with snprintf().  However, since snprintf() returns the\nwould-be-printed size, not the actually output size, the length\ncalculation can still go over the given limit.\n\nUse scnprintf() instead of snprintf(), which returns the actually\noutput letters, for addressing the potential out-of-bounds access\nproperly.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50083",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcp: fix mptcp DSS corruption due to large pmtu xmit",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: fix mptcp DSS corruption due to large pmtu xmit\n\nSyzkaller was able to trigger a DSS corruption:\n\n  TCP: request_sock_subflow_v4: Possible SYN flooding on port [::]:20002. Sending cookies.\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 5227 at net/mptcp/protocol.c:695 __mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695\n  Modules linked in:\n  CPU: 0 UID: 0 PID: 5227 Comm: syz-executor350 Not tainted 6.11.0-syzkaller-08829-gaf9c191ac2a0 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\n  RIP: 0010:__mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695\n  Code: 0f b6 dc 31 ff 89 de e8 b5 dd ea f5 89 d8 48 81 c4 50 01 00 00 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc e8 98 da ea f5 90 <0f> 0b 90 e9 47 ff ff ff e8 8a da ea f5 90 0f 0b 90 e9 99 e0 ff ff\n  RSP: 0018:ffffc90000006db8 EFLAGS: 00010246\n  RAX: ffffffff8ba9df18 RBX: 00000000000055f0 RCX: ffff888030023c00\n  RDX: 0000000000000100 RSI: 00000000000081e5 RDI: 00000000000055f0\n  RBP: 1ffff110062bf1ae R08: ffffffff8ba9cf12 R09: 1ffff110062bf1b8\n  R10: dffffc0000000000 R11: ffffed10062bf1b9 R12: 0000000000000000\n  R13: dffffc0000000000 R14: 00000000700cec61 R15: 00000000000081e5\n  FS:  000055556679c380(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000020287000 CR3: 0000000077892000 CR4: 00000000003506f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   <IRQ>\n   move_skbs_to_msk net/mptcp/protocol.c:811 [inline]\n   mptcp_data_ready+0x29c/0xa90 net/mptcp/protocol.c:854\n   subflow_data_ready+0x34a/0x920 net/mptcp/subflow.c:1490\n   tcp_data_queue+0x20fd/0x76c0 net/ipv4/tcp_input.c:5283\n   tcp_rcv_established+0xfba/0x2020 net/ipv4/tcp_input.c:6237\n   tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915\n   tcp_v4_rcv+0x2dc0/0x37f0 net/ipv4/tcp_ipv4.c:2350\n   ip_protocol_deliver_rcu+0x22e/0x440 net/ipv4/ip_input.c:205\n   ip_local_deliver_finish+0x341/0x5f0 net/ipv4/ip_input.c:233\n   NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314\n   NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314\n   __netif_receive_skb_one_core net/core/dev.c:5662 [inline]\n   __netif_receive_skb+0x2bf/0x650 net/core/dev.c:5775\n   process_backlog+0x662/0x15b0 net/core/dev.c:6107\n   __napi_poll+0xcb/0x490 net/core/dev.c:6771\n   napi_poll net/core/dev.c:6840 [inline]\n   net_rx_action+0x89b/0x1240 net/core/dev.c:6962\n   handle_softirqs+0x2c5/0x980 kernel/softirq.c:554\n   do_softirq+0x11b/0x1e0 kernel/softirq.c:455\n   </IRQ>\n   <TASK>\n   __local_bh_enable_ip+0x1bb/0x200 kernel/softirq.c:382\n   local_bh_enable include/linux/bottom_half.h:33 [inline]\n   rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline]\n   __dev_queue_xmit+0x1764/0x3e80 net/core/dev.c:4451\n   dev_queue_xmit include/linux/netdevice.h:3094 [inline]\n   neigh_hh_output include/net/neighbour.h:526 [inline]\n   neigh_output include/net/neighbour.h:540 [inline]\n   ip_finish_output2+0xd41/0x1390 net/ipv4/ip_output.c:236\n   ip_local_out net/ipv4/ip_output.c:130 [inline]\n   __ip_queue_xmit+0x118c/0x1b80 net/ipv4/ip_output.c:536\n   __tcp_transmit_skb+0x2544/0x3b30 net/ipv4/tcp_output.c:1466\n   tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n   tcp_mtu_probe net/ipv4/tcp_output.c:2547 [inline]\n   tcp_write_xmit+0x641d/0x6bf0 net/ipv4/tcp_output.c:2752\n   __tcp_push_pending_frames+0x9b/0x360 net/ipv4/tcp_output.c:3015\n   tcp_push_pending_frames include/net/tcp.h:2107 [inline]\n   tcp_data_snd_check net/ipv4/tcp_input.c:5714 [inline]\n   tcp_rcv_established+0x1026/0x2020 net/ipv4/tcp_input.c:6239\n   tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915\n   sk_backlog_rcv include/net/sock.h:1113 [inline]\n   __release_sock+0x214/0x350 net/core/sock.c:3072\n   release_sock+0x61/0x1f0 net/core/sock.c:3626\n   mptcp_push_\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50112",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/lam: Disable ADDRESS_MASKING in most cases",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/lam: Disable ADDRESS_MASKING in most cases\n\nLinear Address Masking (LAM) has a weakness related to transient\nexecution as described in the SLAM paper[1]. Unless Linear Address\nSpace Separation (LASS) is enabled this weakness may be exploitable.\n\nUntil kernel adds support for LASS[2], only allow LAM for COMPILE_TEST,\nor when speculation mitigations have been disabled at compile time,\notherwise keep LAM disabled.\n\nThere are no processors in market that support LAM yet, so currently\nnobody is affected by this issue.\n\n[1] SLAM: https://download.vusec.net/papers/slam_sp24.pdf\n[2] LASS: https://lore.kernel.org/lkml/20230609183632.48706-1-alexander.shishkin@linux.intel.com/\n\n[ dhansen: update SPECULATION_MITIGATIONS -> CPU_MITIGATIONS ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50115",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: nSVM: Ignore nCR3[4:0] when loading PDPTEs from memory",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: nSVM: Ignore nCR3[4:0] when loading PDPTEs from memory\n\nIgnore nCR3[4:0] when loading PDPTEs from memory for nested SVM, as bits\n4:0 of CR3 are ignored when PAE paging is used, and thus VMRUN doesn't\nenforce 32-byte alignment of nCR3.\n\nIn the absolute worst case scenario, failure to ignore bits 4:0 can result\nin an out-of-bounds read, e.g. if the target page is at the end of a\nmemslot, and the VMM isn't using guard pages.\n\nPer the APM:\n\n  The CR3 register points to the base address of the page-directory-pointer\n  table. The page-directory-pointer table is aligned on a 32-byte boundary,\n  with the low 5 address bits 4:0 assumed to be 0.\n\nAnd the SDM's much more explicit:\n\n  4:0    Ignored\n\nNote, KVM gets this right when loading PDPTRs, it's only the nSVM flow\nthat is broken.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50121",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfsd: cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net\n\nIn the normal case, when we excute `echo 0 > /proc/fs/nfsd/threads`, the\nfunction `nfs4_state_destroy_net` in `nfs4_state_shutdown_net` will\nrelease all resources related to the hashed `nfs4_client`. If the\n`nfsd_client_shrinker` is running concurrently, the `expire_client`\nfunction will first unhash this client and then destroy it. This can\nlead to the following warning. Additionally, numerous use-after-free\nerrors may occur as well.\n\nnfsd_client_shrinker         echo 0 > /proc/fs/nfsd/threads\n\nexpire_client                nfsd_shutdown_net\n  unhash_client                ...\n                               nfs4_state_shutdown_net\n                                 /* won't wait shrinker exit */\n  /*                             cancel_work(&nn->nfsd_shrinker_work)\n   * nfsd_file for this          /* won't destroy unhashed client1 */\n   * client1 still alive         nfs4_state_destroy_net\n   */\n\n                               nfsd_file_cache_shutdown\n                                 /* trigger warning */\n                                 kmem_cache_destroy(nfsd_file_slab)\n                                 kmem_cache_destroy(nfsd_file_mark_slab)\n  /* release nfsd_file and mark */\n  __destroy_client\n\n====================================================================\nBUG nfsd_file (Not tainted): Objects remaining in nfsd_file on\n__kmem_cache_shutdown()\n--------------------------------------------------------------------\nCPU: 4 UID: 0 PID: 764 Comm: sh Not tainted 6.12.0-rc3+ #1\n\n dump_stack_lvl+0x53/0x70\n slab_err+0xb0/0xf0\n __kmem_cache_shutdown+0x15c/0x310\n kmem_cache_destroy+0x66/0x160\n nfsd_file_cache_shutdown+0xac/0x210 [nfsd]\n nfsd_destroy_serv+0x251/0x2a0 [nfsd]\n nfsd_svc+0x125/0x1e0 [nfsd]\n write_threads+0x16a/0x2a0 [nfsd]\n nfsctl_transaction_write+0x74/0xa0 [nfsd]\n vfs_write+0x1a5/0x6d0\n ksys_write+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n====================================================================\nBUG nfsd_file_mark (Tainted: G    B   W         ): Objects remaining\nnfsd_file_mark on __kmem_cache_shutdown()\n--------------------------------------------------------------------\n\n dump_stack_lvl+0x53/0x70\n slab_err+0xb0/0xf0\n __kmem_cache_shutdown+0x15c/0x310\n kmem_cache_destroy+0x66/0x160\n nfsd_file_cache_shutdown+0xc8/0x210 [nfsd]\n nfsd_destroy_serv+0x251/0x2a0 [nfsd]\n nfsd_svc+0x125/0x1e0 [nfsd]\n write_threads+0x16a/0x2a0 [nfsd]\n nfsctl_transaction_write+0x74/0xa0 [nfsd]\n vfs_write+0x1a5/0x6d0\n ksys_write+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nTo resolve this issue, cancel `nfsd_shrinker_work` using synchronous\nmode in nfs4_state_shutdown_net.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50125",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: SCO: Fix UAF on sco_sock_timeout",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: SCO: Fix UAF on sco_sock_timeout\n\nconn->sk maybe have been unlinked/freed while waiting for sco_conn_lock\nso this checks if the conn->sk is still valid by checking if it part of\nsco_sk_list.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50127",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: sched: fix use-after-free in taprio_change()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix use-after-free in taprio_change()\n\nIn 'taprio_change()', 'admin' pointer may become dangling due to sched\nswitch / removal caused by 'advance_sched()', and critical section\nprotected by 'q->current_entry_lock' is too small to prevent from such\na scenario (which causes use-after-free detected by KASAN). Fix this\nby prefer 'rcu_replace_pointer()' over 'rcu_assign_pointer()' to update\n'admin' immediately before an attempt to schedule freeing.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50131",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tracing: Consider the NULL character when validating the event length",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Consider the NULL character when validating the event length\n\nstrlen() returns a string length excluding the null byte. If the string\nlength equals to the maximum buffer length, the buffer will have no\nspace for the NULL terminating character.\n\nThis commit checks this condition and returns failure for it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50143",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: udf: fix uninit-value use in udf_get_fileshortad",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: fix uninit-value use in udf_get_fileshortad\n\nCheck for overflow when computing alen in udf_current_aext to mitigate\nlater uninit-value use in udf_get_fileshortad KMSAN bug[1].\nAfter applying the patch reproducer did not trigger any issue[2].\n\n[1] https://syzkaller.appspot.com/bug?extid=8901c4560b7ab5c2f9df\n[2] https://syzkaller.appspot.com/x/log.txt?x=10242227980000",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50150",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: typec: altmode should keep reference to parent",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: altmode should keep reference to parent\n\nThe altmode device release refers to its parent device, but without keeping\na reference to it.\n\nWhen registering the altmode, get a reference to the parent and put it in\nthe release function.\n\nBefore this fix, when using CONFIG_DEBUG_KOBJECT_RELEASE, we see issues\nlike this:\n\n[   43.572860] kobject: 'port0.0' (ffff8880057ba008): kobject_release, parent 0000000000000000 (delayed 3000)\n[   43.573532] kobject: 'port0.1' (ffff8880057bd008): kobject_release, parent 0000000000000000 (delayed 1000)\n[   43.574407] kobject: 'port0' (ffff8880057b9008): kobject_release, parent 0000000000000000 (delayed 3000)\n[   43.575059] kobject: 'port1.0' (ffff8880057ca008): kobject_release, parent 0000000000000000 (delayed 4000)\n[   43.575908] kobject: 'port1.1' (ffff8880057c9008): kobject_release, parent 0000000000000000 (delayed 4000)\n[   43.576908] kobject: 'typec' (ffff8880062dbc00): kobject_release, parent 0000000000000000 (delayed 4000)\n[   43.577769] kobject: 'port1' (ffff8880057bf008): kobject_release, parent 0000000000000000 (delayed 3000)\n[   46.612867] ==================================================================\n[   46.613402] BUG: KASAN: slab-use-after-free in typec_altmode_release+0x38/0x129\n[   46.614003] Read of size 8 at addr ffff8880057b9118 by task kworker/2:1/48\n[   46.614538]\n[   46.614668] CPU: 2 UID: 0 PID: 48 Comm: kworker/2:1 Not tainted 6.12.0-rc1-00138-gedbae730ad31 #535\n[   46.615391] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014\n[   46.616042] Workqueue: events kobject_delayed_cleanup\n[   46.616446] Call Trace:\n[   46.616648]  <TASK>\n[   46.616820]  dump_stack_lvl+0x5b/0x7c\n[   46.617112]  ? typec_altmode_release+0x38/0x129\n[   46.617470]  print_report+0x14c/0x49e\n[   46.617769]  ? rcu_read_unlock_sched+0x56/0x69\n[   46.618117]  ? __virt_addr_valid+0x19a/0x1ab\n[   46.618456]  ? kmem_cache_debug_flags+0xc/0x1d\n[   46.618807]  ? typec_altmode_release+0x38/0x129\n[   46.619161]  kasan_report+0x8d/0xb4\n[   46.619447]  ? typec_altmode_release+0x38/0x129\n[   46.619809]  ? process_scheduled_works+0x3cb/0x85f\n[   46.620185]  typec_altmode_release+0x38/0x129\n[   46.620537]  ? process_scheduled_works+0x3cb/0x85f\n[   46.620907]  device_release+0xaf/0xf2\n[   46.621206]  kobject_delayed_cleanup+0x13b/0x17a\n[   46.621584]  process_scheduled_works+0x4f6/0x85f\n[   46.621955]  ? __pfx_process_scheduled_works+0x10/0x10\n[   46.622353]  ? hlock_class+0x31/0x9a\n[   46.622647]  ? lock_acquired+0x361/0x3c3\n[   46.622956]  ? move_linked_works+0x46/0x7d\n[   46.623277]  worker_thread+0x1ce/0x291\n[   46.623582]  ? __kthread_parkme+0xc8/0xdf\n[   46.623900]  ? __pfx_worker_thread+0x10/0x10\n[   46.624236]  kthread+0x17e/0x190\n[   46.624501]  ? kthread+0xfb/0x190\n[   46.624756]  ? __pfx_kthread+0x10/0x10\n[   46.625015]  ret_from_fork+0x20/0x40\n[   46.625268]  ? __pfx_kthread+0x10/0x10\n[   46.625532]  ret_from_fork_asm+0x1a/0x30\n[   46.625805]  </TASK>\n[   46.625953]\n[   46.626056] Allocated by task 678:\n[   46.626287]  kasan_save_stack+0x24/0x44\n[   46.626555]  kasan_save_track+0x14/0x2d\n[   46.626811]  __kasan_kmalloc+0x3f/0x4d\n[   46.627049]  __kmalloc_noprof+0x1bf/0x1f0\n[   46.627362]  typec_register_port+0x23/0x491\n[   46.627698]  cros_typec_probe+0x634/0xbb6\n[   46.628026]  platform_probe+0x47/0x8c\n[   46.628311]  really_probe+0x20a/0x47d\n[   46.628605]  device_driver_attach+0x39/0x72\n[   46.628940]  bind_store+0x87/0xd7\n[   46.629213]  kernfs_fop_write_iter+0x1aa/0x218\n[   46.629574]  vfs_write+0x1d6/0x29b\n[   46.629856]  ksys_write+0xcd/0x13b\n[   46.630128]  do_syscall_64+0xd4/0x139\n[   46.630420]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[   46.630820]\n[   46.630946] Freed by task 48:\n[   46.631182]  kasan_save_stack+0x24/0x44\n[   46.631493]  kasan_save_track+0x14/0x2d\n[   46.631799]  kasan_save_free_info+0x3f/0x4d\n[   46.632144]  __kasan_slab_free+0x37/0x45\n[   46.632474]\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50151",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix OOBs when building SMB2_IOCTL request",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix OOBs when building SMB2_IOCTL request\n\nWhen using encryption, either enforced by the server or when using\n'seal' mount option, the client will squash all compound request buffers\ndown for encryption into a single iov in smb2_set_next_command().\n\nSMB2_ioctl_init() allocates a small buffer (448 bytes) to hold the\nSMB2_IOCTL request in the first iov, and if the user passes an input\nbuffer that is greater than 328 bytes, smb2_set_next_command() will\nend up writing off the end of @rqst->iov[0].iov_base as shown below:\n\n  mount.cifs //srv/share /mnt -o ...,seal\n  ln -s $(perl -e \"print('a')for 1..1024\") /mnt/link\n\n  BUG: KASAN: slab-out-of-bounds in\n  smb2_set_next_command.cold+0x1d6/0x24c [cifs]\n  Write of size 4116 at addr ffff8881148fcab8 by task ln/859\n\n  CPU: 1 UID: 0 PID: 859 Comm: ln Not tainted 6.12.0-rc3 #1\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\n  1.16.3-2.fc40 04/01/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x5d/0x80\n   ? smb2_set_next_command.cold+0x1d6/0x24c [cifs]\n   print_report+0x156/0x4d9\n   ? smb2_set_next_command.cold+0x1d6/0x24c [cifs]\n   ? __virt_addr_valid+0x145/0x310\n   ? __phys_addr+0x46/0x90\n   ? smb2_set_next_command.cold+0x1d6/0x24c [cifs]\n   kasan_report+0xda/0x110\n   ? smb2_set_next_command.cold+0x1d6/0x24c [cifs]\n   kasan_check_range+0x10f/0x1f0\n   __asan_memcpy+0x3c/0x60\n   smb2_set_next_command.cold+0x1d6/0x24c [cifs]\n   smb2_compound_op+0x238c/0x3840 [cifs]\n   ? kasan_save_track+0x14/0x30\n   ? kasan_save_free_info+0x3b/0x70\n   ? vfs_symlink+0x1a1/0x2c0\n   ? do_symlinkat+0x108/0x1c0\n   ? __pfx_smb2_compound_op+0x10/0x10 [cifs]\n   ? kmem_cache_free+0x118/0x3e0\n   ? cifs_get_writable_path+0xeb/0x1a0 [cifs]\n   smb2_get_reparse_inode+0x423/0x540 [cifs]\n   ? __pfx_smb2_get_reparse_inode+0x10/0x10 [cifs]\n   ? rcu_is_watching+0x20/0x50\n   ? __kmalloc_noprof+0x37c/0x480\n   ? smb2_create_reparse_symlink+0x257/0x490 [cifs]\n   ? smb2_create_reparse_symlink+0x38f/0x490 [cifs]\n   smb2_create_reparse_symlink+0x38f/0x490 [cifs]\n   ? __pfx_smb2_create_reparse_symlink+0x10/0x10 [cifs]\n   ? find_held_lock+0x8a/0xa0\n   ? hlock_class+0x32/0xb0\n   ? __build_path_from_dentry_optional_prefix+0x19d/0x2e0 [cifs]\n   cifs_symlink+0x24f/0x960 [cifs]\n   ? __pfx_make_vfsuid+0x10/0x10\n   ? __pfx_cifs_symlink+0x10/0x10 [cifs]\n   ? make_vfsgid+0x6b/0xc0\n   ? generic_permission+0x96/0x2d0\n   vfs_symlink+0x1a1/0x2c0\n   do_symlinkat+0x108/0x1c0\n   ? __pfx_do_symlinkat+0x10/0x10\n   ? strncpy_from_user+0xaa/0x160\n   __x64_sys_symlinkat+0xb9/0xf0\n   do_syscall_64+0xbb/0x1d0\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n  RIP: 0033:0x7f08d75c13bb",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50154",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcp/dccp: Don&#39;t use timer_pending() in reqsk_queue_unlink().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp/dccp: Don't use timer_pending() in reqsk_queue_unlink().\n\nMartin KaFai Lau reported use-after-free [0] in reqsk_timer_handler().\n\n  \"\"\"\n  We are seeing a use-after-free from a bpf prog attached to\n  trace_tcp_retransmit_synack. The program passes the req->sk to the\n  bpf_sk_storage_get_tracing kernel helper which does check for null\n  before using it.\n  \"\"\"\n\nThe commit 83fccfc3940c (\"inet: fix potential deadlock in\nreqsk_queue_unlink()\") added timer_pending() in reqsk_queue_unlink() not\nto call del_timer_sync() from reqsk_timer_handler(), but it introduced a\nsmall race window.\n\nBefore the timer is called, expire_timers() calls detach_timer(timer, true)\nto clear timer->entry.pprev and marks it as not pending.\n\nIf reqsk_queue_unlink() checks timer_pending() just after expire_timers()\ncalls detach_timer(), TCP will miss del_timer_sync(); the reqsk timer will\ncontinue running and send multiple SYN+ACKs until it expires.\n\nThe reported UAF could happen if req->sk is close()d earlier than the timer\nexpiration, which is 63s by default.\n\nThe scenario would be\n\n  1. inet_csk_complete_hashdance() calls inet_csk_reqsk_queue_drop(),\n     but del_timer_sync() is missed\n\n  2. reqsk timer is executed and scheduled again\n\n  3. req->sk is accept()ed and reqsk_put() decrements rsk_refcnt, but\n     reqsk timer still has another one, and inet_csk_accept() does not\n     clear req->sk for non-TFO sockets\n\n  4. sk is close()d\n\n  5. reqsk timer is executed again, and BPF touches req->sk\n\nLet's not use timer_pending() by passing the caller context to\n__inet_csk_reqsk_queue_drop().\n\nNote that reqsk timer is pinned, so the issue does not happen in most\nuse cases. [1]\n\n[0]\nBUG: KFENCE: use-after-free read in bpf_sk_storage_get_tracing+0x2e/0x1b0\n\nUse-after-free read at 0x00000000a891fb3a (in kfence-#1):\nbpf_sk_storage_get_tracing+0x2e/0x1b0\nbpf_prog_5ea3e95db6da0438_tcp_retransmit_synack+0x1d20/0x1dda\nbpf_trace_run2+0x4c/0xc0\ntcp_rtx_synack+0xf9/0x100\nreqsk_timer_handler+0xda/0x3d0\nrun_timer_softirq+0x292/0x8a0\nirq_exit_rcu+0xf5/0x320\nsysvec_apic_timer_interrupt+0x6d/0x80\nasm_sysvec_apic_timer_interrupt+0x16/0x20\nintel_idle_irq+0x5a/0xa0\ncpuidle_enter_state+0x94/0x273\ncpu_startup_entry+0x15e/0x260\nstart_secondary+0x8a/0x90\nsecondary_startup_64_no_verify+0xfa/0xfb\n\nkfence-#1: 0x00000000a72cc7b6-0x00000000d97616d9, size=2376, cache=TCPv6\n\nallocated by task 0 on cpu 9 at 260507.901592s:\nsk_prot_alloc+0x35/0x140\nsk_clone_lock+0x1f/0x3f0\ninet_csk_clone_lock+0x15/0x160\ntcp_create_openreq_child+0x1f/0x410\ntcp_v6_syn_recv_sock+0x1da/0x700\ntcp_check_req+0x1fb/0x510\ntcp_v6_rcv+0x98b/0x1420\nipv6_list_rcv+0x2258/0x26e0\nnapi_complete_done+0x5b1/0x2990\nmlx5e_napi_poll+0x2ae/0x8d0\nnet_rx_action+0x13e/0x590\nirq_exit_rcu+0xf5/0x320\ncommon_interrupt+0x80/0x90\nasm_common_interrupt+0x22/0x40\ncpuidle_enter_state+0xfb/0x273\ncpu_startup_entry+0x15e/0x260\nstart_secondary+0x8a/0x90\nsecondary_startup_64_no_verify+0xfa/0xfb\n\nfreed by task 0 on cpu 9 at 260507.927527s:\nrcu_core_si+0x4ff/0xf10\nirq_exit_rcu+0xf5/0x320\nsysvec_apic_timer_interrupt+0x6d/0x80\nasm_sysvec_apic_timer_interrupt+0x16/0x20\ncpuidle_enter_state+0xfb/0x273\ncpu_startup_entry+0x15e/0x260\nstart_secondary+0x8a/0x90\nsecondary_startup_64_no_verify+0xfa/0xfb",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50180",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fbdev: sisfb: Fix strbuf array overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: sisfb: Fix strbuf array overflow\n\nThe values of the variables xres and yres are placed in strbuf.\nThese variables are obtained from strbuf1.\nThe strbuf1 array contains digit characters\nand a space if the array contains non-digit characters.\nThen, when executing sprintf(strbuf, \"%ux%ux8\", xres, yres);\nmore than 16 bytes will be written to strbuf.\nIt is suggested to increase the size of the strbuf array to 24.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50193",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/entry_32: Clear CPU buffers after register restore in NMI return",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/entry_32: Clear CPU buffers after register restore in NMI return\n\nCPU buffers are currently cleared after call to exc_nmi, but before\nregister state is restored. This may be okay for MDS mitigation but not for\nRDFS. Because RDFS mitigation requires CPU buffers to be cleared when\nregisters don't have any sensitive data.\n\nMove CLEAR_CPU_BUFFERS after RESTORE_ALL_NMI.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50209",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/bnxt_re: Add a check for memory allocation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/bnxt_re: Add a check for memory allocation\n\n__alloc_pbl() can return error when memory allocation fails.\nDriver is not checking the status on one of the instances.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50217",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: fix use-after-free of block device file in __btrfs_free_extra_devids()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix use-after-free of block device file in __btrfs_free_extra_devids()\n\nMounting btrfs from two images (which have the same one fsid and two\ndifferent dev_uuids) in certain executing order may trigger an UAF for\nvariable 'device->bdev_file' in __btrfs_free_extra_devids(). And\nfollowing are the details:\n\n1. Attach image_1 to loop0, attach image_2 to loop1, and scan btrfs\n   devices by ioctl(BTRFS_IOC_SCAN_DEV):\n\n             /  btrfs_device_1 \u2192 loop0\n   fs_device\n             \\  btrfs_device_2 \u2192 loop1\n2. mount /dev/loop0 /mnt\n   btrfs_open_devices\n    btrfs_device_1->bdev_file = btrfs_get_bdev_and_sb(loop0)\n    btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1)\n   btrfs_fill_super\n    open_ctree\n     fail: btrfs_close_devices // -ENOMEM\n\t    btrfs_close_bdev(btrfs_device_1)\n             fput(btrfs_device_1->bdev_file)\n\t      // btrfs_device_1->bdev_file is freed\n\t    btrfs_close_bdev(btrfs_device_2)\n             fput(btrfs_device_2->bdev_file)\n\n3. mount /dev/loop1 /mnt\n   btrfs_open_devices\n    btrfs_get_bdev_and_sb(&bdev_file)\n     // EIO, btrfs_device_1->bdev_file is not assigned,\n     // which points to a freed memory area\n    btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1)\n   btrfs_fill_super\n    open_ctree\n     btrfs_free_extra_devids\n      if (btrfs_device_1->bdev_file)\n       fput(btrfs_device_1->bdev_file) // UAF !\n\nFix it by setting 'device->bdev_file' as 'NULL' after closing the\nbtrfs_device in btrfs_close_one_device().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50230",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix kernel bug due to missing clearing of checked flag",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix kernel bug due to missing clearing of checked flag\n\nSyzbot reported that in directory operations after nilfs2 detects\nfilesystem corruption and degrades to read-only,\n__block_write_begin_int(), which is called to prepare block writes, may\nfail the BUG_ON check for accesses exceeding the folio/page size,\ntriggering a kernel bug.\n\nThis was found to be because the \"checked\" flag of a page/folio was not\ncleared when it was discarded by nilfs2's own routine, which causes the\nsanity check of directory entries to be skipped when the directory\npage/folio is reloaded.  So, fix that.\n\nThis was necessary when the use of nilfs2's own page discard routine was\napplied to more than just metadata files.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50234",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlegacy: Clear stale interrupts before resuming device",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlegacy: Clear stale interrupts before resuming device\n\niwl4965 fails upon resume from hibernation on my laptop. The reason\nseems to be a stale interrupt which isn't being cleared out before\ninterrupts are enabled. We end up with a race beween the resume\ntrying to bring things back up, and the restart work (queued form\nthe interrupt handler) trying to bring things down. Eventually\nthe whole thing blows up.\n\nFix the problem by clearing out any stale interrupts before\ninterrupts get enabled during resume.\n\nHere's a debug log of the indicent:\n[   12.042589] ieee80211 phy0: il_isr ISR inta 0x00000080, enabled 0xaa00008b, fh 0x00000000\n[   12.042625] ieee80211 phy0: il4965_irq_tasklet inta 0x00000080, enabled 0x00000000, fh 0x00000000\n[   12.042651] iwl4965 0000:10:00.0: RF_KILL bit toggled to enable radio.\n[   12.042653] iwl4965 0000:10:00.0: On demand firmware reload\n[   12.042690] ieee80211 phy0: il4965_irq_tasklet End inta 0x00000000, enabled 0xaa00008b, fh 0x00000000, flags 0x00000282\n[   12.052207] ieee80211 phy0: il4965_mac_start enter\n[   12.052212] ieee80211 phy0: il_prep_station Add STA to driver ID 31: ff:ff:ff:ff:ff:ff\n[   12.052244] ieee80211 phy0: il4965_set_hw_ready hardware  ready\n[   12.052324] ieee80211 phy0: il_apm_init Init card's basic functions\n[   12.052348] ieee80211 phy0: il_apm_init L1 Enabled; Disabling L0S\n[   12.055727] ieee80211 phy0: il4965_load_bsm Begin load bsm\n[   12.056140] ieee80211 phy0: il4965_verify_bsm Begin verify bsm\n[   12.058642] ieee80211 phy0: il4965_verify_bsm BSM bootstrap uCode image OK\n[   12.058721] ieee80211 phy0: il4965_load_bsm BSM write complete, poll 1 iterations\n[   12.058734] ieee80211 phy0: __il4965_up iwl4965 is coming up\n[   12.058737] ieee80211 phy0: il4965_mac_start Start UP work done.\n[   12.058757] ieee80211 phy0: __il4965_down iwl4965 is going down\n[   12.058761] ieee80211 phy0: il_scan_cancel_timeout Scan cancel timeout\n[   12.058762] ieee80211 phy0: il_do_scan_abort Not performing scan to abort\n[   12.058765] ieee80211 phy0: il_clear_ucode_stations Clearing ucode stations in driver\n[   12.058767] ieee80211 phy0: il_clear_ucode_stations No active stations found to be cleared\n[   12.058819] ieee80211 phy0: _il_apm_stop Stop card, put in low power state\n[   12.058827] ieee80211 phy0: _il_apm_stop_master stop master\n[   12.058864] ieee80211 phy0: il4965_clear_free_frames 0 frames on pre-allocated heap on clear.\n[   12.058869] ieee80211 phy0: Hardware restart was requested\n[   16.132299] iwl4965 0000:10:00.0: START_ALIVE timeout after 4000ms.\n[   16.132303] ------------[ cut here ]------------\n[   16.132304] Hardware became unavailable upon resume. This could be a software issue prior to suspend or a hardware issue.\n[   16.132338] WARNING: CPU: 0 PID: 181 at net/mac80211/util.c:1826 ieee80211_reconfig+0x8f/0x14b0 [mac80211]\n[   16.132390] Modules linked in: ctr ccm sch_fq_codel xt_tcpudp xt_multiport xt_state iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv4 ip_tables x_tables binfmt_misc joydev mousedev btusb btrtl btintel btbcm bluetooth ecdh_generic ecc iTCO_wdt i2c_dev iwl4965 iwlegacy coretemp snd_hda_codec_analog pcspkr psmouse mac80211 snd_hda_codec_generic libarc4 sdhci_pci cqhci sha256_generic sdhci libsha256 firewire_ohci snd_hda_intel snd_intel_dspcfg mmc_core snd_hda_codec snd_hwdep firewire_core led_class iosf_mbi snd_hda_core uhci_hcd lpc_ich crc_itu_t cfg80211 ehci_pci ehci_hcd snd_pcm usbcore mfd_core rfkill snd_timer snd usb_common soundcore video parport_pc parport intel_agp wmi intel_gtt backlight e1000e agpgart evdev\n[   16.132456] CPU: 0 UID: 0 PID: 181 Comm: kworker/u8:6 Not tainted 6.11.0-cl+ #143\n[   16.132460] Hardware name: Hewlett-Packard HP Compaq 6910p/30BE, BIOS 68MCU Ver. F.19 07/06/2010\n[   16.132463] Workqueue: async async_run_entry_fn\n[   16.132469] RIP: 0010:ieee80211_reconfig+0x8f/0x14b0 [mac80211]\n[   16.132501] Code: da 02 00 0\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50262",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Fix out-of-bounds write in trie_get_next_key()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix out-of-bounds write in trie_get_next_key()\n\ntrie_get_next_key() allocates a node stack with size trie->max_prefixlen,\nwhile it writes (trie->max_prefixlen + 1) nodes to the stack when it has\nfull paths from the root to leaves. For example, consider a trie with\nmax_prefixlen is 8, and the nodes with key 0x00/0, 0x00/1, 0x00/2, ...\n0x00/8 inserted. Subsequent calls to trie_get_next_key with _key with\n.prefixlen = 8 make 9 nodes be written on the node stack with size 8.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50264",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vsock/virtio: Initialization of the dangling pointer occurring in vsk->trans",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock/virtio: Initialization of the dangling pointer occurring in vsk->trans\n\nDuring loopback communication, a dangling pointer can be created in\nvsk->trans, potentially leading to a Use-After-Free condition.  This\nissue is resolved by initializing vsk->trans to NULL.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50267",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: USB: serial: io_edgeport: fix use after free in debug printk",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: serial: io_edgeport: fix use after free in debug printk\n\nThe \"dev_dbg(&urb->dev->dev, ...\" which happens after usb_free_urb(urb)\nis a use after free of the \"urb\" pointer.  Store the \"dev\" pointer at the\nstart of the function to avoid this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50268",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: typec: fix potential out of bounds in ucsi_ccg_update_set_new_cam_cmd()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: fix potential out of bounds in ucsi_ccg_update_set_new_cam_cmd()\n\nThe \"*cmd\" variable can be controlled by the user via debugfs.  That means\n\"new_cam\" can be as high as 255 while the size of the uc->updated[] array\nis UCSI_MAX_ALTMODES (30).\n\nThe call tree is:\nucsi_cmd() // val comes from simple_attr_write_xsigned()\n-> ucsi_send_command()\n   -> ucsi_send_command_common()\n      -> ucsi_run_command() // calls ucsi->ops->sync_control()\n         -> ucsi_ccg_sync_control()",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50269",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: musb: sunxi: Fix accessing an released usb phy",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: musb: sunxi: Fix accessing an released usb phy\n\nCommit 6ed05c68cbca (\"usb: musb: sunxi: Explicitly release USB PHY on\nexit\") will cause that usb phy @glue->xceiv is accessed after released.\n\n1) register platform driver @sunxi_musb_driver\n// get the usb phy @glue->xceiv\nsunxi_musb_probe() -> devm_usb_get_phy().\n\n2) register and unregister platform driver @musb_driver\nmusb_probe() -> sunxi_musb_init()\nuse the phy here\n//the phy is released here\nmusb_remove() -> sunxi_musb_exit() -> devm_usb_put_phy()\n\n3) register @musb_driver again\nmusb_probe() -> sunxi_musb_init()\nuse the phy here but the phy has been released at 2).\n...\n\nFixed by reverting the commit, namely, removing devm_usb_put_phy()\nfrom sunxi_musb_exit().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50278",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dm cache: fix potential out-of-bounds access on the first resume",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: fix potential out-of-bounds access on the first resume\n\nOut-of-bounds access occurs if the fast device is expanded unexpectedly\nbefore the first-time resume of the cache table. This happens because\nexpanding the fast device requires reloading the cache table for\ncache_create to allocate new in-core data structures that fit the new\nsize, and the check in cache_preresume is not performed during the\nfirst resume, leading to the issue.\n\nReproduce steps:\n\n1. prepare component devices:\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc 262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct\n\n2. load a cache table of 512 cache blocks, and deliberately expand the\n   fast device before resuming the cache, making the in-core data\n   structures inadequate.\n\ndmsetup create cache --notable\ndmsetup reload cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\ndmsetup reload cdata --table \"0 131072 linear /dev/sdc 8192\"\ndmsetup resume cdata\ndmsetup resume cache\n\n3. suspend the cache to write out the in-core dirty bitset and hint\n   array, leading to out-of-bounds access to the dirty bitset at offset\n   0x40:\n\ndmsetup suspend cache\n\nKASAN reports:\n\n  BUG: KASAN: vmalloc-out-of-bounds in is_dirty_callback+0x2b/0x80\n  Read of size 8 at addr ffffc90000085040 by task dmsetup/90\n\n  (...snip...)\n  The buggy address belongs to the virtual mapping at\n   [ffffc90000085000, ffffc90000087000) created by:\n   cache_ctr+0x176a/0x35f0\n\n  (...snip...)\n  Memory state around the buggy address:\n   ffffc90000084f00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc90000084f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n  >ffffc90000085000: 00 00 00 00 00 00 00 00 f8 f8 f8 f8 f8 f8 f8 f8\n                                             ^\n   ffffc90000085080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc90000085100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n\nFix by checking the size change on the first resume.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50279",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dm cache: fix out-of-bounds access to the dirty bitset when resizing",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: fix out-of-bounds access to the dirty bitset when resizing\n\ndm-cache checks the dirty bits of the cache blocks to be dropped when\nshrinking the fast device, but an index bug in bitset iteration causes\nout-of-bounds access.\n\nReproduce steps:\n\n1. create a cache device of 1024 cache blocks (128 bytes dirty bitset)\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 131072 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc 262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\n2. shrink the fast device to 512 cache blocks, triggering out-of-bounds\n   access to the dirty bitset (offset 0x80)\n\ndmsetup suspend cache\ndmsetup reload cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup resume cdata\ndmsetup resume cache\n\nKASAN reports:\n\n  BUG: KASAN: vmalloc-out-of-bounds in cache_preresume+0x269/0x7b0\n  Read of size 8 at addr ffffc900000f3080 by task dmsetup/131\n\n  (...snip...)\n  The buggy address belongs to the virtual mapping at\n   [ffffc900000f3000, ffffc900000f5000) created by:\n   cache_ctr+0x176a/0x35f0\n\n  (...snip...)\n  Memory state around the buggy address:\n   ffffc900000f2f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc900000f3000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  >ffffc900000f3080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n                     ^\n   ffffc900000f3100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc900000f3180: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n\nFix by making the index post-incremented.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50282",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: add missing size check in amdgpu_debugfs_gprwave_read()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: add missing size check in amdgpu_debugfs_gprwave_read()\n\nAvoid a possible buffer overflow if size is larger than 4K.\n\n(cherry picked from commit f5d873f5825b40d886d03bd2aede91d4cf002434)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-50301",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: security/keys: fix slab-out-of-bounds in key_task_permission",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsecurity/keys: fix slab-out-of-bounds in key_task_permission\n\nKASAN reports an out of bounds read:\nBUG: KASAN: slab-out-of-bounds in __kuid_val include/linux/uidgid.h:36\nBUG: KASAN: slab-out-of-bounds in uid_eq include/linux/uidgid.h:63 [inline]\nBUG: KASAN: slab-out-of-bounds in key_task_permission+0x394/0x410\nsecurity/keys/permission.c:54\nRead of size 4 at addr ffff88813c3ab618 by task stress-ng/4362\n\nCPU: 2 PID: 4362 Comm: stress-ng Not tainted 5.10.0-14930-gafbffd6c3ede #15\nCall Trace:\n __dump_stack lib/dump_stack.c:82 [inline]\n dump_stack+0x107/0x167 lib/dump_stack.c:123\n print_address_description.constprop.0+0x19/0x170 mm/kasan/report.c:400\n __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560\n kasan_report+0x3a/0x50 mm/kasan/report.c:585\n __kuid_val include/linux/uidgid.h:36 [inline]\n uid_eq include/linux/uidgid.h:63 [inline]\n key_task_permission+0x394/0x410 security/keys/permission.c:54\n search_nested_keyrings+0x90e/0xe90 security/keys/keyring.c:793\n\nThis issue was also reported by syzbot.\n\nIt can be reproduced by following these steps(more details [1]):\n1. Obtain more than 32 inputs that have similar hashes, which ends with the\n   pattern '0xxxxxxxe6'.\n2. Reboot and add the keys obtained in step 1.\n\nThe reproducer demonstrates how this issue happened:\n1. In the search_nested_keyrings function, when it iterates through the\n   slots in a node(below tag ascend_to_node), if the slot pointer is meta\n   and node->back_pointer != NULL(it means a root), it will proceed to\n   descend_to_node. However, there is an exception. If node is the root,\n   and one of the slots points to a shortcut, it will be treated as a\n   keyring.\n2. Whether the ptr is keyring decided by keyring_ptr_is_keyring function.\n   However, KEYRING_PTR_SUBTYPE is 0x2UL, the same as\n   ASSOC_ARRAY_PTR_SUBTYPE_MASK.\n3. When 32 keys with the similar hashes are added to the tree, the ROOT\n   has keys with hashes that are not similar (e.g. slot 0) and it splits\n   NODE A without using a shortcut. When NODE A is filled with keys that\n   all hashes are xxe6, the keys are similar, NODE A will split with a\n   shortcut. Finally, it forms the tree as shown below, where slot 6 points\n   to a shortcut.\n\n                      NODE A\n              +------>+---+\n      ROOT    |       | 0 | xxe6\n      +---+   |       +---+\n xxxx | 0 | shortcut  :   : xxe6\n      +---+   |       +---+\n xxe6 :   :   |       |   | xxe6\n      +---+   |       +---+\n      | 6 |---+       :   : xxe6\n      +---+           +---+\n xxe6 :   :           | f | xxe6\n      +---+           +---+\n xxe6 | f |\n      +---+\n\n4. As mentioned above, If a slot(slot 6) of the root points to a shortcut,\n   it may be mistakenly transferred to a key*, leading to a read\n   out-of-bounds read.\n\nTo fix this issue, one should jump to descend_to_node if the ptr is a\nshortcut, regardless of whether the node is root or not.\n\n[1] https://lore.kernel.org/linux-kernel/1cfa878e-8c7b-4570-8606-21daf5e13ce7@huaweicloud.com/\n\n[jarkko: tweaked the commit message a bit to have an appropriate closes\n tag.]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-52332",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: igb: Fix potential invalid memory access in igb_init_module()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Fix potential invalid memory access in igb_init_module()\n\nThe pci_register_driver() can fail and when this happened, the dca_notifier\nneeds to be unregistered, otherwise the dca_notifier can be called when\nigb fails to install, resulting to invalid memory access.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53057",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: stop qdisc_tree_reduce_backlog on TC_H_ROOT",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: stop qdisc_tree_reduce_backlog on TC_H_ROOT\n\nIn qdisc_tree_reduce_backlog, Qdiscs with major handle ffff: are assumed\nto be either root or ingress. This assumption is bogus since it's valid\nto create egress qdiscs with major handle ffff:\nBudimir Markovic found that for qdiscs like DRR that maintain an active\nclass list, it will cause a UAF with a dangling class pointer.\n\nIn 066a3b5b2346, the concern was to avoid iterating over the ingress\nqdisc since its parent is itself. The proper fix is to stop when parent\nTC_H_ROOT is reached because the only way to retrieve ingress is when a\nhierarchy which does not contain a ffff: major handle call into\nqdisc_lookup with TC_H_MAJ(TC_H_ROOT).\n\nIn the scenario where major ffff: is an egress qdisc in any of the tree\nlevels, the updates will also propagate to TC_H_ROOT, which then the\niteration must stop.\n\n\n net/sched/sch_api.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53059",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: mvm: Fix response handling in iwl_mvm_send_recovery_cmd()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: Fix response handling in iwl_mvm_send_recovery_cmd()\n\n1. The size of the response packet is not validated.\n2. The response buffer is not freed.\n\nResolve these issues by switching to iwl_mvm_send_cmd_status(),\nwhich handles both size validation and frees the buffer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53061",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: s5p-jpeg: prevent buffer overflows",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: s5p-jpeg: prevent buffer overflows\n\nThe current logic allows word to be less than 2. If this happens,\nthere will be buffer overflows, as reported by smatch. Add extra\nchecks to prevent it.\n\nWhile here, remove an unused word = 0 assignment.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53068",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: firmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier()\n\nThe scmi_dev->name is released prematurely in __scmi_device_destroy(),\nwhich causes slab-use-after-free when accessing scmi_dev->name in\nscmi_bus_notifier(). So move the release of scmi_dev->name to\nscmi_device_release() to avoid slab-use-after-free.\n\n  |  BUG: KASAN: slab-use-after-free in strncmp+0xe4/0xec\n  |  Read of size 1 at addr ffffff80a482bcc0 by task swapper/0/1\n  |\n  |  CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.6.38-debug #1\n  |  Hardware name: Qualcomm Technologies, Inc. SA8775P Ride (DT)\n  |  Call trace:\n  |   dump_backtrace+0x94/0x114\n  |   show_stack+0x18/0x24\n  |   dump_stack_lvl+0x48/0x60\n  |   print_report+0xf4/0x5b0\n  |   kasan_report+0xa4/0xec\n  |   __asan_report_load1_noabort+0x20/0x2c\n  |   strncmp+0xe4/0xec\n  |   scmi_bus_notifier+0x5c/0x54c\n  |   notifier_call_chain+0xb4/0x31c\n  |   blocking_notifier_call_chain+0x68/0x9c\n  |   bus_notify+0x54/0x78\n  |   device_del+0x1bc/0x840\n  |   device_unregister+0x20/0xb4\n  |   __scmi_device_destroy+0xac/0x280\n  |   scmi_device_destroy+0x94/0xd0\n  |   scmi_chan_setup+0x524/0x750\n  |   scmi_probe+0x7fc/0x1508\n  |   platform_probe+0xc4/0x19c\n  |   really_probe+0x32c/0x99c\n  |   __driver_probe_device+0x15c/0x3c4\n  |   driver_probe_device+0x5c/0x170\n  |   __driver_attach+0x1c8/0x440\n  |   bus_for_each_dev+0xf4/0x178\n  |   driver_attach+0x3c/0x58\n  |   bus_add_driver+0x234/0x4d4\n  |   driver_register+0xf4/0x3c0\n  |   __platform_driver_register+0x60/0x88\n  |   scmi_driver_init+0xb0/0x104\n  |   do_one_initcall+0xb4/0x664\n  |   kernel_init_freeable+0x3c8/0x894\n  |   kernel_init+0x24/0x1e8\n  |   ret_from_fork+0x10/0x20\n  |\n  |  Allocated by task 1:\n  |   kasan_save_stack+0x2c/0x54\n  |   kasan_set_track+0x2c/0x40\n  |   kasan_save_alloc_info+0x24/0x34\n  |   __kasan_kmalloc+0xa0/0xb8\n  |   __kmalloc_node_track_caller+0x6c/0x104\n  |   kstrdup+0x48/0x84\n  |   kstrdup_const+0x34/0x40\n  |   __scmi_device_create.part.0+0x8c/0x408\n  |   scmi_device_create+0x104/0x370\n  |   scmi_chan_setup+0x2a0/0x750\n  |   scmi_probe+0x7fc/0x1508\n  |   platform_probe+0xc4/0x19c\n  |   really_probe+0x32c/0x99c\n  |   __driver_probe_device+0x15c/0x3c4\n  |   driver_probe_device+0x5c/0x170\n  |   __driver_attach+0x1c8/0x440\n  |   bus_for_each_dev+0xf4/0x178\n  |   driver_attach+0x3c/0x58\n  |   bus_add_driver+0x234/0x4d4\n  |   driver_register+0xf4/0x3c0\n  |   __platform_driver_register+0x60/0x88\n  |   scmi_driver_init+0xb0/0x104\n  |   do_one_initcall+0xb4/0x664\n  |   kernel_init_freeable+0x3c8/0x894\n  |   kernel_init+0x24/0x1e8\n  |   ret_from_fork+0x10/0x20\n  |\n  |  Freed by task 1:\n  |   kasan_save_stack+0x2c/0x54\n  |   kasan_set_track+0x2c/0x40\n  |   kasan_save_free_info+0x38/0x5c\n  |   __kasan_slab_free+0xe8/0x164\n  |   __kmem_cache_free+0x11c/0x230\n  |   kfree+0x70/0x130\n  |   kfree_const+0x20/0x40\n  |   __scmi_device_destroy+0x70/0x280\n  |   scmi_device_destroy+0x94/0xd0\n  |   scmi_chan_setup+0x524/0x750\n  |   scmi_probe+0x7fc/0x1508\n  |   platform_probe+0xc4/0x19c\n  |   really_probe+0x32c/0x99c\n  |   __driver_probe_device+0x15c/0x3c4\n  |   driver_probe_device+0x5c/0x170\n  |   __driver_attach+0x1c8/0x440\n  |   bus_for_each_dev+0xf4/0x178\n  |   driver_attach+0x3c/0x58\n  |   bus_add_driver+0x234/0x4d4\n  |   driver_register+0xf4/0x3c0\n  |   __platform_driver_register+0x60/0x88\n  |   scmi_driver_init+0xb0/0x104\n  |   do_one_initcall+0xb4/0x664\n  |   kernel_init_freeable+0x3c8/0x894\n  |   kernel_init+0x24/0x1e8\n  |   ret_from_fork+0x10/0x20",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53096",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm: resolve faulty mmap_region() error path behaviour",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: resolve faulty mmap_region() error path behaviour\n\nThe mmap_region() function is somewhat terrifying, with spaghetti-like\ncontrol flow and numerous means by which issues can arise and incomplete\nstate, memory leaks and other unpleasantness can occur.\n\nA large amount of the complexity arises from trying to handle errors late\nin the process of mapping a VMA, which forms the basis of recently\nobserved issues with resource leaks and observable inconsistent state.\n\nTaking advantage of previous patches in this series we move a number of\nchecks earlier in the code, simplifying things by moving the core of the\nlogic into a static internal function __mmap_region().\n\nDoing this allows us to perform a number of checks up front before we do\nany real work, and allows us to unwind the writable unmap check\nunconditionally as required and to perform a CONFIG_DEBUG_VM_MAPLE_TREE\nvalidation unconditionally also.\n\nWe move a number of things here:\n\n1. We preallocate memory for the iterator before we call the file-backed\n   memory hook, allowing us to exit early and avoid having to perform\n   complicated and error-prone close/free logic. We carefully free\n   iterator state on both success and error paths.\n\n2. The enclosing mmap_region() function handles the mapping_map_writable()\n   logic early. Previously the logic had the mapping_map_writable() at the\n   point of mapping a newly allocated file-backed VMA, and a matching\n   mapping_unmap_writable() on success and error paths.\n\n   We now do this unconditionally if this is a file-backed, shared writable\n   mapping. If a driver changes the flags to eliminate VM_MAYWRITE, however\n   doing so does not invalidate the seal check we just performed, and we in\n   any case always decrement the counter in the wrapper.\n\n   We perform a debug assert to ensure a driver does not attempt to do the\n   opposite.\n\n3. We also move arch_validate_flags() up into the mmap_region()\n   function. This is only relevant on arm64 and sparc64, and the check is\n   only meaningful for SPARC with ADI enabled. We explicitly add a warning\n   for this arch if a driver invalidates this check, though the code ought\n   eventually to be fixed to eliminate the need for this.\n\nWith all of these measures in place, we no longer need to explicitly close\nthe VMA on error paths, as we place all checks which might fail prior to a\ncall to any driver mmap hook.\n\nThis eliminates an entire class of errors, makes the code easier to reason\nabout and more robust.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53099",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: Check validity of link->type in bpf_link_show_fdinfo()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Check validity of link->type in bpf_link_show_fdinfo()\n\nIf a newly-added link type doesn't invoke BPF_LINK_TYPE(), accessing\nbpf_link_type_strs[link->type] may result in an out-of-bounds access.\n\nTo spot such missed invocations early in the future, checking the\nvalidity of link->type in bpf_link_show_fdinfo() and emitting a warning\nwhen such invocations are missed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53103",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hv_sock: Initializing vsk->trans to NULL to prevent a dangling pointer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhv_sock: Initializing vsk->trans to NULL to prevent a dangling pointer\n\nWhen hvs is released, there is a possibility that vsk->trans may not\nbe initialized to NULL, which could lead to a dangling pointer.\nThis issue is resolved by initializing vsk->trans to NULL.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53104",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: uvcvideo: Skip parsing frames of type UVC_VS_UNDEFINED in uvc_parse_format",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Skip parsing frames of type UVC_VS_UNDEFINED in uvc_parse_format\n\nThis can lead to out of bounds writes since frames of this type were not\ntaken into account when calculating the size of the frames buffer in\nuvc_parse_streaming.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53141",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: ipset: add missing range check in bitmap_ip_uadt",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: ipset: add missing range check in bitmap_ip_uadt\n\nWhen tb[IPSET_ATTR_IP_TO] is not present but tb[IPSET_ATTR_CIDR] exists,\nthe values of ip and ip_to are slightly swapped. Therefore, the range check\nfor ip should be done later, but this part is missing and it seems that the\nvulnerability occurs.\n\nSo we should add missing range checks and remove unnecessary range checks.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53142",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: initramfs: avoid filename buffer overrun",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ninitramfs: avoid filename buffer overrun\n\nThe initramfs filename field is defined in\nDocumentation/driver-api/early-userspace/buffer-format.rst as:\n\n 37 cpio_file := ALGN(4) + cpio_header + filename + \"\\0\" + ALGN(4) + data\n...\n 55 ============= ================== =========================\n 56 Field name    Field size         Meaning\n 57 ============= ================== =========================\n...\n 70 c_namesize    8 bytes            Length of filename, including final \\0\n\nWhen extracting an initramfs cpio archive, the kernel's do_name() path\nhandler assumes a zero-terminated path at @collected, passing it\ndirectly to filp_open() / init_mkdir() / init_mknod().\n\nIf a specially crafted cpio entry carries a non-zero-terminated filename\nand is followed by uninitialized memory, then a file may be created with\ntrailing characters that represent the uninitialized memory. The ability\nto create an initramfs entry would imply already having full control of\nthe system, so the buffer overrun shouldn't be considered a security\nvulnerability.\n\nAppend the output of the following bash script to an existing initramfs\nand observe any created /initramfs_test_fname_overrunAA* path. E.g.\n  ./reproducer.sh | gzip >> /myinitramfs\n\nIt's easiest to observe non-zero uninitialized memory when the output is\ngzipped, as it'll overflow the heap allocated @out_buf in __gunzip(),\nrather than the initrd_start+initrd_size block.\n\n---- reproducer.sh ----\nnilchar=\"A\"\t# change to \"\\0\" to properly zero terminate / pad\nmagic=\"070701\"\nino=1\nmode=$(( 0100777 ))\nuid=0\ngid=0\nnlink=1\nmtime=1\nfilesize=0\ndevmajor=0\ndevminor=1\nrdevmajor=0\nrdevminor=0\ncsum=0\nfname=\"initramfs_test_fname_overrun\"\nnamelen=$(( ${#fname} + 1 ))\t# plus one to account for terminator\n\nprintf \"%s%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%s\" \\\n\t$magic $ino $mode $uid $gid $nlink $mtime $filesize \\\n\t$devmajor $devminor $rdevmajor $rdevminor $namelen $csum $fname\n\ntermpadlen=$(( 1 + ((4 - ((110 + $namelen) & 3)) % 4) ))\nprintf \"%.s${nilchar}\" $(seq 1 $termpadlen)\n---- reproducer.sh ----\n\nSymlink filename fields handled in do_symlink() won't overrun past the\ndata segment, due to the explicit zero-termination of the symlink\ntarget.\n\nFix filename buffer overrun by aborting the initramfs FSM if any cpio\nentry doesn't carry a zero-terminator at the expected (name_len - 1)\noffset.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53147",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: exfat: fix out-of-bounds access of directory entries",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix out-of-bounds access of directory entries\n\nIn the case of the directory size is greater than or equal to\nthe cluster size, if start_clu becomes an EOF cluster(an invalid\ncluster) due to file system corruption, then the directory entry\nwhere ei->hint_femp.eidx hint is outside the directory, resulting\nin an out-of-bounds access, which may cause further file system\ncorruption.\n\nThis commit adds a check for start_clu, if it is an invalid cluster,\nthe file or directory will be treated as empty.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53150",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: usb-audio: Fix out of bounds reads when finding clock sources",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Fix out of bounds reads when finding clock sources\n\nThe current USB-audio driver code doesn't check bLength of each\ndescriptor at traversing for clock descriptors.  That is, when a\ndevice provides a bogus descriptor with a shorter bLength, the driver\nmight hit out-of-bounds reads.\n\nFor addressing it, this patch adds sanity checks to the validator\nfunctions for the clock descriptor traversal.  When the descriptor\nlength is shorter than expected, it's skipped in the loop.\n\nFor the clock source and clock multiplier descriptors, we can just\ncheck bLength against the sizeof() of each descriptor type.\nOTOH, the clock selector descriptor of UAC2 and UAC3 has an array\nof bNrInPins elements and two more fields at its tail, hence those\nhave to be checked in addition to the sizeof() check.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53155",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ocfs2: fix uninitialized value in ocfs2_file_read_iter()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix uninitialized value in ocfs2_file_read_iter()\n\nSyzbot has reported the following KMSAN splat:\n\nBUG: KMSAN: uninit-value in ocfs2_file_read_iter+0x9a4/0xf80\n ocfs2_file_read_iter+0x9a4/0xf80\n __io_read+0x8d4/0x20f0\n io_read+0x3e/0xf0\n io_issue_sqe+0x42b/0x22c0\n io_wq_submit_work+0xaf9/0xdc0\n io_worker_handle_work+0xd13/0x2110\n io_wq_worker+0x447/0x1410\n ret_from_fork+0x6f/0x90\n ret_from_fork_asm+0x1a/0x30\n\nUninit was created at:\n __alloc_pages_noprof+0x9a7/0xe00\n alloc_pages_mpol_noprof+0x299/0x990\n alloc_pages_noprof+0x1bf/0x1e0\n allocate_slab+0x33a/0x1250\n ___slab_alloc+0x12ef/0x35e0\n kmem_cache_alloc_bulk_noprof+0x486/0x1330\n __io_alloc_req_refill+0x84/0x560\n io_submit_sqes+0x172f/0x2f30\n __se_sys_io_uring_enter+0x406/0x41c0\n __x64_sys_io_uring_enter+0x11f/0x1a0\n x64_sys_call+0x2b54/0x3ba0\n do_syscall_64+0xcd/0x1e0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nSince an instance of 'struct kiocb' may be passed from the block layer\nwith 'private' field uninitialized, introduce 'ocfs2_iocb_init_rw_locked()'\nand use it from where 'ocfs2_dio_end_io()' might take care, i.e. in\n'ocfs2_file_read_iter()' and 'ocfs2_file_write_iter()'.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53156",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath9k: add range check for conn_rsp_epid in htc_connect_service()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: add range check for conn_rsp_epid in htc_connect_service()\n\nI found the following bug in my fuzzer:\n\n  UBSAN: array-index-out-of-bounds in drivers/net/wireless/ath/ath9k/htc_hst.c:26:51\n  index 255 is out of range for type 'htc_endpoint [22]'\n  CPU: 0 UID: 0 PID: 8 Comm: kworker/0:0 Not tainted 6.11.0-rc6-dirty #14\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  Workqueue: events request_firmware_work_func\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x180/0x1b0\n   __ubsan_handle_out_of_bounds+0xd4/0x130\n   htc_issue_send.constprop.0+0x20c/0x230\n   ? _raw_spin_unlock_irqrestore+0x3c/0x70\n   ath9k_wmi_cmd+0x41d/0x610\n   ? mark_held_locks+0x9f/0xe0\n   ...\n\nSince this bug has been confirmed to be caused by insufficient verification\nof conn_rsp_epid, I think it would be appropriate to add a range check for\nconn_rsp_epid to htc_connect_service() to prevent the bug from occurring.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53165",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sh: intc: Fix use-after-free bug in register_intc_controller()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsh: intc: Fix use-after-free bug in register_intc_controller()\n\nIn the error handling for this function, d is freed without ever\nremoving it from intc_list which would lead to a use after free.\nTo fix this, let's only add it to the list after everything has\nsucceeded.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53168",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sunrpc: fix one UAF issue caused by sunrpc kernel tcp socket",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsunrpc: fix one UAF issue caused by sunrpc kernel tcp socket\n\nBUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0\nRead of size 1 at addr ffff888111f322cd by task swapper/0/0\n\nCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x68/0xa0\n print_address_description.constprop.0+0x2c/0x3d0\n print_report+0xb4/0x270\n kasan_report+0xbd/0xf0\n tcp_write_timer_handler+0x156/0x3e0\n tcp_write_timer+0x66/0x170\n call_timer_fn+0xfb/0x1d0\n __run_timers+0x3f8/0x480\n run_timer_softirq+0x9b/0x100\n handle_softirqs+0x153/0x390\n __irq_exit_rcu+0x103/0x120\n irq_exit_rcu+0xe/0x20\n sysvec_apic_timer_interrupt+0x76/0x90\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1a/0x20\nRIP: 0010:default_idle+0xf/0x20\nCode: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90\n 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 <fa> c3 cc cc cc\n cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90\nRSP: 0018:ffffffffa2007e28 EFLAGS: 00000242\nRAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590f\nRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835d\nR10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000\nR13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0\n default_idle_call+0x6b/0xa0\n cpuidle_idle_call+0x1af/0x1f0\n do_idle+0xbc/0x130\n cpu_startup_entry+0x33/0x40\n rest_init+0x11f/0x210\n start_kernel+0x39a/0x420\n x86_64_start_reservations+0x18/0x30\n x86_64_start_kernel+0x97/0xa0\n common_startup_64+0x13e/0x141\n </TASK>\n\nAllocated by task 595:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n __kasan_slab_alloc+0x87/0x90\n kmem_cache_alloc_noprof+0x12b/0x3f0\n copy_net_ns+0x94/0x380\n create_new_namespaces+0x24c/0x500\n unshare_nsproxy_namespaces+0x75/0xf0\n ksys_unshare+0x24e/0x4f0\n __x64_sys_unshare+0x1f/0x30\n do_syscall_64+0x70/0x180\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 100:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n __kasan_slab_free+0x54/0x70\n kmem_cache_free+0x156/0x5d0\n cleanup_net+0x5d3/0x670\n process_one_work+0x776/0xa90\n worker_thread+0x2e2/0x560\n kthread+0x1a8/0x1f0\n ret_from_fork+0x34/0x60\n ret_from_fork_asm+0x1a/0x30\n\nReproduction script:\n\nmkdir -p /mnt/nfsshare\nmkdir -p /mnt/nfs/netns_1\nmkfs.ext4 /dev/sdb\nmount /dev/sdb /mnt/nfsshare\nsystemctl restart nfs-server\nchmod 777 /mnt/nfsshare\nexportfs -i -o rw,no_root_squash *:/mnt/nfsshare\n\nip netns add netns_1\nip link add name veth_1_peer type veth peer veth_1\nifconfig veth_1_peer 11.11.0.254 up\nip link set veth_1 netns netns_1\nip netns exec netns_1 ifconfig veth_1 11.11.0.1\n\nip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp \\\n\t--tcp-flags FIN FIN  -j DROP\n\n(note: In my environment, a DESTROY_CLIENTID operation is always sent\n immediately, breaking the nfs tcp connection.)\nip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1 \\\n\t11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1\n\nip netns del netns_1\n\nThe reason here is that the tcp socket in netns_1 (nfs side) has been\nshutdown and closed (done in xs_destroy), but the FIN message (with ack)\nis discarded, and the nfsd side keeps sending retransmission messages.\nAs a result, when the tcp sock in netns_1 processes the received message,\nit sends the message (FIN message) in the sending queue, and the tcp timer\nis re-established. When the network namespace is deleted, the net structure\naccessed by tcp's timer handler function causes problems.\n\nTo fix this problem, let's hold netns refcnt for the tcp kernel socket as\ndone in other modules. This is an ugly hack which can easily be backported\nto earlier kernels. A proper fix which cleans up the interfaces will\nfollow, but may not be so easy to backport.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53171",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ubifs: authentication: Fix use-after-free in ubifs_tnc_end_commit",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubifs: authentication: Fix use-after-free in ubifs_tnc_end_commit\n\nAfter an insertion in TNC, the tree might split and cause a node to\nchange its `znode->parent`. A further deletion of other nodes in the\ntree (which also could free the nodes), the aforementioned node's\n`znode->cparent` could still point to a freed node. This\n`znode->cparent` may not be updated when getting nodes to commit in\n`ubifs_tnc_start_commit()`. This could then trigger a use-after-free\nwhen accessing the `znode->cparent` in `write_index()` in\n`ubifs_tnc_end_commit()`.\n\nThis can be triggered by running\n\n  rm -f /etc/test-file.bin\n  dd if=/dev/urandom of=/etc/test-file.bin bs=1M count=60 conv=fsync\n\nin a loop, and with `CONFIG_UBIFS_FS_AUTHENTICATION`. KASAN then\nreports:\n\n  BUG: KASAN: use-after-free in ubifs_tnc_end_commit+0xa5c/0x1950\n  Write of size 32 at addr ffffff800a3af86c by task ubifs_bgt0_20/153\n\n  Call trace:\n   dump_backtrace+0x0/0x340\n   show_stack+0x18/0x24\n   dump_stack_lvl+0x9c/0xbc\n   print_address_description.constprop.0+0x74/0x2b0\n   kasan_report+0x1d8/0x1f0\n   kasan_check_range+0xf8/0x1a0\n   memcpy+0x84/0xf4\n   ubifs_tnc_end_commit+0xa5c/0x1950\n   do_commit+0x4e0/0x1340\n   ubifs_bg_thread+0x234/0x2e0\n   kthread+0x36c/0x410\n   ret_from_fork+0x10/0x20\n\n  Allocated by task 401:\n   kasan_save_stack+0x38/0x70\n   __kasan_kmalloc+0x8c/0xd0\n   __kmalloc+0x34c/0x5bc\n   tnc_insert+0x140/0x16a4\n   ubifs_tnc_add+0x370/0x52c\n   ubifs_jnl_write_data+0x5d8/0x870\n   do_writepage+0x36c/0x510\n   ubifs_writepage+0x190/0x4dc\n   __writepage+0x58/0x154\n   write_cache_pages+0x394/0x830\n   do_writepages+0x1f0/0x5b0\n   filemap_fdatawrite_wbc+0x170/0x25c\n   file_write_and_wait_range+0x140/0x190\n   ubifs_fsync+0xe8/0x290\n   vfs_fsync_range+0xc0/0x1e4\n   do_fsync+0x40/0x90\n   __arm64_sys_fsync+0x34/0x50\n   invoke_syscall.constprop.0+0xa8/0x260\n   do_el0_svc+0xc8/0x1f0\n   el0_svc+0x34/0x70\n   el0t_64_sync_handler+0x108/0x114\n   el0t_64_sync+0x1a4/0x1a8\n\n  Freed by task 403:\n   kasan_save_stack+0x38/0x70\n   kasan_set_track+0x28/0x40\n   kasan_set_free_info+0x28/0x4c\n   __kasan_slab_free+0xd4/0x13c\n   kfree+0xc4/0x3a0\n   tnc_delete+0x3f4/0xe40\n   ubifs_tnc_remove_range+0x368/0x73c\n   ubifs_tnc_remove_ino+0x29c/0x2e0\n   ubifs_jnl_delete_inode+0x150/0x260\n   ubifs_evict_inode+0x1d4/0x2e4\n   evict+0x1c8/0x450\n   iput+0x2a0/0x3c4\n   do_unlinkat+0x2cc/0x490\n   __arm64_sys_unlinkat+0x90/0x100\n   invoke_syscall.constprop.0+0xa8/0x260\n   do_el0_svc+0xc8/0x1f0\n   el0_svc+0x34/0x70\n   el0t_64_sync_handler+0x108/0x114\n   el0t_64_sync+0x1a4/0x1a8\n\nThe offending `memcpy()` in `ubifs_copy_hash()` has a use-after-free\nwhen a node becomes root in TNC but still has a `cparent` to an already\nfreed node. More specifically, consider the following TNC:\n\n         zroot\n         /\n        /\n      zp1\n      /\n     /\n    zn\n\nInserting a new node `zn_new` with a key smaller then `zn` will trigger\na split in `tnc_insert()` if `zp1` is full:\n\n         zroot\n         /   \\\n        /     \\\n      zp1     zp2\n      /         \\\n     /           \\\n  zn_new          zn\n\n`zn->parent` has now been moved to `zp2`, *but* `zn->cparent` still\npoints to `zp1`.\n\nNow, consider a removal of all the nodes _except_ `zn`. Just when\n`tnc_delete()` is about to delete `zroot` and `zp2`:\n\n         zroot\n             \\\n              \\\n              zp2\n                \\\n                 \\\n                 zn\n\n`zroot` and `zp2` get freed and the tree collapses:\n\n           zn\n\n`zn` now becomes the new `zroot`.\n\n`get_znodes_to_commit()` will now only find `zn`, the new `zroot`, and\n`write_index()` will check its `znode->cparent` that wrongly points to\nthe already freed `zp1`. `ubifs_copy_hash()` thus gets wrongly called\nwith `znode->cparent->zbranch[znode->iip].hash` that triggers the\nuse-after-free!\n\nFix this by explicitly setting `znode->cparent` to `NULL` in\n`get_znodes_to_commit()` for the root node. The search for the dirty\nnodes\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53173",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFSv4.0: Fix a use-after-free problem in the asynchronous open()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSv4.0: Fix a use-after-free problem in the asynchronous open()\n\nYang Erkun reports that when two threads are opening files at the same\ntime, and are forced to abort before a reply is seen, then the call to\nnfs_release_seqid() in nfs4_opendata_free() can result in a\nuse-after-free of the pointer to the defunct rpc task of the other\nthread.\nThe fix is to ensure that if the RPC call is aborted before the call to\nnfs_wait_on_sequence() is complete, then we must call nfs_release_seqid()\nin nfs4_open_release() before the rpc_task is freed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53174",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: SUNRPC: make sure cache entry active before cache_show",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: make sure cache entry active before cache_show\n\nThe function `c_show` was called with protection from RCU. This only\nensures that `cp` will not be freed. Therefore, the reference count for\n`cp` can drop to zero, which will trigger a refcount use-after-free\nwarning when `cache_get` is called. To resolve this issue, use\n`cache_get_rcu` to ensure that `cp` remains active.\n\n------------[ cut here ]------------\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 7 PID: 822 at lib/refcount.c:25\nrefcount_warn_saturate+0xb1/0x120\nCPU: 7 UID: 0 PID: 822 Comm: cat Not tainted 6.12.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb1/0x120\n\nCall Trace:\n <TASK>\n c_show+0x2fc/0x380 [sunrpc]\n seq_read_iter+0x589/0x770\n seq_read+0x1e5/0x270\n proc_reg_read+0xe1/0x140\n vfs_read+0x125/0x530\n ksys_read+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53179",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix use-after-free of signing key",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free of signing key\n\nCustomers have reported use-after-free in @ses->auth_key.response with\nSMB2.1 + sign mounts which occurs due to following race:\n\ntask A                         task B\ncifs_mount()\n dfs_mount_share()\n  get_session()\n   cifs_mount_get_session()    cifs_send_recv()\n    cifs_get_smb_ses()          compound_send_recv()\n     cifs_setup_session()        smb2_setup_request()\n      kfree_sensitive()           smb2_calc_signature()\n                                   crypto_shash_setkey() *UAF*\n\nFix this by ensuring that we have a valid @ses->auth_key.response by\nchecking whether @ses->ses_status is SES_GOOD or SES_EXITING with\n@ses->ses_lock held.  After commit 24a9799aa8ef (\"smb: client: fix UAF\nin smb2_reconnect_server()\"), we made sure to call ->logoff() only\nwhen @ses was known to be good (e.g. valid ->auth_key.response), so\nit's safe to access signing key when @ses->ses_status == SES_EXITING.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53203",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: typec: fix potential array underflow in ucsi_ccg_sync_control()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: fix potential array underflow in ucsi_ccg_sync_control()\n\nThe \"command\" variable can be controlled by the user via debugfs.  The\nworry is that if con_index is zero then \"&uc->ucsi->connector[con_index\n- 1]\" would be an array underflow.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53214",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vfio/pci: Properly hide first-in-list PCIe extended capability",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvfio/pci: Properly hide first-in-list PCIe extended capability\n\nThere are cases where a PCIe extended capability should be hidden from\nthe user. For example, an unknown capability (i.e., capability with ID\ngreater than PCI_EXT_CAP_ID_MAX) or a capability that is intentionally\nchosen to be hidden from the user.\n\nHiding a capability is done by virtualizing and modifying the 'Next\nCapability Offset' field of the previous capability so it points to the\ncapability after the one that should be hidden.\n\nThe special case where the first capability in the list should be hidden\nis handled differently because there is no previous capability that can\nbe modified. In this case, the capability ID and version are zeroed\nwhile leaving the next pointer intact. This hides the capability and\nleaves an anchor for the rest of the capability list.\n\nHowever, today, hiding the first capability in the list is not done\nproperly if the capability is unknown, as struct\nvfio_pci_core_device->pci_config_map is set to the capability ID during\ninitialization but the capability ID is not properly checked later when\nused in vfio_config_do_rw(). This leads to the following warning [1] and\nto an out-of-bounds access to ecap_perms array.\n\nFix it by checking cap_id in vfio_config_do_rw(), and if it is greater\nthan PCI_EXT_CAP_ID_MAX, use an alternative struct perm_bits for direct\nread only access instead of the ecap_perms array.\n\nNote that this is safe since the above is the only case where cap_id can\nexceed PCI_EXT_CAP_ID_MAX (except for the special capabilities, which\nare already checked before).\n\n[1]\n\nWARNING: CPU: 118 PID: 5329 at drivers/vfio/pci/vfio_pci_config.c:1900 vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]\nCPU: 118 UID: 0 PID: 5329 Comm: simx-qemu-syste Not tainted 6.12.0+ #1\n(snip)\nCall Trace:\n <TASK>\n ? show_regs+0x69/0x80\n ? __warn+0x8d/0x140\n ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]\n ? report_bug+0x18f/0x1a0\n ? handle_bug+0x63/0xa0\n ? exc_invalid_op+0x19/0x70\n ? asm_exc_invalid_op+0x1b/0x20\n ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]\n ? vfio_pci_config_rw+0x244/0x430 [vfio_pci_core]\n vfio_pci_rw+0x101/0x1b0 [vfio_pci_core]\n vfio_pci_core_read+0x1d/0x30 [vfio_pci_core]\n vfio_device_fops_read+0x27/0x40 [vfio]\n vfs_read+0xbd/0x340\n ? vfio_device_fops_unl_ioctl+0xbb/0x740 [vfio]\n ? __rseq_handle_notify_resume+0xa4/0x4b0\n __x64_sys_pread64+0x96/0xc0\n x64_sys_call+0x1c3d/0x20d0\n do_syscall_64+0x4d/0x120\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53216",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfsd: release svc_expkey/svc_export with rcu_work",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: release svc_expkey/svc_export with rcu_work\n\nThe last reference for `cache_head` can be reduced to zero in `c_show`\nand `e_show`(using `rcu_read_lock` and `rcu_read_unlock`). Consequently,\n`svc_export_put` and `expkey_put` will be invoked, leading to two\nissues:\n\n1. The `svc_export_put` will directly free ex_uuid. However,\n   `e_show`/`c_show` will access `ex_uuid` after `cache_put`, which can\n   trigger a use-after-free issue, shown below.\n\n   ==================================================================\n   BUG: KASAN: slab-use-after-free in svc_export_show+0x362/0x430 [nfsd]\n   Read of size 1 at addr ff11000010fdc120 by task cat/870\n\n   CPU: 1 UID: 0 PID: 870 Comm: cat Not tainted 6.12.0-rc3+ #1\n   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n   1.16.1-2.fc37 04/01/2014\n   Call Trace:\n    <TASK>\n    dump_stack_lvl+0x53/0x70\n    print_address_description.constprop.0+0x2c/0x3a0\n    print_report+0xb9/0x280\n    kasan_report+0xae/0xe0\n    svc_export_show+0x362/0x430 [nfsd]\n    c_show+0x161/0x390 [sunrpc]\n    seq_read_iter+0x589/0x770\n    seq_read+0x1e5/0x270\n    proc_reg_read+0xe1/0x140\n    vfs_read+0x125/0x530\n    ksys_read+0xc1/0x160\n    do_syscall_64+0x5f/0x170\n    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n   Allocated by task 830:\n    kasan_save_stack+0x20/0x40\n    kasan_save_track+0x14/0x30\n    __kasan_kmalloc+0x8f/0xa0\n    __kmalloc_node_track_caller_noprof+0x1bc/0x400\n    kmemdup_noprof+0x22/0x50\n    svc_export_parse+0x8a9/0xb80 [nfsd]\n    cache_do_downcall+0x71/0xa0 [sunrpc]\n    cache_write_procfs+0x8e/0xd0 [sunrpc]\n    proc_reg_write+0xe1/0x140\n    vfs_write+0x1a5/0x6d0\n    ksys_write+0xc1/0x160\n    do_syscall_64+0x5f/0x170\n    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n   Freed by task 868:\n    kasan_save_stack+0x20/0x40\n    kasan_save_track+0x14/0x30\n    kasan_save_free_info+0x3b/0x60\n    __kasan_slab_free+0x37/0x50\n    kfree+0xf3/0x3e0\n    svc_export_put+0x87/0xb0 [nfsd]\n    cache_purge+0x17f/0x1f0 [sunrpc]\n    nfsd_destroy_serv+0x226/0x2d0 [nfsd]\n    nfsd_svc+0x125/0x1e0 [nfsd]\n    write_threads+0x16a/0x2a0 [nfsd]\n    nfsctl_transaction_write+0x74/0xa0 [nfsd]\n    vfs_write+0x1a5/0x6d0\n    ksys_write+0xc1/0x160\n    do_syscall_64+0x5f/0x170\n    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n2. We cannot sleep while using `rcu_read_lock`/`rcu_read_unlock`.\n   However, `svc_export_put`/`expkey_put` will call path_put, which\n   subsequently triggers a sleeping operation due to the following\n   `dput`.\n\n   =============================\n   WARNING: suspicious RCU usage\n   5.10.0-dirty #141 Not tainted\n   -----------------------------\n   ...\n   Call Trace:\n   dump_stack+0x9a/0xd0\n   ___might_sleep+0x231/0x240\n   dput+0x39/0x600\n   path_put+0x1b/0x30\n   svc_export_put+0x17/0x80\n   e_show+0x1c9/0x200\n   seq_read_iter+0x63f/0x7c0\n   seq_read+0x226/0x2d0\n   vfs_read+0x113/0x2c0\n   ksys_read+0xc9/0x170\n   do_syscall_64+0x33/0x40\n   entry_SYSCALL_64_after_hwframe+0x67/0xd1\n\nFix these issues by using `rcu_work` to help release\n`svc_expkey`/`svc_export`. This approach allows for an asynchronous\ncontext to invoke `path_put` and also facilitates the freeing of\n`uuid/exp/key` after an RCU grace period.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53218",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: f2fs: fix race in concurrent f2fs_stop_gc_thread",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix race in concurrent f2fs_stop_gc_thread\n\nIn my test case, concurrent calls to f2fs shutdown report the following\nstack trace:\n\n Oops: general protection fault, probably for non-canonical address 0xc6cfff63bb5513fc: 0000 [#1] PREEMPT SMP PTI\n CPU: 0 UID: 0 PID: 678 Comm: f2fs_rep_shutdo Not tainted 6.12.0-rc5-next-20241029-g6fb2fa9805c5-dirty #85\n Call Trace:\n  <TASK>\n  ? show_regs+0x8b/0xa0\n  ? __die_body+0x26/0xa0\n  ? die_addr+0x54/0x90\n  ? exc_general_protection+0x24b/0x5c0\n  ? asm_exc_general_protection+0x26/0x30\n  ? kthread_stop+0x46/0x390\n  f2fs_stop_gc_thread+0x6c/0x110\n  f2fs_do_shutdown+0x309/0x3a0\n  f2fs_ioc_shutdown+0x150/0x1c0\n  __f2fs_ioctl+0xffd/0x2ac0\n  f2fs_ioctl+0x76/0xe0\n  vfs_ioctl+0x23/0x60\n  __x64_sys_ioctl+0xce/0xf0\n  x64_sys_call+0x2b1b/0x4540\n  do_syscall_64+0xa7/0x240\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nThe root cause is a race condition in f2fs_stop_gc_thread() called from\ndifferent f2fs shutdown paths:\n\n  [CPU0]                       [CPU1]\n  ----------------------       -----------------------\n  f2fs_stop_gc_thread          f2fs_stop_gc_thread\n                                 gc_th = sbi->gc_thread\n    gc_th = sbi->gc_thread\n    kfree(gc_th)\n    sbi->gc_thread = NULL\n                                 < gc_th != NULL >\n                                 kthread_stop(gc_th->f2fs_gc_task) //UAF\n\nThe commit c7f114d864ac (\"f2fs: fix to avoid use-after-free in\nf2fs_stop_gc_thread()\") attempted to fix this issue by using a read\nsemaphore to prevent races between shutdown and remount threads, but\nit fails to prevent all race conditions.\n\nFix it by converting to write lock of s_umount in f2fs_do_shutdown().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53227",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: bfa: Fix use-after-free in bfad_im_module_exit()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: bfa: Fix use-after-free in bfad_im_module_exit()\n\nBUG: KASAN: slab-use-after-free in __lock_acquire+0x2aca/0x3a20\nRead of size 8 at addr ffff8881082d80c8 by task modprobe/25303\n\nCall Trace:\n <TASK>\n dump_stack_lvl+0x95/0xe0\n print_report+0xcb/0x620\n kasan_report+0xbd/0xf0\n __lock_acquire+0x2aca/0x3a20\n lock_acquire+0x19b/0x520\n _raw_spin_lock+0x2b/0x40\n attribute_container_unregister+0x30/0x160\n fc_release_transport+0x19/0x90 [scsi_transport_fc]\n bfad_im_module_exit+0x23/0x60 [bfa]\n bfad_init+0xdb/0xff0 [bfa]\n do_one_initcall+0xdc/0x550\n do_init_module+0x22d/0x6b0\n load_module+0x4e96/0x5ff0\n init_module_from_file+0xcd/0x130\n idempotent_init_module+0x330/0x620\n __x64_sys_finit_module+0xb3/0x110\n do_syscall_64+0xc1/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n </TASK>\n\nAllocated by task 25303:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x7f/0x90\n fc_attach_transport+0x4f/0x4740 [scsi_transport_fc]\n bfad_im_module_init+0x17/0x80 [bfa]\n bfad_init+0x23/0xff0 [bfa]\n do_one_initcall+0xdc/0x550\n do_init_module+0x22d/0x6b0\n load_module+0x4e96/0x5ff0\n init_module_from_file+0xcd/0x130\n idempotent_init_module+0x330/0x620\n __x64_sys_finit_module+0xb3/0x110\n do_syscall_64+0xc1/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 25303:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n __kasan_slab_free+0x38/0x50\n kfree+0x212/0x480\n bfad_im_module_init+0x7e/0x80 [bfa]\n bfad_init+0x23/0xff0 [bfa]\n do_one_initcall+0xdc/0x550\n do_init_module+0x22d/0x6b0\n load_module+0x4e96/0x5ff0\n init_module_from_file+0xcd/0x130\n idempotent_init_module+0x330/0x620\n __x64_sys_finit_module+0xb3/0x110\n do_syscall_64+0xc1/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nAbove issue happens as follows:\n\nbfad_init\n  error = bfad_im_module_init()\n    fc_release_transport(bfad_im_scsi_transport_template);\n  if (error)\n    goto ext;\n\next:\n  bfad_im_module_exit();\n    fc_release_transport(bfad_im_scsi_transport_template);\n    --> Trigger double release\n\nDon't call bfad_im_module_exit() if bfad_im_module_init() failed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53237",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: fix use-after-free in device_for_each_child()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: fix use-after-free in device_for_each_child()\n\nSyzbot has reported the following KASAN splat:\n\nBUG: KASAN: slab-use-after-free in device_for_each_child+0x18f/0x1a0\nRead of size 8 at addr ffff88801f605308 by task kbnepd bnep0/4980\n\nCPU: 0 UID: 0 PID: 4980 Comm: kbnepd bnep0 Not tainted 6.12.0-rc4-00161-gae90f6a6170d #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x100/0x190\n ? device_for_each_child+0x18f/0x1a0\n print_report+0x13a/0x4cb\n ? __virt_addr_valid+0x5e/0x590\n ? __phys_addr+0xc6/0x150\n ? device_for_each_child+0x18f/0x1a0\n kasan_report+0xda/0x110\n ? device_for_each_child+0x18f/0x1a0\n ? __pfx_dev_memalloc_noio+0x10/0x10\n device_for_each_child+0x18f/0x1a0\n ? __pfx_device_for_each_child+0x10/0x10\n pm_runtime_set_memalloc_noio+0xf2/0x180\n netdev_unregister_kobject+0x1ed/0x270\n unregister_netdevice_many_notify+0x123c/0x1d80\n ? __mutex_trylock_common+0xde/0x250\n ? __pfx_unregister_netdevice_many_notify+0x10/0x10\n ? trace_contention_end+0xe6/0x140\n ? __mutex_lock+0x4e7/0x8f0\n ? __pfx_lock_acquire.part.0+0x10/0x10\n ? rcu_is_watching+0x12/0xc0\n ? unregister_netdev+0x12/0x30\n unregister_netdevice_queue+0x30d/0x3f0\n ? __pfx_unregister_netdevice_queue+0x10/0x10\n ? __pfx_down_write+0x10/0x10\n unregister_netdev+0x1c/0x30\n bnep_session+0x1fb3/0x2ab0\n ? __pfx_bnep_session+0x10/0x10\n ? __pfx_lock_release+0x10/0x10\n ? __pfx_woken_wake_function+0x10/0x10\n ? __kthread_parkme+0x132/0x200\n ? __pfx_bnep_session+0x10/0x10\n ? kthread+0x13a/0x370\n ? __pfx_bnep_session+0x10/0x10\n kthread+0x2b7/0x370\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x48/0x80\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 4974:\n kasan_save_stack+0x30/0x50\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0xaa/0xb0\n __kmalloc_noprof+0x1d1/0x440\n hci_alloc_dev_priv+0x1d/0x2820\n __vhci_create_device+0xef/0x7d0\n vhci_write+0x2c7/0x480\n vfs_write+0x6a0/0xfc0\n ksys_write+0x12f/0x260\n do_syscall_64+0xc7/0x250\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 4979:\n kasan_save_stack+0x30/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n __kasan_slab_free+0x4f/0x70\n kfree+0x141/0x490\n hci_release_dev+0x4d9/0x600\n bt_host_release+0x6a/0xb0\n device_release+0xa4/0x240\n kobject_put+0x1ec/0x5a0\n put_device+0x1f/0x30\n vhci_release+0x81/0xf0\n __fput+0x3f6/0xb30\n task_work_run+0x151/0x250\n do_exit+0xa79/0x2c30\n do_group_exit+0xd5/0x2a0\n get_signal+0x1fcd/0x2210\n arch_do_signal_or_restart+0x93/0x780\n syscall_exit_to_user_mode+0x140/0x290\n do_syscall_64+0xd4/0x250\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-53239",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: 6fire: Release resources at card release",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: 6fire: Release resources at card release\n\nThe current 6fire code tries to release the resources right after the\ncall of usb6fire_chip_abort().  But at this moment, the card object\nmight be still in use (as we're calling snd_card_free_when_closed()).\n\nFor avoid potential UAFs, move the release of resources to the card's\nprivate_free instead of the manual call of usb6fire_chip_destroy() at\nthe USB disconnect callback.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56538",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm: zynqmp_kms: Unplug DRM device before removal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: zynqmp_kms: Unplug DRM device before removal\n\nPrevent userspace accesses to the DRM device from causing\nuse-after-frees by unplugging the device before we remove it. This\ncauses any further userspace accesses to result in an error without\nfurther calls into this driver's internals.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56548",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hfsplus: don't query the device logical block size multiple times",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: don't query the device logical block size multiple times\n\nDevices block sizes may change. One of these cases is a loop device by\nusing ioctl LOOP_SET_BLOCK_SIZE.\n\nWhile this may cause other issues like IO being rejected, in the case of\nhfsplus, it will allocate a block by using that size and potentially write\nout-of-bounds when hfsplus_read_wrapper calls hfsplus_submit_bio and the\nlatter function reads a different io_size.\n\nUsing a new min_io_size initally set to sb_min_blocksize works for the\npurposes of the original fix, since it will be set to the max between\nHFSPLUS_SECTOR_SIZE and the first seen logical block size. We still use the\nmax between HFSPLUS_SECTOR_SIZE and min_io_size in case the latter is not\ninitialized.\n\nTested by mounting an hfsplus filesystem with loop block sizes 512, 1024\nand 4096.\n\nThe produced KASAN report before the fix looks like this:\n\n[  419.944641] ==================================================================\n[  419.945655] BUG: KASAN: slab-use-after-free in hfsplus_read_wrapper+0x659/0xa0a\n[  419.946703] Read of size 2 at addr ffff88800721fc00 by task repro/10678\n[  419.947612]\n[  419.947846] CPU: 0 UID: 0 PID: 10678 Comm: repro Not tainted 6.12.0-rc5-00008-gdf56e0f2f3ca #84\n[  419.949007] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014\n[  419.950035] Call Trace:\n[  419.950384]  <TASK>\n[  419.950676]  dump_stack_lvl+0x57/0x78\n[  419.951212]  ? hfsplus_read_wrapper+0x659/0xa0a\n[  419.951830]  print_report+0x14c/0x49e\n[  419.952361]  ? __virt_addr_valid+0x267/0x278\n[  419.952979]  ? kmem_cache_debug_flags+0xc/0x1d\n[  419.953561]  ? hfsplus_read_wrapper+0x659/0xa0a\n[  419.954231]  kasan_report+0x89/0xb0\n[  419.954748]  ? hfsplus_read_wrapper+0x659/0xa0a\n[  419.955367]  hfsplus_read_wrapper+0x659/0xa0a\n[  419.955948]  ? __pfx_hfsplus_read_wrapper+0x10/0x10\n[  419.956618]  ? do_raw_spin_unlock+0x59/0x1a9\n[  419.957214]  ? _raw_spin_unlock+0x1a/0x2e\n[  419.957772]  hfsplus_fill_super+0x348/0x1590\n[  419.958355]  ? hlock_class+0x4c/0x109\n[  419.958867]  ? __pfx_hfsplus_fill_super+0x10/0x10\n[  419.959499]  ? __pfx_string+0x10/0x10\n[  419.960006]  ? lock_acquire+0x3e2/0x454\n[  419.960532]  ? bdev_name.constprop.0+0xce/0x243\n[  419.961129]  ? __pfx_bdev_name.constprop.0+0x10/0x10\n[  419.961799]  ? pointer+0x3f0/0x62f\n[  419.962277]  ? __pfx_pointer+0x10/0x10\n[  419.962761]  ? vsnprintf+0x6c4/0xfba\n[  419.963178]  ? __pfx_vsnprintf+0x10/0x10\n[  419.963621]  ? setup_bdev_super+0x376/0x3b3\n[  419.964029]  ? snprintf+0x9d/0xd2\n[  419.964344]  ? __pfx_snprintf+0x10/0x10\n[  419.964675]  ? lock_acquired+0x45c/0x5e9\n[  419.965016]  ? set_blocksize+0x139/0x1c1\n[  419.965381]  ? sb_set_blocksize+0x6d/0xae\n[  419.965742]  ? __pfx_hfsplus_fill_super+0x10/0x10\n[  419.966179]  mount_bdev+0x12f/0x1bf\n[  419.966512]  ? __pfx_mount_bdev+0x10/0x10\n[  419.966886]  ? vfs_parse_fs_string+0xce/0x111\n[  419.967293]  ? __pfx_vfs_parse_fs_string+0x10/0x10\n[  419.967702]  ? __pfx_hfsplus_mount+0x10/0x10\n[  419.968073]  legacy_get_tree+0x104/0x178\n[  419.968414]  vfs_get_tree+0x86/0x296\n[  419.968751]  path_mount+0xba3/0xd0b\n[  419.969157]  ? __pfx_path_mount+0x10/0x10\n[  419.969594]  ? kmem_cache_free+0x1e2/0x260\n[  419.970311]  do_mount+0x99/0xe0\n[  419.970630]  ? __pfx_do_mount+0x10/0x10\n[  419.971008]  __do_sys_mount+0x199/0x1c9\n[  419.971397]  do_syscall_64+0xd0/0x135\n[  419.971761]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  419.972233] RIP: 0033:0x7c3cb812972e\n[  419.972564] Code: 48 8b 0d f5 46 0d 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d c2 46 0d 00 f7 d8 64 89 01 48\n[  419.974371] RSP: 002b:00007ffe30632548 EFLAGS: 00000286 ORIG_RAX: 00000000000000a5\n[  419.975048] RAX: ffffffffffffffda RBX: 00007ffe306328d8 RCX: 00007c3cb812972e\n[  419.975701] RDX: 0000000020000000 RSI: 0000000020000c80 RDI:\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56551",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: fix usage slab after free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix usage slab after free\n\n[  +0.000021] BUG: KASAN: slab-use-after-free in drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000027] Read of size 8 at addr ffff8881b8605f88 by task amd_pci_unplug/2147\n\n[  +0.000023] CPU: 6 PID: 2147 Comm: amd_pci_unplug Not tainted 6.10.0+ #1\n[  +0.000016] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020\n[  +0.000016] Call Trace:\n[  +0.000008]  <TASK>\n[  +0.000009]  dump_stack_lvl+0x76/0xa0\n[  +0.000017]  print_report+0xce/0x5f0\n[  +0.000017]  ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000019]  ? srso_return_thunk+0x5/0x5f\n[  +0.000015]  ? kasan_complete_mode_report_info+0x72/0x200\n[  +0.000016]  ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000019]  kasan_report+0xbe/0x110\n[  +0.000015]  ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000023]  __asan_report_load8_noabort+0x14/0x30\n[  +0.000014]  drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000020]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? __kasan_check_write+0x14/0x30\n[  +0.000016]  ? __pfx_drm_sched_entity_flush+0x10/0x10 [gpu_sched]\n[  +0.000020]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? __kasan_check_write+0x14/0x30\n[  +0.000013]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? enable_work+0x124/0x220\n[  +0.000015]  ? __pfx_enable_work+0x10/0x10\n[  +0.000013]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? free_large_kmalloc+0x85/0xf0\n[  +0.000016]  drm_sched_entity_destroy+0x18/0x30 [gpu_sched]\n[  +0.000020]  amdgpu_vce_sw_fini+0x55/0x170 [amdgpu]\n[  +0.000735]  ? __kasan_check_read+0x11/0x20\n[  +0.000016]  vce_v4_0_sw_fini+0x80/0x110 [amdgpu]\n[  +0.000726]  amdgpu_device_fini_sw+0x331/0xfc0 [amdgpu]\n[  +0.000679]  ? mutex_unlock+0x80/0xe0\n[  +0.000017]  ? __pfx_amdgpu_device_fini_sw+0x10/0x10 [amdgpu]\n[  +0.000662]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? __kasan_check_write+0x14/0x30\n[  +0.000013]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? mutex_unlock+0x80/0xe0\n[  +0.000016]  amdgpu_driver_release_kms+0x16/0x80 [amdgpu]\n[  +0.000663]  drm_minor_release+0xc9/0x140 [drm]\n[  +0.000081]  drm_release+0x1fd/0x390 [drm]\n[  +0.000082]  __fput+0x36c/0xad0\n[  +0.000018]  __fput_sync+0x3c/0x50\n[  +0.000014]  __x64_sys_close+0x7d/0xe0\n[  +0.000014]  x64_sys_call+0x1bc6/0x2680\n[  +0.000014]  do_syscall_64+0x70/0x130\n[  +0.000014]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? irqentry_exit_to_user_mode+0x60/0x190\n[  +0.000015]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? irqentry_exit+0x43/0x50\n[  +0.000012]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? exc_page_fault+0x7c/0x110\n[  +0.000015]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  +0.000014] RIP: 0033:0x7ffff7b14f67\n[  +0.000013] Code: ff e8 0d 16 02 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 73 ba f7 ff\n[  +0.000026] RSP: 002b:00007fffffffe378 EFLAGS: 00000246 ORIG_RAX: 0000000000000003\n[  +0.000019] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffff7b14f67\n[  +0.000014] RDX: 0000000000000000 RSI: 00007ffff7f6f47a RDI: 0000000000000003\n[  +0.000014] RBP: 00007fffffffe3a0 R08: 0000555555569890 R09: 0000000000000000\n[  +0.000014] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fffffffe5c8\n[  +0.000013] R13: 00005555555552a9 R14: 0000555555557d48 R15: 00007ffff7ffd040\n[  +0.000020]  </TASK>\n\n[  +0.000016] Allocated by task 383 on cpu 7 at 26.880319s:\n[  +0.000014]  kasan_save_stack+0x28/0x60\n[  +0.000008]  kasan_save_track+0x18/0x70\n[  +0.000007]  kasan_save_alloc_info+0x38/0x60\n[  +0.000007]  __kasan_kmalloc+0xc1/0xd0\n[  +0.000007]  kmalloc_trace_noprof+0x180/0x380\n[  +0.000007]  drm_sched_init+0x411/0xec0 [gpu_sched]\n[  +0.000012]  amdgpu_device_init+0x695f/0xa610 [amdgpu]\n[  +0.000658]  amdgpu_driver_load_kms+0x1a/0x120 [amdgpu]\n[  +0.000662]  amdgpu_pci_p\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56558",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfsd: make sure exp active before svc_export_show",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: make sure exp active before svc_export_show\n\nThe function `e_show` was called with protection from RCU. This only\nensures that `exp` will not be freed. Therefore, the reference count for\n`exp` can drop to zero, which will trigger a refcount use-after-free\nwarning when `exp_get` is called. To resolve this issue, use\n`cache_get_rcu` to ensure that `exp` remains active.\n\n------------[ cut here ]------------\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 3 PID: 819 at lib/refcount.c:25\nrefcount_warn_saturate+0xb1/0x120\nCPU: 3 UID: 0 PID: 819 Comm: cat Not tainted 6.12.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb1/0x120\n...\nCall Trace:\n <TASK>\n e_show+0x20b/0x230 [nfsd]\n seq_read_iter+0x589/0x770\n seq_read+0x1e5/0x270\n vfs_read+0x125/0x530\n ksys_read+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56570",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ovl: Filter invalid inodes with missing lookup function",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\novl: Filter invalid inodes with missing lookup function\n\nAdd a check to the ovl_dentry_weird() function to prevent the\nprocessing of directory inodes that lack the lookup function.\nThis is important because such inodes can cause errors in overlayfs\nwhen passed to the lowerstack.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56581",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: ref-verify: fix use-after-free after invalid ref action",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: ref-verify: fix use-after-free after invalid ref action\n\nAt btrfs_ref_tree_mod() after we successfully inserted the new ref entry\n(local variable 'ref') into the respective block entry's rbtree (local\nvariable 'be'), if we find an unexpected action of BTRFS_DROP_DELAYED_REF,\nwe error out and free the ref entry without removing it from the block\nentry's rbtree. Then in the error path of btrfs_ref_tree_mod() we call\nbtrfs_free_ref_cache(), which iterates over all block entries and then\ncalls free_block_entry() for each one, and there we will trigger a\nuse-after-free when we are called against the block entry to which we\nadded the freed ref entry to its rbtree, since the rbtree still points\nto the block entry, as we didn't remove it from the rbtree before freeing\nit in the error path at btrfs_ref_tree_mod(). Fix this by removing the\nnew ref entry from the rbtree before freeing it.\n\nSyzbot report this with the following stack traces:\n\n   BTRFS error (device loop0 state EA):   Ref action 2, root 5, ref_root 0, parent 8564736, owner 0, offset 0, num_refs 18446744073709551615\n      __btrfs_mod_ref+0x7dd/0xac0 fs/btrfs/extent-tree.c:2523\n      update_ref_for_cow+0x9cd/0x11f0 fs/btrfs/ctree.c:512\n      btrfs_force_cow_block+0x9f6/0x1da0 fs/btrfs/ctree.c:594\n      btrfs_cow_block+0x35e/0xa40 fs/btrfs/ctree.c:754\n      btrfs_search_slot+0xbdd/0x30d0 fs/btrfs/ctree.c:2116\n      btrfs_insert_empty_items+0x9c/0x1a0 fs/btrfs/ctree.c:4314\n      btrfs_insert_empty_item fs/btrfs/ctree.h:669 [inline]\n      btrfs_insert_orphan_item+0x1f1/0x320 fs/btrfs/orphan.c:23\n      btrfs_orphan_add+0x6d/0x1a0 fs/btrfs/inode.c:3482\n      btrfs_unlink+0x267/0x350 fs/btrfs/inode.c:4293\n      vfs_unlink+0x365/0x650 fs/namei.c:4469\n      do_unlinkat+0x4ae/0x830 fs/namei.c:4533\n      __do_sys_unlinkat fs/namei.c:4576 [inline]\n      __se_sys_unlinkat fs/namei.c:4569 [inline]\n      __x64_sys_unlinkat+0xcc/0xf0 fs/namei.c:4569\n      do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n      do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n      entry_SYSCALL_64_after_hwframe+0x77/0x7f\n   BTRFS error (device loop0 state EA):   Ref action 1, root 5, ref_root 5, parent 0, owner 260, offset 0, num_refs 1\n      __btrfs_mod_ref+0x76b/0xac0 fs/btrfs/extent-tree.c:2521\n      update_ref_for_cow+0x96a/0x11f0\n      btrfs_force_cow_block+0x9f6/0x1da0 fs/btrfs/ctree.c:594\n      btrfs_cow_block+0x35e/0xa40 fs/btrfs/ctree.c:754\n      btrfs_search_slot+0xbdd/0x30d0 fs/btrfs/ctree.c:2116\n      btrfs_lookup_inode+0xdc/0x480 fs/btrfs/inode-item.c:411\n      __btrfs_update_delayed_inode+0x1e7/0xb90 fs/btrfs/delayed-inode.c:1030\n      btrfs_update_delayed_inode fs/btrfs/delayed-inode.c:1114 [inline]\n      __btrfs_commit_inode_delayed_items+0x2318/0x24a0 fs/btrfs/delayed-inode.c:1137\n      __btrfs_run_delayed_items+0x213/0x490 fs/btrfs/delayed-inode.c:1171\n      btrfs_commit_transaction+0x8a8/0x3740 fs/btrfs/transaction.c:2313\n      prepare_to_relocate+0x3c4/0x4c0 fs/btrfs/relocation.c:3586\n      relocate_block_group+0x16c/0xd40 fs/btrfs/relocation.c:3611\n      btrfs_relocate_block_group+0x77d/0xd90 fs/btrfs/relocation.c:4081\n      btrfs_relocate_chunk+0x12c/0x3b0 fs/btrfs/volumes.c:3377\n      __btrfs_balance+0x1b0f/0x26b0 fs/btrfs/volumes.c:4161\n      btrfs_balance+0xbdc/0x10c0 fs/btrfs/volumes.c:4538\n   BTRFS error (device loop0 state EA):   Ref action 2, root 5, ref_root 0, parent 8564736, owner 0, offset 0, num_refs 18446744073709551615\n      __btrfs_mod_ref+0x7dd/0xac0 fs/btrfs/extent-tree.c:2523\n      update_ref_for_cow+0x9cd/0x11f0 fs/btrfs/ctree.c:512\n      btrfs_force_cow_block+0x9f6/0x1da0 fs/btrfs/ctree.c:594\n      btrfs_cow_block+0x35e/0xa40 fs/btrfs/ctree.c:754\n      btrfs_search_slot+0xbdd/0x30d0 fs/btrfs/ctree.c:2116\n      btrfs_lookup_inode+0xdc/0x480 fs/btrfs/inode-item.c:411\n      __btrfs_update_delayed_inode+0x1e7/0xb90 fs/btrfs/delayed-inode.c:1030\n      btrfs_update_delayed_i\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56595",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: add a check to prevent array-index-out-of-bounds in dbAdjTree",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: add a check to prevent array-index-out-of-bounds in dbAdjTree\n\nWhen the value of lp is 0 at the beginning of the for loop, it will\nbecome negative in the next assignment and we should bail out.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56596",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix array-index-out-of-bounds in jfs_readdir",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds in jfs_readdir\n\nThe stbl might contain some invalid values. Added a check to\nreturn error code in that case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56597",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix shift-out-of-bounds in dbSplit",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix shift-out-of-bounds in dbSplit\n\nWhen dmt_budmin is less than zero, it causes errors\nin the later stages. Added a check to return an error beforehand\nin dbAllocCtl itself.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56598",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: array-index-out-of-bounds fix in dtReadFirst",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: array-index-out-of-bounds fix in dtReadFirst\n\nThe value of stbl can be sometimes out of bounds due\nto a bad filesystem. Added a check with appopriate return\nof error code in that case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56600",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: inet6: do not leave a dangling sk pointer in inet6_create()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: inet6: do not leave a dangling sk pointer in inet6_create()\n\nsock_init_data() attaches the allocated sk pointer to the provided sock\nobject. If inet6_create() fails later, the sk object is released, but the\nsock object retains the dangling sk pointer, which may cause use-after-free\nlater.\n\nClear the sock sk pointer on error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56601",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: inet: do not leave a dangling sk pointer in inet_create()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: inet: do not leave a dangling sk pointer in inet_create()\n\nsock_init_data() attaches the allocated sk object to the provided sock\nobject. If inet_create() fails later, the sk object is freed, but the\nsock object retains the dangling pointer, which may create use-after-free\nlater.\n\nClear the sk pointer in the sock object on error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56602",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: ieee802154: do not leave a dangling sk pointer in ieee802154_create()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ieee802154: do not leave a dangling sk pointer in ieee802154_create()\n\nsock_init_data() attaches the allocated sk object to the provided sock\nobject. If ieee802154_create() fails later, the allocated sk object is\nfreed, but the dangling pointer remains in the provided sock object, which\nmay allow use-after-free.\n\nClear the sk pointer in the sock object on error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56603",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: af_can: do not leave a dangling sk pointer in can_create()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: af_can: do not leave a dangling sk pointer in can_create()\n\nOn error can_create() frees the allocated sk object, but sock_init_data()\nhas already attached it to the provided sock object. This will leave a\ndangling sk pointer in the sock object and may cause use-after-free later.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56604",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc()\n\nbt_sock_alloc() attaches allocated sk object to the provided sock object.\nIf rfcomm_dlc_alloc() fails, we release the sk object, but leave the\ndangling pointer in the sock object, which may cause use-after-free.\n\nFix this by swapping calls to bt_sock_alloc() and rfcomm_dlc_alloc().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56605",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create()\n\nbt_sock_alloc() allocates the sk object and attaches it to the provided\nsock object. On error l2cap_sock_alloc() frees the sk object, but the\ndangling pointer is still attached to the sock object, which may create\nuse-after-free in other code.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56606",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: af_packet: avoid erroring out after sock_init_data() in packet_create()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_packet: avoid erroring out after sock_init_data() in packet_create()\n\nAfter sock_init_data() the allocated sk object is attached to the provided\nsock object. On error, packet_create() frees the sk object leaving the\ndangling pointer in the sock object on return. Some other code may try\nto use this pointer and cause use-after-free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56608",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix out-of-bounds access in 'dcn21_link_encoder_create'",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix out-of-bounds access in 'dcn21_link_encoder_create'\n\nAn issue was identified in the dcn21_link_encoder_create function where\nan out-of-bounds access could occur when the hpd_source index was used\nto reference the link_enc_hpd_regs array. This array has a fixed size\nand the index was not being checked against the array's bounds before\naccessing it.\n\nThis fix adds a conditional check to ensure that the hpd_source index is\nwithin the valid range of the link_enc_hpd_regs array. If the index is\nout of bounds, the function now returns NULL to prevent undefined\nbehavior.\n\nReferences:\n\n[   65.920507] ------------[ cut here ]------------\n[   65.920510] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn21/dcn21_resource.c:1312:29\n[   65.920519] index 7 is out of range for type 'dcn10_link_enc_hpd_registers [5]'\n[   65.920523] CPU: 3 PID: 1178 Comm: modprobe Tainted: G           OE      6.8.0-cleanershaderfeatureresetasdntipmi200nv2132 #13\n[   65.920525] Hardware name: AMD Majolica-RN/Majolica-RN, BIOS WMJ0429N_Weekly_20_04_2 04/29/2020\n[   65.920527] Call Trace:\n[   65.920529]  <TASK>\n[   65.920532]  dump_stack_lvl+0x48/0x70\n[   65.920541]  dump_stack+0x10/0x20\n[   65.920543]  __ubsan_handle_out_of_bounds+0xa2/0xe0\n[   65.920549]  dcn21_link_encoder_create+0xd9/0x140 [amdgpu]\n[   65.921009]  link_create+0x6d3/0xed0 [amdgpu]\n[   65.921355]  create_links+0x18a/0x4e0 [amdgpu]\n[   65.921679]  dc_create+0x360/0x720 [amdgpu]\n[   65.921999]  ? dmi_matches+0xa0/0x220\n[   65.922004]  amdgpu_dm_init+0x2b6/0x2c90 [amdgpu]\n[   65.922342]  ? console_unlock+0x77/0x120\n[   65.922348]  ? dev_printk_emit+0x86/0xb0\n[   65.922354]  dm_hw_init+0x15/0x40 [amdgpu]\n[   65.922686]  amdgpu_device_init+0x26a8/0x33a0 [amdgpu]\n[   65.922921]  amdgpu_driver_load_kms+0x1b/0xa0 [amdgpu]\n[   65.923087]  amdgpu_pci_probe+0x1b7/0x630 [amdgpu]\n[   65.923087]  local_pci_probe+0x4b/0xb0\n[   65.923087]  pci_device_probe+0xc8/0x280\n[   65.923087]  really_probe+0x187/0x300\n[   65.923087]  __driver_probe_device+0x85/0x130\n[   65.923087]  driver_probe_device+0x24/0x110\n[   65.923087]  __driver_attach+0xac/0x1d0\n[   65.923087]  ? __pfx___driver_attach+0x10/0x10\n[   65.923087]  bus_for_each_dev+0x7d/0xd0\n[   65.923087]  driver_attach+0x1e/0x30\n[   65.923087]  bus_add_driver+0xf2/0x200\n[   65.923087]  driver_register+0x64/0x130\n[   65.923087]  ? __pfx_amdgpu_init+0x10/0x10 [amdgpu]\n[   65.923087]  __pci_register_driver+0x61/0x70\n[   65.923087]  amdgpu_init+0x7d/0xff0 [amdgpu]\n[   65.923087]  do_one_initcall+0x49/0x310\n[   65.923087]  ? kmalloc_trace+0x136/0x360\n[   65.923087]  do_init_module+0x6a/0x270\n[   65.923087]  load_module+0x1fce/0x23a0\n[   65.923087]  init_module_from_file+0x9c/0xe0\n[   65.923087]  ? init_module_from_file+0x9c/0xe0\n[   65.923087]  idempotent_init_module+0x179/0x230\n[   65.923087]  __x64_sys_finit_module+0x5d/0xa0\n[   65.923087]  do_syscall_64+0x76/0x120\n[   65.923087]  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n[   65.923087] RIP: 0033:0x7f2d80f1e88d\n[   65.923087] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48\n[   65.923087] RSP: 002b:00007ffc7bc1aa78 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\n[   65.923087] RAX: ffffffffffffffda RBX: 0000564c9c1db130 RCX: 00007f2d80f1e88d\n[   65.923087] RDX: 0000000000000000 RSI: 0000564c9c1e5480 RDI: 000000000000000f\n[   65.923087] RBP: 0000000000040000 R08: 0000000000000000 R09: 0000000000000002\n[   65.923087] R10: 000000000000000f R11: 0000000000000246 R12: 0000564c9c1e5480\n[   65.923087] R13: 0000564c9c1db260 R14: 0000000000000000 R15: 0000564c9c1e54b0\n[   65.923087]  </TASK>\n[   65.923927] ---[ end trace ]---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56609",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: rtw88: use ieee80211_purge_tx_queue() to purge TX skb",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw88: use ieee80211_purge_tx_queue() to purge TX skb\n\nWhen removing kernel modules by:\n   rmmod rtw88_8723cs rtw88_8703b rtw88_8723x rtw88_sdio rtw88_core\n\nDriver uses skb_queue_purge() to purge TX skb, but not report tx status\ncausing \"Have pending ack frames!\" warning. Use ieee80211_purge_tx_queue()\nto correct this.\n\nSince ieee80211_purge_tx_queue() doesn't take locks, to prevent racing\nbetween TX work and purge TX queue, flush and destroy TX work in advance.\n\n   wlan0: deauthenticating from aa:f5:fd:60:4c:a8 by local\n     choice (Reason: 3=DEAUTH_LEAVING)\n   ------------[ cut here ]------------\n   Have pending ack frames!\n   WARNING: CPU: 3 PID: 9232 at net/mac80211/main.c:1691\n       ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n   CPU: 3 PID: 9232 Comm: rmmod Tainted: G         C\n       6.10.1-200.fc40.aarch64 #1\n   Hardware name: pine64 Pine64 PinePhone Braveheart\n      (1.1)/Pine64 PinePhone Braveheart (1.1), BIOS 2024.01 01/01/2024\n   pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n   pc : ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n   lr : ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n   sp : ffff80008c1b37b0\n   x29: ffff80008c1b37b0 x28: ffff000003be8000 x27: 0000000000000000\n   x26: 0000000000000000 x25: ffff000003dc14b8 x24: ffff80008c1b37d0\n   x23: ffff000000ff9f80 x22: 0000000000000000 x21: 000000007fffffff\n   x20: ffff80007c7e93d8 x19: ffff00006e66f400 x18: 0000000000000000\n   x17: ffff7ffffd2b3000 x16: ffff800083fc0000 x15: 0000000000000000\n   x14: 0000000000000000 x13: 2173656d61726620 x12: 6b636120676e6964\n   x11: 0000000000000000 x10: 000000000000005d x9 : ffff8000802af2b0\n   x8 : ffff80008c1b3430 x7 : 0000000000000001 x6 : 0000000000000001\n   x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n   x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000003be8000\n   Call trace:\n    ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n    idr_for_each+0x74/0x110\n    ieee80211_free_hw+0x44/0xe8 [mac80211]\n    rtw_sdio_remove+0x9c/0xc0 [rtw88_sdio]\n    sdio_bus_remove+0x44/0x180\n    device_remove+0x54/0x90\n    device_release_driver_internal+0x1d4/0x238\n    driver_detach+0x54/0xc0\n    bus_remove_driver+0x78/0x108\n    driver_unregister+0x38/0x78\n    sdio_unregister_driver+0x2c/0x40\n    rtw_8723cs_driver_exit+0x18/0x1000 [rtw88_8723cs]\n    __do_sys_delete_module.isra.0+0x190/0x338\n    __arm64_sys_delete_module+0x1c/0x30\n    invoke_syscall+0x74/0x100\n    el0_svc_common.constprop.0+0x48/0xf0\n    do_el0_svc+0x24/0x38\n    el0_svc+0x3c/0x158\n    el0t_64_sync_handler+0x120/0x138\n    el0t_64_sync+0x194/0x198\n   ---[ end trace 0000000000000000 ]---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56614",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: xsk: fix OOB map writes when deleting elements",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxsk: fix OOB map writes when deleting elements\n\nJordy says:\n\n\"\nIn the xsk_map_delete_elem function an unsigned integer\n(map->max_entries) is compared with a user-controlled signed integer\n(k). Due to implicit type conversion, a large unsigned value for\nmap->max_entries can bypass the intended bounds check:\n\n\tif (k >= map->max_entries)\n\t\treturn -EINVAL;\n\nThis allows k to hold a negative value (between -2147483648 and -2),\nwhich is then used as an array index in m->xsk_map[k], which results\nin an out-of-bounds access.\n\n\tspin_lock_bh(&m->lock);\n\tmap_entry = &m->xsk_map[k]; // Out-of-bounds map_entry\n\told_xs = unrcu_pointer(xchg(map_entry, NULL));  // Oob write\n\tif (old_xs)\n\t\txsk_map_sock_delete(old_xs, map_entry);\n\tspin_unlock_bh(&m->lock);\n\nThe xchg operation can then be used to cause an out-of-bounds write.\nMoreover, the invalid map_entry passed to xsk_map_sock_delete can lead\nto further memory corruption.\n\"\n\nIt indeed results in following splat:\n\n[76612.897343] BUG: unable to handle page fault for address: ffffc8fc2e461108\n[76612.904330] #PF: supervisor write access in kernel mode\n[76612.909639] #PF: error_code(0x0002) - not-present page\n[76612.914855] PGD 0 P4D 0\n[76612.917431] Oops: Oops: 0002 [#1] PREEMPT SMP\n[76612.921859] CPU: 11 UID: 0 PID: 10318 Comm: a.out Not tainted 6.12.0-rc1+ #470\n[76612.929189] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019\n[76612.939781] RIP: 0010:xsk_map_delete_elem+0x2d/0x60\n[76612.944738] Code: 00 00 41 54 55 53 48 63 2e 3b 6f 24 73 38 4c 8d a7 f8 00 00 00 48 89 fb 4c 89 e7 e8 2d bf 05 00 48 8d b4 eb 00 01 00 00 31 ff <48> 87 3e 48 85 ff 74 05 e8 16 ff ff ff 4c 89 e7 e8 3e bc 05 00 31\n[76612.963774] RSP: 0018:ffffc9002e407df8 EFLAGS: 00010246\n[76612.969079] RAX: 0000000000000000 RBX: ffffc9002e461000 RCX: 0000000000000000\n[76612.976323] RDX: 0000000000000001 RSI: ffffc8fc2e461108 RDI: 0000000000000000\n[76612.983569] RBP: ffffffff80000001 R08: 0000000000000000 R09: 0000000000000007\n[76612.990812] R10: ffffc9002e407e18 R11: ffff888108a38858 R12: ffffc9002e4610f8\n[76612.998060] R13: ffff888108a38858 R14: 00007ffd1ae0ac78 R15: ffffc9002e4610c0\n[76613.005303] FS:  00007f80b6f59740(0000) GS:ffff8897e0ec0000(0000) knlGS:0000000000000000\n[76613.013517] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[76613.019349] CR2: ffffc8fc2e461108 CR3: 000000011e3ef001 CR4: 00000000007726f0\n[76613.026595] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[76613.033841] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[76613.041086] PKRU: 55555554\n[76613.043842] Call Trace:\n[76613.046331]  <TASK>\n[76613.048468]  ? __die+0x20/0x60\n[76613.051581]  ? page_fault_oops+0x15a/0x450\n[76613.055747]  ? search_extable+0x22/0x30\n[76613.059649]  ? search_bpf_extables+0x5f/0x80\n[76613.063988]  ? exc_page_fault+0xa9/0x140\n[76613.067975]  ? asm_exc_page_fault+0x22/0x30\n[76613.072229]  ? xsk_map_delete_elem+0x2d/0x60\n[76613.076573]  ? xsk_map_delete_elem+0x23/0x60\n[76613.080914]  __sys_bpf+0x19b7/0x23c0\n[76613.084555]  __x64_sys_bpf+0x1a/0x20\n[76613.088194]  do_syscall_64+0x37/0xb0\n[76613.091832]  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n[76613.096962] RIP: 0033:0x7f80b6d1e88d\n[76613.100592] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48\n[76613.119631] RSP: 002b:00007ffd1ae0ac68 EFLAGS: 00000206 ORIG_RAX: 0000000000000141\n[76613.131330] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f80b6d1e88d\n[76613.142632] RDX: 0000000000000098 RSI: 00007ffd1ae0ad20 RDI: 0000000000000003\n[76613.153967] RBP: 00007ffd1ae0adc0 R08: 0000000000000000 R09: 0000000000000000\n[76613.166030] R10: 00007f80b6f77040 R11: 0000000000000206 R12: 00007ffd1ae0aed8\n[76613.177130] R13: 000055ddf42ce1e9 R14: 000055ddf42d0d98 R15: 00\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56615",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf: fix OOB devmap writes when deleting elements",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: fix OOB devmap writes when deleting elements\n\nJordy reported issue against XSKMAP which also applies to DEVMAP - the\nindex used for accessing map entry, due to being a signed integer,\ncauses the OOB writes. Fix is simple as changing the type from int to\nu32, however, when compared to XSKMAP case, one more thing needs to be\naddressed.\n\nWhen map is released from system via dev_map_free(), we iterate through\nall of the entries and an iterator variable is also an int, which\nimplies OOB accesses. Again, change it to be u32.\n\nExample splat below:\n\n[  160.724676] BUG: unable to handle page fault for address: ffffc8fc2c001000\n[  160.731662] #PF: supervisor read access in kernel mode\n[  160.736876] #PF: error_code(0x0000) - not-present page\n[  160.742095] PGD 0 P4D 0\n[  160.744678] Oops: Oops: 0000 [#1] PREEMPT SMP\n[  160.749106] CPU: 1 UID: 0 PID: 520 Comm: kworker/u145:12 Not tainted 6.12.0-rc1+ #487\n[  160.757050] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019\n[  160.767642] Workqueue: events_unbound bpf_map_free_deferred\n[  160.773308] RIP: 0010:dev_map_free+0x77/0x170\n[  160.777735] Code: 00 e8 fd 91 ed ff e8 b8 73 ed ff 41 83 7d 18 19 74 6e 41 8b 45 24 49 8b bd f8 00 00 00 31 db 85 c0 74 48 48 63 c3 48 8d 04 c7 <48> 8b 28 48 85 ed 74 30 48 8b 7d 18 48 85 ff 74 05 e8 b3 52 fa ff\n[  160.796777] RSP: 0018:ffffc9000ee1fe38 EFLAGS: 00010202\n[  160.802086] RAX: ffffc8fc2c001000 RBX: 0000000080000000 RCX: 0000000000000024\n[  160.809331] RDX: 0000000000000000 RSI: 0000000000000024 RDI: ffffc9002c001000\n[  160.816576] RBP: 0000000000000000 R08: 0000000000000023 R09: 0000000000000001\n[  160.823823] R10: 0000000000000001 R11: 00000000000ee6b2 R12: dead000000000122\n[  160.831066] R13: ffff88810c928e00 R14: ffff8881002df405 R15: 0000000000000000\n[  160.838310] FS:  0000000000000000(0000) GS:ffff8897e0c40000(0000) knlGS:0000000000000000\n[  160.846528] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  160.852357] CR2: ffffc8fc2c001000 CR3: 0000000005c32006 CR4: 00000000007726f0\n[  160.859604] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  160.866847] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  160.874092] PKRU: 55555554\n[  160.876847] Call Trace:\n[  160.879338]  <TASK>\n[  160.881477]  ? __die+0x20/0x60\n[  160.884586]  ? page_fault_oops+0x15a/0x450\n[  160.888746]  ? search_extable+0x22/0x30\n[  160.892647]  ? search_bpf_extables+0x5f/0x80\n[  160.896988]  ? exc_page_fault+0xa9/0x140\n[  160.900973]  ? asm_exc_page_fault+0x22/0x30\n[  160.905232]  ? dev_map_free+0x77/0x170\n[  160.909043]  ? dev_map_free+0x58/0x170\n[  160.912857]  bpf_map_free_deferred+0x51/0x90\n[  160.917196]  process_one_work+0x142/0x370\n[  160.921272]  worker_thread+0x29e/0x3b0\n[  160.925082]  ? rescuer_thread+0x4b0/0x4b0\n[  160.929157]  kthread+0xd4/0x110\n[  160.932355]  ? kthread_park+0x80/0x80\n[  160.936079]  ret_from_fork+0x2d/0x50\n[  160.943396]  ? kthread_park+0x80/0x80\n[  160.950803]  ret_from_fork_asm+0x11/0x20\n[  160.958482]  </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56616",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/dp_mst: Fix MST sideband message body length check",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/dp_mst: Fix MST sideband message body length check\n\nFix the MST sideband message body length check, which must be at least 1\nbyte accounting for the message body CRC (aka message data CRC) at the\nend of the message.\n\nThis fixes a case where an MST branch device returns a header with a\ncorrect header CRC (indicating a correctly received body length), with\nthe body length being incorrectly set to 0. This will later lead to a\nmemory corruption in drm_dp_sideband_append_payload() and the following\nerrors in dmesg:\n\n   UBSAN: array-index-out-of-bounds in drivers/gpu/drm/display/drm_dp_mst_topology.c:786:25\n   index -1 is out of range for type 'u8 [48]'\n   Call Trace:\n    drm_dp_sideband_append_payload+0x33d/0x350 [drm_display_helper]\n    drm_dp_get_one_sb_msg+0x3ce/0x5f0 [drm_display_helper]\n    drm_dp_mst_hpd_irq_handle_event+0xc8/0x1580 [drm_display_helper]\n\n   memcpy: detected field-spanning write (size 18446744073709551615) of single field \"&msg->msg[msg->curlen]\" at drivers/gpu/drm/display/drm_dp_mst_topology.c:791 (size 256)\n   Call Trace:\n    drm_dp_sideband_append_payload+0x324/0x350 [drm_display_helper]\n    drm_dp_get_one_sb_msg+0x3ce/0x5f0 [drm_display_helper]\n    drm_dp_mst_hpd_irq_handle_event+0xc8/0x1580 [drm_display_helper]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56619",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: fix potential out-of-bounds memory access in nilfs_find_entry()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix potential out-of-bounds memory access in nilfs_find_entry()\n\nSyzbot reported that when searching for records in a directory where the\ninode's i_size is corrupted and has a large value, memory access outside\nthe folio/page range may occur, or a use-after-free bug may be detected if\nKASAN is enabled.\n\nThis is because nilfs_last_byte(), which is called by nilfs_find_entry()\nand others to calculate the number of valid bytes of directory data in a\npage from i_size and the page index, loses the upper 32 bits of the 64-bit\nsize information due to an inappropriate type of local variable to which\nthe i_size value is assigned.\n\nThis caused a large byte offset value due to underflow in the end address\ncalculation in the calling nilfs_find_entry(), resulting in memory access\nthat exceeds the folio/page size.\n\nFix this issue by changing the type of the local variable causing the bit\nloss from \"unsigned int\" to \"u64\".  The return value of nilfs_last_byte()\nis also of type \"unsigned int\", but it is truncated so as not to exceed\nPAGE_SIZE and no bit loss occurs, so no change is required.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56631",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: sg: Fix slab-use-after-free read in sg_release()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: sg: Fix slab-use-after-free read in sg_release()\n\nFix a use-after-free bug in sg_release(), detected by syzbot with KASAN:\n\nBUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30\nkernel/locking/lockdep.c:5838\n__mutex_unlock_slowpath+0xe2/0x750 kernel/locking/mutex.c:912\nsg_release+0x1f4/0x2e0 drivers/scsi/sg.c:407\n\nIn sg_release(), the function kref_put(&sfp->f_ref, sg_remove_sfp) is\ncalled before releasing the open_rel_lock mutex. The kref_put() call may\ndecrement the reference count of sfp to zero, triggering its cleanup\nthrough sg_remove_sfp(). This cleanup includes scheduling deferred work\nvia sg_remove_sfp_usercontext(), which ultimately frees sfp.\n\nAfter kref_put(), sg_release() continues to unlock open_rel_lock and may\nreference sfp or sdp. If sfp has already been freed, this results in a\nslab-use-after-free error.\n\nMove the kref_put(&sfp->f_ref, sg_remove_sfp) call after unlocking the\nopen_rel_lock mutex. This ensures:\n\n - No references to sfp or sdp occur after the reference count is\n   decremented.\n\n - Cleanup functions such as sg_remove_sfp() and\n   sg_remove_sfp_usercontext() can safely execute without impacting the\n   mutex handling in sg_release().\n\nThe fix has been tested and validated by syzbot. This patch closes the\nbug reported at the following syzkaller link and ensures proper\nsequencing of resource cleanup and mutex operations, eliminating the\nrisk of use-after-free errors in sg_release().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56633",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcp_bpf: Fix the sk_mem_uncharge logic in tcp_bpf_sendmsg",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_bpf: Fix the sk_mem_uncharge logic in tcp_bpf_sendmsg\n\nThe current sk memory accounting logic in __SK_REDIRECT is pre-uncharging\ntosend bytes, which is either msg->sg.size or a smaller value apply_bytes.\n\nPotential problems with this strategy are as follows:\n\n- If the actual sent bytes are smaller than tosend, we need to charge some\n  bytes back, as in line 487, which is okay but seems not clean.\n\n- When tosend is set to apply_bytes, as in line 417, and (ret < 0), we may\n  miss uncharging (msg->sg.size - apply_bytes) bytes.\n\n[...]\n415 tosend = msg->sg.size;\n416 if (psock->apply_bytes && psock->apply_bytes < tosend)\n417   tosend = psock->apply_bytes;\n[...]\n443 sk_msg_return(sk, msg, tosend);\n444 release_sock(sk);\n446 origsize = msg->sg.size;\n447 ret = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,\n448                             msg, tosend, flags);\n449 sent = origsize - msg->sg.size;\n[...]\n454 lock_sock(sk);\n455 if (unlikely(ret < 0)) {\n456   int free = sk_msg_free_nocharge(sk, msg);\n458   if (!cork)\n459     *copied -= free;\n460 }\n[...]\n487 if (eval == __SK_REDIRECT)\n488   sk_mem_charge(sk, tosend - sent);\n[...]\n\nWhen running the selftest test_txmsg_redir_wait_sndmem with txmsg_apply,\nthe following warning will be reported:\n\n------------[ cut here ]------------\nWARNING: CPU: 6 PID: 57 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x190/0x1a0\nModules linked in:\nCPU: 6 UID: 0 PID: 57 Comm: kworker/6:0 Not tainted 6.12.0-rc1.bm.1-amd64+ #43\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nWorkqueue: events sk_psock_destroy\nRIP: 0010:inet_sock_destruct+0x190/0x1a0\nRSP: 0018:ffffad0a8021fe08 EFLAGS: 00010206\nRAX: 0000000000000011 RBX: ffff9aab4475b900 RCX: ffff9aab481a0800\nRDX: 0000000000000303 RSI: 0000000000000011 RDI: ffff9aab4475b900\nRBP: ffff9aab4475b990 R08: 0000000000000000 R09: ffff9aab40050ec0\nR10: 0000000000000000 R11: ffff9aae6fdb1d01 R12: ffff9aab49c60400\nR13: ffff9aab49c60598 R14: ffff9aab49c60598 R15: dead000000000100\nFS:  0000000000000000(0000) GS:ffff9aae6fd80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffec7e47bd8 CR3: 00000001a1a1c004 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n<TASK>\n? __warn+0x89/0x130\n? inet_sock_destruct+0x190/0x1a0\n? report_bug+0xfc/0x1e0\n? handle_bug+0x5c/0xa0\n? exc_invalid_op+0x17/0x70\n? asm_exc_invalid_op+0x1a/0x20\n? inet_sock_destruct+0x190/0x1a0\n__sk_destruct+0x25/0x220\nsk_psock_destroy+0x2b2/0x310\nprocess_scheduled_works+0xa3/0x3e0\nworker_thread+0x117/0x240\n? __pfx_worker_thread+0x10/0x10\nkthread+0xcf/0x100\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x31/0x40\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n</TASK>\n---[ end trace 0000000000000000 ]---\n\nIn __SK_REDIRECT, a more concise way is delaying the uncharging after sent\nbytes are finalized, and uncharge this value. When (ret < 0), we shall\ninvoke sk_msg_free.\n\nSame thing happens in case __SK_DROP, when tosend is set to apply_bytes,\nwe may miss uncharging (msg->sg.size - apply_bytes) bytes. The same\nwarning will be reported in selftest.\n\n[...]\n468 case __SK_DROP:\n469 default:\n470 sk_msg_free_partial(sk, msg, tosend);\n471 sk_msg_apply_bytes(psock, tosend);\n472 *copied -= (tosend + delta);\n473 return -EACCES;\n[...]\n\nSo instead of sk_msg_free_partial we can do sk_msg_free here.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56640",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/smc: fix LGR and link use-after-free issue",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix LGR and link use-after-free issue\n\nWe encountered a LGR/link use-after-free issue, which manifested as\nthe LGR/link refcnt reaching 0 early and entering the clear process,\nmaking resource access unsafe.\n\n refcount_t: addition on 0; use-after-free.\n WARNING: CPU: 14 PID: 107447 at lib/refcount.c:25 refcount_warn_saturate+0x9c/0x140\n Workqueue: events smc_lgr_terminate_work [smc]\n Call trace:\n  refcount_warn_saturate+0x9c/0x140\n  __smc_lgr_terminate.part.45+0x2a8/0x370 [smc]\n  smc_lgr_terminate_work+0x28/0x30 [smc]\n  process_one_work+0x1b8/0x420\n  worker_thread+0x158/0x510\n  kthread+0x114/0x118\n\nor\n\n refcount_t: underflow; use-after-free.\n WARNING: CPU: 6 PID: 93140 at lib/refcount.c:28 refcount_warn_saturate+0xf0/0x140\n Workqueue: smc_hs_wq smc_listen_work [smc]\n Call trace:\n  refcount_warn_saturate+0xf0/0x140\n  smcr_link_put+0x1cc/0x1d8 [smc]\n  smc_conn_free+0x110/0x1b0 [smc]\n  smc_conn_abort+0x50/0x60 [smc]\n  smc_listen_find_device+0x75c/0x790 [smc]\n  smc_listen_work+0x368/0x8a0 [smc]\n  process_one_work+0x1b8/0x420\n  worker_thread+0x158/0x510\n  kthread+0x114/0x118\n\nIt is caused by repeated release of LGR/link refcnt. One suspect is that\nsmc_conn_free() is called repeatedly because some smc_conn_free() from\nserver listening path are not protected by sock lock.\n\ne.g.\n\nCalls under socklock        | smc_listen_work\n-------------------------------------------------------\nlock_sock(sk)               | smc_conn_abort\nsmc_conn_free               | \\- smc_conn_free\n\\- smcr_link_put            |    \\- smcr_link_put (duplicated)\nrelease_sock(sk)\n\nSo here add sock lock protection in smc_listen_work() path, making it\nexclusive with other connection operations.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56642",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tipc: Fix use-after-free of kernel socket in cleanup_bearer().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Fix use-after-free of kernel socket in cleanup_bearer().\n\nsyzkaller reported a use-after-free of UDP kernel socket\nin cleanup_bearer() without repro. [0][1]\n\nWhen bearer_disable() calls tipc_udp_disable(), cleanup\nof the UDP kernel socket is deferred by work calling\ncleanup_bearer().\n\ntipc_exit_net() waits for such works to finish by checking\ntipc_net(net)->wq_count.  However, the work decrements the\ncount too early before releasing the kernel socket,\nunblocking cleanup_net() and resulting in use-after-free.\n\nLet's move the decrement after releasing the socket in\ncleanup_bearer().\n\n[0]:\nref_tracker: net notrefcnt@000000009b3d1faf has 1/1 users at\n     sk_alloc+0x438/0x608\n     inet_create+0x4c8/0xcb0\n     __sock_create+0x350/0x6b8\n     sock_create_kern+0x58/0x78\n     udp_sock_create4+0x68/0x398\n     udp_sock_create+0x88/0xc8\n     tipc_udp_enable+0x5e8/0x848\n     __tipc_nl_bearer_enable+0x84c/0xed8\n     tipc_nl_bearer_enable+0x38/0x60\n     genl_family_rcv_msg_doit+0x170/0x248\n     genl_rcv_msg+0x400/0x5b0\n     netlink_rcv_skb+0x1dc/0x398\n     genl_rcv+0x44/0x68\n     netlink_unicast+0x678/0x8b0\n     netlink_sendmsg+0x5e4/0x898\n     ____sys_sendmsg+0x500/0x830\n\n[1]:\nBUG: KMSAN: use-after-free in udp_hashslot include/net/udp.h:85 [inline]\nBUG: KMSAN: use-after-free in udp_lib_unhash+0x3b8/0x930 net/ipv4/udp.c:1979\n udp_hashslot include/net/udp.h:85 [inline]\n udp_lib_unhash+0x3b8/0x930 net/ipv4/udp.c:1979\n sk_common_release+0xaf/0x3f0 net/core/sock.c:3820\n inet_release+0x1e0/0x260 net/ipv4/af_inet.c:437\n inet6_release+0x6f/0xd0 net/ipv6/af_inet6.c:489\n __sock_release net/socket.c:658 [inline]\n sock_release+0xa0/0x210 net/socket.c:686\n cleanup_bearer+0x42d/0x4c0 net/tipc/udp_media.c:819\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xcaf/0x1c90 kernel/workqueue.c:3310\n worker_thread+0xf6c/0x1510 kernel/workqueue.c:3391\n kthread+0x531/0x6b0 kernel/kthread.c:389\n ret_from_fork+0x60/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:244\n\nUninit was created at:\n slab_free_hook mm/slub.c:2269 [inline]\n slab_free mm/slub.c:4580 [inline]\n kmem_cache_free+0x207/0xc40 mm/slub.c:4682\n net_free net/core/net_namespace.c:454 [inline]\n cleanup_net+0x16f2/0x19d0 net/core/net_namespace.c:647\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xcaf/0x1c90 kernel/workqueue.c:3310\n worker_thread+0xf6c/0x1510 kernel/workqueue.c:3391\n kthread+0x531/0x6b0 kernel/kthread.c:389\n ret_from_fork+0x60/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:244\n\nCPU: 0 UID: 0 PID: 54 Comm: kworker/0:2 Not tainted 6.12.0-rc1-00131-gf66ebf37d69c #7 91723d6f74857f70725e1583cba3cf4adc716cfa\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nWorkqueue: events cleanup_bearer",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56650",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: x_tables: fix LED ID check in led_tg_check()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: x_tables: fix LED ID check in led_tg_check()\n\nSyzbot has reported the following BUG detected by KASAN:\n\nBUG: KASAN: slab-out-of-bounds in strlen+0x58/0x70\nRead of size 1 at addr ffff8881022da0c8 by task repro/5879\n...\nCall Trace:\n <TASK>\n dump_stack_lvl+0x241/0x360\n ? __pfx_dump_stack_lvl+0x10/0x10\n ? __pfx__printk+0x10/0x10\n ? _printk+0xd5/0x120\n ? __virt_addr_valid+0x183/0x530\n ? __virt_addr_valid+0x183/0x530\n print_report+0x169/0x550\n ? __virt_addr_valid+0x183/0x530\n ? __virt_addr_valid+0x183/0x530\n ? __virt_addr_valid+0x45f/0x530\n ? __phys_addr+0xba/0x170\n ? strlen+0x58/0x70\n kasan_report+0x143/0x180\n ? strlen+0x58/0x70\n strlen+0x58/0x70\n kstrdup+0x20/0x80\n led_tg_check+0x18b/0x3c0\n xt_check_target+0x3bb/0xa40\n ? __pfx_xt_check_target+0x10/0x10\n ? stack_depot_save_flags+0x6e4/0x830\n ? nft_target_init+0x174/0xc30\n nft_target_init+0x82d/0xc30\n ? __pfx_nft_target_init+0x10/0x10\n ? nf_tables_newrule+0x1609/0x2980\n ? nf_tables_newrule+0x1609/0x2980\n ? rcu_is_watching+0x15/0xb0\n ? nf_tables_newrule+0x1609/0x2980\n ? nf_tables_newrule+0x1609/0x2980\n ? __kmalloc_noprof+0x21a/0x400\n nf_tables_newrule+0x1860/0x2980\n ? __pfx_nf_tables_newrule+0x10/0x10\n ? __nla_parse+0x40/0x60\n nfnetlink_rcv+0x14e5/0x2ab0\n ? __pfx_validate_chain+0x10/0x10\n ? __pfx_nfnetlink_rcv+0x10/0x10\n ? __lock_acquire+0x1384/0x2050\n ? netlink_deliver_tap+0x2e/0x1b0\n ? __pfx_lock_release+0x10/0x10\n ? netlink_deliver_tap+0x2e/0x1b0\n netlink_unicast+0x7f8/0x990\n ? __pfx_netlink_unicast+0x10/0x10\n ? __virt_addr_valid+0x183/0x530\n ? __check_object_size+0x48e/0x900\n netlink_sendmsg+0x8e4/0xcb0\n ? __pfx_netlink_sendmsg+0x10/0x10\n ? aa_sock_msg_perm+0x91/0x160\n ? __pfx_netlink_sendmsg+0x10/0x10\n __sock_sendmsg+0x223/0x270\n ____sys_sendmsg+0x52a/0x7e0\n ? __pfx_____sys_sendmsg+0x10/0x10\n __sys_sendmsg+0x292/0x380\n ? __pfx___sys_sendmsg+0x10/0x10\n ? lockdep_hardirqs_on_prepare+0x43d/0x780\n ? __pfx_lockdep_hardirqs_on_prepare+0x10/0x10\n ? exc_page_fault+0x590/0x8c0\n ? do_syscall_64+0xb6/0x230\n do_syscall_64+0xf3/0x230\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n...\n </TASK>\n\nSince an invalid (without '\\0' byte at all) byte sequence may be passed\nfrom userspace, add an extra check to ensure that such a sequence is\nrejected as possible ID and so never passed to 'kstrdup()' and further.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56651",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: can: hi311x: hi3110_can_ist(): fix potential use-after-free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: hi311x: hi3110_can_ist(): fix potential use-after-free\n\nThe commit a22bd630cfff (\"can: hi311x: do not report txerr and rxerr\nduring bus-off\") removed the reporting of rxerr and txerr even in case\nof correct operation (i. e. not bus-off).\n\nThe error count information added to the CAN frame after netif_rx() is\na potential use after free, since there is no guarantee that the skb\nis in the same state. It might be freed or reused.\n\nFix the issue by postponing the netif_rx() call in case of txerr and\nrxerr reporting.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56658",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: defer final 'struct net' free in netns dismantle",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: defer final 'struct net' free in netns dismantle\n\nIlya reported a slab-use-after-free in dst_destroy [1]\n\nIssue is in xfrm6_net_init() and xfrm4_net_init() :\n\nThey copy xfrm[46]_dst_ops_template into net->xfrm.xfrm[46]_dst_ops.\n\nBut net structure might be freed before all the dst callbacks are\ncalled. So when dst_destroy() calls later :\n\nif (dst->ops->destroy)\n    dst->ops->destroy(dst);\n\ndst->ops points to the old net->xfrm.xfrm[46]_dst_ops, which has been freed.\n\nSee a relevant issue fixed in :\n\nac888d58869b (\"net: do not delay dst_entries_add() in dst_release()\")\n\nA fix is to queue the 'struct net' to be freed after one\nanother cleanup_net() round (and existing rcu_barrier())\n\n[1]\n\nBUG: KASAN: slab-use-after-free in dst_destroy (net/core/dst.c:112)\nRead of size 8 at addr ffff8882137ccab0 by task swapper/37/0\nDec 03 05:46:18 kernel:\nCPU: 37 UID: 0 PID: 0 Comm: swapper/37 Kdump: loaded Not tainted 6.12.0 #67\nHardware name: Red Hat KVM/RHEL, BIOS 1.16.1-1.el9 04/01/2014\nCall Trace:\n <IRQ>\ndump_stack_lvl (lib/dump_stack.c:124)\nprint_address_description.constprop.0 (mm/kasan/report.c:378)\n? dst_destroy (net/core/dst.c:112)\nprint_report (mm/kasan/report.c:489)\n? dst_destroy (net/core/dst.c:112)\n? kasan_addr_to_slab (mm/kasan/common.c:37)\nkasan_report (mm/kasan/report.c:603)\n? dst_destroy (net/core/dst.c:112)\n? rcu_do_batch (kernel/rcu/tree.c:2567)\ndst_destroy (net/core/dst.c:112)\nrcu_do_batch (kernel/rcu/tree.c:2567)\n? __pfx_rcu_do_batch (kernel/rcu/tree.c:2491)\n? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4339 kernel/locking/lockdep.c:4406)\nrcu_core (kernel/rcu/tree.c:2825)\nhandle_softirqs (kernel/softirq.c:554)\n__irq_exit_rcu (kernel/softirq.c:589 kernel/softirq.c:428 kernel/softirq.c:637)\nirq_exit_rcu (kernel/softirq.c:651)\nsysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1049 arch/x86/kernel/apic/apic.c:1049)\n </IRQ>\n <TASK>\nasm_sysvec_apic_timer_interrupt (./arch/x86/include/asm/idtentry.h:702)\nRIP: 0010:default_idle (./arch/x86/include/asm/irqflags.h:37 ./arch/x86/include/asm/irqflags.h:92 arch/x86/kernel/process.c:743)\nCode: 00 4d 29 c8 4c 01 c7 4c 29 c2 e9 6e ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 90 0f 00 2d c7 c9 27 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90\nRSP: 0018:ffff888100d2fe00 EFLAGS: 00000246\nRAX: 00000000001870ed RBX: 1ffff110201a5fc2 RCX: ffffffffb61a3e46\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffb3d4d123\nRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed11c7e1835d\nR10: ffff888e3f0c1aeb R11: 0000000000000000 R12: 0000000000000000\nR13: ffff888100d20000 R14: dffffc0000000000 R15: 0000000000000000\n? ct_kernel_exit.constprop.0 (kernel/context_tracking.c:148)\n? cpuidle_idle_call (kernel/sched/idle.c:186)\ndefault_idle_call (./include/linux/cpuidle.h:143 kernel/sched/idle.c:118)\ncpuidle_idle_call (kernel/sched/idle.c:186)\n? __pfx_cpuidle_idle_call (kernel/sched/idle.c:168)\n? lock_release (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5848)\n? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4347 kernel/locking/lockdep.c:4406)\n? tsc_verify_tsc_adjust (arch/x86/kernel/tsc_sync.c:59)\ndo_idle (kernel/sched/idle.c:326)\ncpu_startup_entry (kernel/sched/idle.c:423 (discriminator 1))\nstart_secondary (arch/x86/kernel/smpboot.c:202 arch/x86/kernel/smpboot.c:282)\n? __pfx_start_secondary (arch/x86/kernel/smpboot.c:232)\n? soft_restart_cpu (arch/x86/kernel/head_64.S:452)\ncommon_startup_64 (arch/x86/kernel/head_64.S:414)\n </TASK>\nDec 03 05:46:18 kernel:\nAllocated by task 12184:\nkasan_save_stack (mm/kasan/common.c:48)\nkasan_save_track (./arch/x86/include/asm/current.h:49 mm/kasan/common.c:60 mm/kasan/common.c:69)\n__kasan_slab_alloc (mm/kasan/common.c:319 mm/kasan/common.c:345)\nkmem_cache_alloc_noprof (mm/slub.c:4085 mm/slub.c:4134 mm/slub.c:4141)\ncopy_net_ns (net/core/net_namespace.c:421 net/core/net_namespace.c:480)\ncreate_new_namespaces\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56664",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bpf, sockmap: Fix race between element replace and close()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Fix race between element replace and close()\n\nElement replace (with a socket different from the one stored) may race\nwith socket's close() link popping & unlinking. __sock_map_delete()\nunconditionally unrefs the (wrong) element:\n\n// set map[0] = s0\nmap_update_elem(map, 0, s0)\n\n// drop fd of s0\nclose(s0)\n  sock_map_close()\n    lock_sock(sk)               (s0!)\n    sock_map_remove_links(sk)\n      link = sk_psock_link_pop()\n      sock_map_unlink(sk, link)\n        sock_map_delete_from_link\n                                        // replace map[0] with s1\n                                        map_update_elem(map, 0, s1)\n                                          sock_map_update_elem\n                                (s1!)       lock_sock(sk)\n                                            sock_map_update_common\n                                              psock = sk_psock(sk)\n                                              spin_lock(&stab->lock)\n                                              osk = stab->sks[idx]\n                                              sock_map_add_link(..., &stab->sks[idx])\n                                              sock_map_unref(osk, &stab->sks[idx])\n                                                psock = sk_psock(osk)\n                                                sk_psock_put(sk, psock)\n                                                  if (refcount_dec_and_test(&psock))\n                                                    sk_psock_drop(sk, psock)\n                                              spin_unlock(&stab->lock)\n                                            unlock_sock(sk)\n          __sock_map_delete\n            spin_lock(&stab->lock)\n            sk = *psk                        // s1 replaced s0; sk == s1\n            if (!sk_test || sk_test == sk)   // sk_test (s0) != sk (s1); no branch\n              sk = xchg(psk, NULL)\n            if (sk)\n              sock_map_unref(sk, psk)        // unref s1; sks[idx] will dangle\n                psock = sk_psock(sk)\n                sk_psock_put(sk, psock)\n                  if (refcount_dec_and_test())\n                    sk_psock_drop(sk, psock)\n            spin_unlock(&stab->lock)\n    release_sock(sk)\n\nThen close(map) enqueues bpf_map_free_deferred, which finally calls\nsock_map_free(). This results in some refcount_t warnings along with\na KASAN splat [1].\n\nFix __sock_map_delete(), do not allow sock_map_unref() on elements that\nmay have been replaced.\n\n[1]:\nBUG: KASAN: slab-use-after-free in sock_map_free+0x10e/0x330\nWrite of size 4 at addr ffff88811f5b9100 by task kworker/u64:12/1063\n\nCPU: 14 UID: 0 PID: 1063 Comm: kworker/u64:12 Not tainted 6.12.0+ #125\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014\nWorkqueue: events_unbound bpf_map_free_deferred\nCall Trace:\n <TASK>\n dump_stack_lvl+0x68/0x90\n print_report+0x174/0x4f6\n kasan_report+0xb9/0x190\n kasan_check_range+0x10f/0x1e0\n sock_map_free+0x10e/0x330\n bpf_map_free_deferred+0x173/0x320\n process_one_work+0x846/0x1420\n worker_thread+0x5b3/0xf80\n kthread+0x29e/0x360\n ret_from_fork+0x2d/0x70\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 1202:\n kasan_save_stack+0x1e/0x40\n kasan_save_track+0x10/0x30\n __kasan_slab_alloc+0x85/0x90\n kmem_cache_alloc_noprof+0x131/0x450\n sk_prot_alloc+0x5b/0x220\n sk_alloc+0x2c/0x870\n unix_create1+0x88/0x8a0\n unix_create+0xc5/0x180\n __sock_create+0x241/0x650\n __sys_socketpair+0x1ce/0x420\n __x64_sys_socketpair+0x92/0x100\n do_syscall_64+0x93/0x180\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 46:\n kasan_save_stack+0x1e/0x40\n kasan_save_track+0x10/0x30\n kasan_save_free_info+0x37/0x60\n __kasan_slab_free+0x4b/0x70\n kmem_cache_free+0x1a1/0x590\n __sk_destruct+0x388/0x5a0\n sk_psock_destroy+0x73e/0xa50\n process_one_work+0x846/0x1420\n worker_thread+0x5b3/0xf80\n kthread+0x29e/0x360\n ret_from_fork+0x2d/0x70\n ret_from_fork_asm+0x1a/0x30\n\nThe bu\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56672",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: blk-cgroup: Fix UAF in blkcg_unpin_online()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-cgroup: Fix UAF in blkcg_unpin_online()\n\nblkcg_unpin_online() walks up the blkcg hierarchy putting the online pin. To\nwalk up, it uses blkcg_parent(blkcg) but it was calling that after\nblkcg_destroy_blkgs(blkcg) which could free the blkcg, leading to the\nfollowing UAF:\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in blkcg_unpin_online+0x15a/0x270\n  Read of size 8 at addr ffff8881057678c0 by task kworker/9:1/117\n\n  CPU: 9 UID: 0 PID: 117 Comm: kworker/9:1 Not tainted 6.13.0-rc1-work-00182-gb8f52214c61a-dirty #48\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS unknown 02/02/2022\n  Workqueue: cgwb_release cgwb_release_workfn\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x27/0x80\n   print_report+0x151/0x710\n   kasan_report+0xc0/0x100\n   blkcg_unpin_online+0x15a/0x270\n   cgwb_release_workfn+0x194/0x480\n   process_scheduled_works+0x71b/0xe20\n   worker_thread+0x82a/0xbd0\n   kthread+0x242/0x2c0\n   ret_from_fork+0x33/0x70\n   ret_from_fork_asm+0x1a/0x30\n   </TASK>\n  ...\n  Freed by task 1944:\n   kasan_save_track+0x2b/0x70\n   kasan_save_free_info+0x3c/0x50\n   __kasan_slab_free+0x33/0x50\n   kfree+0x10c/0x330\n   css_free_rwork_fn+0xe6/0xb30\n   process_scheduled_works+0x71b/0xe20\n   worker_thread+0x82a/0xbd0\n   kthread+0x242/0x2c0\n   ret_from_fork+0x33/0x70\n   ret_from_fork_asm+0x1a/0x30\n\nNote that the UAF is not easy to trigger as the free path is indirected\nbehind a couple RCU grace periods and a work item execution. I could only\ntrigger it with artifical msleep() injected in blkcg_unpin_online().\n\nFix it by reading the parent pointer before destroying the blkcg's blkg's.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56704",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: 9p/xen: fix release of IRQ",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\n9p/xen: fix release of IRQ\n\nKernel logs indicate an IRQ was double-freed.\n\nPass correct device ID during IRQ release.\n\n[Dominique: remove confusing variable reset to 0]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56759",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: fix use-after-free when COWing tree bock and tracing is enabled",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix use-after-free when COWing tree bock and tracing is enabled\n\nWhen a COWing a tree block, at btrfs_cow_block(), and we have the\ntracepoint trace_btrfs_cow_block() enabled and preemption is also enabled\n(CONFIG_PREEMPT=y), we can trigger a use-after-free in the COWed extent\nbuffer while inside the tracepoint code. This is because in some paths\nthat call btrfs_cow_block(), such as btrfs_search_slot(), we are holding\nthe last reference on the extent buffer @buf so btrfs_force_cow_block()\ndrops the last reference on the @buf extent buffer when it calls\nfree_extent_buffer_stale(buf), which schedules the release of the extent\nbuffer with RCU. This means that if we are on a kernel with preemption,\nthe current task may be preempted before calling trace_btrfs_cow_block()\nand the extent buffer already released by the time trace_btrfs_cow_block()\nis called, resulting in a use-after-free.\n\nFix this by moving the trace_btrfs_cow_block() from btrfs_cow_block() to\nbtrfs_force_cow_block() before the COWed extent buffer is freed.\nThis also has a side effect of invoking the tracepoint in the tree defrag\ncode, at defrag.c:btrfs_realloc_node(), since btrfs_force_cow_block() is\ncalled there, but this is fine and it was actually missing there.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56766",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mtd: rawnand: fix double free in atmel_pmecc_create_user()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: rawnand: fix double free in atmel_pmecc_create_user()\n\nThe \"user\" pointer was converted from being allocated with kzalloc() to\nbeing allocated by devm_kzalloc().  Calling kfree(user) will lead to a\ndouble free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-56775",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix handling of plane refcount",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix handling of plane refcount\n\n[Why]\nThe mechanism to backup and restore plane states doesn't maintain\nrefcount, which can cause issues if the refcount of the plane changes\nin between backup and restore operations, such as memory leaks if the\nrefcount was supposed to go down, or double frees / invalid memory\naccesses if the refcount was supposed to go up.\n\n[How]\nCache and re-apply current refcount when restoring plane states.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57791",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/smc: check return value of sock_recvmsg when draining clc data",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: check return value of sock_recvmsg when draining clc data\n\nWhen receiving clc msg, the field length in smc_clc_msg_hdr indicates the\nlength of msg should be received from network and the value should not be\nfully trusted as it is from the network. Once the value of length exceeds\nthe value of buflen in function smc_clc_wait_msg it may run into deadloop\nwhen trying to drain the remaining data exceeding buflen.\n\nThis patch checks the return value of sock_recvmsg when draining data in\ncase of deadloop in draining.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57792",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: power: supply: gpio-charger: Fix set charge current limits",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npower: supply: gpio-charger: Fix set charge current limits\n\nFix set charge current limits for devices which allow to set the lowest\ncharge current limit to be greater zero. If requested charge current limit\nis below lowest limit, the index equals current_limit_map_size which leads\nto accessing memory beyond allocated memory.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57798",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req()\n\nWhile receiving an MST up request message from one thread in\ndrm_dp_mst_handle_up_req(), the MST topology could be removed from\nanother thread via drm_dp_mst_topology_mgr_set_mst(false), freeing\nmst_primary and setting drm_dp_mst_topology_mgr::mst_primary to NULL.\nThis could lead to a NULL deref/use-after-free of mst_primary in\ndrm_dp_mst_handle_up_req().\n\nAvoid the above by holding a reference for mst_primary in\ndrm_dp_mst_handle_up_req() while it's used.\n\nv2: Fix kfreeing the request if getting an mst_primary reference fails.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57838",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: s390/entry: Mark IRQ entries to fix stack depot warnings",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/entry: Mark IRQ entries to fix stack depot warnings\n\nThe stack depot filters out everything outside of the top interrupt\ncontext as an uninteresting or irrelevant part of the stack traces. This\nhelps with stack trace de-duplication, avoiding an explosion of saved\nstack traces that share the same IRQ context code path but originate\nfrom different randomly interrupted points, eventually exhausting the\nstack depot.\n\nFiltering uses in_irqentry_text() to identify functions within the\n.irqentry.text and .softirqentry.text sections, which then become the\nlast stack trace entries being saved.\n\nWhile __do_softirq() is placed into the .softirqentry.text section by\ncommon code, populating .irqentry.text is architecture-specific.\n\nCurrently, the .irqentry.text section on s390 is empty, which prevents\nstack depot filtering and de-duplication and could result in warnings\nlike:\n\nStack depot reached limit capacity\nWARNING: CPU: 0 PID: 286113 at lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8\n\nwith PREEMPT and KASAN enabled.\n\nFix this by moving the IO/EXT interrupt handlers from .kprobes.text into\nthe .irqentry.text section and updating the kprobes blacklist to include\nthe .irqentry.text section.\n\nThis is done only for asynchronous interrupts and explicitly not for\nprogram checks, which are synchronous and where the context beyond the\nprogram check is important to preserve. Despite machine checks being\nsomewhat in between, they are extremely rare, and preserving context\nwhen possible is also of value.\n\nSVCs and Restart Interrupts are not relevant, one being always at the\nboundary to user space and the other being a one-time thing.\n\nIRQ entries filtering is also optionally used in ftrace function graph,\nwhere the same logic applies.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57849",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: s390/cpum_sf: Handle CPU hotplug remove during sampling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/cpum_sf: Handle CPU hotplug remove during sampling\n\nCPU hotplug remove handling triggers the following function\ncall sequence:\n\n   CPUHP_AP_PERF_S390_SF_ONLINE  --> s390_pmu_sf_offline_cpu()\n   ...\n   CPUHP_AP_PERF_ONLINE          --> perf_event_exit_cpu()\n\nThe s390 CPUMF sampling CPU hotplug handler invokes:\n\n s390_pmu_sf_offline_cpu()\n +-->  cpusf_pmu_setup()\n       +--> setup_pmc_cpu()\n            +--> deallocate_buffers()\n\nThis function de-allocates all sampling data buffers (SDBs) allocated\nfor that CPU at event initialization. It also clears the\nPMU_F_RESERVED bit. The CPU is gone and can not be sampled.\n\nWith the event still being active on the removed CPU, the CPU event\nhotplug support in kernel performance subsystem triggers the\nfollowing function calls on the removed CPU:\n\n  perf_event_exit_cpu()\n  +--> perf_event_exit_cpu_context()\n       +--> __perf_event_exit_context()\n\t    +--> __perf_remove_from_context()\n\t         +--> event_sched_out()\n\t              +--> cpumsf_pmu_del()\n\t                   +--> cpumsf_pmu_stop()\n                                +--> hw_perf_event_update()\n\nto stop and remove the event. During removal of the event, the\nsampling device driver tries to read out the remaining samples from\nthe sample data buffers (SDBs). But they have already been freed\n(and may have been re-assigned). This may lead to a use after free\nsituation in which case the samples are most likely invalid. In the\nbest case the memory has not been reassigned and still contains\nvalid data.\n\nRemedy this situation and check if the CPU is still in reserved\nstate (bit PMU_F_RESERVED set). In this case the SDBs have not been\nreleased an contain valid data. This is always the case when\nthe event is removed (and no CPU hotplug off occured).\nIf the PMU_F_RESERVED bit is not set, the SDB buffers are gone.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57850",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jffs2: Prevent rtime decompress memory corruption",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njffs2: Prevent rtime decompress memory corruption\n\nThe rtime decompression routine does not fully check bounds during the\nentirety of the decompression pass and can corrupt memory outside the\ndecompression buffer if the compressed data is corrupted. This adds the\nrequired check to prevent this failure mode.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57876",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/dp_mst: Fix resetting msg rx state after topology removal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/dp_mst: Fix resetting msg rx state after topology removal\n\nIf the MST topology is removed during the reception of an MST down reply\nor MST up request sideband message, the\ndrm_dp_mst_topology_mgr::up_req_recv/down_rep_recv states could be reset\nfrom one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with\nthe reading/parsing of the message from another thread via\ndrm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is\npossible since the reader/parser doesn't hold any lock while accessing\nthe reception state. This in turn can lead to a memory corruption in the\nreader/parser as described by commit bd2fccac61b4 (\"drm/dp_mst: Fix MST\nsideband message body length check\").\n\nFix the above by resetting the message reception state if needed before\nreading/parsing a message. Another solution would be to hold the\ndrm_dp_mst_topology_mgr::lock for the whole duration of the message\nreception/parsing in drm_dp_mst_handle_down_rep() and\ndrm_dp_mst_handle_up_req(), however this would require a bigger change.\nSince the fix is also needed for stable, opting for the simpler solution\nin this patch.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57887",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm: adv7511: Fix use-after-free in adv7533_attach_dsi()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: adv7511: Fix use-after-free in adv7533_attach_dsi()\n\nThe host_node pointer was assigned and freed in adv7533_parse_dt(), and\nlater, adv7533_attach_dsi() uses the same. Fix this use-after-free issue\nby\u00a0dropping of_node_put() in adv7533_parse_dt() and calling of_node_put()\nin error path of probe() and also in the remove().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57892",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ocfs2: fix slab-use-after-free due to dangling pointer dqi_priv",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix slab-use-after-free due to dangling pointer dqi_priv\n\nWhen mounting ocfs2 and then remounting it as read-only, a\nslab-use-after-free occurs after the user uses a syscall to\nquota_getnextquota.  Specifically, sb_dqinfo(sb, type)->dqi_priv is the\ndangling pointer.\n\nDuring the remounting process, the pointer dqi_priv is freed but is never\nset as null leaving it to be accessed.  Additionally, the read-only option\nfor remounting sets the DQUOT_SUSPENDED flag instead of setting the\nDQUOT_USAGE_ENABLED flags.  Moreover, later in the process of getting the\nnext quota, the function ocfs2_get_next_id is called and only checks the\nquota usage flags and not the quota suspended flags.\n\nTo fix this, I set dqi_priv to null when it is freed after remounting with\nread-only and put a check for DQUOT_SUSPENDED in ocfs2_get_next_id.\n\n[akpm@linux-foundation.org: coding-style cleanups]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57896",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: flush delalloc workers queue before stopping cleaner kthread during unmount",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: flush delalloc workers queue before stopping cleaner kthread during unmount\n\nDuring the unmount path, at close_ctree(), we first stop the cleaner\nkthread, using kthread_stop() which frees the associated task_struct, and\nthen stop and destroy all the work queues. However after we stopped the\ncleaner we may still have a worker from the delalloc_workers queue running\ninode.c:submit_compressed_extents(), which calls btrfs_add_delayed_iput(),\nwhich in turn tries to wake up the cleaner kthread - which was already\ndestroyed before, resulting in a use-after-free on the task_struct.\n\nSyzbot reported this with the following stack traces:\n\n  BUG: KASAN: slab-use-after-free in __lock_acquire+0x78/0x2100 kernel/locking/lockdep.c:5089\n  Read of size 8 at addr ffff8880259d2818 by task kworker/u8:3/52\n\n  CPU: 1 UID: 0 PID: 52 Comm: kworker/u8:3 Not tainted 6.13.0-rc1-syzkaller-00002-gcdd30ebb1b9f #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n  Workqueue: btrfs-delalloc btrfs_work_helper\n  Call Trace:\n   <TASK>\n   __dump_stack lib/dump_stack.c:94 [inline]\n   dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n   print_address_description mm/kasan/report.c:378 [inline]\n   print_report+0x169/0x550 mm/kasan/report.c:489\n   kasan_report+0x143/0x180 mm/kasan/report.c:602\n   __lock_acquire+0x78/0x2100 kernel/locking/lockdep.c:5089\n   lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849\n   __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]\n   _raw_spin_lock_irqsave+0xd5/0x120 kernel/locking/spinlock.c:162\n   class_raw_spinlock_irqsave_constructor include/linux/spinlock.h:551 [inline]\n   try_to_wake_up+0xc2/0x1470 kernel/sched/core.c:4205\n   submit_compressed_extents+0xdf/0x16e0 fs/btrfs/inode.c:1615\n   run_ordered_work fs/btrfs/async-thread.c:288 [inline]\n   btrfs_work_helper+0x96f/0xc40 fs/btrfs/async-thread.c:324\n   process_one_work kernel/workqueue.c:3229 [inline]\n   process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n   worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n   kthread+0x2f0/0x390 kernel/kthread.c:389\n   ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n   ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n   </TASK>\n\n  Allocated by task 2:\n   kasan_save_stack mm/kasan/common.c:47 [inline]\n   kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n   unpoison_slab_object mm/kasan/common.c:319 [inline]\n   __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:345\n   kasan_slab_alloc include/linux/kasan.h:250 [inline]\n   slab_post_alloc_hook mm/slub.c:4104 [inline]\n   slab_alloc_node mm/slub.c:4153 [inline]\n   kmem_cache_alloc_node_noprof+0x1d9/0x380 mm/slub.c:4205\n   alloc_task_struct_node kernel/fork.c:180 [inline]\n   dup_task_struct+0x57/0x8c0 kernel/fork.c:1113\n   copy_process+0x5d1/0x3d50 kernel/fork.c:2225\n   kernel_clone+0x223/0x870 kernel/fork.c:2807\n   kernel_thread+0x1bc/0x240 kernel/fork.c:2869\n   create_kthread kernel/kthread.c:412 [inline]\n   kthreadd+0x60d/0x810 kernel/kthread.c:767\n   ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n   ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\n  Freed by task 24:\n   kasan_save_stack mm/kasan/common.c:47 [inline]\n   kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n   kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582\n   poison_slab_object mm/kasan/common.c:247 [inline]\n   __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264\n   kasan_slab_free include/linux/kasan.h:233 [inline]\n   slab_free_hook mm/slub.c:2338 [inline]\n   slab_free mm/slub.c:4598 [inline]\n   kmem_cache_free+0x195/0x410 mm/slub.c:4700\n   put_task_struct include/linux/sched/task.h:144 [inline]\n   delayed_put_task_struct+0x125/0x300 kernel/exit.c:227\n   rcu_do_batch kernel/rcu/tree.c:2567 [inline]\n   rcu_core+0xaaa/0x17a0 kernel/rcu/tree.c:2823\n   handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:554\n   run_ksoftirqd+0xca/0x130 kernel/softirq.c:943\n  \n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57899",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: mac80211: fix mbss changed flags corruption on 32 bit systems",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix mbss changed flags corruption on 32 bit systems\n\nOn 32-bit systems, the size of an unsigned long is 4 bytes,\nwhile a u64 is 8 bytes. Therefore, when using\nor_each_set_bit(bit, &bits, sizeof(changed) * BITS_PER_BYTE),\nthe code is incorrectly searching for a bit in a 32-bit\nvariable that is expected to be 64 bits in size,\nleading to incorrect bit finding.\n\nSolution: Ensure that the size of the bits variable is correctly\nadjusted for each architecture.\n\n Call Trace:\n  ? show_regs+0x54/0x58\n  ? __warn+0x6b/0xd4\n  ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211]\n  ? report_bug+0x113/0x150\n  ? exc_overflow+0x30/0x30\n  ? handle_bug+0x27/0x44\n  ? exc_invalid_op+0x18/0x50\n  ? handle_exception+0xf6/0xf6\n  ? exc_overflow+0x30/0x30\n  ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211]\n  ? exc_overflow+0x30/0x30\n  ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211]\n  ? ieee80211_mesh_work+0xff/0x260 [mac80211]\n  ? cfg80211_wiphy_work+0x72/0x98 [cfg80211]\n  ? process_one_work+0xf1/0x1fc\n  ? worker_thread+0x2c0/0x3b4\n  ? kthread+0xc7/0xf0\n  ? mod_delayed_work_on+0x4c/0x4c\n  ? kthread_complete_and_exit+0x14/0x14\n  ? ret_from_fork+0x24/0x38\n  ? kthread_complete_and_exit+0x14/0x14\n  ? ret_from_fork_asm+0xf/0x14\n  ? entry_INT80_32+0xf0/0xf0\n\n[restore no-op path for no changes]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57900",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ila: serialize calls to nf_register_net_hooks()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nila: serialize calls to nf_register_net_hooks()\n\nsyzbot found a race in ila_add_mapping() [1]\n\ncommit 031ae72825ce (\"ila: call nf_unregister_net_hooks() sooner\")\nattempted to fix a similar issue.\n\nLooking at the syzbot repro, we have concurrent ILA_CMD_ADD commands.\n\nAdd a mutex to make sure at most one thread is calling nf_register_net_hooks().\n\n[1]\n BUG: KASAN: slab-use-after-free in rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n BUG: KASAN: slab-use-after-free in __rhashtable_lookup.constprop.0+0x426/0x550 include/linux/rhashtable.h:604\nRead of size 4 at addr ffff888028f40008 by task dhcpcd/5501\n\nCPU: 1 UID: 0 PID: 5501 Comm: dhcpcd Not tainted 6.13.0-rc4-syzkaller-00054-gd6ef8b40d075 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nCall Trace:\n <IRQ>\n  __dump_stack lib/dump_stack.c:94 [inline]\n  dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n  print_address_description mm/kasan/report.c:378 [inline]\n  print_report+0xc3/0x620 mm/kasan/report.c:489\n  kasan_report+0xd9/0x110 mm/kasan/report.c:602\n  rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n  __rhashtable_lookup.constprop.0+0x426/0x550 include/linux/rhashtable.h:604\n  rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n  rhashtable_lookup_fast include/linux/rhashtable.h:672 [inline]\n  ila_lookup_wildcards net/ipv6/ila/ila_xlat.c:127 [inline]\n  ila_xlat_addr net/ipv6/ila/ila_xlat.c:652 [inline]\n  ila_nf_input+0x1ee/0x620 net/ipv6/ila/ila_xlat.c:185\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xbb/0x200 net/netfilter/core.c:626\n  nf_hook.constprop.0+0x42e/0x750 include/linux/netfilter.h:269\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0xa4/0x680 net/ipv6/ip6_input.c:309\n  __netif_receive_skb_one_core+0x12e/0x1e0 net/core/dev.c:5672\n  __netif_receive_skb+0x1d/0x160 net/core/dev.c:5785\n  process_backlog+0x443/0x15f0 net/core/dev.c:6117\n  __napi_poll.constprop.0+0xb7/0x550 net/core/dev.c:6883\n  napi_poll net/core/dev.c:6952 [inline]\n  net_rx_action+0xa94/0x1010 net/core/dev.c:7074\n  handle_softirqs+0x213/0x8f0 kernel/softirq.c:561\n  __do_softirq kernel/softirq.c:595 [inline]\n  invoke_softirq kernel/softirq.c:435 [inline]\n  __irq_exit_rcu+0x109/0x170 kernel/softirq.c:662\n  irq_exit_rcu+0x9/0x30 kernel/softirq.c:678\n  instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]\n  sysvec_apic_timer_interrupt+0xa4/0xc0 arch/x86/kernel/apic/apic.c:1049",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57904",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: adc: at91: call input_free_device() on allocated iio_dev",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: adc: at91: call input_free_device() on allocated iio_dev\n\nCurrent implementation of at91_ts_register() calls input_free_deivce()\non st->ts_input, however, the err label can be reached before the\nallocated iio_dev is stored to st->ts_input. Thus call\ninput_free_device() on input instead of st->ts_input.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57906",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: adc: ti-ads8688: fix information leak in triggered buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: adc: ti-ads8688: fix information leak in triggered buffer\n\nThe 'buffer' local array is used to push data to user space from a\ntriggered buffer, but it does not set values for inactive channels, as\nit only uses iio_for_each_active_channel() to assign new values.\n\nInitialize the array to zero before using it to avoid pushing\nuninitialized information to userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57907",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: adc: rockchip_saradc: fix information leak in triggered buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: adc: rockchip_saradc: fix information leak in triggered buffer\n\nThe 'data' local struct is used to push data to user space from a\ntriggered buffer, but it does not set values for inactive channels, as\nit only uses iio_for_each_active_channel() to assign new values.\n\nInitialize the struct to zero before using it to avoid pushing\nuninitialized information to userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57908",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: imu: kmx61: fix information leak in triggered buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: imu: kmx61: fix information leak in triggered buffer\n\nThe 'buffer' local array is used to push data to user space from a\ntriggered buffer, but it does not set values for inactive channels, as\nit only uses iio_for_each_active_channel() to assign new values.\n\nInitialize the array to zero before using it to avoid pushing\nuninitialized information to userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57910",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: light: vcnl4035: fix information leak in triggered buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: light: vcnl4035: fix information leak in triggered buffer\n\nThe 'buffer' local array is used to push data to userspace from a\ntriggered buffer, but it does not set an initial value for the single\ndata element, which is an u16 aligned to 8 bytes. That leaves at least\n4 bytes uninitialized even after writing an integer value with\nregmap_read().\n\nInitialize the array to zero before using it to avoid pushing\nuninitialized information to userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57911",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: dummy: iio_simply_dummy_buffer: fix information leak in triggered buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: dummy: iio_simply_dummy_buffer: fix information leak in triggered buffer\n\nThe 'data' array is allocated via kmalloc() and it is used to push data\nto user space from a triggered buffer, but it does not set values for\ninactive channels, as it only uses iio_for_each_active_channel()\nto assign new values.\n\nUse kzalloc for the memory allocation to avoid pushing uninitialized\ninformation to userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57912",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: pressure: zpa2326: fix information leak in triggered buffer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: pressure: zpa2326: fix information leak in triggered buffer\n\nThe 'sample' local struct is used to push data to user space from a\ntriggered buffer, but it has a hole between the temperature and the\ntimestamp (u32 pressure, u16 temperature, GAP, u64 timestamp).\nThis hole is never initialized.\n\nInitialize the struct to zero before using it to avoid pushing\nuninitialized information to userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57929",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dm array: fix releasing a faulty array block twice in dm_array_cursor_end",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm array: fix releasing a faulty array block twice in dm_array_cursor_end\n\nWhen dm_bm_read_lock() fails due to locking or checksum errors, it\nreleases the faulty block implicitly while leaving an invalid output\npointer behind. The caller of dm_bm_read_lock() should not operate on\nthis invalid dm_block pointer, or it will lead to undefined result.\nFor example, the dm_array_cursor incorrectly caches the invalid pointer\non reading a faulty array block, causing a double release in\ndm_array_cursor_end(), then hitting the BUG_ON in dm-bufio cache_put().\n\nReproduce steps:\n\n1. initialize a cache device\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc $262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\n2. wipe the second array block offline\n\ndmsteup remove cache cmeta cdata corig\nmapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\nablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\ndd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock\n\n3. try reopen the cache device\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc $262144\"\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\nKernel logs:\n\n(snip)\ndevice-mapper: array: array_block_check failed: blocknr 0 != wanted 10\ndevice-mapper: block manager: array validator check failed for block 10\ndevice-mapper: array: get_ablock failed\ndevice-mapper: cache metadata: dm_array_cursor_next for mapping failed\n------------[ cut here ]------------\nkernel BUG at drivers/md/dm-bufio.c:638!\n\nFix by setting the cached block pointer to NULL on errors.\n\nIn addition to the reproducer described above, this fix can be\nverified using the \"array_cursor/damaged\" test in dm-unit:\n  dm-unit run /pdata/array_cursor/damaged --kernel-dir <KERNEL_DIR>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57945",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: riscv: mm: Fix the out of bound issue of vmemmap address",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: mm: Fix the out of bound issue of vmemmap address\n\nIn sparse vmemmap model, the virtual address of vmemmap is calculated as:\n((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT)).\nAnd the struct page's va can be calculated with an offset:\n(vmemmap + (pfn)).\n\nHowever, when initializing struct pages, kernel actually starts from the\nfirst page from the same section that phys_ram_base belongs to. If the\nfirst page's physical address is not (phys_ram_base >> PAGE_SHIFT), then\nwe get an va below VMEMMAP_START when calculating va for it's struct page.\n\nFor example, if phys_ram_base starts from 0x82000000 with pfn 0x82000, the\nfirst page in the same section is actually pfn 0x80000. During\ninit_unavailable_range(), we will initialize struct page for pfn 0x80000\nwith virtual address ((struct page *)VMEMMAP_START - 0x2000), which is\nbelow VMEMMAP_START as well as PCI_IO_END.\n\nThis commit fixes this bug by introducing a new variable\n'vmemmap_start_pfn' which is aligned with memory section size and using\nit to calculate vmemmap address instead of phys_ram_base.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57951",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hrtimers: Handle CPU state correctly on hotplug",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhrtimers: Handle CPU state correctly on hotplug\n\nConsider a scenario where a CPU transitions from CPUHP_ONLINE to halfway\nthrough a CPU hotunplug down to CPUHP_HRTIMERS_PREPARE, and then back to\nCPUHP_ONLINE:\n\nSince hrtimers_prepare_cpu() does not run, cpu_base.hres_active remains set\nto 1 throughout. However, during a CPU unplug operation, the tick and the\nclockevents are shut down at CPUHP_AP_TICK_DYING. On return to the online\nstate, for instance CFS incorrectly assumes that the hrtick is already\nactive, and the chance of the clockevent device to transition to oneshot\nmode is also lost forever for the CPU, unless it goes back to a lower state\nthan CPUHP_HRTIMERS_PREPARE once.\n\nThis round-trip reveals another issue; cpu_base.online is not set to 1\nafter the transition, which appears as a WARN_ON_ONCE in enqueue_hrtimer().\n\nAside of that, the bulk of the per CPU state is not reset either, which\nmeans there are dangling pointers in the worst case.\n\nAddress this by adding a corresponding startup() callback, which resets the\nstale per CPU state and sets the online flag.\n\n[ tglx: Make the new callback unconditionally available, remove the online\n  \tmodification in the prepare() callback and clear the remaining\n  \tstate in the starting callback instead of the prepare callback ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57980",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: uvcvideo: Fix double free in error path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Fix double free in error path\n\nIf the uvc_status_init() function fails to allocate the int_urb, it will\nfree the dev->status pointer but doesn't reset the pointer to NULL. This\nresults in the kfree() call in uvc_status_cleanup() trying to\ndouble-free the memory. Fix it by resetting the dev->status pointer to\nNULL after freeing it.\n\nReviewed by: Ricardo Ribalda <ribalda@chromium.org>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57982",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: xfrm: state: fix out-of-bounds read during lookup",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: state: fix out-of-bounds read during lookup\n\nlookup and resize can run in parallel.\n\nThe xfrm_state_hash_generation seqlock ensures a retry, but the hash\nfunctions can observe a hmask value that is too large for the new hlist\narray.\n\nrehash does:\n  rcu_assign_pointer(net->xfrm.state_bydst, ndst) [..]\n  net->xfrm.state_hmask = nhashmask;\n\nWhile state lookup does:\n  h = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family);\n  hlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) {\n\nThis is only safe in case the update to state_bydst is larger than\nnet->xfrm.xfrm_state_hmask (or if the lookup function gets\nserialized via state spinlock again).\n\nFix this by prefetching state_hmask and the associated pointers.\nThe xfrm_state_hash_generation seqlock retry will ensure that the pointer\nand the hmask will be consistent.\n\nThe existing helpers, like xfrm_dst_hash(), are now unsafe for RCU side,\nadd lockdep assertions to document that they are only safe for insert\nside.\n\nxfrm_state_lookup_byaddr() uses the spinlock rather than RCU.\nAFAICS this is an oversight from back when state lookup was converted to\nRCU, this lock should be replaced with RCU in a future patch.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-57984",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i3c: dw: Fix use-after-free in dw_i3c_master driver due to race condition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni3c: dw: Fix use-after-free in dw_i3c_master driver due to race condition\n\nIn dw_i3c_common_probe, &master->hj_work is bound with\ndw_i3c_hj_work. And dw_i3c_master_irq_handler can call\ndw_i3c_master_irq_handle_ibis function to start the work.\n\nIf we remove the module which will call dw_i3c_common_remove to\nmake cleanup, it will free master->base through i3c_master_unregister\nwhile the work mentioned above will be used. The sequence of operations\nthat may lead to a UAF bug is as follows:\n\nCPU0                                      CPU1\n\n                                     | dw_i3c_hj_work\ndw_i3c_common_remove                 |\ni3c_master_unregister(&master->base) |\ndevice_unregister(&master->dev)      |\ndevice_release                       |\n//free master->base                  |\n                                     | i3c_master_do_daa(&master->base)\n                                     | //use master->base\n\nFix it by ensuring that the work is canceled before proceeding with\nthe cleanup in dw_i3c_common_remove.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58002",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: uvcvideo: Remove dangling pointers",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Remove dangling pointers\n\nWhen an async control is written, we copy a pointer to the file handle\nthat started the operation. That pointer will be used when the device is\ndone. Which could be anytime in the future.\n\nIf the user closes that file descriptor, its structure will be freed,\nand there will be one dangling pointer per pending async control, that\nthe driver will try to use.\n\nClean all the dangling pointers during release().\n\nTo avoid adding a performance penalty in the most common case (no async\noperation), a counter has been introduced with some logic to make sure\nthat it is properly handled.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58007",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: soc: qcom: socinfo: Avoid out of bounds read of serial number",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: socinfo: Avoid out of bounds read of serial number\n\nOn MSM8916 devices, the serial number exposed in sysfs is constant and does\nnot change across individual devices. It's always:\n\n  db410c:/sys/devices/soc0$ cat serial_number\n  2644893864\n\nThe firmware used on MSM8916 exposes SOCINFO_VERSION(0, 8), which does not\nhave support for the serial_num field in the socinfo struct. There is an\nexisting check to avoid exposing the serial number in that case, but it's\nnot correct: When checking the item_size returned by SMEM, we need to make\nsure the *end* of the serial_num is within bounds, instead of comparing\nwith the *start* offset. The serial_number currently exposed on MSM8916\ndevices is just an out of bounds read of whatever comes after the socinfo\nstruct in SMEM.\n\nFix this by changing offsetof() to offsetofend(), so that the size of the\nfield is also taken into account.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58014",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: brcmsmac: add gain range check to wlc_phy_iqcal_gainparams_nphy()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmsmac: add gain range check to wlc_phy_iqcal_gainparams_nphy()\n\nIn 'wlc_phy_iqcal_gainparams_nphy()', add gain range check to WARN()\ninstead of possible out-of-bounds 'tbl_iqcal_gainparams_nphy' access.\nCompile tested only.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58034",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: memory: tegra20-emc: fix an OF node reference bug in tegra_emc_find_node_by_ram_code()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemory: tegra20-emc: fix an OF node reference bug in tegra_emc_find_node_by_ram_code()\n\nAs of_find_node_by_name() release the reference of the argument device\nnode, tegra_emc_find_node_by_ram_code() releases some device nodes while\nstill in use, resulting in possible UAFs. According to the bindings and\nthe in-tree DTS files, the \"emc-tables\" node is always device's child\nnode with the property \"nvidia,use-ram-code\", and the \"lpddr2\" node is a\nchild of the \"emc-tables\" node. Thus utilize the\nfor_each_child_of_node() macro and of_get_child_by_name() instead of\nof_find_node_by_name() to simplify the code.\n\nThis bug was found by an experimental verification tool that I am\ndeveloping.\n\n[krzysztof: applied v1, adjust the commit msg to incorporate v2 parts]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58055",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: gadget: f_tcm: Don't free command immediately",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_tcm: Don't free command immediately\n\nDon't prematurely free the command. Wait for the status completion of\nthe sense status. It can be freed then. Otherwise we will double-free\nthe command.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58069",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: rtc: pcf85063: fix potential OOB write in PCF85063 NVMEM read",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrtc: pcf85063: fix potential OOB write in PCF85063 NVMEM read\n\nThe nvmem interface supports variable buffer sizes, while the regmap\ninterface operates with fixed-size storage. If an nvmem client uses a\nbuffer size less than 4 bytes, regmap_read will write out of bounds\nas it expects the buffer to point at an unsigned int.\n\nFix this by using an intermediary unsigned int to hold the value.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58093",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: PCI/ASPM: Fix link state exit during switch upstream function removal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/ASPM: Fix link state exit during switch upstream function removal\n\nBefore 456d8aa37d0f (\"PCI/ASPM: Disable ASPM on MFD function removal to\navoid use-after-free\"), we would free the ASPM link only after the last\nfunction on the bus pertaining to the given link was removed.\n\nThat was too late. If function 0 is removed before sibling function,\nlink->downstream would point to free'd memory after.\n\nAfter above change, we freed the ASPM parent link state upon any function\nremoval on the bus pertaining to a given link.\n\nThat is too early. If the link is to a PCIe switch with MFD on the upstream\nport, then removing functions other than 0 first would free a link which\nstill remains parent_link to the remaining downstream ports.\n\nThe resulting GPFs are especially frequent during hot-unplug, because\npciehp removes devices on the link bus in reverse order.\n\nOn that switch, function 0 is the virtual P2P bridge to the internal bus.\nFree exactly when function 0 is removed -- before the parent link is\nobsolete, but after all subordinate links are gone.\n\n[kwilczynski: commit log]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-58240",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tls: separate no-async decryption request handling from async",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntls: separate no-async decryption request handling from async\n\nIf we're not doing async, the handling is much simpler. There's no\nreference counting, we just need to wait for the completion to wake us\nup and return its result.\n\nWe should preferably also use a separate crypto_wait. I'm not seeing a\nUAF as I did in the past, I think aec7961916f3 (\"tls: fix race between\nasync notify and socket close\") took care of it.\n\nThis will make the next fix easier.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2024-8805",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "BlueZ HID over GATT Profile Improper Access Control Remote Code Execut ...",
      "description": "BlueZ HID over GATT Profile Improper Access Control Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of BlueZ. Authentication is not required to exploit this vulnerability.\n\nThe specific flaw exists within the implementation of the HID over GATT Profile. The issue results from the lack of authorization prior to allowing access to functionality. An attacker can leverage this vulnerability to execute code in the context of the current user. Was ZDI-CAN-25177.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21647",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sched: sch_cake: add bounds checks to host bulk flow fairness counts",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched: sch_cake: add bounds checks to host bulk flow fairness counts\n\nEven though we fixed a logic error in the commit cited below, syzbot\nstill managed to trigger an underflow of the per-host bulk flow\ncounters, leading to an out of bounds memory access.\n\nTo avoid any such logic errors causing out of bounds memory accesses,\nthis commit factors out all accesses to the per-host bulk flow counters\nto a series of helpers that perform bounds-checking before any\nincrements and decrements. This also has the benefit of improving\nreadability by moving the conditional checks for the flow mode into\nthese helpers, instead of having them spread out throughout the\ncode (which was the cause of the original logic error).\n\nAs part of this change, the flow quantum calculation is consolidated\ninto a helper function, which means that the dithering applied to the\nost load scaling is now applied both in the DRR rotation and when a\nsparse flow's quantum is first initiated. The only user-visible effect\nof this is that the maximum packet size that can be sent while a flow\nstays sparse will now vary with +/- one byte in some cases. This should\nnot make a noticeable difference in practice, and thus it's not worth\ncomplicating the code to preserve the old behaviour.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21687",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vfio/platform: check the bounds of read/write syscalls",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvfio/platform: check the bounds of read/write syscalls\n\ncount and offset are passed from user space and not checked, only\noffset is capped to 40 bits, which can be used to read/write out of\nbounds of the device.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21692",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: sched: fix ets qdisc OOB Indexing",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix ets qdisc OOB Indexing\n\nHaowei Yan <g1042620637@gmail.com> found that ets_class_from_arg() can\nindex an Out-Of-Bound class in ets_class_from_arg() when passed clid of\n0. The overflow may cause local privilege escalation.\n\n [   18.852298] ------------[ cut here ]------------\n [   18.853271] UBSAN: array-index-out-of-bounds in net/sched/sch_ets.c:93:20\n [   18.853743] index 18446744073709551615 is out of range for type 'ets_class [16]'\n [   18.854254] CPU: 0 UID: 0 PID: 1275 Comm: poc Not tainted 6.12.6-dirty #17\n [   18.854821] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n [   18.856532] Call Trace:\n [   18.857441]  <TASK>\n [   18.858227]  dump_stack_lvl+0xc2/0xf0\n [   18.859607]  dump_stack+0x10/0x20\n [   18.860908]  __ubsan_handle_out_of_bounds+0xa7/0xf0\n [   18.864022]  ets_class_change+0x3d6/0x3f0\n [   18.864322]  tc_ctl_tclass+0x251/0x910\n [   18.864587]  ? lock_acquire+0x5e/0x140\n [   18.865113]  ? __mutex_lock+0x9c/0xe70\n [   18.866009]  ? __mutex_lock+0xa34/0xe70\n [   18.866401]  rtnetlink_rcv_msg+0x170/0x6f0\n [   18.866806]  ? __lock_acquire+0x578/0xc10\n [   18.867184]  ? __pfx_rtnetlink_rcv_msg+0x10/0x10\n [   18.867503]  netlink_rcv_skb+0x59/0x110\n [   18.867776]  rtnetlink_rcv+0x15/0x30\n [   18.868159]  netlink_unicast+0x1c3/0x2b0\n [   18.868440]  netlink_sendmsg+0x239/0x4b0\n [   18.868721]  ____sys_sendmsg+0x3e2/0x410\n [   18.869012]  ___sys_sendmsg+0x88/0xe0\n [   18.869276]  ? rseq_ip_fixup+0x198/0x260\n [   18.869563]  ? rseq_update_cpu_node_id+0x10a/0x190\n [   18.869900]  ? trace_hardirqs_off+0x5a/0xd0\n [   18.870196]  ? syscall_exit_to_user_mode+0xcc/0x220\n [   18.870547]  ? do_syscall_64+0x93/0x150\n [   18.870821]  ? __memcg_slab_free_hook+0x69/0x290\n [   18.871157]  __sys_sendmsg+0x69/0xd0\n [   18.871416]  __x64_sys_sendmsg+0x1d/0x30\n [   18.871699]  x64_sys_call+0x9e2/0x2670\n [   18.871979]  do_syscall_64+0x87/0x150\n [   18.873280]  ? do_syscall_64+0x93/0x150\n [   18.874742]  ? lock_release+0x7b/0x160\n [   18.876157]  ? do_user_addr_fault+0x5ce/0x8f0\n [   18.877833]  ? irqentry_exit_to_user_mode+0xc2/0x210\n [   18.879608]  ? irqentry_exit+0x77/0xb0\n [   18.879808]  ? clear_bhb_loop+0x15/0x70\n [   18.880023]  ? clear_bhb_loop+0x15/0x70\n [   18.880223]  ? clear_bhb_loop+0x15/0x70\n [   18.880426]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n [   18.880683] RIP: 0033:0x44a957\n [   18.880851] Code: ff ff e8 fc 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 8974 24 10\n [   18.881766] RSP: 002b:00007ffcdd00fad8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n [   18.882149] RAX: ffffffffffffffda RBX: 00007ffcdd010db8 RCX: 000000000044a957\n [   18.882507] RDX: 0000000000000000 RSI: 00007ffcdd00fb70 RDI: 0000000000000003\n [   18.885037] RBP: 00007ffcdd010bc0 R08: 000000000703c770 R09: 000000000703c7c0\n [   18.887203] R10: 0000000000000080 R11: 0000000000000246 R12: 0000000000000001\n [   18.888026] R13: 00007ffcdd010da8 R14: 00000000004ca7d0 R15: 0000000000000001\n [   18.888395]  </TASK>\n [   18.888610] ---[ end trace ]---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21702",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pfifo_tail_enqueue: Drop new packet when sch->limit == 0",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npfifo_tail_enqueue: Drop new packet when sch->limit == 0\n\nExpected behaviour:\nIn case we reach scheduler's limit, pfifo_tail_enqueue() will drop a\npacket in scheduler's queue and decrease scheduler's qlen by one.\nThen, pfifo_tail_enqueue() enqueue new packet and increase\nscheduler's qlen by one. Finally, pfifo_tail_enqueue() return\n`NET_XMIT_CN` status code.\n\nWeird behaviour:\nIn case we set `sch->limit == 0` and trigger pfifo_tail_enqueue() on a\nscheduler that has no packet, the 'drop a packet' step will do nothing.\nThis means the scheduler's qlen still has value equal 0.\nThen, we continue to enqueue new packet and increase scheduler's qlen by\none. In summary, we can leverage pfifo_tail_enqueue() to increase qlen by\none and return `NET_XMIT_CN` status code.\n\nThe problem is:\nLet's say we have two qdiscs: Qdisc_A and Qdisc_B.\n - Qdisc_A's type must have '->graft()' function to create parent/child relationship.\n   Let's say Qdisc_A's type is `hfsc`. Enqueue packet to this qdisc will trigger `hfsc_enqueue`.\n - Qdisc_B's type is pfifo_head_drop. Enqueue packet to this qdisc will trigger `pfifo_tail_enqueue`.\n - Qdisc_B is configured to have `sch->limit == 0`.\n - Qdisc_A is configured to route the enqueued's packet to Qdisc_B.\n\nEnqueue packet through Qdisc_A will lead to:\n - hfsc_enqueue(Qdisc_A) -> pfifo_tail_enqueue(Qdisc_B)\n - Qdisc_B->q.qlen += 1\n - pfifo_tail_enqueue() return `NET_XMIT_CN`\n - hfsc_enqueue() check for `NET_XMIT_SUCCESS` and see `NET_XMIT_CN` => hfsc_enqueue() don't increase qlen of Qdisc_A.\n\nThe whole process lead to a situation where Qdisc_A->q.qlen == 0 and Qdisc_B->q.qlen == 1.\nReplace 'hfsc' with other type (for example: 'drr') still lead to the same problem.\nThis violate the design where parent's qlen should equal to the sum of its childrens'qlen.\n\nBug impact: This issue can be used for user->kernel privilege escalation when it is reachable.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21703",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.234-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netem: Update sch->q.qlen before qdisc_tree_reduce_backlog()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetem: Update sch->q.qlen before qdisc_tree_reduce_backlog()\n\nqdisc_tree_reduce_backlog() notifies parent qdisc only if child\nqdisc becomes empty, therefore we need to reduce the backlog of the\nchild qdisc before calling it. Otherwise it would miss the opportunity\nto call cops->qlen_notify(), in the case of DRR, it resulted in UAF\nsince DRR uses ->qlen_notify() to maintain its active list.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21704",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: cdc-acm: Check control transfer buffer size before access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdc-acm: Check control transfer buffer size before access\n\nIf the first fragment is shorter than struct usb_cdc_notification, we can't\ncalculate an expected_size. Log an error and discard the notification\ninstead of reading lengths from memory outside the received data, which can\nlead to memory corruption when the expected_size decreases between\nfragments, causing `expected_size - acm->nb_index` to wrap.\n\nThis issue has been present since the beginning of git history; however,\nit only leads to memory corruption since commit ea2583529cd1\n(\"cdc-acm: reassemble fragmented notifications\").\n\nA mitigating factor is that acm_ctrl_irq() can only execute after userspace\nhas opened /dev/ttyACM*; but if ModemManager is running, ModemManager will\ndo that automatically depending on the USB device's vendor/product IDs and\nits other interfaces.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21715",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: davicom: fix UAF in dm9000_drv_remove",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: davicom: fix UAF in dm9000_drv_remove\n\ndm is netdev private data and it cannot be\nused after free_netdev() call. Using dm after free_netdev()\ncan cause UAF bug. Fix it by moving free_netdev() at the end of the\nfunction.\n\nThis is similar to the issue fixed in commit\nad297cd2db89 (\"net: qcom/emac: fix UAF in emac_remove\").\n\nThis bug is detected by our static analysis tool.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21718",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: rose: fix timer races against user threads",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: rose: fix timer races against user threads\n\nRose timers only acquire the socket spinlock, without\nchecking if the socket is owned by one user thread.\n\nAdd a check and rearm the timers if needed.\n\nBUG: KASAN: slab-use-after-free in rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174\nRead of size 2 at addr ffff88802f09b82a by task swapper/0/0\n\nCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.13.0-rc5-syzkaller-00172-gd1bf27c4e176 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nCall Trace:\n <IRQ>\n  __dump_stack lib/dump_stack.c:94 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n  print_address_description mm/kasan/report.c:378 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:489\n  kasan_report+0x143/0x180 mm/kasan/report.c:602\n  rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174\n  call_timer_fn+0x187/0x650 kernel/time/timer.c:1793\n  expire_timers kernel/time/timer.c:1844 [inline]\n  __run_timers kernel/time/timer.c:2418 [inline]\n  __run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2430\n  run_timer_base kernel/time/timer.c:2439 [inline]\n  run_timer_softirq+0xb7/0x170 kernel/time/timer.c:2449\n  handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561\n  __do_softirq kernel/softirq.c:595 [inline]\n  invoke_softirq kernel/softirq.c:435 [inline]\n  __irq_exit_rcu+0xf7/0x220 kernel/softirq.c:662\n  irq_exit_rcu+0x9/0x30 kernel/softirq.c:678\n  instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]\n  sysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1049\n </IRQ>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21719",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipmr: do not call mr_mfc_uses_dev() for unres entries",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipmr: do not call mr_mfc_uses_dev() for unres entries\n\nsyzbot found that calling mr_mfc_uses_dev() for unres entries\nwould crash [1], because c->mfc_un.res.minvif / c->mfc_un.res.maxvif\nalias to \"struct sk_buff_head unresolved\", which contain two pointers.\n\nThis code never worked, lets remove it.\n\n[1]\nUnable to handle kernel paging request at virtual address ffff5fff2d536613\nKASAN: maybe wild-memory-access in range [0xfffefff96a9b3098-0xfffefff96a9b309f]\nModules linked in:\nCPU: 1 UID: 0 PID: 7321 Comm: syz.0.16 Not tainted 6.13.0-rc7-syzkaller-g1950a0af2d55 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline]\n pc : mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334\n lr : mr_mfc_uses_dev net/ipv4/ipmr_base.c:289 [inline]\n lr : mr_table_dump+0x694/0x8b0 net/ipv4/ipmr_base.c:334\nCall trace:\n  mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline] (P)\n  mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334 (P)\n  mr_rtm_dumproute+0x254/0x454 net/ipv4/ipmr_base.c:382\n  ipmr_rtm_dumproute+0x248/0x4b4 net/ipv4/ipmr.c:2648\n  rtnl_dump_all+0x2e4/0x4e8 net/core/rtnetlink.c:4327\n  rtnl_dumpit+0x98/0x1d0 net/core/rtnetlink.c:6791\n  netlink_dump+0x4f0/0xbc0 net/netlink/af_netlink.c:2317\n  netlink_recvmsg+0x56c/0xe64 net/netlink/af_netlink.c:1973\n  sock_recvmsg_nosec net/socket.c:1033 [inline]\n  sock_recvmsg net/socket.c:1055 [inline]\n  sock_read_iter+0x2d8/0x40c net/socket.c:1125\n  new_sync_read fs/read_write.c:484 [inline]\n  vfs_read+0x740/0x970 fs/read_write.c:565\n  ksys_read+0x15c/0x26c fs/read_write.c:708",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21726",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: padata: avoid UAF for reorder_work",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: avoid UAF for reorder_work\n\nAlthough the previous patch can avoid ps and ps UAF for _do_serial, it\ncan not avoid potential UAF issue for reorder_work. This issue can\nhappen just as below:\n\ncrypto_request\t\t\tcrypto_request\t\tcrypto_del_alg\npadata_do_serial\n  ...\n  padata_reorder\n    // processes all remaining\n    // requests then breaks\n    while (1) {\n      if (!padata)\n        break;\n      ...\n    }\n\n\t\t\t\tpadata_do_serial\n\t\t\t\t  // new request added\n\t\t\t\t  list_add\n    // sees the new request\n    queue_work(reorder_work)\n\t\t\t\t  padata_reorder\n\t\t\t\t    queue_work_on(squeue->work)\n...\n\n\t\t\t\t<kworker context>\n\t\t\t\tpadata_serial_worker\n\t\t\t\t// completes new request,\n\t\t\t\t// no more outstanding\n\t\t\t\t// requests\n\n\t\t\t\t\t\t\tcrypto_del_alg\n\t\t\t\t\t\t\t  // free pd\n\n<kworker context>\ninvoke_padata_reorder\n  // UAF of pd\n\nTo avoid UAF for 'reorder_work', get 'pd' ref before put 'reorder_work'\ninto the 'serial_wq' and put 'pd' ref until the 'serial_wq' finish.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21727",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: padata: fix UAF in padata_reorder",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: fix UAF in padata_reorder\n\nA bug was found when run ltp test:\n\nBUG: KASAN: slab-use-after-free in padata_find_next+0x29/0x1a0\nRead of size 4 at addr ffff88bbfe003524 by task kworker/u113:2/3039206\n\nCPU: 0 PID: 3039206 Comm: kworker/u113:2 Kdump: loaded Not tainted 6.6.0+\nWorkqueue: pdecrypt_parallel padata_parallel_worker\nCall Trace:\n<TASK>\ndump_stack_lvl+0x32/0x50\nprint_address_description.constprop.0+0x6b/0x3d0\nprint_report+0xdd/0x2c0\nkasan_report+0xa5/0xd0\npadata_find_next+0x29/0x1a0\npadata_reorder+0x131/0x220\npadata_parallel_worker+0x3d/0xc0\nprocess_one_work+0x2ec/0x5a0\n\nIf 'mdelay(10)' is added before calling 'padata_find_next' in the\n'padata_reorder' function, this issue could be reproduced easily with\nltp test (pcrypt_aead01).\n\nThis can be explained as bellow:\n\npcrypt_aead_encrypt\n...\npadata_do_parallel\nrefcount_inc(&pd->refcnt); // add refcnt\n...\npadata_do_serial\npadata_reorder // pd\nwhile (1) {\npadata_find_next(pd, true); // using pd\nqueue_work_on\n...\npadata_serial_worker\t\t\t\tcrypto_del_alg\npadata_put_pd_cnt // sub refcnt\n\t\t\t\t\t\tpadata_free_shell\n\t\t\t\t\t\tpadata_put_pd(ps->pd);\n\t\t\t\t\t\t// pd is freed\n// loop again, but pd is freed\n// call padata_find_next, UAF\n}\n\nIn the padata_reorder function, when it loops in 'while', if the alg is\ndeleted, the refcnt may be decreased to 0 before entering\n'padata_find_next', which leads to UAF.\n\nAs mentioned in [1], do_serial is supposed to be called with BHs disabled\nand always happen under RCU protection, to address this issue, add\nsynchronize_rcu() in 'padata_free_shell' wait for all _do_serial calls\nto finish.\n\n[1] https://lore.kernel.org/all/20221028160401.cccypv4euxikusiq@parnassus.localdomain/\n[2] https://lore.kernel.org/linux-kernel/jfjz5d7zwbytztackem7ibzalm5lnxldi2eofeiczqmqs2m7o6@fq426cwnjtkm/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21734",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: misc: fastrpc: Fix copy buffer page size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: fastrpc: Fix copy buffer page size\n\nFor non-registered buffer, fastrpc driver copies the buffer and\npass it to the remote subsystem. There is a problem with current\nimplementation of page size calculation which is not considering\nthe offset in the calculation. This might lead to passing of\nimproper and out-of-bounds page size which could result in\nmemory issue. Calculate page start and page end using the offset\nadjusted address instead of absolute address.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21735",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFC: nci: Add bounds checking in nci_hci_create_pipe()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFC: nci: Add bounds checking in nci_hci_create_pipe()\n\nThe \"pipe\" variable is a u8 which comes from the network.  If it's more\nthan 127, then it results in memory corruption in the caller,\nnci_hci_connect_gate().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21753",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: btrfs: fix use-after-free when attempting to join an aborted transaction",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix use-after-free when attempting to join an aborted transaction\n\nWhen we are trying to join the current transaction and if it's aborted,\nwe read its 'aborted' field after unlocking fs_info->trans_lock and\nwithout holding any extra reference count on it. This means that a\nconcurrent task that is aborting the transaction may free the transaction\nbefore we read its 'aborted' field, leading to a use-after-free.\n\nFix this by reading the 'aborted' field while holding fs_info->trans_lock\nsince any freeing task must first acquire that lock and set\nfs_info->running_transaction to NULL before freeing the transaction.\n\nThis was reported by syzbot and Dmitry with the following stack traces\nfrom KASAN:\n\n   ==================================================================\n   BUG: KASAN: slab-use-after-free in join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278\n   Read of size 4 at addr ffff888011839024 by task kworker/u4:9/1128\n\n   CPU: 0 UID: 0 PID: 1128 Comm: kworker/u4:9 Not tainted 6.13.0-rc7-syzkaller-00019-gc45323b7560e #0\n   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\n   Workqueue: events_unbound btrfs_async_reclaim_data_space\n   Call Trace:\n    <TASK>\n    __dump_stack lib/dump_stack.c:94 [inline]\n    dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n    print_address_description mm/kasan/report.c:378 [inline]\n    print_report+0x169/0x550 mm/kasan/report.c:489\n    kasan_report+0x143/0x180 mm/kasan/report.c:602\n    join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278\n    start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697\n    flush_space+0x448/0xcf0 fs/btrfs/space-info.c:803\n    btrfs_async_reclaim_data_space+0x159/0x510 fs/btrfs/space-info.c:1321\n    process_one_work kernel/workqueue.c:3236 [inline]\n    process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317\n    worker_thread+0x870/0xd30 kernel/workqueue.c:3398\n    kthread+0x2f0/0x390 kernel/kthread.c:389\n    ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n    ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n    </TASK>\n\n   Allocated by task 5315:\n    kasan_save_stack mm/kasan/common.c:47 [inline]\n    kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n    poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n    __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394\n    kasan_kmalloc include/linux/kasan.h:260 [inline]\n    __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329\n    kmalloc_noprof include/linux/slab.h:901 [inline]\n    join_transaction+0x144/0xda0 fs/btrfs/transaction.c:308\n    start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697\n    btrfs_create_common+0x1b2/0x2e0 fs/btrfs/inode.c:6572\n    lookup_open fs/namei.c:3649 [inline]\n    open_last_lookups fs/namei.c:3748 [inline]\n    path_openat+0x1c03/0x3590 fs/namei.c:3984\n    do_filp_open+0x27f/0x4e0 fs/namei.c:4014\n    do_sys_openat2+0x13e/0x1d0 fs/open.c:1402\n    do_sys_open fs/open.c:1417 [inline]\n    __do_sys_creat fs/open.c:1495 [inline]\n    __se_sys_creat fs/open.c:1489 [inline]\n    __x64_sys_creat+0x123/0x170 fs/open.c:1489\n    do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n    do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n    entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n   Freed by task 5336:\n    kasan_save_stack mm/kasan/common.c:47 [inline]\n    kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n    kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582\n    poison_slab_object mm/kasan/common.c:247 [inline]\n    __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264\n    kasan_slab_free include/linux/kasan.h:233 [inline]\n    slab_free_hook mm/slub.c:2353 [inline]\n    slab_free mm/slub.c:4613 [inline]\n    kfree+0x196/0x430 mm/slub.c:4761\n    cleanup_transaction fs/btrfs/transaction.c:2063 [inline]\n    btrfs_commit_transaction+0x2c97/0x3720 fs/btrfs/transaction.c:2598\n    insert_balance_item+0x1284/0x20b0 fs/btrfs/volumes.c:3757\n    btrfs_balance+0x992/\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21756",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vsock: Keep the binding until socket destruction",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: Keep the binding until socket destruction\n\nPreserve sockets bindings; this includes both resulting from an explicit\nbind() and those implicitly bound through autobind during connect().\n\nPrevents socket unbinding during a transport reassignment, which fixes a\nuse-after-free:\n\n    1. vsock_create() (refcnt=1) calls vsock_insert_unbound() (refcnt=2)\n    2. transport->release() calls vsock_remove_bound() without checking if\n       sk was bound and moved to bound list (refcnt=1)\n    3. vsock_bind() assumes sk is in unbound list and before\n       __vsock_insert_bound(vsock_bound_sockets()) calls\n       __vsock_remove_bound() which does:\n           list_del_init(&vsk->bound_table); // nop\n           sock_put(&vsk->sk);               // refcnt=0\n\nBUG: KASAN: slab-use-after-free in __vsock_bind+0x62e/0x730\nRead of size 4 at addr ffff88816b46a74c by task a.out/2057\n dump_stack_lvl+0x68/0x90\n print_report+0x174/0x4f6\n kasan_report+0xb9/0x190\n __vsock_bind+0x62e/0x730\n vsock_bind+0x97/0xe0\n __sys_bind+0x154/0x1f0\n __x64_sys_bind+0x6e/0xb0\n do_syscall_64+0x93/0x1b0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nAllocated by task 2057:\n kasan_save_stack+0x1e/0x40\n kasan_save_track+0x10/0x30\n __kasan_slab_alloc+0x85/0x90\n kmem_cache_alloc_noprof+0x131/0x450\n sk_prot_alloc+0x5b/0x220\n sk_alloc+0x2c/0x870\n __vsock_create.constprop.0+0x2e/0xb60\n vsock_create+0xe4/0x420\n __sock_create+0x241/0x650\n __sys_socket+0xf2/0x1a0\n __x64_sys_socket+0x6e/0xb0\n do_syscall_64+0x93/0x1b0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 2057:\n kasan_save_stack+0x1e/0x40\n kasan_save_track+0x10/0x30\n kasan_save_free_info+0x37/0x60\n __kasan_slab_free+0x4b/0x70\n kmem_cache_free+0x1a1/0x590\n __sk_destruct+0x388/0x5a0\n __vsock_bind+0x5e1/0x730\n vsock_bind+0x97/0xe0\n __sys_bind+0x154/0x1f0\n __x64_sys_bind+0x6e/0xb0\n do_syscall_64+0x93/0x1b0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 7 PID: 2057 at lib/refcount.c:25 refcount_warn_saturate+0xce/0x150\nRIP: 0010:refcount_warn_saturate+0xce/0x150\n __vsock_bind+0x66d/0x730\n vsock_bind+0x97/0xe0\n __sys_bind+0x154/0x1f0\n __x64_sys_bind+0x6e/0xb0\n do_syscall_64+0x93/0x1b0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 7 PID: 2057 at lib/refcount.c:28 refcount_warn_saturate+0xee/0x150\nRIP: 0010:refcount_warn_saturate+0xee/0x150\n vsock_remove_bound+0x187/0x1e0\n __vsock_release+0x383/0x4a0\n vsock_release+0x90/0x120\n __sock_release+0xa3/0x250\n sock_close+0x14/0x20\n __fput+0x359/0xa80\n task_work_run+0x107/0x1d0\n do_exit+0x847/0x2560\n do_group_exit+0xb8/0x250\n __x64_sys_exit_group+0x3a/0x50\n x64_sys_call+0xfec/0x14f0\n do_syscall_64+0x93/0x1b0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21761",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: openvswitch: use RCU protection in ovs_vport_cmd_fill_info()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nopenvswitch: use RCU protection in ovs_vport_cmd_fill_info()\n\novs_vport_cmd_fill_info() can be called without RTNL or RCU.\n\nUse RCU protection and dev_net_rcu() to avoid potential UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21762",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arp: use RCU protection in arp_xmit()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narp: use RCU protection in arp_xmit()\n\narp_xmit() can be called without RTNL or RCU protection.\n\nUse RCU protection to avoid potential UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21764",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ndisc: use RCU protection in ndisc_alloc_skb()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nndisc: use RCU protection in ndisc_alloc_skb()\n\nndisc_alloc_skb() can be called without RTNL or RCU being held.\n\nAdd RCU protection to avoid possible UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21772",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: partitions: mac: fix handling of bogus partition table",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npartitions: mac: fix handling of bogus partition table\n\nFix several issues in partition probing:\n\n - The bailout for a bad partoffset must use put_dev_sector(), since the\n   preceding read_part_sector() succeeded.\n - If the partition table claims a silly sector size like 0xfff bytes\n   (which results in partition table entries straddling sector boundaries),\n   bail out instead of accessing out-of-bounds memory.\n - We must not assume that the partition table contains proper NUL\n   termination - use strnlen() and strncmp() instead of strlen() and\n   strcmp().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21780",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table()\n\nIt malicious user provides a small pptable through sysfs and then\na bigger pptable, it may cause buffer overflow attack in function\nsmu_sys_set_pp_table().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21782",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: orangefs: fix a oob in orangefs_debug_write",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\norangefs: fix a oob in orangefs_debug_write\n\nI got a syzbot report: slab-out-of-bounds Read in\norangefs_debug_write... several people suggested fixes,\nI tested Al Viro's suggestion and made this patch.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21785",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arm64: cacheinfo: Avoid out-of-bounds write to cacheinfo array",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: cacheinfo: Avoid out-of-bounds write to cacheinfo array\n\nThe loop that detects/populates cache information already has a bounds\ncheck on the array size but does not account for cache levels with\nseparate data/instructions cache. Fix this by incrementing the index\nfor any populated leaf (instead of any populated level).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21791",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vrf: use RCU protection in l3mdev_l3_out()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvrf: use RCU protection in l3mdev_l3_out()\n\nl3mdev_l3_out() can be called without RCU being held:\n\nraw_sendmsg()\n ip_push_pending_frames()\n  ip_send_skb()\n   ip_local_out()\n    __ip_local_out()\n     l3mdev_ip_out()\n\nAdd rcu_read_lock() / rcu_read_unlock() pair to avoid\na potential UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21811",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nilfs2: protect access to buffers with no active references",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: protect access to buffers with no active references\n\nnilfs_lookup_dirty_data_buffers(), which iterates through the buffers\nattached to dirty data folios/pages, accesses the attached buffers without\nlocking the folios/pages.\n\nFor data cache, nilfs_clear_folio_dirty() may be called asynchronously\nwhen the file system degenerates to read only, so\nnilfs_lookup_dirty_data_buffers() still has the potential to cause use\nafter free issues when buffers lose the protection of their dirty state\nmidway due to this asynchronous clearing and are unintentionally freed by\ntry_to_free_buffers().\n\nEliminate this race issue by adjusting the lock section in this function.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21812",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ax25: rcu protect dev->ax25_ptr",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: rcu protect dev->ax25_ptr\n\nsyzbot found a lockdep issue [1].\n\nWe should remove ax25 RTNL dependency in ax25_setsockopt()\n\nThis should also fix a variety of possible UAF in ax25.\n\n[1]\n\nWARNING: possible circular locking dependency detected\n6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted\n------------------------------------------------------\nsyz.5.1818/12806 is trying to acquire lock:\n ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680\n\nbut task is already holding lock:\n ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]\n ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (sk_lock-AF_AX25){+.+.}-{0:0}:\n        lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849\n        lock_sock_nested+0x48/0x100 net/core/sock.c:3642\n        lock_sock include/net/sock.h:1618 [inline]\n        ax25_kill_by_device net/ax25/af_ax25.c:101 [inline]\n        ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146\n        notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85\n       __dev_notify_flags+0x207/0x400\n        dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026\n        dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563\n        dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820\n        sock_do_ioctl+0x240/0x460 net/socket.c:1234\n        sock_ioctl+0x626/0x8e0 net/socket.c:1339\n        vfs_ioctl fs/ioctl.c:51 [inline]\n        __do_sys_ioctl fs/ioctl.c:906 [inline]\n        __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892\n        do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n        do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n-> #0 (rtnl_mutex){+.+.}-{4:4}:\n        check_prev_add kernel/locking/lockdep.c:3161 [inline]\n        check_prevs_add kernel/locking/lockdep.c:3280 [inline]\n        validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904\n        __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226\n        lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849\n        __mutex_lock_common kernel/locking/mutex.c:585 [inline]\n        __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735\n        ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680\n        do_sock_setsockopt+0x3af/0x720 net/socket.c:2324\n        __sys_setsockopt net/socket.c:2349 [inline]\n        __do_sys_setsockopt net/socket.c:2355 [inline]\n        __se_sys_setsockopt net/socket.c:2352 [inline]\n        __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352\n        do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n        do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(sk_lock-AF_AX25);\n                               lock(rtnl_mutex);\n                               lock(sk_lock-AF_AX25);\n  lock(rtnl_mutex);\n\n *** DEADLOCK ***\n\n1 lock held by syz.5.1818/12806:\n  #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline]\n  #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574\n\nstack backtrace:\nCPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:94 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n  print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074\n  check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206\n  check_prev_add kernel/locking/lockdep.c:3161 [inline]\n  check_prevs_add kernel/lockin\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21855",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ibmvnic: Don't reference skb after sending to VIOS",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Don't reference skb after sending to VIOS\n\nPreviously, after successfully flushing the xmit buffer to VIOS,\nthe tx_bytes stat was incremented by the length of the skb.\n\nIt is invalid to access the skb memory after sending the buffer to\nthe VIOS because, at any point after sending, the VIOS can trigger\nan interrupt to free this memory. A race between reading skb->len\nand freeing the skb is possible (especially during LPM) and will\nresult in use-after-free:\n ==================================================================\n BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic]\n Read of size 4 at addr c00000024eb48a70 by task hxecom/14495\n <...>\n Call Trace:\n [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable)\n [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0\n [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8\n [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0\n [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic]\n [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358\n <...>\n Freed by task 0:\n kasan_save_stack+0x34/0x68\n kasan_save_track+0x2c/0x50\n kasan_save_free_info+0x64/0x108\n __kasan_mempool_poison_object+0x148/0x2d4\n napi_skb_cache_put+0x5c/0x194\n net_tx_action+0x154/0x5b8\n handle_softirqs+0x20c/0x60c\n do_softirq_own_stack+0x6c/0x88\n <...>\n The buggy address belongs to the object at c00000024eb48a00 which\n  belongs to the cache skbuff_head_cache of size 224\n==================================================================",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21858",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: geneve: Fix use-after-free in geneve_find_dev().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngeneve: Fix use-after-free in geneve_find_dev().\n\nsyzkaller reported a use-after-free in geneve_find_dev() [0]\nwithout repro.\n\ngeneve_configure() links struct geneve_dev.next to\nnet_generic(net, geneve_net_id)->geneve_list.\n\nThe net here could differ from dev_net(dev) if IFLA_NET_NS_PID,\nIFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set.\n\nWhen dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally\ncalls unregister_netdevice_queue() for each dev in the netns,\nand later the dev is freed.\n\nHowever, its geneve_dev.next is still linked to the backend UDP\nsocket netns.\n\nThen, use-after-free will occur when another geneve dev is created\nin the netns.\n\nLet's call geneve_dellink() instead in geneve_destroy_tunnels().\n\n[0]:\nBUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline]\nBUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\nRead of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441\n\nCPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d\nHardware name: linux,dummy-virt (DT)\nCall trace:\n show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x16c/0x6f0 mm/kasan/report.c:489\n kasan_report+0xc0/0x120 mm/kasan/report.c:602\n __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379\n geneve_find_dev drivers/net/geneve.c:1295 [inline]\n geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\n geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634\n rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]\n netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348\n netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892\n sock_sendmsg_nosec net/socket.c:713 [inline]\n __sock_sendmsg net/socket.c:728 [inline]\n ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568\n ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622\n __sys_sendmsg net/socket.c:2654 [inline]\n __do_sys_sendmsg net/socket.c:2659 [inline]\n __se_sys_sendmsg net/socket.c:2657 [inline]\n __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151\n el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762\n el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600\n\nAllocated by task 13247:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x30/0x68 mm/kasan/common.c:68\n kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4298 [inline]\n __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304\n __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645\n alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470\n rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604\n rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_n\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21863",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: io_uring: prevent opcode speculation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: prevent opcode speculation\n\nsqe->opcode is used for different tables, make sure we santitise it\nagainst speculations.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21887",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ovl: fix UAF in ovl_dentry_update_reval by moving dput() in ovl_link_up",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\novl: fix UAF in ovl_dentry_update_reval by moving dput() in ovl_link_up\n\nThe issue was caused by dput(upper) being called before\novl_dentry_update_reval(), while upper->d_flags was still\naccessed in ovl_dentry_remote().\n\nMove dput(upper) after its last use to prevent use-after-free.\n\nBUG: KASAN: slab-use-after-free in ovl_dentry_remote fs/overlayfs/util.c:162 [inline]\nBUG: KASAN: slab-use-after-free in ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167\n\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0xc3/0x620 mm/kasan/report.c:488\n kasan_report+0xd9/0x110 mm/kasan/report.c:601\n ovl_dentry_remote fs/overlayfs/util.c:162 [inline]\n ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167\n ovl_link_up fs/overlayfs/copy_up.c:610 [inline]\n ovl_copy_up_one+0x2105/0x3490 fs/overlayfs/copy_up.c:1170\n ovl_copy_up_flags+0x18d/0x200 fs/overlayfs/copy_up.c:1223\n ovl_rename+0x39e/0x18c0 fs/overlayfs/dir.c:1136\n vfs_rename+0xf84/0x20a0 fs/namei.c:4893\n...\n </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21905",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: limit printed string from FW file",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: limit printed string from FW file\n\nThere's no guarantee here that the file is always with a\nNUL-termination, so reading the string may read beyond the\nend of the TLV. If that's the last TLV in the file, it can\nperhaps even read beyond the end of the file buffer.\n\nFix that by limiting the print format to the size of the\nbuffer we have.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21920",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vlan: enforce underlying device type",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvlan: enforce underlying device type\n\nCurrently, VLAN devices can be created on top of non-ethernet devices.\n\nBesides the fact that it doesn't make much sense, this also causes a\nbug which leaks the address of a kernel function to usermode.\n\nWhen creating a VLAN device, we initialize GARP (garp_init_applicant)\nand MRP (mrp_init_applicant) for the underlying device.\n\nAs part of the initialization process, we add the multicast address of\neach applicant to the underlying device, by calling dev_mc_add.\n\n__dev_mc_add uses dev->addr_len to determine the length of the new\nmulticast address.\n\nThis causes an out-of-bounds read if dev->addr_len is greater than 6,\nsince the multicast addresses provided by GARP and MRP are only 6\nbytes long.\n\nThis behaviour can be reproduced using the following commands:\n\nip tunnel add gretest mode ip6gre local ::1 remote ::2 dev lo\nip l set up dev gretest\nip link add link gretest name vlantest type vlan id 100\n\nThen, the following command will display the address of garp_pdu_rcv:\n\nip maddr show | grep 01:80:c2:00:00:21\n\nFix the bug by enforcing the type of the underlying device during VLAN\ndevice initialization.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21926",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: gso: fix ownership in __udp_gso_segment",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: gso: fix ownership in __udp_gso_segment\n\nIn __udp_gso_segment the skb destructor is removed before segmenting the\nskb but the socket reference is kept as-is. This is an issue if the\noriginal skb is later orphaned as we can hit the following bug:\n\n  kernel BUG at ./include/linux/skbuff.h:3312!  (skb_orphan)\n  RIP: 0010:ip_rcv_core+0x8b2/0xca0\n  Call Trace:\n   ip_rcv+0xab/0x6e0\n   __netif_receive_skb_one_core+0x168/0x1b0\n   process_backlog+0x384/0x1100\n   __napi_poll.constprop.0+0xa1/0x370\n   net_rx_action+0x925/0xe50\n\nThe above can happen following a sequence of events when using\nOpenVSwitch, when an OVS_ACTION_ATTR_USERSPACE action precedes an\nOVS_ACTION_ATTR_OUTPUT action:\n\n1. OVS_ACTION_ATTR_USERSPACE is handled (in do_execute_actions): the skb\n   goes through queue_gso_packets and then __udp_gso_segment, where its\n   destructor is removed.\n2. The segments' data are copied and sent to userspace.\n3. OVS_ACTION_ATTR_OUTPUT is handled (in do_execute_actions) and the\n   same original skb is sent to its path.\n4. If it later hits skb_orphan, we hit the bug.\n\nFix this by also removing the reference to the socket in\n__udp_gso_segment.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21927",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu()\n\nnvme_tcp_recv_pdu() doesn't check the validity of the header length.\nWhen header digests are enabled, a target might send a packet with an\ninvalid header length (e.g. 255), causing nvme_tcp_verify_hdgst()\nto access memory outside the allocated area and cause memory corruptions\nby overwriting it with the calculated digest.\n\nFix this by rejecting packets with an unexpected header length.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21928",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: HID: intel-ish-hid: Fix use-after-free issue in ishtp_hid_remove()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: intel-ish-hid: Fix use-after-free issue in ishtp_hid_remove()\n\nThe system can experience a random crash a few minutes after the driver is\nremoved. This issue occurs due to improper handling of memory freeing in\nthe ishtp_hid_remove() function.\n\nThe function currently frees the `driver_data` directly within the loop\nthat destroys the HID devices, which can lead to accessing freed memory.\nSpecifically, `hid_destroy_device()` uses `driver_data` when it calls\n`hid_ishtp_set_feature()` to power off the sensor, so freeing\n`driver_data` beforehand can result in accessing invalid memory.\n\nThis patch resolves the issue by storing the `driver_data` in a temporary\nvariable before calling `hid_destroy_device()`, and then freeing the\n`driver_data` after the device is destroyed.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21934",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: rapidio: fix an API misues when rio_add_net() fails",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrapidio: fix an API misues when rio_add_net() fails\n\nrio_add_net() calls device_register() and fails when device_register()\nfails.  Thus, put_device() should be used rather than kfree().  Add\n\"mport->net = NULL;\" to avoid a use after free issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21968",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix slab-use-after-free on hdcp_work",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix slab-use-after-free on hdcp_work\n\n[Why]\nA slab-use-after-free is reported when HDCP is destroyed but the\nproperty_validate_dwork queue is still running.\n\n[How]\nCancel the delayed work when destroying workqueue.\n\n(cherry picked from commit 725a04ba5a95e89c89633d4322430cfbca7ce128)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21969",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd\n\nAfter the hci sync command releases l2cap_conn, the hci receive data work\nqueue references the released l2cap_conn when sending to the upper layer.\nAdd hci dev lock to the hci receive data work queue to synchronize the two.\n\n[1]\nBUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954\nRead of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837\n\nCPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nWorkqueue: hci1 hci_rx_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:489\n kasan_report+0x143/0x180 mm/kasan/report.c:602\n l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline]\n l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954\n l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline]\n l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline]\n l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817\n hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline]\n hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nAllocated by task 5837:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329\n kmalloc_noprof include/linux/slab.h:901 [inline]\n kzalloc_noprof include/linux/slab.h:1037 [inline]\n l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860\n l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239\n hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]\n hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726\n hci_event_func net/bluetooth/hci_event.c:7473 [inline]\n hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525\n hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nFreed by task 54:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2353 [inline]\n slab_free mm/slub.c:4613 [inline]\n kfree+0x196/0x430 mm/slub.c:4761\n l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235\n hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]\n hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266\n hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603\n hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entr\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21991",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/microcode/AMD: Fix out-of-bounds on systems with CPU-less NUMA nodes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/microcode/AMD: Fix out-of-bounds on systems with CPU-less NUMA nodes\n\nCurrently, load_microcode_amd() iterates over all NUMA nodes, retrieves their\nCPU masks and unconditionally accesses per-CPU data for the first CPU of each\nmask.\n\nAccording to Documentation/admin-guide/mm/numaperf.rst:\n\n  \"Some memory may share the same node as a CPU, and others are provided as\n  memory only nodes.\"\n\nTherefore, some node CPU masks may be empty and wouldn't have a \"first CPU\".\n\nOn a machine with far memory (and therefore CPU-less NUMA nodes):\n- cpumask_of_node(nid) is 0\n- cpumask_first(0) is CONFIG_NR_CPUS\n- cpu_data(CONFIG_NR_CPUS) accesses the cpu_info per-CPU array at an\n  index that is 1 out of bounds\n\nThis does not have any security implications since flashing microcode is\na privileged operation but I believe this has reliability implications by\npotentially corrupting memory while flashing a microcode update.\n\nWhen booting with CONFIG_UBSAN_BOUNDS=y on an AMD machine that flashes\na microcode update. I get the following splat:\n\n  UBSAN: array-index-out-of-bounds in arch/x86/kernel/cpu/microcode/amd.c:X:Y\n  index 512 is out of range for type 'unsigned long[512]'\n  [...]\n  Call Trace:\n   dump_stack\n   __ubsan_handle_out_of_bounds\n   load_microcode_amd\n   request_microcode_amd\n   reload_store\n   kernfs_fop_write_iter\n   vfs_write\n   ksys_write\n   do_syscall_64\n   entry_SYSCALL_64_after_hwframe\n\nChange the loop to go over only NUMA nodes which have CPUs before determining\nwhether the first CPU on the respective node needs microcode update.\n\n  [ bp: Massage commit message, fix typo. ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-21993",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic()\n\nWhen performing an iSCSI boot using IPv6, iscsistart still reads the\n/sys/firmware/ibft/ethernetX/subnet-mask entry. Since the IPv6 prefix\nlength is 64, this causes the shift exponent to become negative,\ntriggering a UBSAN warning. As the concept of a subnet mask does not\napply to IPv6, the value is set to ~0 to suppress the warning message.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22004",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: atm: fix use after free in lec_send()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atm: fix use after free in lec_send()\n\nThe ->send() operation frees skb so save the length before calling\n->send() to avoid a use after free.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22020",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: memstick: rtsx_usb_ms: Fix slab-use-after-free in rtsx_usb_ms_drv_remove",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemstick: rtsx_usb_ms: Fix slab-use-after-free in rtsx_usb_ms_drv_remove\n\nThis fixes the following crash:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]\nRead of size 8 at addr ffff888136335380 by task kworker/6:0/140241\n\nCPU: 6 UID: 0 PID: 140241 Comm: kworker/6:0 Kdump: loaded Tainted: G            E      6.14.0-rc6+ #1\nTainted: [E]=UNSIGNED_MODULE\nHardware name: LENOVO 30FNA1V7CW/1057, BIOS S0EKT54A 07/01/2024\nWorkqueue: events rtsx_usb_ms_poll_card [rtsx_usb_ms]\nCall Trace:\n <TASK>\n dump_stack_lvl+0x51/0x70\n print_address_description.constprop.0+0x27/0x320\n ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]\n print_report+0x3e/0x70\n kasan_report+0xab/0xe0\n ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]\n rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]\n ? __pfx_rtsx_usb_ms_poll_card+0x10/0x10 [rtsx_usb_ms]\n ? __pfx___schedule+0x10/0x10\n ? kick_pool+0x3b/0x270\n process_one_work+0x357/0x660\n worker_thread+0x390/0x4c0\n ? __pfx_worker_thread+0x10/0x10\n kthread+0x190/0x1d0\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x2d/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 161446:\n kasan_save_stack+0x20/0x40\n kasan_save_track+0x10/0x30\n __kasan_kmalloc+0x7b/0x90\n __kmalloc_noprof+0x1a7/0x470\n memstick_alloc_host+0x1f/0xe0 [memstick]\n rtsx_usb_ms_drv_probe+0x47/0x320 [rtsx_usb_ms]\n platform_probe+0x60/0xe0\n call_driver_probe+0x35/0x120\n really_probe+0x123/0x410\n __driver_probe_device+0xc7/0x1e0\n driver_probe_device+0x49/0xf0\n __device_attach_driver+0xc6/0x160\n bus_for_each_drv+0xe4/0x160\n __device_attach+0x13a/0x2b0\n bus_probe_device+0xbd/0xd0\n device_add+0x4a5/0x760\n platform_device_add+0x189/0x370\n mfd_add_device+0x587/0x5e0\n mfd_add_devices+0xb1/0x130\n rtsx_usb_probe+0x28e/0x2e0 [rtsx_usb]\n usb_probe_interface+0x15c/0x460\n call_driver_probe+0x35/0x120\n really_probe+0x123/0x410\n __driver_probe_device+0xc7/0x1e0\n driver_probe_device+0x49/0xf0\n __device_attach_driver+0xc6/0x160\n bus_for_each_drv+0xe4/0x160\n __device_attach+0x13a/0x2b0\n rebind_marked_interfaces.isra.0+0xcc/0x110\n usb_reset_device+0x352/0x410\n usbdev_do_ioctl+0xe5c/0x1860\n usbdev_ioctl+0xa/0x20\n __x64_sys_ioctl+0xc5/0xf0\n do_syscall_64+0x59/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 161506:\n kasan_save_stack+0x20/0x40\n kasan_save_track+0x10/0x30\n kasan_save_free_info+0x36/0x60\n __kasan_slab_free+0x34/0x50\n kfree+0x1fd/0x3b0\n device_release+0x56/0xf0\n kobject_cleanup+0x73/0x1c0\n rtsx_usb_ms_drv_remove+0x13d/0x220 [rtsx_usb_ms]\n platform_remove+0x2f/0x50\n device_release_driver_internal+0x24b/0x2e0\n bus_remove_device+0x124/0x1d0\n device_del+0x239/0x530\n platform_device_del.part.0+0x19/0xe0\n platform_device_unregister+0x1c/0x40\n mfd_remove_devices_fn+0x167/0x170\n device_for_each_child_reverse+0xc9/0x130\n mfd_remove_devices+0x6e/0xa0\n rtsx_usb_disconnect+0x2e/0xd0 [rtsx_usb]\n usb_unbind_interface+0xf3/0x3f0\n device_release_driver_internal+0x24b/0x2e0\n proc_disconnect_claim+0x13d/0x220\n usbdev_do_ioctl+0xb5e/0x1860\n usbdev_ioctl+0xa/0x20\n __x64_sys_ioctl+0xc5/0xf0\n do_syscall_64+0x59/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nLast potentially related work creation:\n kasan_save_stack+0x20/0x40\n kasan_record_aux_stack+0x85/0x90\n insert_work+0x29/0x100\n __queue_work+0x34a/0x540\n call_timer_fn+0x2a/0x160\n expire_timers+0x5f/0x1f0\n __run_timer_base.part.0+0x1b6/0x1e0\n run_timer_softirq+0x8b/0xe0\n handle_softirqs+0xf9/0x360\n __irq_exit_rcu+0x114/0x130\n sysvec_apic_timer_interrupt+0x72/0x90\n asm_sysvec_apic_timer_interrupt+0x16/0x20\n\nSecond to last potentially related work creation:\n kasan_save_stack+0x20/0x40\n kasan_record_aux_stack+0x85/0x90\n insert_work+0x29/0x100\n __queue_work+0x34a/0x540\n call_timer_fn+0x2a/0x160\n expire_timers+0x5f/0x1f0\n __run_timer_base.part.0+0x1b6/0x1e0\n run_timer_softirq+0x8b/0xe0\n handle_softirqs+0xf9/0x\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22022",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: xhci: Apply the link chain quirk on NEC isoc endpoints",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: xhci: Apply the link chain quirk on NEC isoc endpoints\n\nTwo clearly different specimens of NEC uPD720200 (one with start/stop\nbug, one without) were seen to cause IOMMU faults after some Missed\nService Errors. Faulting address is immediately after a transfer ring\nsegment and patched dynamic debug messages revealed that the MSE was\nreceived when waiting for a TD near the end of that segment:\n\n[ 1.041954] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ffa08fe0\n[ 1.042120] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09000 flags=0x0000]\n[ 1.042146] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09040 flags=0x0000]\n\nIt gets even funnier if the next page is a ring segment accessible to\nthe HC. Below, it reports MSE in segment at ff1e8000, plows through a\nzero-filled page at ff1e9000 and starts reporting events for TRBs in\npage at ff1ea000 every microframe, instead of jumping to seg ff1e6000.\n\n[ 7.041671] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0\n[ 7.041999] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0\n[ 7.042011] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint\n[ 7.042028] xhci_hcd: All TDs skipped for slot 1 ep 2. Clear skip flag.\n[ 7.042134] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint\n[ 7.042138] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31\n[ 7.042144] xhci_hcd: Looking for event-dma 00000000ff1ea040 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820\n[ 7.042259] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint\n[ 7.042262] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31\n[ 7.042266] xhci_hcd: Looking for event-dma 00000000ff1ea050 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820\n\nAt some point completion events change from Isoch Buffer Overrun to\nShort Packet and the HC finally finds cycle bit mismatch in ff1ec000.\n\n[ 7.098130] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13\n[ 7.098132] xhci_hcd: Looking for event-dma 00000000ff1ecc50 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820\n[ 7.098254] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13\n[ 7.098256] xhci_hcd: Looking for event-dma 00000000ff1ecc60 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820\n[ 7.098379] xhci_hcd: Overrun event on slot 1 ep 2\n\nIt's possible that data from the isochronous device were written to\nrandom buffers of pending TDs on other endpoints (either IN or OUT),\nother devices or even other HCs in the same IOMMU domain.\n\nLastly, an error from a different USB device on another HC. Was it\ncaused by the above? I don't know, but it may have been. The disk\nwas working without any other issues and generated PCIe traffic to\nstarve the NEC of upstream BW and trigger those MSEs. The two HCs\nshared one x1 slot by means of a commercial \"PCIe splitter\" board.\n\n[ 7.162604] usb 10-2: reset SuperSpeed USB device number 3 using xhci_hcd\n[ 7.178990] sd 9:0:0:0: [sdb] tag#0 UNKNOWN(0x2003) Result: hostbyte=0x07 driverbyte=DRIVER_OK cmd_age=0s\n[ 7.179001] sd 9:0:0:0: [sdb] tag#0 CDB: opcode=0x28 28 00 04 02 ae 00 00 02 00 00\n[ 7.179004] I/O error, dev sdb, sector 67284480 op 0x0:(READ) flags 0x80700 phys_seg 5 prio class 0\n\nFortunately, it appears that this ridiculous bug is avoided by setting\nthe chain bit of Link TRBs on isochronous rings. Other ancient HCs are\nknown which also expect the bit to be set and they ignore Link TRBs if\nit's not. Reportedly, 0.95 spec guaranteed that the bit is set.\n\nThe bandwidth-starved NEC HC running a 32KB/uframe UVC endpoint reports\ntens of MSEs per second and runs into the bug within seconds. Chaining\nLink TRBs allows the same workload to run for many minutes, many times.\n\nNo ne\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22055",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: fix geneve_opt length integer overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix geneve_opt length integer overflow\n\nstruct geneve_opt uses 5 bit length for each single option, which\nmeans every vary size option should be smaller than 128 bytes.\n\nHowever, all current related Netlink policies cannot promise this\nlength condition and the attacker can exploit a exact 128-byte size\noption to *fake* a zero length option and confuse the parsing logic,\nfurther achieve heap out-of-bounds read.\n\nOne example crash log is like below:\n\n[    3.905425] ==================================================================\n[    3.905925] BUG: KASAN: slab-out-of-bounds in nla_put+0xa9/0xe0\n[    3.906255] Read of size 124 at addr ffff888005f291cc by task poc/177\n[    3.906646]\n[    3.906775] CPU: 0 PID: 177 Comm: poc-oob-read Not tainted 6.1.132 #1\n[    3.907131] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\n[    3.907784] Call Trace:\n[    3.907925]  <TASK>\n[    3.908048]  dump_stack_lvl+0x44/0x5c\n[    3.908258]  print_report+0x184/0x4be\n[    3.909151]  kasan_report+0xc5/0x100\n[    3.909539]  kasan_check_range+0xf3/0x1a0\n[    3.909794]  memcpy+0x1f/0x60\n[    3.909968]  nla_put+0xa9/0xe0\n[    3.910147]  tunnel_key_dump+0x945/0xba0\n[    3.911536]  tcf_action_dump_1+0x1c1/0x340\n[    3.912436]  tcf_action_dump+0x101/0x180\n[    3.912689]  tcf_exts_dump+0x164/0x1e0\n[    3.912905]  fw_dump+0x18b/0x2d0\n[    3.913483]  tcf_fill_node+0x2ee/0x460\n[    3.914778]  tfilter_notify+0xf4/0x180\n[    3.915208]  tc_new_tfilter+0xd51/0x10d0\n[    3.918615]  rtnetlink_rcv_msg+0x4a2/0x560\n[    3.919118]  netlink_rcv_skb+0xcd/0x200\n[    3.919787]  netlink_unicast+0x395/0x530\n[    3.921032]  netlink_sendmsg+0x3d0/0x6d0\n[    3.921987]  __sock_sendmsg+0x99/0xa0\n[    3.922220]  __sys_sendto+0x1b7/0x240\n[    3.922682]  __x64_sys_sendto+0x72/0x90\n[    3.922906]  do_syscall_64+0x5e/0x90\n[    3.923814]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n[    3.924122] RIP: 0033:0x7e83eab84407\n[    3.924331] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 faf\n[    3.925330] RSP: 002b:00007ffff505e370 EFLAGS: 00000202 ORIG_RAX: 000000000000002c\n[    3.925752] RAX: ffffffffffffffda RBX: 00007e83eaafa740 RCX: 00007e83eab84407\n[    3.926173] RDX: 00000000000001a8 RSI: 00007ffff505e3c0 RDI: 0000000000000003\n[    3.926587] RBP: 00007ffff505f460 R08: 00007e83eace1000 R09: 000000000000000c\n[    3.926977] R10: 0000000000000000 R11: 0000000000000202 R12: 00007ffff505f3c0\n[    3.927367] R13: 00007ffff505f5c8 R14: 00007e83ead1b000 R15: 00005d4fbbe6dcb8\n\nFix these issues by enforing correct length condition in related\npolicies.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22056",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nft_tunnel: fix geneve_opt type confusion addition",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_tunnel: fix geneve_opt type confusion addition\n\nWhen handling multiple NFTA_TUNNEL_KEY_OPTS_GENEVE attributes, the\nparsing logic should place every geneve_opt structure one by one\ncompactly. Hence, when deciding the next geneve_opt position, the\npointer addition should be in units of char *.\n\nHowever, the current implementation erroneously does type conversion\nbefore the addition, which will lead to heap out-of-bounds write.\n\n[    6.989857] ==================================================================\n[    6.990293] BUG: KASAN: slab-out-of-bounds in nft_tunnel_obj_init+0x977/0xa70\n[    6.990725] Write of size 124 at addr ffff888005f18974 by task poc/178\n[    6.991162]\n[    6.991259] CPU: 0 PID: 178 Comm: poc-oob-write Not tainted 6.1.132 #1\n[    6.991655] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\n[    6.992281] Call Trace:\n[    6.992423]  <TASK>\n[    6.992586]  dump_stack_lvl+0x44/0x5c\n[    6.992801]  print_report+0x184/0x4be\n[    6.993790]  kasan_report+0xc5/0x100\n[    6.994252]  kasan_check_range+0xf3/0x1a0\n[    6.994486]  memcpy+0x38/0x60\n[    6.994692]  nft_tunnel_obj_init+0x977/0xa70\n[    6.995677]  nft_obj_init+0x10c/0x1b0\n[    6.995891]  nf_tables_newobj+0x585/0x950\n[    6.996922]  nfnetlink_rcv_batch+0xdf9/0x1020\n[    6.998997]  nfnetlink_rcv+0x1df/0x220\n[    6.999537]  netlink_unicast+0x395/0x530\n[    7.000771]  netlink_sendmsg+0x3d0/0x6d0\n[    7.001462]  __sock_sendmsg+0x99/0xa0\n[    7.001707]  ____sys_sendmsg+0x409/0x450\n[    7.002391]  ___sys_sendmsg+0xfd/0x170\n[    7.003145]  __sys_sendmsg+0xea/0x170\n[    7.004359]  do_syscall_64+0x5e/0x90\n[    7.005817]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n[    7.006127] RIP: 0033:0x7ec756d4e407\n[    7.006339] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 faf\n[    7.007364] RSP: 002b:00007ffed5d46760 EFLAGS: 00000202 ORIG_RAX: 000000000000002e\n[    7.007827] RAX: ffffffffffffffda RBX: 00007ec756cc4740 RCX: 00007ec756d4e407\n[    7.008223] RDX: 0000000000000000 RSI: 00007ffed5d467f0 RDI: 0000000000000003\n[    7.008620] RBP: 00007ffed5d468a0 R08: 0000000000000000 R09: 0000000000000000\n[    7.009039] R10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000000\n[    7.009429] R13: 00007ffed5d478b0 R14: 00007ec756ee5000 R15: 00005cbd4e655cb8\n\nFix this bug with correct pointer addition and conversion in parse\nand dump code.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22058",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: udp: Fix memory accounting leak.",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudp: Fix memory accounting leak.\n\nMatt Dowling reported a weird UDP memory usage issue.\n\nUnder normal operation, the UDP memory usage reported in /proc/net/sockstat\nremains close to zero.  However, it occasionally spiked to 524,288 pages\nand never dropped.  Moreover, the value doubled when the application was\nterminated.  Finally, it caused intermittent packet drops.\n\nWe can reproduce the issue with the script below [0]:\n\n  1. /proc/net/sockstat reports 0 pages\n\n    # cat /proc/net/sockstat | grep UDP:\n    UDP: inuse 1 mem 0\n\n  2. Run the script till the report reaches 524,288\n\n    # python3 test.py & sleep 5\n    # cat /proc/net/sockstat | grep UDP:\n    UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> PAGE_SHIFT\n\n  3. Kill the socket and confirm the number never drops\n\n    # pkill python3 && sleep 5\n    # cat /proc/net/sockstat | grep UDP:\n    UDP: inuse 1 mem 524288\n\n  4. (necessary since v6.0) Trigger proto_memory_pcpu_drain()\n\n    # python3 test.py & sleep 1 && pkill python3\n\n  5. The number doubles\n\n    # cat /proc/net/sockstat | grep UDP:\n    UDP: inuse 1 mem 1048577\n\nThe application set INT_MAX to SO_RCVBUF, which triggered an integer\noverflow in udp_rmem_release().\n\nWhen a socket is close()d, udp_destruct_common() purges its receive\nqueue and sums up skb->truesize in the queue.  This total is calculated\nand stored in a local unsigned integer variable.\n\nThe total size is then passed to udp_rmem_release() to adjust memory\naccounting.  However, because the function takes a signed integer\nargument, the total size can wrap around, causing an overflow.\n\nThen, the released amount is calculated as follows:\n\n  1) Add size to sk->sk_forward_alloc.\n  2) Round down sk->sk_forward_alloc to the nearest lower multiple of\n      PAGE_SIZE and assign it to amount.\n  3) Subtract amount from sk->sk_forward_alloc.\n  4) Pass amount >> PAGE_SHIFT to __sk_mem_reduce_allocated().\n\nWhen the issue occurred, the total in udp_destruct_common() was 2147484480\n(INT_MAX + 833), which was cast to -2147482816 in udp_rmem_release().\n\nAt 1) sk->sk_forward_alloc is changed from 3264 to -2147479552, and\n2) sets -2147479552 to amount.  3) reverts the wraparound, so we don't\nsee a warning in inet_sock_destruct().  However, udp_memory_allocated\nends up doubling at 4).\n\nSince commit 3cd3399dd7a8 (\"net: implement per-cpu reserves for\nmemory_allocated\"), memory usage no longer doubles immediately after\na socket is close()d because __sk_mem_reduce_allocated() caches the\namount in udp_memory_per_cpu_fw_alloc.  However, the next time a UDP\nsocket receives a packet, the subtraction takes effect, causing UDP\nmemory usage to double.\n\nThis issue makes further memory allocation fail once the socket's\nsk->sk_rmem_alloc exceeds net.ipv4.udp_rmem_min, resulting in packet\ndrops.\n\nTo prevent this issue, let's use unsigned int for the calculation and\ncall sk_forward_alloc_add() only once for the small delta.\n\nNote that first_packet_length() also potentially has the same problem.\n\n[0]:\nfrom socket import *\n\nSO_RCVBUFFORCE = 33\nINT_MAX = (2 ** 31) - 1\n\ns = socket(AF_INET, SOCK_DGRAM)\ns.bind(('', 0))\ns.setsockopt(SOL_SOCKET, SO_RCVBUFFORCE, INT_MAX)\n\nc = socket(AF_INET, SOCK_DGRAM)\nc.connect(s.getsockname())\n\ndata = b'a' * 100\n\nwhile True:\n    c.send(data)",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22104",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ibmvnic: Use kernel helpers for hex dumps",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Use kernel helpers for hex dumps\n\nPreviously, when the driver was printing hex dumps, the buffer was cast\nto an 8 byte long and printed using string formatters. If the buffer\nsize was not a multiple of 8 then a read buffer overflow was possible.\n\nTherefore, create a new ibmvnic function that loops over a buffer and\ncalls hex_dump_to_buffer instead.\n\nThis patch address KASAN reports like the one below:\n  ibmvnic 30000003 env3: Login Buffer:\n  ibmvnic 30000003 env3: 01000000af000000\n  <...>\n  ibmvnic 30000003 env3: 2e6d62692e736261\n  ibmvnic 30000003 env3: 65050003006d6f63\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in ibmvnic_login+0xacc/0xffc [ibmvnic]\n  Read of size 8 at addr c0000001331a9aa8 by task ip/17681\n  <...>\n  Allocated by task 17681:\n  <...>\n  ibmvnic_login+0x2f0/0xffc [ibmvnic]\n  ibmvnic_open+0x148/0x308 [ibmvnic]\n  __dev_open+0x1ac/0x304\n  <...>\n  The buggy address is located 168 bytes inside of\n                allocated 175-byte region [c0000001331a9a00, c0000001331a9aaf)\n  <...>\n  =================================================================\n  ibmvnic 30000003 env3: 000000000033766e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-22121",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix out-of-bound read in ext4_xattr_inode_dec_ref_all()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix out-of-bound read in ext4_xattr_inode_dec_ref_all()\n\nThere's issue as follows:\nBUG: KASAN: use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790\nRead of size 4 at addr ffff88807b003000 by task syz-executor.0/15172\n\nCPU: 3 PID: 15172 Comm: syz-executor.0\nCall Trace:\n __dump_stack lib/dump_stack.c:82 [inline]\n dump_stack+0xbe/0xfd lib/dump_stack.c:123\n print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c:400\n __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560\n kasan_report+0x3a/0x50 mm/kasan/report.c:585\n ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c:1137\n ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c:2896\n ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c:323\n evict+0x39f/0x880 fs/inode.c:622\n iput_final fs/inode.c:1746 [inline]\n iput fs/inode.c:1772 [inline]\n iput+0x525/0x6c0 fs/inode.c:1758\n ext4_orphan_cleanup fs/ext4/super.c:3298 [inline]\n ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c:5300\n mount_bdev+0x355/0x410 fs/super.c:1446\n legacy_get_tree+0xfe/0x220 fs/fs_context.c:611\n vfs_get_tree+0x8d/0x2f0 fs/super.c:1576\n do_new_mount fs/namespace.c:2983 [inline]\n path_mount+0x119a/0x1ad0 fs/namespace.c:3316\n do_mount+0xfc/0x110 fs/namespace.c:3329\n __do_sys_mount fs/namespace.c:3540 [inline]\n __se_sys_mount+0x219/0x2e0 fs/namespace.c:3514\n do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x67/0xd1\n\nMemory state around the buggy address:\n ffff88807b002f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88807b002f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88807b003000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n                   ^\n ffff88807b003080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88807b003100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nAbove issue happens as ext4_xattr_delete_inode() isn't check xattr\nis valid if xattr is in inode.\nTo solve above issue call xattr_check_inode() check if xattr if valid\nin inode. In fact, we can directly verify in ext4_iget_extra_inode(),\nso that there is no divergent verification.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-23150",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix off-by-one error in do_split",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix off-by-one error in do_split\n\nSyzkaller detected a use-after-free issue in ext4_insert_dentry that was\ncaused by out-of-bounds access due to incorrect splitting in do_split.\n\nBUG: KASAN: use-after-free in ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c:2109\nWrite of size 251 at addr ffff888074572f14 by task syz-executor335/5847\n\nCPU: 0 UID: 0 PID: 5847 Comm: syz-executor335 Not tainted 6.12.0-rc6-syzkaller-00318-ga9cda7c0ffed #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n kasan_check_range+0x282/0x290 mm/kasan/generic.c:189\n __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106\n ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c:2109\n add_dirent_to_buf+0x3d9/0x750 fs/ext4/namei.c:2154\n make_indexed_dir+0xf98/0x1600 fs/ext4/namei.c:2351\n ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c:2455\n ext4_add_nondir+0x8d/0x290 fs/ext4/namei.c:2796\n ext4_symlink+0x920/0xb50 fs/ext4/namei.c:3431\n vfs_symlink+0x137/0x2e0 fs/namei.c:4615\n do_symlinkat+0x222/0x3a0 fs/namei.c:4641\n __do_sys_symlink fs/namei.c:4662 [inline]\n __se_sys_symlink fs/namei.c:4660 [inline]\n __x64_sys_symlink+0x7a/0x90 fs/namei.c:4660\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n </TASK>\n\nThe following loop is located right above 'if' statement.\n\nfor (i = count-1; i >= 0; i--) {\n\t/* is more than half of this entry in 2nd half of the block? */\n\tif (size + map[i].size/2 > blocksize/2)\n\t\tbreak;\n\tsize += map[i].size;\n\tmove++;\n}\n\n'i' in this case could go down to -1, in which case sum of active entries\nwouldn't exceed half the block size, but previous behaviour would also do\nsplit in half if sum would exceed at the very last block, which in case of\nhaving too many long name files in a single block could lead to\nout-of-bounds access and following use-after-free.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37738",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: ignore xattrs past end",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: ignore xattrs past end\n\nOnce inside 'ext4_xattr_inode_dec_ref_all' we should\nignore xattrs entries past the 'end' entry.\n\nThis fixes the following KASAN reported issue:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_xattr_inode_dec_ref_all+0xb8c/0xe90\nRead of size 4 at addr ffff888012c120c4 by task repro/2065\n\nCPU: 1 UID: 0 PID: 2065 Comm: repro Not tainted 6.13.0-rc2+ #11\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x1fd/0x300\n ? tcp_gro_dev_warn+0x260/0x260\n ? _printk+0xc0/0x100\n ? read_lock_is_recursive+0x10/0x10\n ? irq_work_queue+0x72/0xf0\n ? __virt_addr_valid+0x17b/0x4b0\n print_address_description+0x78/0x390\n print_report+0x107/0x1f0\n ? __virt_addr_valid+0x17b/0x4b0\n ? __virt_addr_valid+0x3ff/0x4b0\n ? __phys_addr+0xb5/0x160\n ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90\n kasan_report+0xcc/0x100\n ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90\n ext4_xattr_inode_dec_ref_all+0xb8c/0xe90\n ? ext4_xattr_delete_inode+0xd30/0xd30\n ? __ext4_journal_ensure_credits+0x5f0/0x5f0\n ? __ext4_journal_ensure_credits+0x2b/0x5f0\n ? inode_update_timestamps+0x410/0x410\n ext4_xattr_delete_inode+0xb64/0xd30\n ? ext4_truncate+0xb70/0xdc0\n ? ext4_expand_extra_isize_ea+0x1d20/0x1d20\n ? __ext4_mark_inode_dirty+0x670/0x670\n ? ext4_journal_check_start+0x16f/0x240\n ? ext4_inode_is_fast_symlink+0x2f2/0x3a0\n ext4_evict_inode+0xc8c/0xff0\n ? ext4_inode_is_fast_symlink+0x3a0/0x3a0\n ? do_raw_spin_unlock+0x53/0x8a0\n ? ext4_inode_is_fast_symlink+0x3a0/0x3a0\n evict+0x4ac/0x950\n ? proc_nr_inodes+0x310/0x310\n ? trace_ext4_drop_inode+0xa2/0x220\n ? _raw_spin_unlock+0x1a/0x30\n ? iput+0x4cb/0x7e0\n do_unlinkat+0x495/0x7c0\n ? try_break_deleg+0x120/0x120\n ? 0xffffffff81000000\n ? __check_object_size+0x15a/0x210\n ? strncpy_from_user+0x13e/0x250\n ? getname_flags+0x1dc/0x530\n __x64_sys_unlinkat+0xc8/0xf0\n do_syscall_64+0x65/0x110\n entry_SYSCALL_64_after_hwframe+0x67/0x6f\nRIP: 0033:0x434ffd\nCode: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 8\nRSP: 002b:00007ffc50fa7b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000107\nRAX: ffffffffffffffda RBX: 00007ffc50fa7e18 RCX: 0000000000434ffd\nRDX: 0000000000000000 RSI: 0000000020000240 RDI: 0000000000000005\nRBP: 00007ffc50fa7be0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001\nR13: 00007ffc50fa7e08 R14: 00000000004bbf30 R15: 0000000000000001\n </TASK>\n\nThe buggy address belongs to the object at ffff888012c12000\n which belongs to the cache filp of size 360\nThe buggy address is located 196 bytes inside of\n freed 360-byte region [ffff888012c12000, ffff888012c12168)\n\nThe buggy address belongs to the physical page:\npage: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x12c12\nhead: order:1 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0\nflags: 0x40(head|node=0|zone=0)\npage_type: f5(slab)\nraw: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004\nraw: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000\nhead: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004\nhead: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000\nhead: 0000000000000001 ffffea00004b0481 ffffffffffffffff 0000000000000000\nhead: 0000000000000002 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888012c11f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff888012c12000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n> ffff888012c12080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                           ^\n ffff888012c12100: fb fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc\n ffff888012c12180: fc fc fc fc fc fc fc fc fc\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37785",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ext4: fix OOB read when checking dotdot dir",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix OOB read when checking dotdot dir\n\nMounting a corrupted filesystem with directory which contains '.' dir\nentry with rec_len == block size results in out-of-bounds read (later\non, when the corrupted directory is removed).\n\next4_empty_dir() assumes every ext4 directory contains at least '.'\nand '..' as directory entries in the first data block. It first loads\nthe '.' dir entry, performs sanity checks by calling ext4_check_dir_entry()\nand then uses its rec_len member to compute the location of '..' dir\nentry (in ext4_next_entry). It assumes the '..' dir entry fits into the\nsame data block.\n\nIf the rec_len of '.' is precisely one block (4KB), it slips through the\nsanity checks (it is considered the last directory entry in the data\nblock) and leaves \"struct ext4_dir_entry_2 *de\" point exactly past the\nmemory slot allocated to the data block. The following call to\next4_check_dir_entry() on new value of de then dereferences this pointer\nwhich results in out-of-bounds mem access.\n\nFix this by extending __ext4_check_dir_entry() to check for '.' dir\nentries that reach the end of data block. Make sure to ignore the phony\ndir entries for checksum (by checking name_len for non-zero).\n\nNote: This is reported by KASAN as use-after-free in case another\nstructure was recently freed from the slot past the bound, but it is\nreally an OOB read.\n\nThis issue was found by syzkaller tool.\n\nCall Trace:\n[   38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710\n[   38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375\n[   38.595158]\n[   38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1\n[   38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[   38.595304] Call Trace:\n[   38.595308]  <TASK>\n[   38.595311]  dump_stack_lvl+0xa7/0xd0\n[   38.595325]  print_address_description.constprop.0+0x2c/0x3f0\n[   38.595339]  ? __ext4_check_dir_entry+0x67e/0x710\n[   38.595349]  print_report+0xaa/0x250\n[   38.595359]  ? __ext4_check_dir_entry+0x67e/0x710\n[   38.595368]  ? kasan_addr_to_slab+0x9/0x90\n[   38.595378]  kasan_report+0xab/0xe0\n[   38.595389]  ? __ext4_check_dir_entry+0x67e/0x710\n[   38.595400]  __ext4_check_dir_entry+0x67e/0x710\n[   38.595410]  ext4_empty_dir+0x465/0x990\n[   38.595421]  ? __pfx_ext4_empty_dir+0x10/0x10\n[   38.595432]  ext4_rmdir.part.0+0x29a/0xd10\n[   38.595441]  ? __dquot_initialize+0x2a7/0xbf0\n[   38.595455]  ? __pfx_ext4_rmdir.part.0+0x10/0x10\n[   38.595464]  ? __pfx___dquot_initialize+0x10/0x10\n[   38.595478]  ? down_write+0xdb/0x140\n[   38.595487]  ? __pfx_down_write+0x10/0x10\n[   38.595497]  ext4_rmdir+0xee/0x140\n[   38.595506]  vfs_rmdir+0x209/0x670\n[   38.595517]  ? lookup_one_qstr_excl+0x3b/0x190\n[   38.595529]  do_rmdir+0x363/0x3c0\n[   38.595537]  ? __pfx_do_rmdir+0x10/0x10\n[   38.595544]  ? strncpy_from_user+0x1ff/0x2e0\n[   38.595561]  __x64_sys_unlinkat+0xf0/0x130\n[   38.595570]  do_syscall_64+0x5b/0x180\n[   38.595583]  entry_SYSCALL_64_after_hwframe+0x76/0x7e",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37797",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: hfsc: Fix a UAF vulnerability in class handling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: hfsc: Fix a UAF vulnerability in class handling\n\nThis patch fixes a Use-After-Free vulnerability in the HFSC qdisc class\nhandling. The issue occurs due to a time-of-check/time-of-use condition\nin hfsc_change_class() when working with certain child qdiscs like netem\nor codel.\n\nThe vulnerability works as follows:\n1. hfsc_change_class() checks if a class has packets (q.qlen != 0)\n2. It then calls qdisc_peek_len(), which for certain qdiscs (e.g.,\n   codel, netem) might drop packets and empty the queue\n3. The code continues assuming the queue is still non-empty, adding\n   the class to vttree\n4. This breaks HFSC scheduler assumptions that only non-empty classes\n   are in vttree\n5. Later, when the class is destroyed, this can lead to a Use-After-Free\n\nThe fix adds a second queue length check after qdisc_peek_len() to verify\nthe queue wasn't emptied.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37799",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vmxnet3: Fix malformed packet sizing in vmxnet3_process_xdp",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvmxnet3: Fix malformed packet sizing in vmxnet3_process_xdp\n\nvmxnet3 driver's XDP handling is buggy for packet sizes using ring0 (that\nis, packet sizes between 128 - 3k bytes).\n\nWe noticed MTU-related connectivity issues with Cilium's service load-\nbalancing in case of vmxnet3 as NIC underneath. A simple curl to a HTTP\nbackend service where the XDP LB was doing IPIP encap led to overly large\npacket sizes but only for *some* of the packets (e.g. HTTP GET request)\nwhile others (e.g. the prior TCP 3WHS) looked completely fine on the wire.\n\nIn fact, the pcap recording on the backend node actually revealed that the\nnode with the XDP LB was leaking uninitialized kernel data onto the wire\nfor the affected packets, for example, while the packets should have been\n152 bytes their actual size was 1482 bytes, so the remainder after 152 bytes\nwas padded with whatever other data was in that page at the time (e.g. we\nsaw user/payload data from prior processed packets).\n\nWe only noticed this through an MTU issue, e.g. when the XDP LB node and\nthe backend node both had the same MTU (e.g. 1500) then the curl request\ngot dropped on the backend node's NIC given the packet was too large even\nthough the IPIP-encapped packet normally would never even come close to\nthe MTU limit. Lowering the MTU on the XDP LB (e.g. 1480) allowed to let\nthe curl request succeed (which also indicates that the kernel ignored the\npadding, and thus the issue wasn't very user-visible).\n\nCommit e127ce7699c1 (\"vmxnet3: Fix missing reserved tailroom\") was too eager\nto also switch xdp_prepare_buff() from rcd->len to rbi->len. It really needs\nto stick to rcd->len which is the actual packet length from the descriptor.\nThe latter we also feed into vmxnet3_process_xdp_small(), by the way, and\nit indicates the correct length needed to initialize the xdp->{data,data_end}\nparts. For e127ce7699c1 (\"vmxnet3: Fix missing reserved tailroom\") the\nrelevant part was adapting xdp_init_buff() to address the warning given the\nxdp_data_hard_end() depends on xdp->frame_sz. With that fixed, traffic on\nthe wire looks good again.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37803",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: udmabuf: fix a buf size overflow issue during udmabuf creation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudmabuf: fix a buf size overflow issue during udmabuf creation\n\nby casting size_limit_mb to u64  when calculate pglimit.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37810",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: dwc3: gadget: check that event count does not exceed event buffer length",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: gadget: check that event count does not exceed event buffer length\n\nThe event count is read from register DWC3_GEVNTCOUNT.\nThere is a check for the count being zero, but not for exceeding the\nevent buffer length.\nCheck that event count does not exceed event buffer length,\navoiding an out-of-bounds access when memcpy'ing the event.\nCrash log:\nUnable to handle kernel paging request at virtual address ffffffc0129be000\npc : __memcpy+0x114/0x180\nlr : dwc3_check_event_buf+0xec/0x348\nx3 : 0000000000000030 x2 : 000000000000dfc4\nx1 : ffffffc0129be000 x0 : ffffff87aad60080\nCall trace:\n__memcpy+0x114/0x180\ndwc3_interrupt+0x24/0x34",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37823",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: hfsc: Fix a potential UAF in hfsc_dequeue() too",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: hfsc: Fix a potential UAF in hfsc_dequeue() too\n\nSimilarly to the previous patch, we need to safe guard hfsc_dequeue()\ntoo. But for this one, we don't have a reliable reproducer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37833",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/niu: Niu requires MSIX ENTRY_DATA fields touch before entry reads",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/niu: Niu requires MSIX ENTRY_DATA fields touch before entry reads\n\nFix niu_try_msix() to not cause a fatal trap on sparc systems.\n\nSet PCI_DEV_FLAGS_MSIX_TOUCH_ENTRY_DATA_FIRST on the struct pci_dev to\nwork around a bug in the hardware or firmware.\n\nFor each vector entry in the msix table, niu chips will cause a fatal\ntrap if any registers in that entry are read before that entries'\nENTRY_DATA register is written to. Testing indicates writes to other\nregisters are not sufficient to prevent the fatal trap, however the value\ndoes not appear to matter. This only needs to happen once after power up,\nso simply rebooting into a kernel lacking this fix will NOT cause the\ntrap.\n\nNON-RESUMABLE ERROR: Reporting on cpu 64\nNON-RESUMABLE ERROR: TPC [0x00000000005f6900] <msix_prepare_msi_desc+0x90/0xa0>\nNON-RESUMABLE ERROR: RAW [4010000000000016:00000e37f93e32ff:0000000202000080:ffffffffffffffff\nNON-RESUMABLE ERROR:      0000000800000000:0000000000000000:0000000000000000:0000000000000000]\nNON-RESUMABLE ERROR: handle [0x4010000000000016] stick [0x00000e37f93e32ff]\nNON-RESUMABLE ERROR: type [precise nonresumable]\nNON-RESUMABLE ERROR: attrs [0x02000080] < ASI sp-faulted priv >\nNON-RESUMABLE ERROR: raddr [0xffffffffffffffff]\nNON-RESUMABLE ERROR: insn effective address [0x000000c50020000c]\nNON-RESUMABLE ERROR: size [0x8]\nNON-RESUMABLE ERROR: asi [0x00]\nCPU: 64 UID: 0 PID: 745 Comm: kworker/64:1 Not tainted 6.11.5 #63\nWorkqueue: events work_for_cpu_fn\nTSTATE: 0000000011001602 TPC: 00000000005f6900 TNPC: 00000000005f6904 Y: 00000000    Not tainted\nTPC: <msix_prepare_msi_desc+0x90/0xa0>\ng0: 00000000000002e9 g1: 000000000000000c g2: 000000c50020000c g3: 0000000000000100\ng4: ffff8000470307c0 g5: ffff800fec5be000 g6: ffff800047a08000 g7: 0000000000000000\no0: ffff800014feb000 o1: ffff800047a0b620 o2: 0000000000000011 o3: ffff800047a0b620\no4: 0000000000000080 o5: 0000000000000011 sp: ffff800047a0ad51 ret_pc: 00000000005f7128\nRPC: <__pci_enable_msix_range+0x3cc/0x460>\nl0: 000000000000000d l1: 000000000000c01f l2: ffff800014feb0a8 l3: 0000000000000020\nl4: 000000000000c000 l5: 0000000000000001 l6: 0000000020000000 l7: ffff800047a0b734\ni0: ffff800014feb000 i1: ffff800047a0b730 i2: 0000000000000001 i3: 000000000000000d\ni4: 0000000000000000 i5: 0000000000000000 i6: ffff800047a0ae81 i7: 00000000101888b0\nI7: <niu_try_msix.constprop.0+0xc0/0x130 [niu]>\nCall Trace:\n[<00000000101888b0>] niu_try_msix.constprop.0+0xc0/0x130 [niu]\n[<000000001018f840>] niu_get_invariants+0x183c/0x207c [niu]\n[<00000000101902fc>] niu_pci_init_one+0x27c/0x2fc [niu]\n[<00000000005ef3e4>] local_pci_probe+0x28/0x74\n[<0000000000469240>] work_for_cpu_fn+0x8/0x1c\n[<000000000046b008>] process_scheduled_works+0x144/0x210\n[<000000000046b518>] worker_thread+0x13c/0x1c0\n[<00000000004710e0>] kthread+0xb8/0xc8\n[<00000000004060c8>] ret_from_fork+0x1c/0x2c\n[<0000000000000000>] 0x0\nKernel panic - not syncing: Non-resumable error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37878",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf/core: Fix WARN_ON(!ctx) in __free_event() for partial init",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Fix WARN_ON(!ctx) in __free_event() for partial init\n\nMove the get_ctx(child_ctx) call and the child_event->ctx assignment to\noccur immediately after the child event is allocated. Ensure that\nchild_event->ctx is non-NULL before any subsequent error path within\ninherit_event calls free_event(), satisfying the assumptions of the\ncleanup code.\n\nDetails:\n\nThere's no clear Fixes tag, because this bug is a side-effect of\nmultiple interacting commits over time (up to 15 years old), not\na single regression.\n\nThe code initially incremented refcount then assigned context\nimmediately after the child_event was created. Later, an early\nvalidity check for child_event was added before the\nrefcount/assignment. Even later, a WARN_ON_ONCE() cleanup check was\nadded, assuming event->ctx is valid if the pmu_ctx is valid.\nThe problem is that the WARN_ON_ONCE() could trigger after the initial\ncheck passed but before child_event->ctx was assigned, violating its\nprecondition. The solution is to assign child_event->ctx right after\nits initial validation. This ensures the context exists for any\nsubsequent checks or cleanup routines, resolving the WARN_ON_ONCE().\n\nTo resolve it, defer the refcount update and child_event->ctx assignment\ndirectly after child_event->pmu_ctx is set but before checking if the\nparent event is orphaned. The cleanup routine depends on\nevent->pmu_ctx being non-NULL before it verifies event->ctx is\nnon-NULL. This also maintains the author's original intent of passing\nin child_ctx to find_get_pmu_context before its refcount/assignment.\n\n[ mingo: Expanded the changelog from another email by Gabriel Shahrouzi. ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37890",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: hfsc: Fix a UAF vulnerability in class with netem as child qdisc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: hfsc: Fix a UAF vulnerability in class with netem as child qdisc\n\nAs described in Gerrard's report [1], we have a UAF case when an hfsc class\nhas a netem child qdisc. The crux of the issue is that hfsc is assuming\nthat checking for cl->qdisc->q.qlen == 0 guarantees that it hasn't inserted\nthe class in the vttree or eltree (which is not true for the netem\nduplicate case).\n\nThis patch checks the n_active class variable to make sure that the code\nwon't insert the class in the vttree or eltree twice, catering for the\nreentrant case.\n\n[1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37892",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mtd: inftlcore: Add error check for inftl_read_oob()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: inftlcore: Add error check for inftl_read_oob()\n\nIn INFTL_findwriteunit(), the return value of inftl_read_oob()\nneed to be checked. A proper implementation can be\nfound in INFTL_deleteblock(). The status will be set as\nSECTOR_IGNORE to break from the while-loop correctly\nif the inftl_read_oob() fails.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37903",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Fix slab-use-after-free in hdcp",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix slab-use-after-free in hdcp\n\nThe HDCP code in amdgpu_dm_hdcp.c copies pointers to amdgpu_dm_connector\nobjects without incrementing the kref reference counts. When using a\nUSB-C dock, and the dock is unplugged, the corresponding\namdgpu_dm_connector objects are freed, creating dangling pointers in the\nHDCP code. When the dock is plugged back, the dangling pointers are\ndereferenced, resulting in a slab-use-after-free:\n\n[   66.775837] BUG: KASAN: slab-use-after-free in event_property_validate+0x42f/0x6c0 [amdgpu]\n[   66.776171] Read of size 4 at addr ffff888127804120 by task kworker/0:1/10\n\n[   66.776179] CPU: 0 UID: 0 PID: 10 Comm: kworker/0:1 Not tainted 6.14.0-rc7-00180-g54505f727a38-dirty #233\n[   66.776183] Hardware name: HP HP Pavilion Aero Laptop 13-be0xxx/8916, BIOS F.17 12/18/2024\n[   66.776186] Workqueue: events event_property_validate [amdgpu]\n[   66.776494] Call Trace:\n[   66.776496]  <TASK>\n[   66.776497]  dump_stack_lvl+0x70/0xa0\n[   66.776504]  print_report+0x175/0x555\n[   66.776507]  ? __virt_addr_valid+0x243/0x450\n[   66.776510]  ? kasan_complete_mode_report_info+0x66/0x1c0\n[   66.776515]  kasan_report+0xeb/0x1c0\n[   66.776518]  ? event_property_validate+0x42f/0x6c0 [amdgpu]\n[   66.776819]  ? event_property_validate+0x42f/0x6c0 [amdgpu]\n[   66.777121]  __asan_report_load4_noabort+0x14/0x20\n[   66.777124]  event_property_validate+0x42f/0x6c0 [amdgpu]\n[   66.777342]  ? __lock_acquire+0x6b40/0x6b40\n[   66.777347]  ? enable_assr+0x250/0x250 [amdgpu]\n[   66.777571]  process_one_work+0x86b/0x1510\n[   66.777575]  ? pwq_dec_nr_in_flight+0xcf0/0xcf0\n[   66.777578]  ? assign_work+0x16b/0x280\n[   66.777580]  ? lock_is_held_type+0xa3/0x130\n[   66.777583]  worker_thread+0x5c0/0xfa0\n[   66.777587]  ? process_one_work+0x1510/0x1510\n[   66.777588]  kthread+0x3a2/0x840\n[   66.777591]  ? kthread_is_per_cpu+0xd0/0xd0\n[   66.777594]  ? trace_hardirqs_on+0x4f/0x60\n[   66.777597]  ? _raw_spin_unlock_irq+0x27/0x60\n[   66.777599]  ? calculate_sigpending+0x77/0xa0\n[   66.777602]  ? kthread_is_per_cpu+0xd0/0xd0\n[   66.777605]  ret_from_fork+0x40/0x90\n[   66.777607]  ? kthread_is_per_cpu+0xd0/0xd0\n[   66.777609]  ret_from_fork_asm+0x11/0x20\n[   66.777614]  </TASK>\n\n[   66.777643] Allocated by task 10:\n[   66.777646]  kasan_save_stack+0x39/0x60\n[   66.777649]  kasan_save_track+0x14/0x40\n[   66.777652]  kasan_save_alloc_info+0x37/0x50\n[   66.777655]  __kasan_kmalloc+0xbb/0xc0\n[   66.777658]  __kmalloc_cache_noprof+0x1c8/0x4b0\n[   66.777661]  dm_dp_add_mst_connector+0xdd/0x5c0 [amdgpu]\n[   66.777880]  drm_dp_mst_port_add_connector+0x47e/0x770 [drm_display_helper]\n[   66.777892]  drm_dp_send_link_address+0x1554/0x2bf0 [drm_display_helper]\n[   66.777901]  drm_dp_check_and_send_link_address+0x187/0x1f0 [drm_display_helper]\n[   66.777909]  drm_dp_mst_link_probe_work+0x2b8/0x410 [drm_display_helper]\n[   66.777917]  process_one_work+0x86b/0x1510\n[   66.777919]  worker_thread+0x5c0/0xfa0\n[   66.777922]  kthread+0x3a2/0x840\n[   66.777925]  ret_from_fork+0x40/0x90\n[   66.777927]  ret_from_fork_asm+0x11/0x20\n\n[   66.777932] Freed by task 1713:\n[   66.777935]  kasan_save_stack+0x39/0x60\n[   66.777938]  kasan_save_track+0x14/0x40\n[   66.777940]  kasan_save_free_info+0x3b/0x60\n[   66.777944]  __kasan_slab_free+0x52/0x70\n[   66.777946]  kfree+0x13f/0x4b0\n[   66.777949]  dm_dp_mst_connector_destroy+0xfa/0x150 [amdgpu]\n[   66.778179]  drm_connector_free+0x7d/0xb0\n[   66.778184]  drm_mode_object_put.part.0+0xee/0x160\n[   66.778188]  drm_mode_object_put+0x37/0x50\n[   66.778191]  drm_atomic_state_default_clear+0x220/0xd60\n[   66.778194]  __drm_atomic_state_free+0x16e/0x2a0\n[   66.778197]  drm_mode_atomic_ioctl+0x15ed/0x2ba0\n[   66.778200]  drm_ioctl_kernel+0x17a/0x310\n[   66.778203]  drm_ioctl+0x584/0xd10\n[   66.778206]  amdgpu_drm_ioctl+0xd2/0x1c0 [amdgpu]\n[   66.778375]  __x64_sys_ioctl+0x139/0x1a0\n[   66.778378]  x64_sys_call+0xee7/0xfb0\n[   66.778381] \n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37914",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: ets: Fix double list add in class with netem as child qdisc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: ets: Fix double list add in class with netem as child qdisc\n\nAs described in Gerrard's report [1], there are use cases where a netem\nchild qdisc will make the parent qdisc's enqueue callback reentrant.\nIn the case of ets, there won't be a UAF, but the code will add the same\nclassifier to the list twice, which will cause memory corruption.\n\nIn addition to checking for qlen being zero, this patch checks whether\nthe class was already added to the active_list (cl_is_active) before\ndoing the addition to cater for the reentrant case.\n\n[1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37930",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/nouveau: Fix WARN_ON in nouveau_fence_context_kill()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/nouveau: Fix WARN_ON in nouveau_fence_context_kill()\n\nNouveau is mostly designed in a way that it's expected that fences only\never get signaled through nouveau_fence_signal(). However, in at least\none other place, nouveau_fence_done(), can signal fences, too. If that\nhappens (race) a signaled fence remains in the pending list for a while,\nuntil it gets removed by nouveau_fence_update().\n\nShould nouveau_fence_context_kill() run in the meantime, this would be\na bug because the function would attempt to set an error code on an\nalready signaled fence.\n\nHave nouveau_fence_context_kill() check for a fence being signaled.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37951",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/v3d: Add job to pending list if the reset was skipped",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/v3d: Add job to pending list if the reset was skipped\n\nWhen a CL/CSD job times out, we check if the GPU has made any progress\nsince the last timeout. If so, instead of resetting the hardware, we skip\nthe reset and let the timer get rearmed. This gives long-running jobs a\nchance to complete.\n\nHowever, when `timedout_job()` is called, the job in question is removed\nfrom the pending list, which means it won't be automatically freed through\n`free_job()`. Consequently, when we skip the reset and keep the job\nrunning, the job won't be freed when it finally completes.\n\nThis situation leads to a memory leak, as exposed in [1] and [2].\n\nSimilarly to commit 704d3d60fec4 (\"drm/etnaviv: don't block scheduler when\nGPU is still active\"), this patch ensures the job is put back on the\npending list when extending the timeout.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37968",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: light: opt3001: fix deadlock due to concurrent flag access",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: light: opt3001: fix deadlock due to concurrent flag access\n\nThe threaded IRQ function in this driver is reading the flag twice: once to\nlock a mutex and once to unlock it. Even though the code setting the flag\nis designed to prevent it, there are subtle cases where the flag could be\ntrue at the mutex_lock stage and false at the mutex_unlock stage. This\nresults in the mutex not being unlocked, resulting in a deadlock.\n\nFix it by making the opt3001_irq() code generally more robust, reading the\nflag into a variable and using the variable value at both stages.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37969",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: imu: st_lsm6dsx: fix possible lockup in st_lsm6dsx_read_tagged_fifo",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: imu: st_lsm6dsx: fix possible lockup in st_lsm6dsx_read_tagged_fifo\n\nPrevent st_lsm6dsx_read_tagged_fifo from falling in an infinite loop in\ncase pattern_len is equal to zero and the device FIFO is not empty.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37970",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: iio: imu: st_lsm6dsx: fix possible lockup in st_lsm6dsx_read_fifo",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: imu: st_lsm6dsx: fix possible lockup in st_lsm6dsx_read_fifo\n\nPrevent st_lsm6dsx_read_fifo from falling in an infinite loop in case\npattern_len is equal to zero and the device FIFO is not empty.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37982",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: wl1251: fix memory leak in wl1251_tx_work",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wl1251: fix memory leak in wl1251_tx_work\n\nThe skb dequeued from tx_queue is lost when wl1251_ps_elp_wakeup fails\nwith a -ETIMEDOUT error. Fix that by queueing the skb back to tx_queue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37989",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: phy: leds: fix memory leak",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phy: leds: fix memory leak\n\nA network restart test on a router led to an out-of-memory condition,\nwhich was traced to a memory leak in the PHY LED trigger code.\n\nThe root cause is misuse of the devm API. The registration function\n(phy_led_triggers_register) is called from phy_attach_direct, not\nphy_probe, and the unregister function (phy_led_triggers_unregister)\nis called from phy_detach, not phy_remove. This means the register and\nunregister functions can be called multiple times for the same PHY\ndevice, but devm-allocated memory is not freed until the driver is\nunbound.\n\nThis also prevents kmemleak from detecting the leak, as the devm API\ninternally stores the allocated pointer.\n\nFix this by replacing devm_kzalloc/devm_kcalloc with standard\nkzalloc/kcalloc, and add the corresponding kfree calls in the unregister\npath.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37991",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: parisc: Fix double SIGFPE crash",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Fix double SIGFPE crash\n\nCamm noticed that on parisc a SIGFPE exception will crash an application with\na second SIGFPE in the signal handler.  Dave analyzed it, and it happens\nbecause glibc uses a double-word floating-point store to atomically update\nfunction descriptors. As a result of lazy binding, we hit a floating-point\nstore in fpe_func almost immediately.\n\nWhen the T bit is set, an assist exception trap occurs when when the\nco-processor encounters *any* floating-point instruction except for a double\nstore of register %fr0.  The latter cancels all pending traps.  Let's fix this\nby clearing the Trap (T) bit in the FP status register before returning to the\nsignal handler in userspace.\n\nThe issue can be reproduced with this test program:\n\nroot@parisc:~# cat fpe.c\n\nstatic void fpe_func(int sig, siginfo_t *i, void *v) {\n        sigset_t set;\n        sigemptyset(&set);\n        sigaddset(&set, SIGFPE);\n        sigprocmask(SIG_UNBLOCK, &set, NULL);\n        printf(\"GOT signal %d with si_code %ld\\n\", sig, i->si_code);\n}\n\nint main() {\n        struct sigaction action = {\n                .sa_sigaction = fpe_func,\n                .sa_flags = SA_RESTART|SA_SIGINFO };\n        sigaction(SIGFPE, &action, 0);\n        feenableexcept(FE_OVERFLOW);\n        return printf(\"%lf\\n\",1.7976931348623158E308*1.7976931348623158E308);\n}\n\nroot@parisc:~# gcc fpe.c -lm\nroot@parisc:~# ./a.out\n Floating point exception\n\nroot@parisc:~# strace -f ./a.out\n execve(\"./a.out\", [\"./a.out\"], 0xf9ac7034 /* 20 vars */) = 0\n getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0\n ...\n rt_sigaction(SIGFPE, {sa_handler=0x1110a, sa_mask=[], sa_flags=SA_RESTART|SA_SIGINFO}, NULL, 8) = 0\n --- SIGFPE {si_signo=SIGFPE, si_code=FPE_FLTOVF, si_addr=0x1078f} ---\n --- SIGFPE {si_signo=SIGFPE, si_code=FPE_FLTOVF, si_addr=0xf8f21237} ---\n +++ killed by SIGFPE +++\n Floating point exception",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37995",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: module: ensure that kobject_put() is safe for module type kobjects",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmodule: ensure that kobject_put() is safe for module type kobjects\n\nIn 'lookup_or_create_module_kobject()', an internal kobject is created\nusing 'module_ktype'. So call to 'kobject_put()' on error handling\npath causes an attempt to use an uninitialized completion pointer in\n'module_kobject_release()'. In this scenario, we just want to release\nkobject without an extra synchronization required for a regular module\nunloading process, so adding an extra check whether 'complete()' is\nactually required makes 'kobject_put()' safe.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-37997",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: ipset: fix region locking in hash types",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: ipset: fix region locking in hash types\n\nRegion locking introduced in v5.6-rc4 contained three macros to handle\nthe region locks: ahash_bucket_start(), ahash_bucket_end() which gave\nback the start and end hash bucket values belonging to a given region\nlock and ahash_region() which should give back the region lock belonging\nto a given hash bucket. The latter was incorrect which can lead to a\nrace condition between the garbage collector and adding new elements\nwhen a hash type of set is defined with timeouts.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38000",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue()\n\nWhen enqueuing the first packet to an HFSC class, hfsc_enqueue() calls the\nchild qdisc's peek() operation before incrementing sch->q.qlen and\nsch->qstats.backlog. If the child qdisc uses qdisc_peek_dequeued(), this may\ntrigger an immediate dequeue and potential packet drop. In such cases,\nqdisc_tree_reduce_backlog() is called, but the HFSC qdisc's qlen and backlog\nhave not yet been updated, leading to inconsistent queue accounting. This\ncan leave an empty HFSC class in the active list, causing further\nconsequences like use-after-free.\n\nThis patch fixes the bug by moving the increment of sch->q.qlen and\nsch->qstats.backlog before the call to the child qdisc's peek() operation.\nThis ensures that queue length and backlog are always accurate when packet\ndrops or dequeues are triggered during the peek.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38001",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: hfsc: Address reentrant enqueue adding class to eltree twice",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: hfsc: Address reentrant enqueue adding class to eltree twice\n\nSavino says:\n    \"We are writing to report that this recent patch\n    (141d34391abbb315d68556b7c67ad97885407547) [1]\n    can be bypassed, and a UAF can still occur when HFSC is utilized with\n    NETEM.\n\n    The patch only checks the cl->cl_nactive field to determine whether\n    it is the first insertion or not [2], but this field is only\n    incremented by init_vf [3].\n\n    By using HFSC_RSC (which uses init_ed) [4], it is possible to bypass the\n    check and insert the class twice in the eltree.\n    Under normal conditions, this would lead to an infinite loop in\n    hfsc_dequeue for the reasons we already explained in this report [5].\n\n    However, if TBF is added as root qdisc and it is configured with a\n    very low rate,\n    it can be utilized to prevent packets from being dequeued.\n    This behavior can be exploited to perform subsequent insertions in the\n    HFSC eltree and cause a UAF.\"\n\nTo fix both the UAF and the infinite loop, with netem as an hfsc child,\ncheck explicitly in hfsc_enqueue whether the class is already in the eltree\nwhenever the HFSC_RSC flag is set.\n\n[1] https://web.git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=141d34391abbb315d68556b7c67ad97885407547\n[2] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L1572\n[3] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L677\n[4] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L1574\n[5] https://lore.kernel.org/netdev/8DuRWwfqjoRDLDmBMlIfbrsZg9Gx50DHJc1ilxsEBNe2D6NMoigR_eIRIG0LOjMc3r10nUUZtArXx4oZBIdUfZQrwjcQhdinnMis_0G7VEk=@willsroot.io/T/#u",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38003",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: can: bcm: add missing rcu read protection for procfs content",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: bcm: add missing rcu read protection for procfs content\n\nWhen the procfs content is generated for a bcm_op which is in the process\nto be removed the procfs output might show unreliable data (UAF).\n\nAs the removal of bcm_op's is already implemented with rcu handling this\npatch adds the missing rcu_read_lock() and makes sure the list entries\nare properly removed under rcu protection.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38004",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: can: bcm: add locking for bcm_op runtime updates",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: bcm: add locking for bcm_op runtime updates\n\nThe CAN broadcast manager (CAN BCM) can send a sequence of CAN frames via\nhrtimer. The content and also the length of the sequence can be changed\nresp reduced at runtime where the 'currframe' counter is then set to zero.\n\nAlthough this appeared to be a safe operation the updates of 'currframe'\ncan be triggered from user space and hrtimer context in bcm_can_tx().\nAnderson Nascimento created a proof of concept that triggered a KASAN\nslab-out-of-bounds read access which can be prevented with a spin_lock_bh.\n\nAt the rework of bcm_can_tx() the 'count' variable has been moved into\nthe protected section as this variable can be modified from both contexts\ntoo.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38005",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dmaengine: ti: k3-udma: Add missing locking",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: ti: k3-udma: Add missing locking\n\nRecent kernels complain about a missing lock in k3-udma.c when the lock\nvalidator is enabled:\n\n[    4.128073] WARNING: CPU: 0 PID: 746 at drivers/dma/ti/../virt-dma.h:169 udma_start.isra.0+0x34/0x238\n[    4.137352] CPU: 0 UID: 0 PID: 746 Comm: kworker/0:3 Not tainted 6.12.9-arm64 #28\n[    4.144867] Hardware name: pp-v12 (DT)\n[    4.148648] Workqueue: events udma_check_tx_completion\n[    4.153841] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    4.160834] pc : udma_start.isra.0+0x34/0x238\n[    4.165227] lr : udma_start.isra.0+0x30/0x238\n[    4.169618] sp : ffffffc083cabcf0\n[    4.172963] x29: ffffffc083cabcf0 x28: 0000000000000000 x27: ffffff800001b005\n[    4.180167] x26: ffffffc0812f0000 x25: 0000000000000000 x24: 0000000000000000\n[    4.187370] x23: 0000000000000001 x22: 00000000e21eabe9 x21: ffffff8000fa0670\n[    4.194571] x20: ffffff8001b6bf00 x19: ffffff8000fa0430 x18: ffffffc083b95030\n[    4.201773] x17: 0000000000000000 x16: 00000000f0000000 x15: 0000000000000048\n[    4.208976] x14: 0000000000000048 x13: 0000000000000000 x12: 0000000000000001\n[    4.216179] x11: ffffffc08151a240 x10: 0000000000003ea1 x9 : ffffffc08046ab68\n[    4.223381] x8 : ffffffc083cabac0 x7 : ffffffc081df3718 x6 : 0000000000029fc8\n[    4.230583] x5 : ffffffc0817ee6d8 x4 : 0000000000000bc0 x3 : 0000000000000000\n[    4.237784] x2 : 0000000000000000 x1 : 00000000001fffff x0 : 0000000000000000\n[    4.244986] Call trace:\n[    4.247463]  udma_start.isra.0+0x34/0x238\n[    4.251509]  udma_check_tx_completion+0xd0/0xdc\n[    4.256076]  process_one_work+0x244/0x3fc\n[    4.260129]  process_scheduled_works+0x6c/0x74\n[    4.264610]  worker_thread+0x150/0x1dc\n[    4.268398]  kthread+0xd8/0xe8\n[    4.271492]  ret_from_fork+0x10/0x20\n[    4.275107] irq event stamp: 220\n[    4.278363] hardirqs last  enabled at (219): [<ffffffc080a27c7c>] _raw_spin_unlock_irq+0x38/0x50\n[    4.287183] hardirqs last disabled at (220): [<ffffffc080a1c154>] el1_dbg+0x24/0x50\n[    4.294879] softirqs last  enabled at (182): [<ffffffc080037e68>] handle_softirqs+0x1c0/0x3cc\n[    4.303437] softirqs last disabled at (177): [<ffffffc080010170>] __do_softirq+0x1c/0x28\n[    4.311559] ---[ end trace 0000000000000000 ]---\n\nThis commit adds the missing locking.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38022",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/core: Fix \"KASAN: slab-use-after-free Read in ib_register_device\" problem",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/core: Fix \"KASAN: slab-use-after-free Read in ib_register_device\" problem\n\nCall Trace:\n\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xc3/0x670 mm/kasan/report.c:521\n kasan_report+0xe0/0x110 mm/kasan/report.c:634\n strlen+0x93/0xa0 lib/string.c:420\n __fortify_strlen include/linux/fortify-string.h:268 [inline]\n get_kobj_path_length lib/kobject.c:118 [inline]\n kobject_get_path+0x3f/0x2a0 lib/kobject.c:158\n kobject_uevent_env+0x289/0x1870 lib/kobject_uevent.c:545\n ib_register_device drivers/infiniband/core/device.c:1472 [inline]\n ib_register_device+0x8cf/0xe00 drivers/infiniband/core/device.c:1393\n rxe_register_device+0x275/0x320 drivers/infiniband/sw/rxe/rxe_verbs.c:1552\n rxe_net_add+0x8e/0xe0 drivers/infiniband/sw/rxe/rxe_net.c:550\n rxe_newlink+0x70/0x190 drivers/infiniband/sw/rxe/rxe.c:225\n nldev_newlink+0x3a3/0x680 drivers/infiniband/core/nldev.c:1796\n rdma_nl_rcv_msg+0x387/0x6e0 drivers/infiniband/core/netlink.c:195\n rdma_nl_rcv_skb.constprop.0.isra.0+0x2e5/0x450\n netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]\n netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339\n netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n ____sys_sendmsg+0xa95/0xc70 net/socket.c:2566\n ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620\n __sys_sendmsg+0x16d/0x220 net/socket.c:2652\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x260 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nThis problem is similar to the problem that the\ncommit 1d6a9e7449e2 (\"RDMA/core: Fix use-after-free when rename device name\")\nfixes.\n\nThe root cause is: the function ib_device_rename() renames the name with\nlock. But in the function kobject_uevent(), this name is accessed without\nlock protection at the same time.\n\nThe solution is to add the lock protection when this name is accessed in\nthe function kobject_uevent().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38023",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfs: handle failure of nfs_get_lock_context in unlock path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfs: handle failure of nfs_get_lock_context in unlock path\n\nWhen memory is insufficient, the allocation of nfs_lock_context in\nnfs_get_lock_context() fails and returns -ENOMEM. If we mistakenly treat\nan nfs4_unlockdata structure (whose l_ctx member has been set to -ENOMEM)\nas valid and proceed to execute rpc_run_task(), this will trigger a NULL\npointer dereference in nfs4_locku_prepare. For example:\n\nBUG: kernel NULL pointer dereference, address: 000000000000000c\nPGD 0 P4D 0\nOops: Oops: 0000 [#1] SMP PTI\nCPU: 15 UID: 0 PID: 12 Comm: kworker/u64:0 Not tainted 6.15.0-rc2-dirty #60\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40\nWorkqueue: rpciod rpc_async_schedule\nRIP: 0010:nfs4_locku_prepare+0x35/0xc2\nCode: 89 f2 48 89 fd 48 c7 c7 68 69 ef b5 53 48 8b 8e 90 00 00 00 48 89 f3\nRSP: 0018:ffffbbafc006bdb8 EFLAGS: 00010246\nRAX: 000000000000004b RBX: ffff9b964fc1fa00 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: fffffffffffffff4 RDI: ffff9ba53fddbf40\nRBP: ffff9ba539934000 R08: 0000000000000000 R09: ffffbbafc006bc38\nR10: ffffffffb6b689c8 R11: 0000000000000003 R12: ffff9ba539934030\nR13: 0000000000000001 R14: 0000000004248060 R15: ffffffffb56d1c30\nFS: 0000000000000000(0000) GS:ffff9ba5881f0000(0000) knlGS:00000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000000000000c CR3: 000000093f244000 CR4: 00000000000006f0\nCall Trace:\n <TASK>\n __rpc_execute+0xbc/0x480\n rpc_async_schedule+0x2f/0x40\n process_one_work+0x232/0x5d0\n worker_thread+0x1da/0x3d0\n ? __pfx_worker_thread+0x10/0x10\n kthread+0x10d/0x240\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x34/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\nModules linked in:\nCR2: 000000000000000c\n---[ end trace 0000000000000000 ]---\n\nFree the allocated nfs4_unlockdata when nfs_get_lock_context() fails and\nreturn NULL to terminate subsequent rpc_run_task, preventing NULL pointer\ndereference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38024",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/rxe: Fix slab-use-after-free Read in rxe_queue_cleanup bug",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix slab-use-after-free Read in rxe_queue_cleanup bug\n\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x7d/0xa0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xcf/0x610 mm/kasan/report.c:489\n kasan_report+0xb5/0xe0 mm/kasan/report.c:602\n rxe_queue_cleanup+0xd0/0xe0 drivers/infiniband/sw/rxe/rxe_queue.c:195\n rxe_cq_cleanup+0x3f/0x50 drivers/infiniband/sw/rxe/rxe_cq.c:132\n __rxe_cleanup+0x168/0x300 drivers/infiniband/sw/rxe/rxe_pool.c:232\n rxe_create_cq+0x22e/0x3a0 drivers/infiniband/sw/rxe/rxe_verbs.c:1109\n create_cq+0x658/0xb90 drivers/infiniband/core/uverbs_cmd.c:1052\n ib_uverbs_create_cq+0xc7/0x120 drivers/infiniband/core/uverbs_cmd.c:1095\n ib_uverbs_write+0x969/0xc90 drivers/infiniband/core/uverbs_main.c:679\n vfs_write fs/read_write.c:677 [inline]\n vfs_write+0x26a/0xcc0 fs/read_write.c:659\n ksys_write+0x1b8/0x200 fs/read_write.c:731\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xaa/0x1b0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nIn the function rxe_create_cq, when rxe_cq_from_init fails, the function\nrxe_cleanup will be called to handle the allocated resources. In fact,\nsome memory resources have already been freed in the function\nrxe_cq_from_init. Thus, this problem will occur.\n\nThe solution is to let rxe_cleanup do all the work.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38029",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: kasan: avoid sleepable page allocation from atomic context",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkasan: avoid sleepable page allocation from atomic context\n\napply_to_pte_range() enters the lazy MMU mode and then invokes\nkasan_populate_vmalloc_pte() callback on each page table walk iteration. \nHowever, the callback can go into sleep when trying to allocate a single\npage, e.g.  if an architecutre disables preemption on lazy MMU mode enter.\n\nOn s390 if make arch_enter_lazy_mmu_mode() -> preempt_enable() and\narch_leave_lazy_mmu_mode() -> preempt_disable(), such crash occurs:\n\n[    0.663336] BUG: sleeping function called from invalid context at ./include/linux/sched/mm.h:321\n[    0.663348] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2, name: kthreadd\n[    0.663358] preempt_count: 1, expected: 0\n[    0.663366] RCU nest depth: 0, expected: 0\n[    0.663375] no locks held by kthreadd/2.\n[    0.663383] Preemption disabled at:\n[    0.663386] [<0002f3284cbb4eda>] apply_to_pte_range+0xfa/0x4a0\n[    0.663405] CPU: 0 UID: 0 PID: 2 Comm: kthreadd Not tainted 6.15.0-rc5-gcc-kasan-00043-gd76bb1ebb558-dirty #162 PREEMPT\n[    0.663408] Hardware name: IBM 3931 A01 701 (KVM/Linux)\n[    0.663409] Call Trace:\n[    0.663410]  [<0002f3284c385f58>] dump_stack_lvl+0xe8/0x140\n[    0.663413]  [<0002f3284c507b9e>] __might_resched+0x66e/0x700\n[    0.663415]  [<0002f3284cc4f6c0>] __alloc_frozen_pages_noprof+0x370/0x4b0\n[    0.663419]  [<0002f3284ccc73c0>] alloc_pages_mpol+0x1a0/0x4a0\n[    0.663421]  [<0002f3284ccc8518>] alloc_frozen_pages_noprof+0x88/0xc0\n[    0.663424]  [<0002f3284ccc8572>] alloc_pages_noprof+0x22/0x120\n[    0.663427]  [<0002f3284cc341ac>] get_free_pages_noprof+0x2c/0xc0\n[    0.663429]  [<0002f3284cceba70>] kasan_populate_vmalloc_pte+0x50/0x120\n[    0.663433]  [<0002f3284cbb4ef8>] apply_to_pte_range+0x118/0x4a0\n[    0.663435]  [<0002f3284cbc7c14>] apply_to_pmd_range+0x194/0x3e0\n[    0.663437]  [<0002f3284cbc99be>] __apply_to_page_range+0x2fe/0x7a0\n[    0.663440]  [<0002f3284cbc9e88>] apply_to_page_range+0x28/0x40\n[    0.663442]  [<0002f3284ccebf12>] kasan_populate_vmalloc+0x82/0xa0\n[    0.663445]  [<0002f3284cc1578c>] alloc_vmap_area+0x34c/0xc10\n[    0.663448]  [<0002f3284cc1c2a6>] __get_vm_area_node+0x186/0x2a0\n[    0.663451]  [<0002f3284cc1e696>] __vmalloc_node_range_noprof+0x116/0x310\n[    0.663454]  [<0002f3284cc1d950>] __vmalloc_node_noprof+0xd0/0x110\n[    0.663457]  [<0002f3284c454b88>] alloc_thread_stack_node+0xf8/0x330\n[    0.663460]  [<0002f3284c458d56>] dup_task_struct+0x66/0x4d0\n[    0.663463]  [<0002f3284c45be90>] copy_process+0x280/0x4b90\n[    0.663465]  [<0002f3284c460940>] kernel_clone+0xd0/0x4b0\n[    0.663467]  [<0002f3284c46115e>] kernel_thread+0xbe/0xe0\n[    0.663469]  [<0002f3284c4e440e>] kthreadd+0x50e/0x7f0\n[    0.663472]  [<0002f3284c38c04a>] __ret_from_fork+0x8a/0xf0\n[    0.663475]  [<0002f3284ed57ff2>] ret_from_fork+0xa/0x38\n\nInstead of allocating single pages per-PTE, bulk-allocate the shadow\nmemory prior to applying kasan_populate_vmalloc_pte() callback on a page\nrange.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38041",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: clk: sunxi-ng: h616: Reparent GPU clock during frequency changes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: sunxi-ng: h616: Reparent GPU clock during frequency changes\n\nThe H616 manual does not state that the GPU PLL supports\ndynamic frequency configuration, so we must take extra care when changing\nthe frequency. Currently any attempt to do device DVFS on the GPU lead\nto panfrost various ooops, and GPU hangs.\n\nThe manual describes the algorithm for changing the PLL\nfrequency, which the CPU PLL notifier code already support, so we reuse\nthat to reparent the GPU clock to GPU1 clock during frequency\nchanges.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38042",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dmaengine: ti: k3-udma-glue: Drop skip_fdq argument from k3_udma_glue_reset_rx_chn",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: ti: k3-udma-glue: Drop skip_fdq argument from k3_udma_glue_reset_rx_chn\n\nThe user of k3_udma_glue_reset_rx_chn() e.g. ti_am65_cpsw_nuss can\nrun on multiple platforms having different DMA architectures.\nOn some platforms there can be one FDQ for all flows in the RX channel\nwhile for others there is a separate FDQ for each flow in the RX channel.\n\nSo far we have been relying on the skip_fdq argument of\nk3_udma_glue_reset_rx_chn().\n\nInstead of relying on the user to provide this information, infer it\nbased on DMA architecture during k3_udma_glue_request_rx_chn() and save it\nin an internal flag 'single_fdq'. Use that flag at\nk3_udma_glue_reset_rx_chn() to deicide if the FDQ needs\nto be cleared for every flow or just for flow 0.\n\nFixes the below issue on ti_am65_cpsw_nuss driver on AM62-SK.\n\n> ip link set eth1 down\n> ip link set eth0 down\n> ethtool -L eth0 rx 8\n> ip link set eth0 up\n> modprobe -r ti_am65_cpsw_nuss\n\n[  103.045726] ------------[ cut here ]------------\n[  103.050505] k3_knav_desc_pool size 512000 != avail 64000\n[  103.050703] WARNING: CPU: 1 PID: 450 at drivers/net/ethernet/ti/k3-cppi-desc-pool.c:33 k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool]\n[  103.068810] Modules linked in: ti_am65_cpsw_nuss(-) k3_cppi_desc_pool snd_soc_hdmi_codec crct10dif_ce snd_soc_simple_card snd_soc_simple_card_utils display_connector rtc_ti_k3 k3_j72xx_bandgap tidss drm_client_lib snd_soc_davinci_mcas\np drm_dma_helper tps6598x phylink snd_soc_ti_udma rti_wdt drm_display_helper snd_soc_tlv320aic3x_i2c typec at24 phy_gmii_sel snd_soc_ti_edma snd_soc_tlv320aic3x sii902x snd_soc_ti_sdma sa2ul omap_mailbox drm_kms_helper authenc cfg80211 r\nfkill fuse drm drm_panel_orientation_quirks backlight ip_tables x_tables ipv6 [last unloaded: k3_cppi_desc_pool]\n[  103.119950] CPU: 1 UID: 0 PID: 450 Comm: modprobe Not tainted 6.13.0-rc7-00001-g9c5e3435fa66 #1011\n[  103.119968] Hardware name: Texas Instruments AM625 SK (DT)\n[  103.119974] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  103.119983] pc : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool]\n[  103.148007] lr : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool]\n[  103.154709] sp : ffff8000826ebbc0\n[  103.158015] x29: ffff8000826ebbc0 x28: ffff0000090b6300 x27: 0000000000000000\n[  103.165145] x26: 0000000000000000 x25: 0000000000000000 x24: ffff0000019df6b0\n[  103.172271] x23: ffff0000019df6b8 x22: ffff0000019df410 x21: ffff8000826ebc88\n[  103.179397] x20: 000000000007d000 x19: ffff00000a3b3000 x18: 0000000000000000\n[  103.186522] x17: 0000000000000000 x16: 0000000000000000 x15: 000001e8c35e1cde\n[  103.193647] x14: 0000000000000396 x13: 000000000000035c x12: 0000000000000000\n[  103.200772] x11: 000000000000003a x10: 00000000000009c0 x9 : ffff8000826eba20\n[  103.207897] x8 : ffff0000090b6d20 x7 : ffff00007728c180 x6 : ffff00007728c100\n[  103.215022] x5 : 0000000000000001 x4 : ffff000000508a50 x3 : ffff7ffff6146000\n[  103.222147] x2 : 0000000000000000 x1 : e300b4173ee6b200 x0 : 0000000000000000\n[  103.229274] Call trace:\n[  103.231714]  k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] (P)\n[  103.238408]  am65_cpsw_nuss_free_rx_chns+0x28/0x4c [ti_am65_cpsw_nuss]\n[  103.244942]  devm_action_release+0x14/0x20\n[  103.249040]  release_nodes+0x3c/0x68\n[  103.252610]  devres_release_all+0x8c/0xdc\n[  103.256614]  device_unbind_cleanup+0x18/0x60\n[  103.260876]  device_release_driver_internal+0xf8/0x178\n[  103.266004]  driver_detach+0x50/0x9c\n[  103.269571]  bus_remove_driver+0x6c/0xbc\n[  103.273485]  driver_unregister+0x30/0x60\n[  103.277401]  platform_driver_unregister+0x14/0x20\n[  103.282096]  am65_cpsw_nuss_driver_exit+0x18/0xff4 [ti_am65_cpsw_nuss]\n[  103.288620]  __arm64_sys_delete_module+0x17c/0x25c\n[  103.293404]  invoke_syscall+0x44/0x100\n[  103.297149]  el0_svc_common.constprop.0+0xc0/0xe0\n[  103.301845]  do_el0_svc+0x1c/0x28\n[  103.305155]  el0_svc+0x28/0x98\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38045",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: fix debug actions order",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: fix debug actions order\n\nThe order of actions taken for debug was implemented incorrectly.\nNow we implemented the dump split and do the FW reset only in the\nmiddle of the dump (rather than the FW killing itself on error.)\nAs a result, some of the actions taken when applying the config\nwill now crash the device, so we need to fix the order.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38048",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: virtio_ring: Fix data race by tagging event_triggered as racy for KCSAN",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_ring: Fix data race by tagging event_triggered as racy for KCSAN\n\nsyzbot reports a data-race when accessing the event_triggered, here is the\nsimplified stack when the issue occurred:\n\n==================================================================\nBUG: KCSAN: data-race in virtqueue_disable_cb / virtqueue_enable_cb_delayed\n\nwrite to 0xffff8881025bc452 of 1 bytes by task 3288 on cpu 0:\n virtqueue_enable_cb_delayed+0x42/0x3c0 drivers/virtio/virtio_ring.c:2653\n start_xmit+0x230/0x1310 drivers/net/virtio_net.c:3264\n __netdev_start_xmit include/linux/netdevice.h:5151 [inline]\n netdev_start_xmit include/linux/netdevice.h:5160 [inline]\n xmit_one net/core/dev.c:3800 [inline]\n\nread to 0xffff8881025bc452 of 1 bytes by interrupt on cpu 1:\n virtqueue_disable_cb_split drivers/virtio/virtio_ring.c:880 [inline]\n virtqueue_disable_cb+0x92/0x180 drivers/virtio/virtio_ring.c:2566\n skb_xmit_done+0x5f/0x140 drivers/net/virtio_net.c:777\n vring_interrupt+0x161/0x190 drivers/virtio/virtio_ring.c:2715\n __handle_irq_event_percpu+0x95/0x490 kernel/irq/handle.c:158\n handle_irq_event_percpu kernel/irq/handle.c:193 [inline]\n\nvalue changed: 0x01 -> 0x00\n==================================================================\n\nWhen the data race occurs, the function virtqueue_enable_cb_delayed() sets\nevent_triggered to false, and virtqueue_disable_cb_split/packed() reads it\nas false due to the race condition. Since event_triggered is an unreliable\nhint used for optimization, this should only cause the driver temporarily\nsuggest that the device not send an interrupt notification when the event\nindex is used.\n\nFix this KCSAN reported data-race issue by explicitly tagging the access as\ndata_racy.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38051",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: Fix use-after-free in cifs_fill_dirent",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: Fix use-after-free in cifs_fill_dirent\n\nThere is a race condition in the readdir concurrency process, which may\naccess the rsp buffer after it has been released, triggering the\nfollowing KASAN warning.\n\n ==================================================================\n BUG: KASAN: slab-use-after-free in cifs_fill_dirent+0xb03/0xb60 [cifs]\n Read of size 4 at addr ffff8880099b819c by task a.out/342975\n\n CPU: 2 UID: 0 PID: 342975 Comm: a.out Not tainted 6.15.0-rc6+ #240 PREEMPT(full)\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x53/0x70\n  print_report+0xce/0x640\n  kasan_report+0xb8/0xf0\n  cifs_fill_dirent+0xb03/0xb60 [cifs]\n  cifs_readdir+0x12cb/0x3190 [cifs]\n  iterate_dir+0x1a1/0x520\n  __x64_sys_getdents+0x134/0x220\n  do_syscall_64+0x4b/0x110\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n RIP: 0033:0x7f996f64b9f9\n Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89\n f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01\n f0 ff ff  0d f7 c3 0c 00 f7 d8 64 89 8\n RSP: 002b:00007f996f53de78 EFLAGS: 00000207 ORIG_RAX: 000000000000004e\n RAX: ffffffffffffffda RBX: 00007f996f53ecdc RCX: 00007f996f64b9f9\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\n RBP: 00007f996f53dea0 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000207 R12: ffffffffffffff88\n R13: 0000000000000000 R14: 00007ffc8cd9a500 R15: 00007f996f51e000\n  </TASK>\n\n Allocated by task 408:\n  kasan_save_stack+0x20/0x40\n  kasan_save_track+0x14/0x30\n  __kasan_slab_alloc+0x6e/0x70\n  kmem_cache_alloc_noprof+0x117/0x3d0\n  mempool_alloc_noprof+0xf2/0x2c0\n  cifs_buf_get+0x36/0x80 [cifs]\n  allocate_buffers+0x1d2/0x330 [cifs]\n  cifs_demultiplex_thread+0x22b/0x2690 [cifs]\n  kthread+0x394/0x720\n  ret_from_fork+0x34/0x70\n  ret_from_fork_asm+0x1a/0x30\n\n Freed by task 342979:\n  kasan_save_stack+0x20/0x40\n  kasan_save_track+0x14/0x30\n  kasan_save_free_info+0x3b/0x60\n  __kasan_slab_free+0x37/0x50\n  kmem_cache_free+0x2b8/0x500\n  cifs_buf_release+0x3c/0x70 [cifs]\n  cifs_readdir+0x1c97/0x3190 [cifs]\n  iterate_dir+0x1a1/0x520\n  __x64_sys_getdents64+0x134/0x220\n  do_syscall_64+0x4b/0x110\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n The buggy address belongs to the object at ffff8880099b8000\n  which belongs to the cache cifs_request of size 16588\n The buggy address is located 412 bytes inside of\n  freed 16588-byte region [ffff8880099b8000, ffff8880099bc0cc)\n\n The buggy address belongs to the physical page:\n page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x99b8\n head: order:3 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n anon flags: 0x80000000000040(head|node=0|zone=1)\n page_type: f5(slab)\n raw: 0080000000000040 ffff888001e03400 0000000000000000 dead000000000001\n raw: 0000000000000000 0000000000010001 00000000f5000000 0000000000000000\n head: 0080000000000040 ffff888001e03400 0000000000000000 dead000000000001\n head: 0000000000000000 0000000000010001 00000000f5000000 0000000000000000\n head: 0080000000000003 ffffea0000266e01 00000000ffffffff 00000000ffffffff\n head: ffffffffffffffff 0000000000000000 00000000ffffffff 0000000000000008\n page dumped because: kasan: bad access detected\n\n Memory state around the buggy address:\n  ffff8880099b8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff8880099b8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n >ffff8880099b8180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                             ^\n  ffff8880099b8200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff8880099b8280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ==================================================================\n\nPOC is available in the link [1].\n\nThe problem triggering process is as follows:\n\nProcess 1                       Process 2\n-----------------------------------\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38052",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/tipc: fix slab-use-after-free Read in tipc_aead_encrypt_done",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/tipc: fix slab-use-after-free Read in tipc_aead_encrypt_done\n\nSyzbot reported a slab-use-after-free with the following call trace:\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in tipc_aead_encrypt_done+0x4bd/0x510 net/tipc/crypto.c:840\n  Read of size 8 at addr ffff88807a733000 by task kworker/1:0/25\n\n  Call Trace:\n   kasan_report+0xd9/0x110 mm/kasan/report.c:601\n   tipc_aead_encrypt_done+0x4bd/0x510 net/tipc/crypto.c:840\n   crypto_request_complete include/crypto/algapi.h:266\n   aead_request_complete include/crypto/internal/aead.h:85\n   cryptd_aead_crypt+0x3b8/0x750 crypto/cryptd.c:772\n   crypto_request_complete include/crypto/algapi.h:266\n   cryptd_queue_worker+0x131/0x200 crypto/cryptd.c:181\n   process_one_work+0x9fb/0x1b60 kernel/workqueue.c:3231\n\n  Allocated by task 8355:\n   kzalloc_noprof include/linux/slab.h:778\n   tipc_crypto_start+0xcc/0x9e0 net/tipc/crypto.c:1466\n   tipc_init_net+0x2dd/0x430 net/tipc/core.c:72\n   ops_init+0xb9/0x650 net/core/net_namespace.c:139\n   setup_net+0x435/0xb40 net/core/net_namespace.c:343\n   copy_net_ns+0x2f0/0x670 net/core/net_namespace.c:508\n   create_new_namespaces+0x3ea/0xb10 kernel/nsproxy.c:110\n   unshare_nsproxy_namespaces+0xc0/0x1f0 kernel/nsproxy.c:228\n   ksys_unshare+0x419/0x970 kernel/fork.c:3323\n   __do_sys_unshare kernel/fork.c:3394\n\n  Freed by task 63:\n   kfree+0x12a/0x3b0 mm/slub.c:4557\n   tipc_crypto_stop+0x23c/0x500 net/tipc/crypto.c:1539\n   tipc_exit_net+0x8c/0x110 net/tipc/core.c:119\n   ops_exit_list+0xb0/0x180 net/core/net_namespace.c:173\n   cleanup_net+0x5b7/0xbf0 net/core/net_namespace.c:640\n   process_one_work+0x9fb/0x1b60 kernel/workqueue.c:3231\n\nAfter freed the tipc_crypto tx by delete namespace, tipc_aead_encrypt_done\nmay still visit it in cryptd_queue_worker workqueue.\n\nI reproduce this issue by:\n  ip netns add ns1\n  ip link add veth1 type veth peer name veth2\n  ip link set veth1 netns ns1\n  ip netns exec ns1 tipc bearer enable media eth dev veth1\n  ip netns exec ns1 tipc node set key this_is_a_master_key master\n  ip netns exec ns1 tipc bearer disable media eth dev veth1\n  ip netns del ns1\n\nThe key of reproduction is that, simd_aead_encrypt is interrupted, leading\nto crypto_simd_usable() return false. Thus, the cryptd_queue_worker is\ntriggered, and the tipc_crypto tx will be visited.\n\n  tipc_disc_timeout\n    tipc_bearer_xmit_skb\n      tipc_crypto_xmit\n        tipc_aead_encrypt\n          crypto_aead_encrypt\n            // encrypt()\n            simd_aead_encrypt\n              // crypto_simd_usable() is false\n              child = &ctx->cryptd_tfm->base;\n\n  simd_aead_encrypt\n    crypto_aead_encrypt\n      // encrypt()\n      cryptd_aead_encrypt_enqueue\n        cryptd_aead_enqueue\n          cryptd_enqueue_request\n            // trigger cryptd_queue_worker\n            queue_work_on(smp_processor_id(), cryptd_wq, &cpu_queue->work)\n\nFix this by holding net reference count before encrypt.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38058",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: __legitimize_mnt(): check for MNT_SYNC_UMOUNT should be under mount_lock",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\n__legitimize_mnt(): check for MNT_SYNC_UMOUNT should be under mount_lock\n\n... or we risk stealing final mntput from sync umount - raising mnt_count\nafter umount(2) has verified that victim is not busy, but before it\nhas set MNT_SYNC_UMOUNT; in that case __legitimize_mnt() doesn't see\nthat it's safe to quietly undo mnt_count increment and leaves dropping\nthe reference to caller, where it'll be a full-blown mntput().\n\nCheck under mount_lock is needed; leaving the current one done before\ntaking that makes no sense - it's nowhere near common enough to bother\nwith.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38062",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: genirq/msi: Store the IOMMU IOVA directly in msi_desc instead of iommu_cookie",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngenirq/msi: Store the IOMMU IOVA directly in msi_desc instead of iommu_cookie\n\nThe IOMMU translation for MSI message addresses has been a 2-step process,\nseparated in time:\n\n 1) iommu_dma_prepare_msi(): A cookie pointer containing the IOVA address\n    is stored in the MSI descriptor when an MSI interrupt is allocated.\n\n 2) iommu_dma_compose_msi_msg(): this cookie pointer is used to compute a\n    translated message address.\n\nThis has an inherent lifetime problem for the pointer stored in the cookie\nthat must remain valid between the two steps. However, there is no locking\nat the irq layer that helps protect the lifetime. Today, this works under\nthe assumption that the iommu domain is not changed while MSI interrupts\nbeing programmed. This is true for normal DMA API users within the kernel,\nas the iommu domain is attached before the driver is probed and cannot be\nchanged while a driver is attached.\n\nClassic VFIO type1 also prevented changing the iommu domain while VFIO was\nrunning as it does not support changing the \"container\" after starting up.\n\nHowever, iommufd has improved this so that the iommu domain can be changed\nduring VFIO operation. This potentially allows userspace to directly race\nVFIO_DEVICE_ATTACH_IOMMUFD_PT (which calls iommu_attach_group()) and\nVFIO_DEVICE_SET_IRQS (which calls into iommu_dma_compose_msi_msg()).\n\nThis potentially causes both the cookie pointer and the unlocked call to\niommu_get_domain_for_dev() on the MSI translation path to become UAFs.\n\nFix the MSI cookie UAF by removing the cookie pointer. The translated IOVA\naddress is already known during iommu_dma_prepare_msi() and cannot change.\nThus, it can simply be stored as an integer in the MSI descriptor.\n\nThe other UAF related to iommu_get_domain_for_dev() will be addressed in\npatch \"iommu: Make iommu_dma_prepare_msi() into a generic operation\" by\nusing the IOMMU group mutex.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38064",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: virtio: break and reset virtio devices on device_shutdown()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio: break and reset virtio devices on device_shutdown()\n\nHongyu reported a hang on kexec in a VM. QEMU reported invalid memory\naccesses during the hang.\n\n\tInvalid read at addr 0x102877002, size 2, region '(null)', reason: rejected\n\tInvalid write at addr 0x102877A44, size 2, region '(null)', reason: rejected\n\t...\n\nIt was traced down to virtio-console. Kexec works fine if virtio-console\nis not in use.\n\nThe issue is that virtio-console continues to write to the MMIO even after\nunderlying virtio-pci device is reset.\n\nAdditionally, Eric noticed that IOMMUs are reset before devices, if\ndevices are not reset on shutdown they continue to poke at guest memory\nand get errors from the IOMMU. Some devices get wedged then.\n\nThe problem can be solved by breaking all virtio devices on virtio\nbus shutdown, then resetting them.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38065",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: orangefs: Do not truncate file size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\norangefs: Do not truncate file size\n\n'len' is used to store the result of i_size_read(), so making 'len'\na size_t results in truncation to 4GiB on 32-bit systems.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38071",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/mm: Check return value from memblock_phys_alloc_range()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/mm: Check return value from memblock_phys_alloc_range()\n\nAt least with CONFIG_PHYSICAL_START=0x100000, if there is < 4 MiB of\ncontiguous free memory available at this point, the kernel will crash\nand burn because memblock_phys_alloc_range() returns 0 on failure,\nwhich leads memblock_phys_free() to throw the first 4 MiB of physical\nmemory to the wolves.\n\nAt a minimum it should fail gracefully with a meaningful diagnostic,\nbut in fact everything seems to work fine without the weird reserve\nallocation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38073",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: block: fix race between set_blocksize and read paths",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: fix race between set_blocksize and read paths\n\nWith the new large sector size support, it's now the case that\nset_blocksize can change i_blksize and the folio order in a manner that\nconflicts with a concurrent reader and causes a kernel crash.\n\nSpecifically, let's say that udev-worker calls libblkid to detect the\nlabels on a block device.  The read call can create an order-0 folio to\nread the first 4096 bytes from the disk.  But then udev is preempted.\n\nNext, someone tries to mount an 8k-sectorsize filesystem from the same\nblock device.  The filesystem calls set_blksize, which sets i_blksize to\n8192 and the minimum folio order to 1.\n\nNow udev resumes, still holding the order-0 folio it allocated.  It then\ntries to schedule a read bio and do_mpage_readahead tries to create\nbufferheads for the folio.  Unfortunately, blocks_per_folio == 0 because\nthe page size is 4096 but the blocksize is 8192 so no bufferheads are\nattached and the bh walk never sets bdev.  We then submit the bio with a\nNULL block device and crash.\n\nTherefore, truncate the page cache after flushing but before updating\ni_blksize.  However, that's not enough -- we also need to lock out file\nIO and page faults during the update.  Take both the i_rwsem and the\ninvalidate_lock in exclusive mode for invalidations, and in shared mode\nfor read/write operations.\n\nI don't know if this is the correct fix, but xfs/259 found it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38074",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vhost-scsi: protect vq->log_used with vq->mutex",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvhost-scsi: protect vq->log_used with vq->mutex\n\nThe vhost-scsi completion path may access vq->log_base when vq->log_used is\nalready set to false.\n\n    vhost-thread                       QEMU-thread\n\nvhost_scsi_complete_cmd_work()\n-> vhost_add_used()\n   -> vhost_add_used_n()\n      if (unlikely(vq->log_used))\n                                      QEMU disables vq->log_used\n                                      via VHOST_SET_VRING_ADDR.\n                                      mutex_lock(&vq->mutex);\n                                      vq->log_used = false now!\n                                      mutex_unlock(&vq->mutex);\n\n\t\t\t\t      QEMU gfree(vq->log_base)\n        log_used()\n        -> log_write(vq->log_base)\n\nAssuming the VMM is QEMU. The vq->log_base is from QEMU userpace and can be\nreclaimed via gfree(). As a result, this causes invalid memory writes to\nQEMU userspace.\n\nThe control queue path has the same issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38075",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: target: iscsi: Fix timeout on deleted connection",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: iscsi: Fix timeout on deleted connection\n\nNOPIN response timer may expire on a deleted connection and crash with\nsuch logs:\n\nDid not receive response to NOPIN on CID: 0, failing connection for I_T Nexus (null),i,0x00023d000125,iqn.2017-01.com.iscsi.target,t,0x3d\n\nBUG: Kernel NULL pointer dereference on read at 0x00000000\nNIP  strlcpy+0x8/0xb0\nLR iscsit_fill_cxn_timeout_err_stats+0x5c/0xc0 [iscsi_target_mod]\nCall Trace:\n iscsit_handle_nopin_response_timeout+0xfc/0x120 [iscsi_target_mod]\n call_timer_fn+0x58/0x1f0\n run_timer_softirq+0x740/0x860\n __do_softirq+0x16c/0x420\n irq_exit+0x188/0x1c0\n timer_interrupt+0x184/0x410\n\nThat is because nopin response timer may be re-started on nopin timer\nexpiration.\n\nStop nopin timer before stopping the nopin response timer to be sure\nthat no one of them will be re-started.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38078",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: pcm: Fix race of buffer access at PCM OSS layer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: pcm: Fix race of buffer access at PCM OSS layer\n\nThe PCM OSS layer tries to clear the buffer with the silence data at\ninitialization (or reconfiguration) of a stream with the explicit call\nof snd_pcm_format_set_silence() with runtime->dma_area.  But this may\nlead to a UAF because the accessed runtime->dma_area might be freed\nconcurrently, as it's performed outside the PCM ops.\n\nFor avoiding it, move the code into the PCM core and perform it inside\nthe buffer access lock, so that it won't be changed during the\noperation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38079",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: algif_hash - fix double free in hash_accept",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: algif_hash - fix double free in hash_accept\n\nIf accept(2) is called on socket type algif_hash with\nMSG_MORE flag set and crypto_ahash_import fails,\nsk2 is freed. However, it is also freed in af_alg_release,\nleading to slab-use-after-free error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38080",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/amd/display: Increase block_sequence array size",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Increase block_sequence array size\n\n[Why]\nIt's possible to generate more than 50 steps in hwss_build_fast_sequence,\nfor example with a 6-pipe asic where all pipes are in one MPC chain. This\noverflows the block_sequence buffer and corrupts block_sequence_steps,\ncausing a crash.\n\n[How]\nExpand block_sequence to 100 items. A naive upper bound on the possible\nnumber of steps for a 6-pipe asic, ignoring the potential for steps to be\nmutually exclusive, is 91 with current code, therefore 100 is sufficient.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38084",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm/hugetlb: unshare page tables during VMA split, not before",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/hugetlb: unshare page tables during VMA split, not before\n\nCurrently, __split_vma() triggers hugetlb page table unsharing through\nvm_ops->may_split().  This happens before the VMA lock and rmap locks are\ntaken - which is too early, it allows racing VMA-locked page faults in our\nprocess and racing rmap walks from other processes to cause page tables to\nbe shared again before we actually perform the split.\n\nFix it by explicitly calling into the hugetlb unshare logic from\n__split_vma() in the same place where THP splitting also happens.  At that\npoint, both the VMA and the rmap(s) are write-locked.\n\nAn annoying detail is that we can now call into the helper\nhugetlb_unshare_pmds() from two different locking contexts:\n\n1. from hugetlb_split(), holding:\n    - mmap lock (exclusively)\n    - VMA lock\n    - file rmap lock (exclusively)\n2. hugetlb_unshare_all_pmds(), which I think is designed to be able to\n   call us with only the mmap lock held (in shared mode), but currently\n   only runs while holding mmap lock (exclusively) and VMA lock\n\nBackporting note:\nThis commit fixes a racy protection that was introduced in commit\nb30c14cd6102 (\"hugetlb: unshare some PMDs when splitting VMAs\"); that\ncommit claimed to fix an issue introduced in 5.13, but it should actually\nalso go all the way back.\n\n[jannh@google.com: v2]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38085",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm/hugetlb: fix huge_pmd_unshare() vs GUP-fast race",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/hugetlb: fix huge_pmd_unshare() vs GUP-fast race\n\nhuge_pmd_unshare() drops a reference on a page table that may have\npreviously been shared across processes, potentially turning it into a\nnormal page table used in another process in which unrelated VMAs can\nafterwards be installed.\n\nIf this happens in the middle of a concurrent gup_fast(), gup_fast() could\nend up walking the page tables of another process.  While I don't see any\nway in which that immediately leads to kernel memory corruption, it is\nreally weird and unexpected.\n\nFix it with an explicit broadcast IPI through tlb_remove_table_sync_one(),\njust like we do in khugepaged when removing page tables for a THP\ncollapse.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38086",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: ch9200: fix uninitialised access during mii_nway_restart",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ch9200: fix uninitialised access during mii_nway_restart\n\nIn mii_nway_restart() the code attempts to call\nmii->mdio_read which is ch9200_mdio_read(). ch9200_mdio_read()\nutilises a local buffer called \"buff\", which is initialised\nwith control_read(). However \"buff\" is conditionally\ninitialised inside control_read():\n\n        if (err == size) {\n                memcpy(data, buf, size);\n        }\n\nIf the condition of \"err == size\" is not met, then\n\"buff\" remains uninitialised. Once this happens the\nuninitialised \"buff\" is accessed and returned during\nch9200_mdio_read():\n\n        return (buff[0] | buff[1] << 8);\n\nThe problem stems from the fact that ch9200_mdio_read()\nignores the return value of control_read(), leading to\nuinit-access of \"buff\".\n\nTo fix this we should check the return value of\ncontrol_read() and return early on error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38090",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drivers/rapidio/rio_cm.c: prevent possible heap overwrite",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers/rapidio/rio_cm.c: prevent possible heap overwrite\n\nIn\n\nriocm_cdev_ioctl(RIO_CM_CHAN_SEND)\n   -> cm_chan_msg_send()\n      -> riocm_ch_send()\n\ncm_chan_msg_send() checks that userspace didn't send too much data but\nriocm_ch_send() failed to check that userspace sent sufficient data.  The\nresult is that riocm_ch_send() can write to fields in the rio_ch_chan_hdr\nwhich were outside the bounds of the space which cm_chan_msg_send()\nallocated.\n\nAddress this by teaching riocm_ch_send() to check that the entire\nrio_ch_chan_hdr was copied in from userspace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38095",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dma-buf: insert memory barrier before updating num_fences",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndma-buf: insert memory barrier before updating num_fences\n\nsmp_store_mb() inserts memory barrier after storing operation.\nIt is different with what the comment is originally aiming so Null\npointer dereference can be happened if memory update is reordered.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38096",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: iwlwifi: don't warn when if there is a FW error",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: don't warn when if there is a FW error\n\niwl_trans_reclaim is warning if it is called when the FW is not alive.\nBut if it is called when there is a pending restart, i.e. after a FW\nerror, there is no need to warn, instead - return silently.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38099",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: Disable SCO support if READ_VOICE_SETTING is unsupported/broken",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Disable SCO support if READ_VOICE_SETTING is unsupported/broken\n\nA SCO connection without the proper voice_setting can cause\nthe controller to lock up.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38100",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: x86/iopl: Cure TIF_IO_BITMAP inconsistencies",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/iopl: Cure TIF_IO_BITMAP inconsistencies\n\nio_bitmap_exit() is invoked from exit_thread() when a task exists or\nwhen a fork fails. In the latter case the exit_thread() cleans up\nresources which were allocated during fork().\n\nio_bitmap_exit() invokes task_update_io_bitmap(), which in turn ends up\nin tss_update_io_bitmap(). tss_update_io_bitmap() operates on the\ncurrent task. If current has TIF_IO_BITMAP set, but no bitmap installed,\ntss_update_io_bitmap() crashes with a NULL pointer dereference.\n\nThere are two issues, which lead to that problem:\n\n  1) io_bitmap_exit() should not invoke task_update_io_bitmap() when\n     the task, which is cleaned up, is not the current task. That's a\n     clear indicator for a cleanup after a failed fork().\n\n  2) A task should not have TIF_IO_BITMAP set and neither a bitmap\n     installed nor IOPL emulation level 3 activated.\n\n     This happens when a kernel thread is created in the context of\n     a user space thread, which has TIF_IO_BITMAP set as the thread\n     flags are copied and the IO bitmap pointer is cleared.\n\n     Other than in the failed fork() case this has no impact because\n     kernel threads including IO workers never return to user space and\n     therefore never invoke tss_update_io_bitmap().\n\nCure this by adding the missing cleanups and checks:\n\n  1) Prevent io_bitmap_exit() to invoke task_update_io_bitmap() if\n     the to be cleaned up task is not the current task.\n\n  2) Clear TIF_IO_BITMAP in copy_thread() unconditionally. For user\n     space forks it is set later, when the IO bitmap is inherited in\n     io_bitmap_share().\n\nFor paranoia sake, add a warning into tss_update_io_bitmap() to catch\nthe case, when that code is invoked with inconsistent state.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38105",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: usb-audio: Kill timer properly at removal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Kill timer properly at removal\n\nThe USB-audio MIDI code initializes the timer, but in a rare case, the\ndriver might be freed without the disconnect call.  This leaves the\ntimer in an active state while the assigned object is released via\nsnd_usbmidi_free(), which ends up with a kernel warning when the debug\nconfiguration is enabled, as spotted by fuzzer.\n\nFor avoiding the problem, put timer_shutdown_sync() at\nsnd_usbmidi_free(), so that the timer can be killed properly.\nWhile we're at it, replace the existing timer_delete_sync() at the\ndisconnect callback with timer_shutdown_sync(), too.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38107",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: ets: fix a race in ets_qdisc_change()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: ets: fix a race in ets_qdisc_change()\n\nGerrard Tai reported a race condition in ETS, whenever SFQ perturb timer\nfires at the wrong time.\n\nThe race is as follows:\n\nCPU 0                                 CPU 1\n[1]: lock root\n[2]: qdisc_tree_flush_backlog()\n[3]: unlock root\n |\n |                                    [5]: lock root\n |                                    [6]: rehash\n |                                    [7]: qdisc_tree_reduce_backlog()\n |\n[4]: qdisc_put()\n\nThis can be abused to underflow a parent's qlen.\n\nCalling qdisc_purge_queue() instead of qdisc_tree_flush_backlog()\nshould fix the race, because all packets will be purged from the qdisc\nbefore releasing the lock.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38108",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: red: fix a race in __red_change()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: red: fix a race in __red_change()\n\nGerrard Tai reported a race condition in RED, whenever SFQ perturb timer\nfires at the wrong time.\n\nThe race is as follows:\n\nCPU 0                                 CPU 1\n[1]: lock root\n[2]: qdisc_tree_flush_backlog()\n[3]: unlock root\n |\n |                                    [5]: lock root\n |                                    [6]: rehash\n |                                    [7]: qdisc_tree_reduce_backlog()\n |\n[4]: qdisc_put()\n\nThis can be abused to underflow a parent's qlen.\n\nCalling qdisc_purge_queue() instead of qdisc_tree_flush_backlog()\nshould fix the race, because all packets will be purged from the qdisc\nbefore releasing the lock.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38112",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: Fix TOCTOU issue in sk_is_readable()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: Fix TOCTOU issue in sk_is_readable()\n\nsk->sk_prot->sock_is_readable is a valid function pointer when sk resides\nin a sockmap. After the last sk_psock_put() (which usually happens when\nsocket is removed from sockmap), sk->sk_prot gets restored and\nsk->sk_prot->sock_is_readable becomes NULL.\n\nThis makes sk_is_readable() racy, if the value of sk->sk_prot is reloaded\nafter the initial check. Which in turn may lead to a null pointer\ndereference.\n\nEnsure the function pointer does not turn NULL after the check.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38115",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net_sched: sch_sfq: fix a potential crash on gso_skb handling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: sch_sfq: fix a potential crash on gso_skb handling\n\nSFQ has an assumption of always being able to queue at least one packet.\n\nHowever, after the blamed commit, sch->q.len can be inflated by packets\nin sch->gso_skb, and an enqueue() on an empty SFQ qdisc can be followed\nby an immediate drop.\n\nFix sfq_drop() to properly clear q->tail in this situation.\n\n\nip netns add lb\nip link add dev to-lb type veth peer name in-lb netns lb\nethtool -K to-lb tso off                 # force qdisc to requeue gso_skb\nip netns exec lb ethtool -K in-lb gro on # enable NAPI\nip link set dev to-lb up\nip -netns lb link set dev in-lb up\nip addr add dev to-lb 192.168.20.1/24\nip -netns lb addr add dev in-lb 192.168.20.2/24\ntc qdisc replace dev to-lb root sfq limit 100\n\nip netns exec lb netserver\n\nnetperf -H 192.168.20.2 -l 100 &\nnetperf -H 192.168.20.2 -l 100 &\nnetperf -H 192.168.20.2 -l 100 &\nnetperf -H 192.168.20.2 -l 100 &",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38117",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: MGMT: Protect mgmt_pending list with its own lock",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: MGMT: Protect mgmt_pending list with its own lock\n\nThis uses a mutex to protect from concurrent access of mgmt_pending\nlist which can cause crashes like:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91\nRead of size 2 at addr ffff0000c48885b2 by task syz.4.334/7318\n\nCPU: 0 UID: 0 PID: 7318 Comm: syz.4.334 Not tainted 6.15.0-rc7-syzkaller-g187899f4124a #0 PREEMPT\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025\nCall trace:\n show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack+0x30/0x40 lib/dump_stack.c:94\n dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120\n print_address_description+0xa8/0x254 mm/kasan/report.c:408\n print_report+0x68/0x84 mm/kasan/report.c:521\n kasan_report+0xb0/0x110 mm/kasan/report.c:634\n __asan_report_load2_noabort+0x20/0x2c mm/kasan/report_generic.c:379\n hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91\n mgmt_pending_find+0x7c/0x140 net/bluetooth/mgmt_util.c:223\n pending_find net/bluetooth/mgmt.c:947 [inline]\n remove_adv_monitor+0x44/0x1a4 net/bluetooth/mgmt.c:5445\n hci_mgmt_cmd+0x780/0xc00 net/bluetooth/hci_sock.c:1712\n hci_sock_sendmsg+0x544/0xbb0 net/bluetooth/hci_sock.c:1832\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n sock_write_iter+0x25c/0x378 net/socket.c:1131\n new_sync_write fs/read_write.c:591 [inline]\n vfs_write+0x62c/0x97c fs/read_write.c:684\n ksys_write+0x120/0x210 fs/read_write.c:736\n __do_sys_write fs/read_write.c:747 [inline]\n __se_sys_write fs/read_write.c:744 [inline]\n __arm64_sys_write+0x7c/0x90 fs/read_write.c:744\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600\n\nAllocated by task 7037:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x40/0x78 mm/kasan/common.c:68\n kasan_save_alloc_info+0x44/0x54 mm/kasan/generic.c:562\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x9c/0xb4 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4327 [inline]\n __kmalloc_noprof+0x2fc/0x4c8 mm/slub.c:4339\n kmalloc_noprof include/linux/slab.h:909 [inline]\n sk_prot_alloc+0xc4/0x1f0 net/core/sock.c:2198\n sk_alloc+0x44/0x3ac net/core/sock.c:2254\n bt_sock_alloc+0x4c/0x300 net/bluetooth/af_bluetooth.c:148\n hci_sock_create+0xa8/0x194 net/bluetooth/hci_sock.c:2202\n bt_sock_create+0x14c/0x24c net/bluetooth/af_bluetooth.c:132\n __sock_create+0x43c/0x91c net/socket.c:1541\n sock_create net/socket.c:1599 [inline]\n __sys_socket_create net/socket.c:1636 [inline]\n __sys_socket+0xd4/0x1c0 net/socket.c:1683\n __do_sys_socket net/socket.c:1697 [inline]\n __se_sys_socket net/socket.c:1695 [inline]\n __arm64_sys_socket+0x7c/0x94 net/socket.c:1695\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600\n\nFreed by task 6607:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x40/0x78 mm/kasan/common.c:68\n kasan_save_free_info+0x58/0x70 mm/kasan/generic.c:576\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x68/0x88 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38119",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: core: ufs: Fix a hang in the error handler",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: ufs: Fix a hang in the error handler\n\nufshcd_err_handling_prepare() calls ufshcd_rpm_get_sync(). The latter\nfunction can only succeed if UFSHCD_EH_IN_PROGRESS is not set because\nresuming involves submitting a SCSI command and ufshcd_queuecommand()\nreturns SCSI_MLQUEUE_HOST_BUSY if UFSHCD_EH_IN_PROGRESS is set. Fix this\nhang by setting UFSHCD_EH_IN_PROGRESS after ufshcd_rpm_get_sync() has\nbeen called instead of before.\n\nBacktrace:\n__switch_to+0x174/0x338\n__schedule+0x600/0x9e4\nschedule+0x7c/0xe8\nschedule_timeout+0xa4/0x1c8\nio_schedule_timeout+0x48/0x70\nwait_for_common_io+0xa8/0x160 //waiting on START_STOP\nwait_for_completion_io_timeout+0x10/0x20\nblk_execute_rq+0xe4/0x1e4\nscsi_execute_cmd+0x108/0x244\nufshcd_set_dev_pwr_mode+0xe8/0x250\n__ufshcd_wl_resume+0x94/0x354\nufshcd_wl_runtime_resume+0x3c/0x174\nscsi_runtime_resume+0x64/0xa4\nrpm_resume+0x15c/0xa1c\n__pm_runtime_resume+0x4c/0x90 // Runtime resume ongoing\nufshcd_err_handler+0x1a0/0xd08\nprocess_one_work+0x174/0x808\nworker_thread+0x15c/0x490\nkthread+0xf4/0x1ec\nret_from_fork+0x10/0x20\n\n[ bvanassche: rewrote patch description ]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38126",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: stmmac: make sure that ptp_rate is not 0 before configuring timestamping",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: stmmac: make sure that ptp_rate is not 0 before configuring timestamping\n\nThe stmmac platform drivers that do not open-code the clk_ptp_rate value\nafter having retrieved the default one from the device-tree can end up\nwith 0 in clk_ptp_rate (as clk_get_rate can return 0). It will\neventually propagate up to PTP initialization when bringing up the\ninterface, leading to a divide by 0:\n\n Division by zero in kernel.\n CPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.30-00001-g48313bd5768a #22\n Hardware name: STM32 (Device Tree Support)\n Call trace:\n  unwind_backtrace from show_stack+0x18/0x1c\n  show_stack from dump_stack_lvl+0x6c/0x8c\n  dump_stack_lvl from Ldiv0_64+0x8/0x18\n  Ldiv0_64 from stmmac_init_tstamp_counter+0x190/0x1a4\n  stmmac_init_tstamp_counter from stmmac_hw_setup+0xc1c/0x111c\n  stmmac_hw_setup from __stmmac_open+0x18c/0x434\n  __stmmac_open from stmmac_open+0x3c/0xbc\n  stmmac_open from __dev_open+0xf4/0x1ac\n  __dev_open from __dev_change_flags+0x1cc/0x224\n  __dev_change_flags from dev_change_flags+0x24/0x60\n  dev_change_flags from ip_auto_config+0x2e8/0x11a0\n  ip_auto_config from do_one_initcall+0x84/0x33c\n  do_one_initcall from kernel_init_freeable+0x1b8/0x214\n  kernel_init_freeable from kernel_init+0x24/0x140\n  kernel_init from ret_from_fork+0x14/0x28\n Exception stack(0xe0815fb0 to 0xe0815ff8)\n\nPrevent this division by 0 by adding an explicit check and error log\nabout the actual issue. While at it, remove the same check from\nstmmac_ptp_register, which then becomes duplicate",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38129",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: page_pool: Fix use-after-free in page_pool_recycle_in_ring",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npage_pool: Fix use-after-free in page_pool_recycle_in_ring\n\nsyzbot reported a uaf in page_pool_recycle_in_ring:\n\nBUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862\nRead of size 8 at addr ffff8880286045a0 by task syz.0.284/6943\n\nCPU: 0 UID: 0 PID: 6943 Comm: syz.0.284 Not tainted 6.13.0-rc3-syzkaller-gdfa94ce54f41 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:489\n kasan_report+0x143/0x180 mm/kasan/report.c:602\n lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862\n __raw_spin_unlock_bh include/linux/spinlock_api_smp.h:165 [inline]\n _raw_spin_unlock_bh+0x1b/0x40 kernel/locking/spinlock.c:210\n spin_unlock_bh include/linux/spinlock.h:396 [inline]\n ptr_ring_produce_bh include/linux/ptr_ring.h:164 [inline]\n page_pool_recycle_in_ring net/core/page_pool.c:707 [inline]\n page_pool_put_unrefed_netmem+0x748/0xb00 net/core/page_pool.c:826\n page_pool_put_netmem include/net/page_pool/helpers.h:323 [inline]\n page_pool_put_full_netmem include/net/page_pool/helpers.h:353 [inline]\n napi_pp_put_page+0x149/0x2b0 net/core/skbuff.c:1036\n skb_pp_recycle net/core/skbuff.c:1047 [inline]\n skb_free_head net/core/skbuff.c:1094 [inline]\n skb_release_data+0x6c4/0x8a0 net/core/skbuff.c:1125\n skb_release_all net/core/skbuff.c:1190 [inline]\n __kfree_skb net/core/skbuff.c:1204 [inline]\n sk_skb_reason_drop+0x1c9/0x380 net/core/skbuff.c:1242\n kfree_skb_reason include/linux/skbuff.h:1263 [inline]\n __skb_queue_purge_reason include/linux/skbuff.h:3343 [inline]\n\nroot cause is:\n\npage_pool_recycle_in_ring\n  ptr_ring_produce\n    spin_lock(&r->producer_lock);\n    WRITE_ONCE(r->queue[r->producer++], ptr)\n      //recycle last page to pool\n\t\t\t\tpage_pool_release\n\t\t\t\t  page_pool_scrub\n\t\t\t\t    page_pool_empty_ring\n\t\t\t\t      ptr_ring_consume\n\t\t\t\t      page_pool_return_page  //release all page\n\t\t\t\t  __page_pool_destroy\n\t\t\t\t     free_percpu(pool->recycle_stats);\n\t\t\t\t     free(pool) //free\n\n     spin_unlock(&r->producer_lock); //pool->ring uaf read\n  recycle_stat_inc(pool, ring);\n\npage_pool can be free while page pool recycle the last page in ring.\nAdd producer-lock barrier to page_pool_release to prevent the page\npool from being free before all pages have been recycled.\n\nrecycle_stat_inc() is empty when CONFIG_PAGE_POOL_STATS is not\nenabled, which will trigger Wempty-body build warning. Add definition\nfor pool stat macro to fix warning.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38138",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dmaengine: ti: Add NULL check in udma_probe()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: ti: Add NULL check in udma_probe()\n\ndevm_kasprintf() returns NULL when memory allocation fails. Currently,\nudma_probe() does not check for this case, which results in a NULL\npointer dereference.\n\nAdd NULL check after devm_kasprintf() to prevent this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38146",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: openvswitch: Fix the dead loop of MPLS parse",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: Fix the dead loop of MPLS parse\n\nThe unexpected MPLS packet may not end with the bottom label stack.\nWhen there are many stacks, The label count value has wrapped around.\nA dead loop occurs, soft lockup/CPU stuck finally.\n\nstack backtrace:\nUBSAN: array-index-out-of-bounds in /build/linux-0Pa0xK/linux-5.15.0/net/openvswitch/flow.c:662:26\nindex -1 is out of range for type '__be32 [3]'\nCPU: 34 PID: 0 Comm: swapper/34 Kdump: loaded Tainted: G           OE   5.15.0-121-generic #131-Ubuntu\nHardware name: Dell Inc. PowerEdge C6420/0JP9TF, BIOS 2.12.2 07/14/2021\nCall Trace:\n <IRQ>\n show_stack+0x52/0x5c\n dump_stack_lvl+0x4a/0x63\n dump_stack+0x10/0x16\n ubsan_epilogue+0x9/0x36\n __ubsan_handle_out_of_bounds.cold+0x44/0x49\n key_extract_l3l4+0x82a/0x840 [openvswitch]\n ? kfree_skbmem+0x52/0xa0\n key_extract+0x9c/0x2b0 [openvswitch]\n ovs_flow_key_extract+0x124/0x350 [openvswitch]\n ovs_vport_receive+0x61/0xd0 [openvswitch]\n ? kernel_init_free_pages.part.0+0x4a/0x70\n ? get_page_from_freelist+0x353/0x540\n netdev_port_receive+0xc4/0x180 [openvswitch]\n ? netdev_port_receive+0x180/0x180 [openvswitch]\n netdev_frame_hook+0x1f/0x40 [openvswitch]\n __netif_receive_skb_core.constprop.0+0x23a/0xf00\n __netif_receive_skb_list_core+0xfa/0x240\n netif_receive_skb_list_internal+0x18e/0x2a0\n napi_complete_done+0x7a/0x1c0\n bnxt_poll+0x155/0x1c0 [bnxt_en]\n __napi_poll+0x30/0x180\n net_rx_action+0x126/0x280\n ? bnxt_msix+0x67/0x80 [bnxt_en]\n handle_softirqs+0xda/0x2d0\n irq_exit_rcu+0x96/0xc0\n common_interrupt+0x8e/0xa0\n </IRQ>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38147",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: calipso: Don't call calipso functions for AF_INET sk.",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncalipso: Don't call calipso functions for AF_INET sk.\n\nsyzkaller reported a null-ptr-deref in txopt_get(). [0]\n\nThe offset 0x70 was of struct ipv6_txoptions in struct ipv6_pinfo,\nso struct ipv6_pinfo was NULL there.\n\nHowever, this never happens for IPv6 sockets as inet_sk(sk)->pinet6\nis always set in inet6_create(), meaning the socket was not IPv6 one.\n\nThe root cause is missing validation in netlbl_conn_setattr().\n\nnetlbl_conn_setattr() switches branches based on struct\nsockaddr.sa_family, which is passed from userspace.  However,\nnetlbl_conn_setattr() does not check if the address family matches\nthe socket.\n\nThe syzkaller must have called connect() for an IPv6 address on\nan IPv4 socket.\n\nWe have a proper validation in tcp_v[46]_connect(), but\nsecurity_socket_connect() is called in the earlier stage.\n\nLet's copy the validation to netlbl_conn_setattr().\n\n[0]:\nOops: general protection fault, probably for non-canonical address 0xdffffc000000000e: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: null-ptr-deref in range [0x0000000000000070-0x0000000000000077]\nCPU: 2 UID: 0 PID: 12928 Comm: syz.9.1677 Not tainted 6.12.0 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nRIP: 0010:txopt_get include/net/ipv6.h:390 [inline]\nRIP: 0010:\nCode: 02 00 00 49 8b ac 24 f8 02 00 00 e8 84 69 2a fd e8 ff 00 16 fd 48 8d 7d 70 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 53 02 00 00 48 8b 6d 70 48 85 ed 0f 84 ab 01 00\nRSP: 0018:ffff88811b8afc48 EFLAGS: 00010212\nRAX: dffffc0000000000 RBX: 1ffff11023715f8a RCX: ffffffff841ab00c\nRDX: 000000000000000e RSI: ffffc90007d9e000 RDI: 0000000000000070\nRBP: 0000000000000000 R08: ffffed1023715f9d R09: ffffed1023715f9e\nR10: ffffed1023715f9d R11: 0000000000000003 R12: ffff888123075f00\nR13: ffff88810245bd80 R14: ffff888113646780 R15: ffff888100578a80\nFS:  00007f9019bd7640(0000) GS:ffff8882d2d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f901b927bac CR3: 0000000104788003 CR4: 0000000000770ef0\nPKRU: 80000000\nCall Trace:\n <TASK>\n calipso_sock_setattr+0x56/0x80 net/netlabel/netlabel_calipso.c:557\n netlbl_conn_setattr+0x10c/0x280 net/netlabel/netlabel_kapi.c:1177\n selinux_netlbl_socket_connect_helper+0xd3/0x1b0 security/selinux/netlabel.c:569\n selinux_netlbl_socket_connect_locked security/selinux/netlabel.c:597 [inline]\n selinux_netlbl_socket_connect+0xb6/0x100 security/selinux/netlabel.c:615\n selinux_socket_connect+0x5f/0x80 security/selinux/hooks.c:4931\n security_socket_connect+0x50/0xa0 security/security.c:4598\n __sys_connect_file+0xa4/0x190 net/socket.c:2067\n __sys_connect+0x12c/0x170 net/socket.c:2088\n __do_sys_connect net/socket.c:2098 [inline]\n __se_sys_connect net/socket.c:2095 [inline]\n __x64_sys_connect+0x73/0xb0 net/socket.c:2095\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xaa/0x1b0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f901b61a12d\nCode: 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f9019bd6fa8 EFLAGS: 00000246 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 00007f901b925fa0 RCX: 00007f901b61a12d\nRDX: 000000000000001c RSI: 0000200000000140 RDI: 0000000000000003\nRBP: 00007f901b701505 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007f901b5b62a0 R15: 00007f9019bb7000\n </TASK>\nModules linked in:",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38157",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath9k_htc: Abort software beacon handling if disabled",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k_htc: Abort software beacon handling if disabled\n\nA malicious USB device can send a WMI_SWBA_EVENTID event from an\nath9k_htc-managed device before beaconing has been enabled. This causes\na device-by-zero error in the driver, leading to either a crash or an\nout of bounds read.\n\nPrevent this by aborting the handling in ath9k_htc_swba() if beacons are\nnot enabled.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38159",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: rtw88: fix the 'para' buffer size to avoid reading out of bounds",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw88: fix the 'para' buffer size to avoid reading out of bounds\n\nSet the size to 6 instead of 2, since 'para' array is passed to\n'rtw_fw_bt_wifi_control(rtwdev, para[0], &para[1])', which reads\n5 bytes:\n\nvoid rtw_fw_bt_wifi_control(struct rtw_dev *rtwdev, u8 op_code, u8 *data)\n{\n    ...\n    SET_BT_WIFI_CONTROL_DATA1(h2c_pkt, *data);\n    SET_BT_WIFI_CONTROL_DATA2(h2c_pkt, *(data + 1));\n    ...\n    SET_BT_WIFI_CONTROL_DATA5(h2c_pkt, *(data + 4));\n\nDetected using the static analysis tool - Svace.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38160",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: clk: bcm: rpi: Add NULL check in raspberrypi_clk_register()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: bcm: rpi: Add NULL check in raspberrypi_clk_register()\n\ndevm_kasprintf() returns NULL when memory allocation fails. Currently,\nraspberrypi_clk_register() does not check for this case, which results\nin a NULL pointer dereference.\n\nAdd NULL check after devm_kasprintf() to prevent this issue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38161",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/mlx5: Fix error flow upon firmware failure for RQ destruction",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx5: Fix error flow upon firmware failure for RQ destruction\n\nUpon RQ destruction if the firmware command fails which is the\nlast resource to be destroyed some SW resources were already cleaned\nregardless of the failure.\n\nNow properly rollback the object to its original state upon such failure.\n\nIn order to avoid a use-after free in case someone tries to destroy the\nobject again, which results in the following kernel trace:\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 0 PID: 37589 at lib/refcount.c:28 refcount_warn_saturate+0xf4/0x148\nModules linked in: rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) rfkill mlx5_core(OE) mlxdevm(OE) ib_uverbs(OE) ib_core(OE) psample mlxfw(OE) mlx_compat(OE) macsec tls pci_hyperv_intf sunrpc vfat fat virtio_net net_failover failover fuse loop nfnetlink vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vmw_vmci vsock xfs crct10dif_ce ghash_ce sha2_ce sha256_arm64 sha1_ce virtio_console virtio_gpu virtio_blk virtio_dma_buf virtio_mmio dm_mirror dm_region_hash dm_log dm_mod xpmem(OE)\nCPU: 0 UID: 0 PID: 37589 Comm: python3 Kdump: loaded Tainted: G           OE     -------  ---  6.12.0-54.el10.aarch64 #1\nTainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\nHardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : refcount_warn_saturate+0xf4/0x148\nlr : refcount_warn_saturate+0xf4/0x148\nsp : ffff80008b81b7e0\nx29: ffff80008b81b7e0 x28: ffff000133d51600 x27: 0000000000000001\nx26: 0000000000000000 x25: 00000000ffffffea x24: ffff00010ae80f00\nx23: ffff00010ae80f80 x22: ffff0000c66e5d08 x21: 0000000000000000\nx20: ffff0000c66e0000 x19: ffff00010ae80340 x18: 0000000000000006\nx17: 0000000000000000 x16: 0000000000000020 x15: ffff80008b81b37f\nx14: 0000000000000000 x13: 2e656572662d7265 x12: ffff80008283ef78\nx11: ffff80008257efd0 x10: ffff80008283efd0 x9 : ffff80008021ed90\nx8 : 0000000000000001 x7 : 00000000000bffe8 x6 : c0000000ffff7fff\nx5 : ffff0001fb8e3408 x4 : 0000000000000000 x3 : ffff800179993000\nx2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000133d51600\nCall trace:\n refcount_warn_saturate+0xf4/0x148\n mlx5_core_put_rsc+0x88/0xa0 [mlx5_ib]\n mlx5_core_destroy_rq_tracked+0x64/0x98 [mlx5_ib]\n mlx5_ib_destroy_wq+0x34/0x80 [mlx5_ib]\n ib_destroy_wq_user+0x30/0xc0 [ib_core]\n uverbs_free_wq+0x28/0x58 [ib_uverbs]\n destroy_hw_idr_uobject+0x34/0x78 [ib_uverbs]\n uverbs_destroy_uobject+0x48/0x240 [ib_uverbs]\n __uverbs_cleanup_ufile+0xd4/0x1a8 [ib_uverbs]\n uverbs_destroy_ufile_hw+0x48/0x120 [ib_uverbs]\n ib_uverbs_close+0x2c/0x100 [ib_uverbs]\n __fput+0xd8/0x2f0\n __fput_sync+0x50/0x70\n __arm64_sys_close+0x40/0x90\n invoke_syscall.constprop.0+0x74/0xd0\n do_el0_svc+0x48/0xe8\n el0_svc+0x44/0x1d0\n el0t_64_sync_handler+0x120/0x130\n el0t_64_sync+0x1a4/0x1a8",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38162",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nft_set_pipapo: prevent overflow in lookup table allocation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_pipapo: prevent overflow in lookup table allocation\n\nWhen calculating the lookup table size, ensure the following\nmultiplication does not overflow:\n\n- desc->field_len[] maximum value is U8_MAX multiplied by\n  NFT_PIPAPO_GROUPS_PER_BYTE(f) that can be 2, worst case.\n- NFT_PIPAPO_BUCKETS(f->bb) is 2^8, worst case.\n- sizeof(unsigned long), from sizeof(*f->lt), lt in\n  struct nft_pipapo_field.\n\nThen, use check_mul_overflow() to multiply by bucket size and then use\ncheck_add_overflow() to the alignment for avx2 (if needed). Finally, add\nlt_size_check_overflow() helper and use it to consolidate this.\n\nWhile at it, replace leftover allocation using the GFP_KERNEL to\nGFP_KERNEL_ACCOUNT for consistency, in pipapo_resize().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38177",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sch_hfsc: make hfsc_qlen_notify() idempotent",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsch_hfsc: make hfsc_qlen_notify() idempotent\n\nhfsc_qlen_notify() is not idempotent either and not friendly\nto its callers, like fq_codel_dequeue(). Let's make it idempotent\nto ease qdisc_tree_reduce_backlog() callers' life:\n\n1. update_vf() decreases cl->cl_nactive, so we can check whether it is\nnon-zero before calling it.\n\n2. eltree_remove() always removes RB node cl->el_node, but we can use\n   RB_EMPTY_NODE() + RB_CLEAR_NODE() to make it safe.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38180",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: atm: fix /proc/net/atm/lec handling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atm: fix /proc/net/atm/lec handling\n\n/proc/net/atm/lec must ensure safety against dev_lec[] changes.\n\nIt appears it had dev_put() calls without prior dev_hold(),\nleading to imbalance and UAF.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38181",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: calipso: Fix null-ptr-deref in calipso_req_{set,del}attr().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncalipso: Fix null-ptr-deref in calipso_req_{set,del}attr().\n\nsyzkaller reported a null-ptr-deref in sock_omalloc() while allocating\na CALIPSO option.  [0]\n\nThe NULL is of struct sock, which was fetched by sk_to_full_sk() in\ncalipso_req_setattr().\n\nSince commit a1a5344ddbe8 (\"tcp: avoid two atomic ops for syncookies\"),\nreqsk->rsk_listener could be NULL when SYN Cookie is returned to its\nclient, as hinted by the leading SYN Cookie log.\n\nHere are 3 options to fix the bug:\n\n  1) Return 0 in calipso_req_setattr()\n  2) Return an error in calipso_req_setattr()\n  3) Alaways set rsk_listener\n\n1) is no go as it bypasses LSM, but 2) effectively disables SYN Cookie\nfor CALIPSO.  3) is also no go as there have been many efforts to reduce\natomic ops and make TCP robust against DDoS.  See also commit 3b24d854cb35\n(\"tcp/dccp: do not touch listener sk_refcnt under synflood\").\n\nAs of the blamed commit, SYN Cookie already did not need refcounting,\nand no one has stumbled on the bug for 9 years, so no CALIPSO user will\ncare about SYN Cookie.\n\nLet's return an error in calipso_req_setattr() and calipso_req_delattr()\nin the SYN Cookie case.\n\nThis can be reproduced by [1] on Fedora and now connect() of nc times out.\n\n[0]:\nTCP: request_sock_TCPv6: Possible SYN flooding on port [::]:20002. Sending cookies.\nOops: general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037]\nCPU: 3 UID: 0 PID: 12262 Comm: syz.1.2611 Not tainted 6.14.0 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nRIP: 0010:read_pnet include/net/net_namespace.h:406 [inline]\nRIP: 0010:sock_net include/net/sock.h:655 [inline]\nRIP: 0010:sock_kmalloc+0x35/0x170 net/core/sock.c:2806\nCode: 89 d5 41 54 55 89 f5 53 48 89 fb e8 25 e3 c6 fd e8 f0 91 e3 00 48 8d 7b 30 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 26 01 00 00 48 b8 00 00 00 00 00 fc ff df 4c 8b\nRSP: 0018:ffff88811af89038 EFLAGS: 00010216\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffff888105266400\nRDX: 0000000000000006 RSI: ffff88800c890000 RDI: 0000000000000030\nRBP: 0000000000000050 R08: 0000000000000000 R09: ffff88810526640e\nR10: ffffed1020a4cc81 R11: ffff88810526640f R12: 0000000000000000\nR13: 0000000000000820 R14: ffff888105266400 R15: 0000000000000050\nFS:  00007f0653a07640(0000) GS:ffff88811af80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f863ba096f4 CR3: 00000000163c0005 CR4: 0000000000770ef0\nPKRU: 80000000\nCall Trace:\n <IRQ>\n ipv6_renew_options+0x279/0x950 net/ipv6/exthdrs.c:1288\n calipso_req_setattr+0x181/0x340 net/ipv6/calipso.c:1204\n calipso_req_setattr+0x56/0x80 net/netlabel/netlabel_calipso.c:597\n netlbl_req_setattr+0x18a/0x440 net/netlabel/netlabel_kapi.c:1249\n selinux_netlbl_inet_conn_request+0x1fb/0x320 security/selinux/netlabel.c:342\n selinux_inet_conn_request+0x1eb/0x2c0 security/selinux/hooks.c:5551\n security_inet_conn_request+0x50/0xa0 security/security.c:4945\n tcp_v6_route_req+0x22c/0x550 net/ipv6/tcp_ipv6.c:825\n tcp_conn_request+0xec8/0x2b70 net/ipv4/tcp_input.c:7275\n tcp_v6_conn_request+0x1e3/0x440 net/ipv6/tcp_ipv6.c:1328\n tcp_rcv_state_process+0xafa/0x52b0 net/ipv4/tcp_input.c:6781\n tcp_v6_do_rcv+0x8a6/0x1a40 net/ipv6/tcp_ipv6.c:1667\n tcp_v6_rcv+0x505e/0x5b50 net/ipv6/tcp_ipv6.c:1904\n ip6_protocol_deliver_rcu+0x17c/0x1da0 net/ipv6/ip6_input.c:436\n ip6_input_finish+0x103/0x180 net/ipv6/ip6_input.c:480\n NF_HOOK include/linux/netfilter.h:314 [inline]\n NF_HOOK include/linux/netfilter.h:308 [inline]\n ip6_input+0x13c/0x6b0 net/ipv6/ip6_input.c:491\n dst_input include/net/dst.h:469 [inline]\n ip6_rcv_finish net/ipv6/ip6_input.c:79 [inline]\n ip6_rcv_finish+0xb6/0x490 net/ipv6/ip6_input.c:69\n NF_HOOK include/linux/netfilter.h:314 [inline]\n NF_HOOK include/linux/netf\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38184",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tipc: fix null-ptr-deref when acquiring remote ip of ethernet bearer",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: fix null-ptr-deref when acquiring remote ip of ethernet bearer\n\nThe reproduction steps:\n1. create a tun interface\n2. enable l2 bearer\n3. TIPC_NL_UDP_GET_REMOTEIP with media name set to tun\n\ntipc: Started in network mode\ntipc: Node identity 8af312d38a21, cluster identity 4711\ntipc: Enabled bearer <eth:syz_tun>, priority 1\nOops: general protection fault\nKASAN: null-ptr-deref in range\nCPU: 1 UID: 1000 PID: 559 Comm: poc Not tainted 6.16.0-rc1+ #117 PREEMPT\nHardware name: QEMU Ubuntu 24.04 PC\nRIP: 0010:tipc_udp_nl_dump_remoteip+0x4a4/0x8f0\n\nthe ub was in fact a struct dev.\n\nwhen bid != 0 && skip_cnt != 0, bearer_list[bid] may be NULL or\nother media when other thread changes it.\n\nfix this by checking media_id.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38192",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: clear the dst when changing skb protocol",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: clear the dst when changing skb protocol\n\nA not-so-careful NAT46 BPF program can crash the kernel\nif it indiscriminately flips ingress packets from v4 to v6:\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000000\n    ip6_rcv_core (net/ipv6/ip6_input.c:190:20)\n    ipv6_rcv (net/ipv6/ip6_input.c:306:8)\n    process_backlog (net/core/dev.c:6186:4)\n    napi_poll (net/core/dev.c:6906:9)\n    net_rx_action (net/core/dev.c:7028:13)\n    do_softirq (kernel/softirq.c:462:3)\n    netif_rx (net/core/dev.c:5326:3)\n    dev_loopback_xmit (net/core/dev.c:4015:2)\n    ip_mc_finish_output (net/ipv4/ip_output.c:363:8)\n    NF_HOOK (./include/linux/netfilter.h:314:9)\n    ip_mc_output (net/ipv4/ip_output.c:400:5)\n    dst_output (./include/net/dst.h:459:9)\n    ip_local_out (net/ipv4/ip_output.c:130:9)\n    ip_send_skb (net/ipv4/ip_output.c:1496:8)\n    udp_send_skb (net/ipv4/udp.c:1040:8)\n    udp_sendmsg (net/ipv4/udp.c:1328:10)\n\nThe output interface has a 4->6 program attached at ingress.\nWe try to loop the multicast skb back to the sending socket.\nIngress BPF runs as part of netif_rx(), pushes a valid v6 hdr\nand changes skb->protocol to v6. We enter ip6_rcv_core which\ntries to use skb_dst(). But the dst is still an IPv4 one left\nafter IPv4 mcast output.\n\nClear the dst in all BPF helpers which change the protocol.\nTry to preserve metadata dsts, those may carry non-routing\nmetadata.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38194",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jffs2: check that raw node were preallocated before writing summary",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njffs2: check that raw node were preallocated before writing summary\n\nSyzkaller detected a kernel bug in jffs2_link_node_ref, caused by fault\ninjection in jffs2_prealloc_raw_node_refs. jffs2_sum_write_sumnode doesn't\ncheck return value of jffs2_prealloc_raw_node_refs and simply lets any\nerror propagate into jffs2_sum_write_data, which eventually calls\njffs2_link_node_ref in order to link the summary to an expectedly allocated\nnode.\n\nkernel BUG at fs/jffs2/nodelist.c:592!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\nCPU: 1 PID: 31277 Comm: syz-executor.7 Not tainted 6.1.128-syzkaller-00139-ge10f83ca10a1 #0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nRIP: 0010:jffs2_link_node_ref+0x570/0x690 fs/jffs2/nodelist.c:592\nCall Trace:\n <TASK>\n jffs2_sum_write_data fs/jffs2/summary.c:841 [inline]\n jffs2_sum_write_sumnode+0xd1a/0x1da0 fs/jffs2/summary.c:874\n jffs2_do_reserve_space+0xa18/0xd60 fs/jffs2/nodemgmt.c:388\n jffs2_reserve_space+0x55f/0xaa0 fs/jffs2/nodemgmt.c:197\n jffs2_write_inode_range+0x246/0xb50 fs/jffs2/write.c:362\n jffs2_write_end+0x726/0x15d0 fs/jffs2/file.c:301\n generic_perform_write+0x314/0x5d0 mm/filemap.c:3856\n __generic_file_write_iter+0x2ae/0x4d0 mm/filemap.c:3973\n generic_file_write_iter+0xe3/0x350 mm/filemap.c:4005\n call_write_iter include/linux/fs.h:2265 [inline]\n do_iter_readv_writev+0x20f/0x3c0 fs/read_write.c:735\n do_iter_write+0x186/0x710 fs/read_write.c:861\n vfs_iter_write+0x70/0xa0 fs/read_write.c:902\n iter_file_splice_write+0x73b/0xc90 fs/splice.c:685\n do_splice_from fs/splice.c:763 [inline]\n direct_splice_actor+0x10c/0x170 fs/splice.c:950\n splice_direct_to_actor+0x337/0xa10 fs/splice.c:896\n do_splice_direct+0x1a9/0x280 fs/splice.c:1002\n do_sendfile+0xb13/0x12c0 fs/read_write.c:1255\n __do_sys_sendfile64 fs/read_write.c:1323 [inline]\n __se_sys_sendfile64 fs/read_write.c:1309 [inline]\n __x64_sys_sendfile64+0x1cf/0x210 fs/read_write.c:1309\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nFix this issue by checking return value of jffs2_prealloc_raw_node_refs\nbefore calling jffs2_sum_write_data.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38197",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: platform/x86: dell_rbu: Fix list usage",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: dell_rbu: Fix list usage\n\nPass the correct list head to list_for_each_entry*() when looping through\nthe packet list.\n\nWithout this patch, reading the packet data via sysfs will show the data\nincorrectly (because it starts at the wrong packet), and clearing the\npacket list will result in a NULL pointer dereference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38200",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: fix MMIO write access to an invalid page in i40e_clear_hw",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix MMIO write access to an invalid page in i40e_clear_hw\n\nWhen the device sends a specific input, an integer underflow can occur, leading\nto MMIO write access to an invalid page.\n\nPrevent the integer underflow by changing the type of related variables.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38201",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: netfilter: nft_set_pipapo: clamp maximum map bucket size to INT_MAX",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_pipapo: clamp maximum map bucket size to INT_MAX\n\nOtherwise, it is possible to hit WARN_ON_ONCE in __kvmalloc_node_noprof()\nwhen resizing hashtable because __GFP_NOWARN is unset.\n\nSimilar to:\n\n  b541ba7d1f5a (\"netfilter: conntrack: clamp maximum hashtable size to INT_MAX\")",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38204",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix array-index-out-of-bounds read in add_missing_indices",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix array-index-out-of-bounds read in add_missing_indices\n\nstbl is s8 but it must contain offsets into slot which can go from 0 to\n127.\n\nAdded a bound check for that error and return -EIO if the check fails.\nAlso make jfs_readdir return with error if add_missing_indices returns\nwith an error.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38206",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: exfat: fix double free in delayed_free",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix double free in delayed_free\n\nThe double free could happen in the following path.\n\nexfat_create_upcase_table()\n        exfat_create_upcase_table() : return error\n        exfat_free_upcase_table() : free ->vol_utbl\n        exfat_load_default_upcase_table : return error\n     exfat_kill_sb()\n           delayed_free()\n                  exfat_free_upcase_table() <--------- double free\nThis patch set ->vol_util as NULL after freeing it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38208",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: add NULL check in automount_fullpath",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: add NULL check in automount_fullpath\n\npage is checked for null in __build_path_from_dentry_optional_prefix\nwhen tcon->origin_fullpath is not set. However, the check is missing when\nit is set.\nAdd a check to prevent a potential NULL pointer dereference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38211",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: RDMA/iwcm: Fix use-after-free of work objects after cm_id destruction",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/iwcm: Fix use-after-free of work objects after cm_id destruction\n\nThe commit 59c68ac31e15 (\"iw_cm: free cm_id resources on the last\nderef\") simplified cm_id resource management by freeing cm_id once all\nreferences to the cm_id were removed. The references are removed either\nupon completion of iw_cm event handlers or when the application destroys\nthe cm_id. This commit introduced the use-after-free condition where\ncm_id_private object could still be in use by event handler works during\nthe destruction of cm_id. The commit aee2424246f9 (\"RDMA/iwcm: Fix a\nuse-after-free related to destroying CM IDs\") addressed this use-after-\nfree by flushing all pending works at the cm_id destruction.\n\nHowever, still another use-after-free possibility remained. It happens\nwith the work objects allocated for each cm_id_priv within\nalloc_work_entries() during cm_id creation, and subsequently freed in\ndealloc_work_entries() once all references to the cm_id are removed.\nIf the cm_id's last reference is decremented in the event handler work,\nthe work object for the work itself gets removed, and causes the use-\nafter-free BUG below:\n\n  BUG: KASAN: slab-use-after-free in __pwq_activate_work+0x1ff/0x250\n  Read of size 8 at addr ffff88811f9cf800 by task kworker/u16:1/147091\n\n  CPU: 2 UID: 0 PID: 147091 Comm: kworker/u16:1 Not tainted 6.15.0-rc2+ #27 PREEMPT(voluntary)\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014\n  Workqueue:  0x0 (iw_cm_wq)\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x6a/0x90\n   print_report+0x174/0x554\n   ? __virt_addr_valid+0x208/0x430\n   ? __pwq_activate_work+0x1ff/0x250\n   kasan_report+0xae/0x170\n   ? __pwq_activate_work+0x1ff/0x250\n   __pwq_activate_work+0x1ff/0x250\n   pwq_dec_nr_in_flight+0x8c5/0xfb0\n   process_one_work+0xc11/0x1460\n   ? __pfx_process_one_work+0x10/0x10\n   ? assign_work+0x16c/0x240\n   worker_thread+0x5ef/0xfd0\n   ? __pfx_worker_thread+0x10/0x10\n   kthread+0x3b0/0x770\n   ? __pfx_kthread+0x10/0x10\n   ? rcu_is_watching+0x11/0xb0\n   ? _raw_spin_unlock_irq+0x24/0x50\n   ? rcu_is_watching+0x11/0xb0\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork+0x30/0x70\n   ? __pfx_kthread+0x10/0x10\n   ret_from_fork_asm+0x1a/0x30\n   </TASK>\n\n  Allocated by task 147416:\n   kasan_save_stack+0x2c/0x50\n   kasan_save_track+0x10/0x30\n   __kasan_kmalloc+0xa6/0xb0\n   alloc_work_entries+0xa9/0x260 [iw_cm]\n   iw_cm_connect+0x23/0x4a0 [iw_cm]\n   rdma_connect_locked+0xbfd/0x1920 [rdma_cm]\n   nvme_rdma_cm_handler+0x8e5/0x1b60 [nvme_rdma]\n   cma_cm_event_handler+0xae/0x320 [rdma_cm]\n   cma_work_handler+0x106/0x1b0 [rdma_cm]\n   process_one_work+0x84f/0x1460\n   worker_thread+0x5ef/0xfd0\n   kthread+0x3b0/0x770\n   ret_from_fork+0x30/0x70\n   ret_from_fork_asm+0x1a/0x30\n\n  Freed by task 147091:\n   kasan_save_stack+0x2c/0x50\n   kasan_save_track+0x10/0x30\n   kasan_save_free_info+0x37/0x60\n   __kasan_slab_free+0x4b/0x70\n   kfree+0x13a/0x4b0\n   dealloc_work_entries+0x125/0x1f0 [iw_cm]\n   iwcm_deref_id+0x6f/0xa0 [iw_cm]\n   cm_work_handler+0x136/0x1ba0 [iw_cm]\n   process_one_work+0x84f/0x1460\n   worker_thread+0x5ef/0xfd0\n   kthread+0x3b0/0x770\n   ret_from_fork+0x30/0x70\n   ret_from_fork_asm+0x1a/0x30\n\n  Last potentially related work creation:\n   kasan_save_stack+0x2c/0x50\n   kasan_record_aux_stack+0xa3/0xb0\n   __queue_work+0x2ff/0x1390\n   queue_work_on+0x67/0xc0\n   cm_event_handler+0x46a/0x820 [iw_cm]\n   siw_cm_upcall+0x330/0x650 [siw]\n   siw_cm_work_handler+0x6b9/0x2b20 [siw]\n   process_one_work+0x84f/0x1460\n   worker_thread+0x5ef/0xfd0\n   kthread+0x3b0/0x770\n   ret_from_fork+0x30/0x70\n   ret_from_fork_asm+0x1a/0x30\n\nThis BUG is reproducible by repeating the blktests test case nvme/061\nfor the rdma transport and the siw driver.\n\nTo avoid the use-after-free of cm_id_private work objects, ensure that\nthe last reference to the cm_id is decremented not in the event handler\nworks, but in the cm_id destruction context. For that purpose, mo\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38212",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipc: fix to protect IPCS lookups using RCU",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipc: fix to protect IPCS lookups using RCU\n\nsyzbot reported that it discovered a use-after-free vulnerability, [0]\n\n[0]: https://lore.kernel.org/all/67af13f8.050a0220.21dd3.0038.GAE@google.com/\n\nidr_for_each() is protected by rwsem, but this is not enough.  If it is\nnot protected by RCU read-critical region, when idr_for_each() calls\nradix_tree_node_free() through call_rcu() to free the radix_tree_node\nstructure, the node will be freed immediately, and when reading the next\nnode in radix_tree_for_each_slot(), the already freed memory may be read.\n\nTherefore, we need to add code to make sure that idr_for_each() is\nprotected within the RCU read-critical region when we call it in\nshm_destroy_orphaned().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38215",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fbdev: Fix do_register_framebuffer to prevent null-ptr-deref in fb_videomode_to_var",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: Fix do_register_framebuffer to prevent null-ptr-deref in fb_videomode_to_var\n\nIf fb_add_videomode() in do_register_framebuffer() fails to allocate\nmemory for fb_videomode, it will later lead to a null-ptr dereference in\nfb_videomode_to_var(), as the fb_info is registered while not having the\nmode in modelist that is expected to be there, i.e. the one that is\ndescribed in fb_info->var.\n\n================================================================\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]\nCPU: 1 PID: 30371 Comm: syz-executor.1 Not tainted 5.10.226-syzkaller #0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nRIP: 0010:fb_videomode_to_var+0x24/0x610 drivers/video/fbdev/core/modedb.c:901\nCall Trace:\n display_to_var+0x3a/0x7c0 drivers/video/fbdev/core/fbcon.c:929\n fbcon_resize+0x3e2/0x8f0 drivers/video/fbdev/core/fbcon.c:2071\n resize_screen drivers/tty/vt/vt.c:1176 [inline]\n vc_do_resize+0x53a/0x1170 drivers/tty/vt/vt.c:1263\n fbcon_modechanged+0x3ac/0x6e0 drivers/video/fbdev/core/fbcon.c:2720\n fbcon_update_vcs+0x43/0x60 drivers/video/fbdev/core/fbcon.c:2776\n do_fb_ioctl+0x6d2/0x740 drivers/video/fbdev/core/fbmem.c:1128\n fb_ioctl+0xe7/0x150 drivers/video/fbdev/core/fbmem.c:1203\n vfs_ioctl fs/ioctl.c:48 [inline]\n __do_sys_ioctl fs/ioctl.c:753 [inline]\n __se_sys_ioctl fs/ioctl.c:739 [inline]\n __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:739\n do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x67/0xd1\n================================================================\n\nEven though fbcon_init() checks beforehand if fb_match_mode() in\nvar_to_display() fails, it can not prevent the panic because fbcon_init()\ndoes not return error code. Considering this and the comment in the code\nabout fb_match_mode() returning NULL - \"This should not happen\" - it is\nbetter to prevent registering the fb_info if its mode was not set\nsuccessfully. Also move fb_add_videomode() closer to the beginning of\ndo_register_framebuffer() to avoid having to do the cleanup on fail.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38229",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: cxusb: no longer judge rbuf when the write fails",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: cxusb: no longer judge rbuf when the write fails\n\nsyzbot reported a uninit-value in cxusb_i2c_xfer. [1]\n\nOnly when the write operation of usb_bulk_msg() in dvb_usb_generic_rw()\nsucceeds and rlen is greater than 0, the read operation of usb_bulk_msg()\nwill be executed to read rlen bytes of data from the dvb device into the\nrbuf.\n\nIn this case, although rlen is 1, the write operation failed which resulted\nin the dvb read operation not being executed, and ultimately variable i was\nnot initialized.\n\n[1]\nBUG: KMSAN: uninit-value in cxusb_gpio_tuner drivers/media/usb/dvb-usb/cxusb.c:124 [inline]\nBUG: KMSAN: uninit-value in cxusb_i2c_xfer+0x153a/0x1a60 drivers/media/usb/dvb-usb/cxusb.c:196\n cxusb_gpio_tuner drivers/media/usb/dvb-usb/cxusb.c:124 [inline]\n cxusb_i2c_xfer+0x153a/0x1a60 drivers/media/usb/dvb-usb/cxusb.c:196\n __i2c_transfer+0xe25/0x3150 drivers/i2c/i2c-core-base.c:-1\n i2c_transfer+0x317/0x4a0 drivers/i2c/i2c-core-base.c:2315\n i2c_transfer_buffer_flags+0x125/0x1e0 drivers/i2c/i2c-core-base.c:2343\n i2c_master_send include/linux/i2c.h:109 [inline]\n i2cdev_write+0x210/0x280 drivers/i2c/i2c-dev.c:183\n do_loop_readv_writev fs/read_write.c:848 [inline]\n vfs_writev+0x963/0x14e0 fs/read_write.c:1057\n do_writev+0x247/0x5c0 fs/read_write.c:1101\n __do_sys_writev fs/read_write.c:1169 [inline]\n __se_sys_writev fs/read_write.c:1166 [inline]\n __x64_sys_writev+0x98/0xe0 fs/read_write.c:1166\n x64_sys_call+0x2229/0x3c80 arch/x86/include/generated/asm/syscalls_64.h:21\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x1e0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38230",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: validate AG parameters in dbMount() to prevent crashes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: validate AG parameters in dbMount() to prevent crashes\n\nValidate db_agheight, db_agwidth, and db_agstart in dbMount to catch\ncorrupted metadata early and avoid undefined behavior in dbAllocAG.\nLimits are derived from L2LPERCTL, LPERCTL/MAXAG, and CTLTREESIZE:\n\n- agheight: 0 to L2LPERCTL/2 (0 to 5) ensures shift\n  (L2LPERCTL - 2*agheight) >= 0.\n- agwidth: 1 to min(LPERCTL/MAXAG, 2^(L2LPERCTL - 2*agheight))\n  ensures agperlev >= 1.\n  - Ranges: 1-8 (agheight 0-3), 1-4 (agheight 4), 1 (agheight 5).\n  - LPERCTL/MAXAG = 1024/128 = 8 limits leaves per AG;\n    2^(10 - 2*agheight) prevents division to 0.\n- agstart: 0 to CTLTREESIZE-1 - agwidth*(MAXAG-1) keeps ti within\n  stree (size 1365).\n  - Ranges: 0-1237 (agwidth 1), 0-348 (agwidth 8).\n\nUBSAN: shift-out-of-bounds in fs/jfs/jfs_dmap.c:1400:9\nshift exponent -335544310 is negative\nCPU: 0 UID: 0 PID: 5822 Comm: syz-executor130 Not tainted 6.14.0-rc5-syzkaller #0\nHardware name: Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n ubsan_epilogue lib/ubsan.c:231 [inline]\n __ubsan_handle_shift_out_of_bounds+0x3c8/0x420 lib/ubsan.c:468\n dbAllocAG+0x1087/0x10b0 fs/jfs/jfs_dmap.c:1400\n dbDiscardAG+0x352/0xa20 fs/jfs/jfs_dmap.c:1613\n jfs_ioc_trim+0x45a/0x6b0 fs/jfs/jfs_discard.c:105\n jfs_ioctl+0x2cd/0x3e0 fs/jfs/ioctl.c:131\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:906 [inline]\n __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38231",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfsd: Initialize ssc before laundromat_work to prevent NULL dereference",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: Initialize ssc before laundromat_work to prevent NULL dereference\n\nIn nfs4_state_start_net(), laundromat_work may access nfsd_ssc through\nnfs4_laundromat -> nfsd4_ssc_expire_umount. If nfsd_ssc isn't initialized,\nthis can cause NULL pointer dereference.\n\nNormally the delayed start of laundromat_work allows sufficient time for\nnfsd_ssc initialization to complete. However, when the kernel waits too\nlong for userspace responses (e.g. in nfs4_state_start_net ->\nnfsd4_end_grace -> nfsd4_record_grace_done -> nfsd4_cld_grace_done ->\ncld_pipe_upcall -> __cld_pipe_upcall -> wait_for_completion path), the\ndelayed work may start before nfsd_ssc initialization finishes.\n\nFix this by moving nfsd_ssc initialization before starting laundromat_work.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38232",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFSD: fix race between nfsd registration and exports_proc",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: fix race between nfsd registration and exports_proc\n\nAs of now nfsd calls create_proc_exports_entry() at start of init_nfsd\nand cleanup by remove_proc_entry() at last of exit_nfsd.\n\nWhich causes kernel OOPs if there is race between below 2 operations:\n(i) exportfs -r\n(ii) mount -t nfsd none /proc/fs/nfsd\n\nfor 5.4 kernel ARM64:\n\nCPU 1:\nel1_irq+0xbc/0x180\narch_counter_get_cntvct+0x14/0x18\nrunning_clock+0xc/0x18\npreempt_count_add+0x88/0x110\nprep_new_page+0xb0/0x220\nget_page_from_freelist+0x2d8/0x1778\n__alloc_pages_nodemask+0x15c/0xef0\n__vmalloc_node_range+0x28c/0x478\n__vmalloc_node_flags_caller+0x8c/0xb0\nkvmalloc_node+0x88/0xe0\nnfsd_init_net+0x6c/0x108 [nfsd]\nops_init+0x44/0x170\nregister_pernet_operations+0x114/0x270\nregister_pernet_subsys+0x34/0x50\ninit_nfsd+0xa8/0x718 [nfsd]\ndo_one_initcall+0x54/0x2e0\n\nCPU 2 :\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000010\n\nPC is at : exports_net_open+0x50/0x68 [nfsd]\n\nCall trace:\nexports_net_open+0x50/0x68 [nfsd]\nexports_proc_open+0x2c/0x38 [nfsd]\nproc_reg_open+0xb8/0x198\ndo_dentry_open+0x1c4/0x418\nvfs_open+0x38/0x48\npath_openat+0x28c/0xf18\ndo_filp_open+0x70/0xe8\ndo_sys_open+0x154/0x248\n\nSometimes it crashes at exports_net_open() and sometimes cache_seq_next_rcu().\n\nand same is happening on latest 6.14 kernel as well:\n\n[    0.000000] Linux version 6.14.0-rc5-next-20250304-dirty\n...\n[  285.455918] Unable to handle kernel paging request at virtual address 00001f4800001f48\n...\n[  285.464902] pc : cache_seq_next_rcu+0x78/0xa4\n...\n[  285.469695] Call trace:\n[  285.470083]  cache_seq_next_rcu+0x78/0xa4 (P)\n[  285.470488]  seq_read+0xe0/0x11c\n[  285.470675]  proc_reg_read+0x9c/0xf0\n[  285.470874]  vfs_read+0xc4/0x2fc\n[  285.471057]  ksys_read+0x6c/0xf4\n[  285.471231]  __arm64_sys_read+0x1c/0x28\n[  285.471428]  invoke_syscall+0x44/0x100\n[  285.471633]  el0_svc_common.constprop.0+0x40/0xe0\n[  285.471870]  do_el0_svc_compat+0x1c/0x34\n[  285.472073]  el0_svc_compat+0x2c/0x80\n[  285.472265]  el0t_32_sync_handler+0x90/0x140\n[  285.472473]  el0t_32_sync+0x19c/0x1a0\n[  285.472887] Code: f9400885 93407c23 937d7c27 11000421 (f86378a3)\n[  285.473422] ---[ end trace 0000000000000000 ]---\n\nIt reproduced simply with below script:\nwhile [ 1 ]\ndo\n/exportfs -r\ndone &\n\nwhile [ 1 ]\ndo\ninsmod /nfsd.ko\nmount -t nfsd none /proc/fs/nfsd\numount /proc/fs/nfsd\nrmmod nfsd\ndone &\n\nSo exporting interfaces to user space shall be done at last and\ncleanup at first place.\n\nWith change there is no Kernel OOPs.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38250",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: hci_core: Fix use-after-free in vhci_flush()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_core: Fix use-after-free in vhci_flush()\n\nsyzbot reported use-after-free in vhci_flush() without repro. [0]\n\nFrom the splat, a thread close()d a vhci file descriptor while\nits device was being used by iotcl() on another thread.\n\nOnce the last fd refcnt is released, vhci_release() calls\nhci_unregister_dev(), hci_free_dev(), and kfree() for struct\nvhci_data, which is set to hci_dev->dev->driver_data.\n\nThe problem is that there is no synchronisation after unlinking\nhdev from hci_dev_list in hci_unregister_dev().  There might be\nanother thread still accessing the hdev which was fetched before\nthe unlink operation.\n\nWe can use SRCU for such synchronisation.\n\nLet's run hci_dev_reset() under SRCU and wait for its completion\nin hci_unregister_dev().\n\nAnother option would be to restore hci_dev->destruct(), which was\nremoved in commit 587ae086f6e4 (\"Bluetooth: Remove unused\nhci-destruct cb\").  However, this would not be a good solution, as\nwe should not run hci_unregister_dev() while there are in-flight\nioctl() requests, which could lead to another data-race KCSAN splat.\n\nNote that other drivers seem to have the same problem, for exmaple,\nvirtbt_remove().\n\n[0]:\nBUG: KASAN: slab-use-after-free in skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline]\nBUG: KASAN: slab-use-after-free in skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937\nRead of size 8 at addr ffff88807cb8d858 by task syz.1.219/6718\n\nCPU: 1 UID: 0 PID: 6718 Comm: syz.1.219 Not tainted 6.16.0-rc1-syzkaller-00196-g08207f42d3ff #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xd2/0x2b0 mm/kasan/report.c:521\n kasan_report+0x118/0x150 mm/kasan/report.c:634\n skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline]\n skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937\n skb_queue_purge include/linux/skbuff.h:3368 [inline]\n vhci_flush+0x44/0x50 drivers/bluetooth/hci_vhci.c:69\n hci_dev_do_reset net/bluetooth/hci_core.c:552 [inline]\n hci_dev_reset+0x420/0x5c0 net/bluetooth/hci_core.c:592\n sock_do_ioctl+0xd9/0x300 net/socket.c:1190\n sock_ioctl+0x576/0x790 net/socket.c:1311\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fcf5b98e929\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fcf5c7b9038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007fcf5bbb6160 RCX: 00007fcf5b98e929\nRDX: 0000000000000000 RSI: 00000000400448cb RDI: 0000000000000009\nRBP: 00007fcf5ba10b39 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007fcf5bbb6160 R15: 00007ffd6353d528\n </TASK>\n\nAllocated by task 6535:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4359\n kmalloc_noprof include/linux/slab.h:905 [inline]\n kzalloc_noprof include/linux/slab.h:1039 [inline]\n vhci_open+0x57/0x360 drivers/bluetooth/hci_vhci.c:635\n misc_open+0x2bc/0x330 drivers/char/misc.c:161\n chrdev_open+0x4c9/0x5e0 fs/char_dev.c:414\n do_dentry_open+0xdf0/0x1970 fs/open.c:964\n vfs_open+0x3b/0x340 fs/open.c:1094\n do_open fs/namei.c:3887 [inline]\n path_openat+0x2ee5/0x3830 fs/name\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38264",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nvme-tcp: sanitize request list handling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-tcp: sanitize request list handling\n\nValidate the request in nvme_tcp_handle_r2t() to ensure it's not part of\nany list, otherwise a malicious R2T PDU might inject a loop in request\nlist processing.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38293",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath11k: fix node corruption in ar->arvifs list",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix node corruption in ar->arvifs list\n\nIn current WLAN recovery code flow, ath11k_core_halt() only\nreinitializes the \"arvifs\" list head. This will cause the\nlist node immediately following the list head to become an\ninvalid list node. Because the prev of that node still points\nto the list head \"arvifs\", but the next of the list head \"arvifs\"\nno longer points to that list node.\n\nWhen a WLAN recovery occurs during the execution of a vif\nremoval, and it happens before the spin_lock_bh(&ar->data_lock)\nin ath11k_mac_op_remove_interface(), list_del() will detect the\npreviously mentioned situation, thereby triggering a kernel panic.\n\nThe fix is to remove and reinitialize all vif list nodes from the\nlist head \"arvifs\" during WLAN halt. The reinitialization is to make\nthe list nodes valid, ensuring that the list_del() in\nath11k_mac_op_remove_interface() can execute normally.\n\nCall trace:\n__list_del_entry_valid_or_report+0xb8/0xd0\nath11k_mac_op_remove_interface+0xb0/0x27c [ath11k]\ndrv_remove_interface+0x48/0x194 [mac80211]\nieee80211_do_stop+0x6e0/0x844 [mac80211]\nieee80211_stop+0x44/0x17c [mac80211]\n__dev_close_many+0xac/0x150\n__dev_change_flags+0x194/0x234\ndev_change_flags+0x24/0x6c\ndevinet_ioctl+0x3a0/0x670\ninet_ioctl+0x200/0x248\nsock_do_ioctl+0x60/0x118\nsock_ioctl+0x274/0x35c\n__arm64_sys_ioctl+0xac/0xf0\ninvoke_syscall+0x48/0x114\n...\n\nTested-on: QCA6698AQ hw2.1 PCI WLAN.HSP.1.1-04591-QCAHSPSWPL_V1_V2_SILICONZ_IOE-1",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38310",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: seg6: Fix validation of nexthop addresses",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nseg6: Fix validation of nexthop addresses\n\nThe kernel currently validates that the length of the provided nexthop\naddress does not exceed the specified length. This can lead to the\nkernel reading uninitialized memory if user space provided a shorter\nlength than the specified one.\n\nFix by validating that the provided length exactly matches the specified\none.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38313",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bus: fsl-mc: fix double-free on mc_dev",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: fsl-mc: fix double-free on mc_dev\n\nThe blamed commit tried to simplify how the deallocations are done but,\nin the process, introduced a double-free on the mc_dev variable.\n\nIn case the MC device is a DPRC, a new mc_bus is allocated and the\nmc_dev variable is just a reference to one of its fields. In this\ncircumstance, on the error path only the mc_bus should be freed.\n\nThis commit introduces back the following checkpatch warning which is a\nfalse-positive.\n\nWARNING: kfree(NULL) is safe and this check is probably not required\n+       if (mc_bus)\n+               kfree(mc_bus);",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38320",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: arm64/ptrace: Fix stack-out-of-bounds read in regs_get_kernel_stack_nth()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64/ptrace: Fix stack-out-of-bounds read in regs_get_kernel_stack_nth()\n\nKASAN reports a stack-out-of-bounds read in regs_get_kernel_stack_nth().\n\nCall Trace:\n[   97.283505] BUG: KASAN: stack-out-of-bounds in regs_get_kernel_stack_nth+0xa8/0xc8\n[   97.284677] Read of size 8 at addr ffff800089277c10 by task 1.sh/2550\n[   97.285732]\n[   97.286067] CPU: 7 PID: 2550 Comm: 1.sh Not tainted 6.6.0+ #11\n[   97.287032] Hardware name: linux,dummy-virt (DT)\n[   97.287815] Call trace:\n[   97.288279]  dump_backtrace+0xa0/0x128\n[   97.288946]  show_stack+0x20/0x38\n[   97.289551]  dump_stack_lvl+0x78/0xc8\n[   97.290203]  print_address_description.constprop.0+0x84/0x3c8\n[   97.291159]  print_report+0xb0/0x280\n[   97.291792]  kasan_report+0x84/0xd0\n[   97.292421]  __asan_load8+0x9c/0xc0\n[   97.293042]  regs_get_kernel_stack_nth+0xa8/0xc8\n[   97.293835]  process_fetch_insn+0x770/0xa30\n[   97.294562]  kprobe_trace_func+0x254/0x3b0\n[   97.295271]  kprobe_dispatcher+0x98/0xe0\n[   97.295955]  kprobe_breakpoint_handler+0x1b0/0x210\n[   97.296774]  call_break_hook+0xc4/0x100\n[   97.297451]  brk_handler+0x24/0x78\n[   97.298073]  do_debug_exception+0xac/0x178\n[   97.298785]  el1_dbg+0x70/0x90\n[   97.299344]  el1h_64_sync_handler+0xcc/0xe8\n[   97.300066]  el1h_64_sync+0x78/0x80\n[   97.300699]  kernel_clone+0x0/0x500\n[   97.301331]  __arm64_sys_clone+0x70/0x90\n[   97.302084]  invoke_syscall+0x68/0x198\n[   97.302746]  el0_svc_common.constprop.0+0x11c/0x150\n[   97.303569]  do_el0_svc+0x38/0x50\n[   97.304164]  el0_svc+0x44/0x1d8\n[   97.304749]  el0t_64_sync_handler+0x100/0x130\n[   97.305500]  el0t_64_sync+0x188/0x190\n[   97.306151]\n[   97.306475] The buggy address belongs to stack of task 1.sh/2550\n[   97.307461]  and is located at offset 0 in frame:\n[   97.308257]  __se_sys_clone+0x0/0x138\n[   97.308910]\n[   97.309241] This frame has 1 object:\n[   97.309873]  [48, 184) 'args'\n[   97.309876]\n[   97.310749] The buggy address belongs to the virtual mapping at\n[   97.310749]  [ffff800089270000, ffff800089279000) created by:\n[   97.310749]  dup_task_struct+0xc0/0x2e8\n[   97.313347]\n[   97.313674] The buggy address belongs to the physical page:\n[   97.314604] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x14f69a\n[   97.315885] flags: 0x15ffffe00000000(node=1|zone=2|lastcpupid=0xfffff)\n[   97.316957] raw: 015ffffe00000000 0000000000000000 dead000000000122 0000000000000000\n[   97.318207] raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\n[   97.319445] page dumped because: kasan: bad access detected\n[   97.320371]\n[   97.320694] Memory state around the buggy address:\n[   97.321511]  ffff800089277b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   97.322681]  ffff800089277b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   97.323846] >ffff800089277c00: 00 00 f1 f1 f1 f1 f1 f1 00 00 00 00 00 00 00 00\n[   97.325023]                          ^\n[   97.325683]  ffff800089277c80: 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3 f3 f3\n[   97.326856]  ffff800089277d00: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nThis issue seems to be related to the behavior of some gcc compilers and\nwas also fixed on the s390 architecture before:\n\n commit d93a855c31b7 (\"s390/ptrace: Avoid KASAN false positives in regs_get_kernel_stack_nth()\")\n\nAs described in that commit, regs_get_kernel_stack_nth() has confirmed that\n`addr` is on the stack, so reading the value at `*addr` should be allowed.\nUse READ_ONCE_NOCHECK() helper to silence the KASAN check for this case.\n\n[will: Use '*addr' as the argument to READ_ONCE_NOCHECK()]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38324",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mpls: Use rcu_dereference_rtnl() in mpls_route_input_rcu().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmpls: Use rcu_dereference_rtnl() in mpls_route_input_rcu().\n\nAs syzbot reported [0], mpls_route_input_rcu() can be called\nfrom mpls_getroute(), where is under RTNL.\n\nnet->mpls.platform_label is only updated under RTNL.\n\nLet's use rcu_dereference_rtnl() in mpls_route_input_rcu() to\nsilence the splat.\n\n[0]:\nWARNING: suspicious RCU usage\n6.15.0-rc7-syzkaller-00082-g5cdb2c77c4c3 #0 Not tainted\n ----------------------------\nnet/mpls/af_mpls.c:84 suspicious rcu_dereference_check() usage!\n\nother info that might help us debug this:\n\nrcu_scheduler_active = 2, debug_locks = 1\n1 lock held by syz.2.4451/17730:\n #0: ffffffff9012a3e8 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_lock net/core/rtnetlink.c:80 [inline]\n #0: ffffffff9012a3e8 (rtnl_mutex){+.+.}-{4:4}, at: rtnetlink_rcv_msg+0x371/0xe90 net/core/rtnetlink.c:6961\n\nstack backtrace:\nCPU: 1 UID: 0 PID: 17730 Comm: syz.2.4451 Not tainted 6.15.0-rc7-syzkaller-00082-g5cdb2c77c4c3 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120\n lockdep_rcu_suspicious+0x166/0x260 kernel/locking/lockdep.c:6865\n mpls_route_input_rcu+0x1d4/0x200 net/mpls/af_mpls.c:84\n mpls_getroute+0x621/0x1ea0 net/mpls/af_mpls.c:2381\n rtnetlink_rcv_msg+0x3c9/0xe90 net/core/rtnetlink.c:6964\n netlink_rcv_skb+0x16d/0x440 net/netlink/af_netlink.c:2534\n netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]\n netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339\n netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n ____sys_sendmsg+0xa98/0xc70 net/socket.c:2566\n ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620\n __sys_sendmmsg+0x200/0x420 net/socket.c:2709\n __do_sys_sendmmsg net/socket.c:2736 [inline]\n __se_sys_sendmmsg net/socket.c:2733 [inline]\n __x64_sys_sendmmsg+0x9c/0x100 net/socket.c:2733\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x230 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f0a2818e969\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f0a28f52038 EFLAGS: 00000246 ORIG_RAX: 0000000000000133\nRAX: ffffffffffffffda RBX: 00007f0a283b5fa0 RCX: 00007f0a2818e969\nRDX: 0000000000000003 RSI: 0000200000000080 RDI: 0000000000000003\nRBP: 00007f0a28210ab1 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007f0a283b5fa0 R15: 00007ffce5e9f268\n </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38328",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jffs2: check jffs2_prealloc_raw_node_refs() result in few other places",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njffs2: check jffs2_prealloc_raw_node_refs() result in few other places\n\nFuzzing hit another invalid pointer dereference due to the lack of\nchecking whether jffs2_prealloc_raw_node_refs() completed successfully.\nSubsequent logic implies that the node refs have been allocated.\n\nHandle that. The code is ready for propagating the error upwards.\n\nKASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]\nCPU: 1 PID: 5835 Comm: syz-executor145 Not tainted 5.10.234-syzkaller #0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nRIP: 0010:jffs2_link_node_ref+0xac/0x690 fs/jffs2/nodelist.c:600\nCall Trace:\n jffs2_mark_erased_block fs/jffs2/erase.c:460 [inline]\n jffs2_erase_pending_blocks+0x688/0x1860 fs/jffs2/erase.c:118\n jffs2_garbage_collect_pass+0x638/0x1a00 fs/jffs2/gc.c:253\n jffs2_reserve_space+0x3f4/0xad0 fs/jffs2/nodemgmt.c:167\n jffs2_write_inode_range+0x246/0xb50 fs/jffs2/write.c:362\n jffs2_write_end+0x712/0x1110 fs/jffs2/file.c:302\n generic_perform_write+0x2c2/0x500 mm/filemap.c:3347\n __generic_file_write_iter+0x252/0x610 mm/filemap.c:3465\n generic_file_write_iter+0xdb/0x230 mm/filemap.c:3497\n call_write_iter include/linux/fs.h:2039 [inline]\n do_iter_readv_writev+0x46d/0x750 fs/read_write.c:740\n do_iter_write+0x18c/0x710 fs/read_write.c:866\n vfs_writev+0x1db/0x6a0 fs/read_write.c:939\n do_pwritev fs/read_write.c:1036 [inline]\n __do_sys_pwritev fs/read_write.c:1083 [inline]\n __se_sys_pwritev fs/read_write.c:1078 [inline]\n __x64_sys_pwritev+0x235/0x310 fs/read_write.c:1078\n do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x67/0xd1\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38332",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: lpfc: Use memcpy() for BIOS version",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Use memcpy() for BIOS version\n\nThe strlcat() with FORTIFY support is triggering a panic because it\nthinks the target buffer will overflow although the correct target\nbuffer size is passed in.\n\nAnyway, instead of memset() with 0 followed by a strlcat(), just use\nmemcpy() and ensure that the resulting buffer is NULL terminated.\n\nBIOSVersion is only used for the lpfc_printf_log() which expects a\nproperly terminated string.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38350",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Always pass notifications when child class becomes empty",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Always pass notifications when child class becomes empty\n\nCertain classful qdiscs may invoke their classes' dequeue handler on an\nenqueue operation. This may unexpectedly empty the child qdisc and thus\nmake an in-flight class passive via qlen_notify(). Most qdiscs do not\nexpect such behaviour at this point in time and may re-activate the\nclass eventually anyways which will lead to a use-after-free.\n\nThe referenced fix commit attempted to fix this behavior for the HFSC\ncase by moving the backlog accounting around, though this turned out to\nbe incomplete since the parent's parent may run into the issue too.\nThe following reproducer demonstrates this use-after-free:\n\n    tc qdisc add dev lo root handle 1: drr\n    tc filter add dev lo parent 1: basic classid 1:1\n    tc class add dev lo parent 1: classid 1:1 drr\n    tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1\n    tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0\n    tc qdisc add dev lo parent 2:1 handle 3: netem\n    tc qdisc add dev lo parent 3:1 handle 4: blackhole\n\n    echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888\n    tc class delete dev lo classid 1:1\n    echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888\n\nSince backlog accounting issues leading to a use-after-frees on stale\nclass pointers is a recurring pattern at this point, this patch takes\na different approach. Instead of trying to fix the accounting, the patch\nensures that qdisc_tree_reduce_backlog always calls qlen_notify when\nthe child qdisc is empty. This solves the problem because deletion of\nqdiscs always involves a call to qdisc_reset() and / or\nqdisc_purge_queue() which ultimately resets its qlen to 0 thus causing\nthe following qdisc_tree_reduce_backlog() to report to the parent. Note\nthat this may call qlen_notify on passive classes multiple times. This\nis not a problem after the recent patch series that made all the\nclassful qdiscs qlen_notify() handlers idempotent.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38352",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: posix-cpu-timers: fix race between handle_posix_cpu_timers() and posix_cpu_timer_del()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nposix-cpu-timers: fix race between handle_posix_cpu_timers() and posix_cpu_timer_del()\n\nIf an exiting non-autoreaping task has already passed exit_notify() and\ncalls handle_posix_cpu_timers() from IRQ, it can be reaped by its parent\nor debugger right after unlock_task_sighand().\n\nIf a concurrent posix_cpu_timer_del() runs at that moment, it won't be\nable to detect timer->it.cpu.firing != 0: cpu_timer_task_rcu() and/or\nlock_task_sighand() will fail.\n\nAdd the tsk->exit_state check into run_posix_cpu_timers() to fix this.\n\nThis fix is not needed if CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y, because\nexit_task_work() is called before exit_notify(). But the check still\nmakes sense, task_work_add(&tsk->posix_cputimers_work.work) will fail\nanyway in this case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38386",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ACPICA: Refuse to evaluate a method if arguments are missing",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Refuse to evaluate a method if arguments are missing\n\nAs reported in [1], a platform firmware update that increased the number\nof method parameters and forgot to update a least one of its callers,\ncaused ACPICA to crash due to use-after-free.\n\nSince this a result of a clear AML issue that arguably cannot be fixed\nup by the interpreter (it cannot produce missing data out of thin air),\naddress it by making ACPICA refuse to evaluate a method if the caller\nattempts to pass fewer arguments than expected to it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38399",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: target: Fix NULL pointer dereference in core_scsi3_decode_spec_i_port()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: Fix NULL pointer dereference in core_scsi3_decode_spec_i_port()\n\nThe function core_scsi3_decode_spec_i_port(), in its error code path,\nunconditionally calls core_scsi3_lunacl_undepend_item() passing the\ndest_se_deve pointer, which may be NULL.\n\nThis can lead to a NULL pointer dereference if dest_se_deve remains\nunset.\n\nSPC-3 PR SPEC_I_PT: Unable to locate dest_tpg\nUnable to handle kernel paging request at virtual address dfff800000000012\nCall trace:\n  core_scsi3_lunacl_undepend_item+0x2c/0xf0 [target_core_mod] (P)\n  core_scsi3_decode_spec_i_port+0x120c/0x1c30 [target_core_mod]\n  core_scsi3_emulate_pro_register+0x6b8/0xcd8 [target_core_mod]\n  target_scsi3_emulate_pr_out+0x56c/0x840 [target_core_mod]\n\nFix this by adding a NULL check before calling\ncore_scsi3_lunacl_undepend_item()",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38403",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vsock/vmci: Clear the vmci transport packet properly when initializing it",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock/vmci: Clear the vmci transport packet properly when initializing it\n\nIn vmci_transport_packet_init memset the vmci_transport_packet before\npopulating the fields to avoid any uninitialised data being left in the\nstructure.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38408",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: genirq/irq_sim: Initialize work context pointers properly",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngenirq/irq_sim: Initialize work context pointers properly\n\nInitialize `ops` member's pointers properly by using kzalloc() instead of\nkmalloc() when allocating the simulation work context. Otherwise the\npointers contain random content leading to invalid dereferencing.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38415",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Squashfs: check return result of sb_min_blocksize",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: check return result of sb_min_blocksize\n\nSyzkaller reports an \"UBSAN: shift-out-of-bounds in squashfs_bio_read\" bug.\n\nSyzkaller forks multiple processes which after mounting the Squashfs\nfilesystem, issues an ioctl(\"/dev/loop0\", LOOP_SET_BLOCK_SIZE, 0x8000). \nNow if this ioctl occurs at the same time another process is in the\nprocess of mounting a Squashfs filesystem on /dev/loop0, the failure\noccurs.  When this happens the following code in squashfs_fill_super()\nfails.\n\n----\nmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);\nmsblk->devblksize_log2 = ffz(~msblk->devblksize);\n----\n\nsb_min_blocksize() returns 0, which means msblk->devblksize is set to 0.\n\nAs a result, ffz(~msblk->devblksize) returns 64, and msblk->devblksize_log2\nis set to 64.\n\nThis subsequently causes the\n\nUBSAN: shift-out-of-bounds in fs/squashfs/block.c:195:36\nshift exponent 64 is too large for 64-bit type 'u64' (aka\n'unsigned long long')\n\nThis commit adds a check for a 0 return by sb_min_blocksize().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38420",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: carl9170: do not ping device which has failed to load firmware",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: carl9170: do not ping device which has failed to load firmware\n\nSyzkaller reports [1, 2] crashes caused by an attempts to ping\nthe device which has failed to load firmware. Since such a device\ndoesn't pass 'ieee80211_register_hw()', an internal workqueue\nmanaged by 'ieee80211_queue_work()' is not yet created and an\nattempt to queue work on it causes null-ptr-deref.\n\n[1] https://syzkaller.appspot.com/bug?extid=9a4aec827829942045ff\n[2] https://syzkaller.appspot.com/bug?extid=0d8afba53e8fb2633217",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38424",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf: Fix sample vs do_exit()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix sample vs do_exit()\n\nBaisheng Gao reported an ARM64 crash, which Mark decoded as being a\nsynchronous external abort -- most likely due to trying to access\nMMIO in bad ways.\n\nThe crash further shows perf trying to do a user stack sample while in\nexit_mmap()'s tlb_finish_mmu() -- i.e. while tearing down the address\nspace it is trying to access.\n\nIt turns out that we stop perf after we tear down the userspace mm; a\nreceipie for disaster, since perf likes to access userspace for\nvarious reasons.\n\nFlip this order by moving up where we stop perf in do_exit().\n\nAdditionally, harden PERF_SAMPLE_CALLCHAIN and PERF_SAMPLE_STACK_USER\nto abort when the current task does not have an mm (exit_mm() makes\nsure to set current->mm = NULL; before commencing with the actual\nteardown). Such that CPU wide events don't trip on this same problem.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38425",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i2c: tegra: check msg length in SMBUS block read",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: tegra: check msg length in SMBUS block read\n\nFor SMBUS block read, do not continue to read if the message length\npassed from the device is '0' or greater than the maximum allowed bytes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38439",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bnxt_en: Set DMA unmap len correctly for XDP_REDIRECT",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt_en: Set DMA unmap len correctly for XDP_REDIRECT\n\nWhen transmitting an XDP_REDIRECT packet, call dma_unmap_len_set()\nwith the proper length instead of 0.  This bug triggers this warning\non a system with IOMMU enabled:\n\nWARNING: CPU: 36 PID: 0 at drivers/iommu/dma-iommu.c:842 __iommu_dma_unmap+0x159/0x170\nRIP: 0010:__iommu_dma_unmap+0x159/0x170\nCode: a8 00 00 00 00 48 c7 45 b0 00 00 00 00 48 c7 45 c8 00 00 00 00 48 c7 45 a0 ff ff ff ff 4c 89 45\nb8 4c 89 45 c0 e9 77 ff ff ff <0f> 0b e9 60 ff ff ff e8 8b bf 6a 00 66 66 2e 0f 1f 84 00 00 00 00\nRSP: 0018:ff22d31181150c88 EFLAGS: 00010206\nRAX: 0000000000002000 RBX: 00000000e13a0000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ff22d31181150cf0 R08: ff22d31181150ca8 R09: 0000000000000000\nR10: 0000000000000000 R11: ff22d311d36c9d80 R12: 0000000000001000\nR13: ff13544d10645010 R14: ff22d31181150c90 R15: ff13544d0b2bac00\nFS: 0000000000000000(0000) GS:ff13550908a00000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00005be909dacff8 CR3: 0008000173408003 CR4: 0000000000f71ef0\nPKRU: 55555554\nCall Trace:\n<IRQ>\n? show_regs+0x6d/0x80\n? __warn+0x89/0x160\n? __iommu_dma_unmap+0x159/0x170\n? report_bug+0x17e/0x1b0\n? handle_bug+0x46/0x90\n? exc_invalid_op+0x18/0x80\n? asm_exc_invalid_op+0x1b/0x20\n? __iommu_dma_unmap+0x159/0x170\n? __iommu_dma_unmap+0xb3/0x170\niommu_dma_unmap_page+0x4f/0x100\ndma_unmap_page_attrs+0x52/0x220\n? srso_alias_return_thunk+0x5/0xfbef5\n? xdp_return_frame+0x2e/0xd0\nbnxt_tx_int_xdp+0xdf/0x440 [bnxt_en]\n__bnxt_poll_work_done+0x81/0x1e0 [bnxt_en]\nbnxt_poll+0xd3/0x1e0 [bnxt_en]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38445",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: md/raid1: Fix stack memory use after return in raid1_reshape",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid1: Fix stack memory use after return in raid1_reshape\n\nIn the raid1_reshape function, newpool is\nallocated on the stack and assigned to conf->r1bio_pool.\nThis results in conf->r1bio_pool.wait.head pointing\nto a stack address.\nAccessing this address later can lead to a kernel panic.\n\nExample access path:\n\nraid1_reshape()\n{\n\t// newpool is on the stack\n\tmempool_t newpool, oldpool;\n\t// initialize newpool.wait.head to stack address\n\tmempool_init(&newpool, ...);\n\tconf->r1bio_pool = newpool;\n}\n\nraid1_read_request() or raid1_write_request()\n{\n\talloc_r1bio()\n\t{\n\t\tmempool_alloc()\n\t\t{\n\t\t\t// if pool->alloc fails\n\t\t\tremove_element()\n\t\t\t{\n\t\t\t\t--pool->curr_nr;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmempool_free()\n{\n\tif (pool->curr_nr < pool->min_nr) {\n\t\t// pool->wait.head is a stack address\n\t\t// wake_up() will try to access this invalid address\n\t\t// which leads to a kernel panic\n\t\treturn;\n\t\twake_up(&pool->wait);\n\t}\n}\n\nFix:\nreinit conf->r1bio_pool.wait after assigning newpool.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38449",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: drm/gem: Acquire references on GEM handles for framebuffers",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/gem: Acquire references on GEM handles for framebuffers\n\nA GEM handle can be released while the GEM buffer object is attached\nto a DRM framebuffer. This leads to the release of the dma-buf backing\nthe buffer object, if any. [1] Trying to use the framebuffer in further\nmode-setting operations leads to a segmentation fault. Most easily\nhappens with driver that use shadow planes for vmap-ing the dma-buf\nduring a page flip. An example is shown below.\n\n[  156.791968] ------------[ cut here ]------------\n[  156.796830] WARNING: CPU: 2 PID: 2255 at drivers/dma-buf/dma-buf.c:1527 dma_buf_vmap+0x224/0x430\n[...]\n[  156.942028] RIP: 0010:dma_buf_vmap+0x224/0x430\n[  157.043420] Call Trace:\n[  157.045898]  <TASK>\n[  157.048030]  ? show_trace_log_lvl+0x1af/0x2c0\n[  157.052436]  ? show_trace_log_lvl+0x1af/0x2c0\n[  157.056836]  ? show_trace_log_lvl+0x1af/0x2c0\n[  157.061253]  ? drm_gem_shmem_vmap+0x74/0x710\n[  157.065567]  ? dma_buf_vmap+0x224/0x430\n[  157.069446]  ? __warn.cold+0x58/0xe4\n[  157.073061]  ? dma_buf_vmap+0x224/0x430\n[  157.077111]  ? report_bug+0x1dd/0x390\n[  157.080842]  ? handle_bug+0x5e/0xa0\n[  157.084389]  ? exc_invalid_op+0x14/0x50\n[  157.088291]  ? asm_exc_invalid_op+0x16/0x20\n[  157.092548]  ? dma_buf_vmap+0x224/0x430\n[  157.096663]  ? dma_resv_get_singleton+0x6d/0x230\n[  157.101341]  ? __pfx_dma_buf_vmap+0x10/0x10\n[  157.105588]  ? __pfx_dma_resv_get_singleton+0x10/0x10\n[  157.110697]  drm_gem_shmem_vmap+0x74/0x710\n[  157.114866]  drm_gem_vmap+0xa9/0x1b0\n[  157.118763]  drm_gem_vmap_unlocked+0x46/0xa0\n[  157.123086]  drm_gem_fb_vmap+0xab/0x300\n[  157.126979]  drm_atomic_helper_prepare_planes.part.0+0x487/0xb10\n[  157.133032]  ? lockdep_init_map_type+0x19d/0x880\n[  157.137701]  drm_atomic_helper_commit+0x13d/0x2e0\n[  157.142671]  ? drm_atomic_nonblocking_commit+0xa0/0x180\n[  157.147988]  drm_mode_atomic_ioctl+0x766/0xe40\n[...]\n[  157.346424] ---[ end trace 0000000000000000 ]---\n\nAcquiring GEM handles for the framebuffer's GEM buffer objects prevents\nthis from happening. The framebuffer's cleanup later puts the handle\nreferences.\n\nCommit 1a148af06000 (\"drm/gem-shmem: Use dma_buf from GEM object\ninstance\") triggers the segmentation fault easily by using the dma-buf\nfield more widely. The underlying issue with reference counting has\nbeen present before.\n\nv2:\n- acquire the handle instead of the BO (Christian)\n- fix comment style (Christian)\n- drop the Fixes tag (Christian)\n- rename err_ gotos\n- add missing Link tag",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38457",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Abort __tc_modify_qdisc if parent class does not exist",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Abort __tc_modify_qdisc if parent class does not exist\n\nLion's patch [1] revealed an ancient bug in the qdisc API.\nWhenever a user creates/modifies a qdisc specifying as a parent another\nqdisc, the qdisc API will, during grafting, detect that the user is\nnot trying to attach to a class and reject. However grafting is\nperformed after qdisc_create (and thus the qdiscs' init callback) is\nexecuted. In qdiscs that eventually call qdisc_tree_reduce_backlog\nduring init or change (such as fq, hhf, choke, etc), an issue\narises. For example, executing the following commands:\n\nsudo tc qdisc add dev lo root handle a: htb default 2\nsudo tc qdisc add dev lo parent a: handle beef fq\n\nQdiscs such as fq, hhf, choke, etc unconditionally invoke\nqdisc_tree_reduce_backlog() in their control path init() or change() which\nthen causes a failure to find the child class; however, that does not stop\nthe unconditional invocation of the assumed child qdisc's qlen_notify with\na null class. All these qdiscs make the assumption that class is non-null.\n\nThe solution is ensure that qdisc_leaf() which looks up the parent\nclass, and is invoked prior to qdisc_create(), should return failure on\nnot finding the class.\nIn this patch, we leverage qdisc_leaf to return ERR_PTRs whenever the\nparentid doesn't correspond to a class, so that we can detect it\nearlier on and abort before qdisc_create is called.\n\n[1] https://lore.kernel.org/netdev/d912cbd7-193b-4269-9857-525bee8bbb6a@gmail.com/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38459",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: atm: clip: Fix infinite recursive call of clip_push().",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: clip: Fix infinite recursive call of clip_push().\n\nsyzbot reported the splat below. [0]\n\nThis happens if we call ioctl(ATMARP_MKIP) more than once.\n\nDuring the first call, clip_mkip() sets clip_push() to vcc->push(),\nand the second call copies it to clip_vcc->old_push().\n\nLater, when the socket is close()d, vcc_destroy_socket() passes\nNULL skb to clip_push(), which calls clip_vcc->old_push(),\ntriggering the infinite recursion.\n\nLet's prevent the second ioctl(ATMARP_MKIP) by checking\nvcc->user_back, which is allocated by the first call as clip_vcc.\n\nNote also that we use lock_sock() to prevent racy calls.\n\n[0]:\nBUG: TASK stack guard page was hit at ffffc9000d66fff8 (stack is ffffc9000d670000..ffffc9000d678000)\nOops: stack guard page: 0000 [#1] SMP KASAN NOPTI\nCPU: 0 UID: 0 PID: 5322 Comm: syz.0.0 Not tainted 6.16.0-rc4-syzkaller #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nRIP: 0010:clip_push+0x5/0x720 net/atm/clip.c:191\nCode: e0 8f aa 8c e8 1c ad 5b fa eb ae 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 55 <41> 57 41 56 41 55 41 54 53 48 83 ec 20 48 89 f3 49 89 fd 48 bd 00\nRSP: 0018:ffffc9000d670000 EFLAGS: 00010246\nRAX: 1ffff1100235a4a5 RBX: ffff888011ad2508 RCX: ffff8880003c0000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff888037f01000\nRBP: dffffc0000000000 R08: ffffffff8fa104f7 R09: 1ffffffff1f4209e\nR10: dffffc0000000000 R11: ffffffff8a99b300 R12: ffffffff8a99b300\nR13: ffff888037f01000 R14: ffff888011ad2500 R15: ffff888037f01578\nFS:  000055557ab6d500(0000) GS:ffff88808d250000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000d66fff8 CR3: 0000000043172000 CR4: 0000000000352ef0\nCall Trace:\n <TASK>\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n...\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n vcc_destroy_socket net/atm/common.c:183 [inline]\n vcc_release+0x157/0x460 net/atm/common.c:205\n __sock_release net/socket.c:647 [inline]\n sock_close+0xc0/0x240 net/socket.c:1391\n __fput+0x449/0xa70 fs/file_table.c:465\n task_work_run+0x1d1/0x260 kernel/task_work.c:227\n resume_user_mode_work include/linux/resume_user_mode.h:50 [inline]\n exit_to_user_mode_loop+0xec/0x110 kernel/entry/common.c:114\n exit_to_user_mode_prepare include/linux/entry-common.h:330 [inline]\n syscall_exit_to_user_mode_work include/linux/entry-common.h:414 [inline]\n syscall_exit_to_user_mode include/linux/entry-common.h:449 [inline]\n do_syscall_64+0x2bd/0x3b0 arch/x86/entry/syscall_64.c:100\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7ff31c98e929\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fffb5aa1f78 EFLAGS: 00000246 ORIG_RAX: 00000000000001b4\nRAX: 0000000000000000 RBX: 0000000000012747 RCX: 00007ff31c98e929\nRDX: 0000000000000000 RSI: 000000000000001e RDI: 0000000000000003\nRBP: 00007ff31cbb7ba0 R08: 0000000000000001 R09: 0000000db5aa226f\nR10: 00007ff31c7ff030 R11: 0000000000000246 R12: 00007ff31cbb608c\nR13: 00007ff31cbb6080 R14: ffffffffffffffff R15: 00007fffb5aa2090\n </TASK>\nModules linked in:",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38461",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vsock: Fix transport_* TOCTOU",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: Fix transport_* TOCTOU\n\nTransport assignment may race with module unload. Protect new_transport\nfrom becoming a stale pointer.\n\nThis also takes care of an insecure call in vsock_use_local_transport();\nadd a lockdep assert.\n\nBUG: unable to handle page fault for address: fffffbfff8056000\nOops: Oops: 0000 [#1] SMP KASAN\nRIP: 0010:vsock_assign_transport+0x366/0x600\nCall Trace:\n vsock_connect+0x59c/0xc40\n __sys_connect+0xe8/0x100\n __x64_sys_connect+0x6e/0xc0\n do_syscall_64+0x92/0x1c0\n entry_SYSCALL_64_after_hwframe+0x4b/0x53",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38462",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: vsock: Fix transport_{g2h,h2g} TOCTOU",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: Fix transport_{g2h,h2g} TOCTOU\n\nvsock_find_cid() and vsock_dev_do_ioctl() may race with module unload.\ntransport_{g2h,h2g} may become NULL after the NULL check.\n\nIntroduce vsock_transport_local_cid() to protect from a potential\nnull-ptr-deref.\n\nKASAN: null-ptr-deref in range [0x0000000000000118-0x000000000000011f]\nRIP: 0010:vsock_find_cid+0x47/0x90\nCall Trace:\n __vsock_bind+0x4b2/0x720\n vsock_bind+0x90/0xe0\n __sys_bind+0x14d/0x1e0\n __x64_sys_bind+0x6e/0xc0\n do_syscall_64+0x92/0x1c0\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\nKASAN: null-ptr-deref in range [0x0000000000000118-0x000000000000011f]\nRIP: 0010:vsock_dev_do_ioctl.isra.0+0x58/0xf0\nCall Trace:\n __x64_sys_ioctl+0x12d/0x190\n do_syscall_64+0x92/0x1c0\n entry_SYSCALL_64_after_hwframe+0x4b/0x53",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38464",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tipc: Fix use-after-free in tipc_conn_close()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Fix use-after-free in tipc_conn_close().\n\nsyzbot reported a null-ptr-deref in tipc_conn_close() during netns\ndismantle. [0]\n\ntipc_topsrv_stop() iterates tipc_net(net)->topsrv->conn_idr and calls\ntipc_conn_close() for each tipc_conn.\n\nThe problem is that tipc_conn_close() is called after releasing the\nIDR lock.\n\nAt the same time, there might be tipc_conn_recv_work() running and it\ncould call tipc_conn_close() for the same tipc_conn and release its\nlast ->kref.\n\nOnce we release the IDR lock in tipc_topsrv_stop(), there is no\nguarantee that the tipc_conn is alive.\n\nLet's hold the ref before releasing the lock and put the ref after\ntipc_conn_close() in tipc_topsrv_stop().\n\n[0]:\nBUG: KASAN: use-after-free in tipc_conn_close+0x122/0x140 net/tipc/topsrv.c:165\nRead of size 8 at addr ffff888099305a08 by task kworker/u4:3/435\n\nCPU: 0 PID: 435 Comm: kworker/u4:3 Not tainted 4.19.204-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nWorkqueue: netns cleanup_net\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x1fc/0x2ef lib/dump_stack.c:118\n print_address_description.cold+0x54/0x219 mm/kasan/report.c:256\n kasan_report_error.cold+0x8a/0x1b9 mm/kasan/report.c:354\n kasan_report mm/kasan/report.c:412 [inline]\n __asan_report_load8_noabort+0x88/0x90 mm/kasan/report.c:433\n tipc_conn_close+0x122/0x140 net/tipc/topsrv.c:165\n tipc_topsrv_stop net/tipc/topsrv.c:701 [inline]\n tipc_topsrv_exit_net+0x27b/0x5c0 net/tipc/topsrv.c:722\n ops_exit_list+0xa5/0x150 net/core/net_namespace.c:153\n cleanup_net+0x3b4/0x8b0 net/core/net_namespace.c:553\n process_one_work+0x864/0x1570 kernel/workqueue.c:2153\n worker_thread+0x64c/0x1130 kernel/workqueue.c:2296\n kthread+0x33f/0x460 kernel/kthread.c:259\n ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415\n\nAllocated by task 23:\n kmem_cache_alloc_trace+0x12f/0x380 mm/slab.c:3625\n kmalloc include/linux/slab.h:515 [inline]\n kzalloc include/linux/slab.h:709 [inline]\n tipc_conn_alloc+0x43/0x4f0 net/tipc/topsrv.c:192\n tipc_topsrv_accept+0x1b5/0x280 net/tipc/topsrv.c:470\n process_one_work+0x864/0x1570 kernel/workqueue.c:2153\n worker_thread+0x64c/0x1130 kernel/workqueue.c:2296\n kthread+0x33f/0x460 kernel/kthread.c:259\n ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415\n\nFreed by task 23:\n __cache_free mm/slab.c:3503 [inline]\n kfree+0xcc/0x210 mm/slab.c:3822\n tipc_conn_kref_release net/tipc/topsrv.c:150 [inline]\n kref_put include/linux/kref.h:70 [inline]\n conn_put+0x2cd/0x3a0 net/tipc/topsrv.c:155\n process_one_work+0x864/0x1570 kernel/workqueue.c:2153\n worker_thread+0x64c/0x1130 kernel/workqueue.c:2296\n kthread+0x33f/0x460 kernel/kthread.c:259\n ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415\n\nThe buggy address belongs to the object at ffff888099305a00\n which belongs to the cache kmalloc-512 of size 512\nThe buggy address is located 8 bytes inside of\n 512-byte region [ffff888099305a00, ffff888099305c00)\nThe buggy address belongs to the page:\npage:ffffea000264c140 count:1 mapcount:0 mapping:ffff88813bff0940 index:0x0\nflags: 0xfff00000000100(slab)\nraw: 00fff00000000100 ffffea00028b6b88 ffffea0002cd2b08 ffff88813bff0940\nraw: 0000000000000000 ffff888099305000 0000000100000006 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888099305900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888099305980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff888099305a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff888099305a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888099305b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38466",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf: Revert to requiring CAP_SYS_ADMIN for uprobes",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Revert to requiring CAP_SYS_ADMIN for uprobes\n\nJann reports that uprobes can be used destructively when used in the\nmiddle of an instruction. The kernel only verifies there is a valid\ninstruction at the requested offset, but due to variable instruction\nlength cannot determine if this is an instruction as seen by the\nintended execution stream.\n\nAdditionally, Mark Rutland notes that on architectures that mix data\nin the text segment (like arm64), a similar things can be done if the\ndata word is 'mistaken' for an instruction.\n\nAs such, require CAP_SYS_ADMIN for uprobes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38473",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: Bluetooth: Fix null-ptr-deref in l2cap_sock_resume_cb()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix null-ptr-deref in l2cap_sock_resume_cb()\n\nsyzbot reported null-ptr-deref in l2cap_sock_resume_cb(). [0]\n\nl2cap_sock_resume_cb() has a similar problem that was fixed by commit\n1bff51ea59a9 (\"Bluetooth: fix use-after-free error in lock_sock_nested()\").\n\nSince both l2cap_sock_kill() and l2cap_sock_resume_cb() are executed\nunder l2cap_sock_resume_cb(), we can avoid the issue simply by checking\nif chan->data is NULL.\n\nLet's not access to the killed socket in l2cap_sock_resume_cb().\n\n[0]:\nBUG: KASAN: null-ptr-deref in instrument_atomic_write include/linux/instrumented.h:82 [inline]\nBUG: KASAN: null-ptr-deref in clear_bit include/asm-generic/bitops/instrumented-atomic.h:41 [inline]\nBUG: KASAN: null-ptr-deref in l2cap_sock_resume_cb+0xb4/0x17c net/bluetooth/l2cap_sock.c:1711\nWrite of size 8 at addr 0000000000000570 by task kworker/u9:0/52\n\nCPU: 1 UID: 0 PID: 52 Comm: kworker/u9:0 Not tainted 6.16.0-rc4-syzkaller-g7482bb149b9f #0 PREEMPT\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nWorkqueue: hci0 hci_rx_work\nCall trace:\n show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:501 (C)\n __dump_stack+0x30/0x40 lib/dump_stack.c:94\n dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120\n print_report+0x58/0x84 mm/kasan/report.c:524\n kasan_report+0xb0/0x110 mm/kasan/report.c:634\n check_region_inline mm/kasan/generic.c:-1 [inline]\n kasan_check_range+0x264/0x2a4 mm/kasan/generic.c:189\n __kasan_check_write+0x20/0x30 mm/kasan/shadow.c:37\n instrument_atomic_write include/linux/instrumented.h:82 [inline]\n clear_bit include/asm-generic/bitops/instrumented-atomic.h:41 [inline]\n l2cap_sock_resume_cb+0xb4/0x17c net/bluetooth/l2cap_sock.c:1711\n l2cap_security_cfm+0x524/0xea0 net/bluetooth/l2cap_core.c:7357\n hci_auth_cfm include/net/bluetooth/hci_core.h:2092 [inline]\n hci_auth_complete_evt+0x2e8/0xa4c net/bluetooth/hci_event.c:3514\n hci_event_func net/bluetooth/hci_event.c:7511 [inline]\n hci_event_packet+0x650/0xe9c net/bluetooth/hci_event.c:7565\n hci_rx_work+0x320/0xb18 net/bluetooth/hci_core.c:4070\n process_one_work+0x7e8/0x155c kernel/workqueue.c:3238\n process_scheduled_works kernel/workqueue.c:3321 [inline]\n worker_thread+0x958/0xed8 kernel/workqueue.c:3402\n kthread+0x5fc/0x75c kernel/kthread.c:464\n ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:847",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38474",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: net: sierra: check for no status endpoint",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: net: sierra: check for no status endpoint\n\nThe driver checks for having three endpoints and\nhaving bulk in and out endpoints, but not that\nthe third endpoint is interrupt input.\nRectify the omission.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38477",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: sch_qfq: Fix race condition on qfq_aggregate",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_qfq: Fix race condition on qfq_aggregate\n\nA race condition can occur when 'agg' is modified in qfq_change_agg\n(called during qfq_enqueue) while other threads access it\nconcurrently. For example, qfq_dump_class may trigger a NULL\ndereference, and qfq_delete_class may cause a use-after-free.\n\nThis patch addresses the issue by:\n\n1. Moved qfq_destroy_class into the critical section.\n\n2. Added sch_tree_lock protection to qfq_dump_class and\nqfq_dump_class_stats.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38488",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix use-after-free in crypt_message when using async crypto",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free in crypt_message when using async crypto\n\nThe CVE-2024-50047 fix removed asynchronous crypto handling from\ncrypt_message(), assuming all crypto operations are synchronous.\nHowever, when hardware crypto accelerators are used, this can cause\nuse-after-free crashes:\n\n  crypt_message()\n    // Allocate the creq buffer containing the req\n    creq = smb2_get_aead_req(..., &req);\n\n    // Async encryption returns -EINPROGRESS immediately\n    rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);\n\n    // Free creq while async operation is still in progress\n    kvfree_sensitive(creq, ...);\n\nHardware crypto modules often implement async AEAD operations for\nperformance. When crypto_aead_encrypt/decrypt() returns -EINPROGRESS,\nthe operation completes asynchronously. Without crypto_wait_req(),\nthe function immediately frees the request buffer, leading to crashes\nwhen the driver later accesses the freed memory.\n\nThis results in a use-after-free condition when the hardware crypto\ndriver later accesses the freed request structure, leading to kernel\ncrashes with NULL pointer dereferences.\n\nThe issue occurs because crypto_alloc_aead() with mask=0 doesn't\nguarantee synchronous operation. Even without CRYPTO_ALG_ASYNC in\nthe mask, async implementations can be selected.\n\nFix by restoring the async crypto handling:\n- DECLARE_CRYPTO_WAIT(wait) for completion tracking\n- aead_request_set_callback() for async completion notification\n- crypto_wait_req() to wait for operation completion\n\nThis ensures the request buffer isn't freed until the crypto operation\ncompletes, whether synchronous or asynchronous, while preserving the\nCVE-2024-50047 fix.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38491",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mptcp: make fallback action and fallback decision atomic",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: make fallback action and fallback decision atomic\n\nSyzkaller reported the following splat:\n\n  WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 __mptcp_do_fallback net/mptcp/protocol.h:1223 [inline]\n  WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 mptcp_do_fallback net/mptcp/protocol.h:1244 [inline]\n  WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 check_fully_established net/mptcp/options.c:982 [inline]\n  WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 mptcp_incoming_options+0x21a8/0x2510 net/mptcp/options.c:1153\n  Modules linked in:\n  CPU: 1 UID: 0 PID: 7704 Comm: syz.3.1419 Not tainted 6.16.0-rc3-gbd5ce2324dba #20 PREEMPT(voluntary)\n  Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n  RIP: 0010:__mptcp_do_fallback net/mptcp/protocol.h:1223 [inline]\n  RIP: 0010:mptcp_do_fallback net/mptcp/protocol.h:1244 [inline]\n  RIP: 0010:check_fully_established net/mptcp/options.c:982 [inline]\n  RIP: 0010:mptcp_incoming_options+0x21a8/0x2510 net/mptcp/options.c:1153\n  Code: 24 18 e8 bb 2a 00 fd e9 1b df ff ff e8 b1 21 0f 00 e8 ec 5f c4 fc 44 0f b7 ac 24 b0 00 00 00 e9 54 f1 ff ff e8 d9 5f c4 fc 90 <0f> 0b 90 e9 b8 f4 ff ff e8 8b 2a 00 fd e9 8d e6 ff ff e8 81 2a 00\n  RSP: 0018:ffff8880a3f08448 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffff8880180a8000 RCX: ffffffff84afcf45\n  RDX: ffff888090223700 RSI: ffffffff84afdaa7 RDI: 0000000000000001\n  RBP: ffff888017955780 R08: 0000000000000001 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n  R13: ffff8880180a8910 R14: ffff8880a3e9d058 R15: 0000000000000000\n  FS:  00005555791b8500(0000) GS:ffff88811c495000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 000000110c2800b7 CR3: 0000000058e44000 CR4: 0000000000350ef0\n  Call Trace:\n   <IRQ>\n   tcp_reset+0x26f/0x2b0 net/ipv4/tcp_input.c:4432\n   tcp_validate_incoming+0x1057/0x1b60 net/ipv4/tcp_input.c:5975\n   tcp_rcv_established+0x5b5/0x21f0 net/ipv4/tcp_input.c:6166\n   tcp_v4_do_rcv+0x5dc/0xa70 net/ipv4/tcp_ipv4.c:1925\n   tcp_v4_rcv+0x3473/0x44a0 net/ipv4/tcp_ipv4.c:2363\n   ip_protocol_deliver_rcu+0xba/0x480 net/ipv4/ip_input.c:205\n   ip_local_deliver_finish+0x2f1/0x500 net/ipv4/ip_input.c:233\n   NF_HOOK include/linux/netfilter.h:317 [inline]\n   NF_HOOK include/linux/netfilter.h:311 [inline]\n   ip_local_deliver+0x1be/0x560 net/ipv4/ip_input.c:254\n   dst_input include/net/dst.h:469 [inline]\n   ip_rcv_finish net/ipv4/ip_input.c:447 [inline]\n   NF_HOOK include/linux/netfilter.h:317 [inline]\n   NF_HOOK include/linux/netfilter.h:311 [inline]\n   ip_rcv+0x514/0x810 net/ipv4/ip_input.c:567\n   __netif_receive_skb_one_core+0x197/0x1e0 net/core/dev.c:5975\n   __netif_receive_skb+0x1f/0x120 net/core/dev.c:6088\n   process_backlog+0x301/0x1360 net/core/dev.c:6440\n   __napi_poll.constprop.0+0xba/0x550 net/core/dev.c:7453\n   napi_poll net/core/dev.c:7517 [inline]\n   net_rx_action+0xb44/0x1010 net/core/dev.c:7644\n   handle_softirqs+0x1d0/0x770 kernel/softirq.c:579\n   do_softirq+0x3f/0x90 kernel/softirq.c:480\n   </IRQ>\n   <TASK>\n   __local_bh_enable_ip+0xed/0x110 kernel/softirq.c:407\n   local_bh_enable include/linux/bottom_half.h:33 [inline]\n   inet_csk_listen_stop+0x2c5/0x1070 net/ipv4/inet_connection_sock.c:1524\n   mptcp_check_listen_stop.part.0+0x1cc/0x220 net/mptcp/protocol.c:2985\n   mptcp_check_listen_stop net/mptcp/mib.h:118 [inline]\n   __mptcp_close+0x9b9/0xbd0 net/mptcp/protocol.c:3000\n   mptcp_close+0x2f/0x140 net/mptcp/protocol.c:3066\n   inet_release+0xed/0x200 net/ipv4/af_inet.c:435\n   inet6_release+0x4f/0x70 net/ipv6/af_inet6.c:487\n   __sock_release+0xb3/0x270 net/socket.c:649\n   sock_close+0x1c/0x30 net/socket.c:1439\n   __fput+0x402/0xb70 fs/file_table.c:465\n   task_work_run+0x150/0x240 kernel/task_work.c:227\n   resume_user_mode_work include/linux/resume_user_mode.h:50 [inline]\n   exit_to_user_mode_loop+0xd4\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38494",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: HID: core: do not bypass hid_hw_raw_request",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: core: do not bypass hid_hw_raw_request\n\nhid_hw_raw_request() is actually useful to ensure the provided buffer\nand length are valid. Directly calling in the low level transport driver\nfunction bypassed those checks and allowed invalid paramto be used.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38495",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: HID: core: ensure the allocated report buffer can contain the reserved report ID",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: core: ensure the allocated report buffer can contain the reserved report ID\n\nWhen the report ID is not used, the low level transport drivers expect\nthe first byte to be 0. However, currently the allocated buffer not\naccount for that extra byte, meaning that instead of having 8 guaranteed\nbytes for implement to be working, we only have 7.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38497",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: usb: gadget: configfs: Fix OOB read on empty string write",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: configfs: Fix OOB read on empty string write\n\nWhen writing an empty string to either 'qw_sign' or 'landingPage'\nsysfs attributes, the store functions attempt to access page[l - 1]\nbefore validating that the length 'l' is greater than zero.\n\nThis patch fixes the vulnerability by adding a check at the beginning\nof os_desc_qw_sign_store() and webusb_landingPage_store() to handle\nthe zero-length input case gracefully by returning immediately.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38498",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: do_change_type(): refuse to operate on unmounted/not ours mounts",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndo_change_type(): refuse to operate on unmounted/not ours mounts\n\nEnsure that propagation settings can only be changed for mounts located\nin the caller's mount namespace. This change aligns permission checking\nwith the rest of mount(2).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38499",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: clone_private_mnt(): make sure that caller has CAP_SYS_ADMIN in the right userns",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclone_private_mnt(): make sure that caller has CAP_SYS_ADMIN in the right userns\n\nWhat we want is to verify there is that clone won't expose something\nhidden by a mount we wouldn't be able to undo.  \"Wouldn't be able to undo\"\nmay be a result of MNT_LOCKED on a child, but it may also come from\nlacking admin rights in the userns of the namespace mount belongs to.\n\nclone_private_mnt() checks the former, but not the latter.\n\nThere's a number of rather confusing CAP_SYS_ADMIN checks in various\nuserns during the mount, especially with the new mount API; they serve\ndifferent purposes and in case of clone_private_mnt() they usually,\nbut not always end up covering the missing check mentioned above.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38512",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: prevent A-MSDU attacks in mesh networks",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: prevent A-MSDU attacks in mesh networks\n\nThis patch is a mitigation to prevent the A-MSDU spoofing vulnerability\nfor mesh networks. The initial update to the IEEE 802.11 standard, in\nresponse to the FragAttacks, missed this case (CVE-2025-27558). It can\nbe considered a variant of CVE-2020-24588 but for mesh networks.\n\nThis patch tries to detect if a standard MSDU was turned into an A-MSDU\nby an adversary. This is done by parsing a received A-MSDU as a standard\nMSDU, calculating the length of the Mesh Control header, and seeing if\nthe 6 bytes after this header equal the start of an rfc1042 header. If\nequal, this is a strong indication of an ongoing attack attempt.\n\nThis defense was tested with mac80211_hwsim against a mesh network that\nuses an empty Mesh Address Extension field, i.e., when four addresses\nare used, and when using a 12-byte Mesh Address Extension field, i.e.,\nwhen six addresses are used. Functionality of normal MSDUs and A-MSDUs\nwas also tested, and confirmed working, when using both an empty and\n12-byte Mesh Address Extension field.\n\nIt was also tested with mac80211_hwsim that A-MSDU attacks in non-mesh\nnetworks keep being detected and prevented.\n\nNote that the vulnerability being patched, and the defense being\nimplemented, was also discussed in the following paper and in the\nfollowing IEEE 802.11 presentation:\n\nhttps://papers.mathyvanhoef.com/wisec2025.pdf\nhttps://mentor.ieee.org/802.11/dcn/25/11-25-0949-00-000m-a-msdu-mesh-spoof-protection.docx",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38527",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix use-after-free in cifs_oplock_break",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free in cifs_oplock_break\n\nA race condition can occur in cifs_oplock_break() leading to a\nuse-after-free of the cinode structure when unmounting:\n\n  cifs_oplock_break()\n    _cifsFileInfo_put(cfile)\n      cifsFileInfo_put_final()\n        cifs_sb_deactive()\n          [last ref, start releasing sb]\n            kill_sb()\n              kill_anon_super()\n                generic_shutdown_super()\n                  evict_inodes()\n                    dispose_list()\n                      evict()\n                        destroy_inode()\n                          call_rcu(&inode->i_rcu, i_callback)\n    spin_lock(&cinode->open_file_lock)  <- OK\n                            [later] i_callback()\n                              cifs_free_inode()\n                                kmem_cache_free(cinode)\n    spin_unlock(&cinode->open_file_lock)  <- UAF\n    cifs_done_oplock_break(cinode)       <- UAF\n\nThe issue occurs when umount has already released its reference to the\nsuperblock. When _cifsFileInfo_put() calls cifs_sb_deactive(), this\nreleases the last reference, triggering the immediate cleanup of all\ninodes under RCU. However, cifs_oplock_break() continues to access the\ncinode after this point, resulting in use-after-free.\n\nFix this by holding an extra reference to the superblock during the\nentire oplock break operation. This ensures that the superblock and\nits inodes remain valid until the oplock break completes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38535",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: phy: tegra: xusb: Fix unbalanced regulator disable in UTMI PHY mode",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nphy: tegra: xusb: Fix unbalanced regulator disable in UTMI PHY mode\n\nWhen transitioning from USB_ROLE_DEVICE to USB_ROLE_NONE, the code\nassumed that the regulator should be disabled. However, if the regulator\nis marked as always-on, regulator_is_enabled() continues to return true,\nleading to an incorrect attempt to disable a regulator which is not\nenabled.\n\nThis can result in warnings such as:\n\n[  250.155624] WARNING: CPU: 1 PID: 7326 at drivers/regulator/core.c:3004\n_regulator_disable+0xe4/0x1a0\n[  250.155652] unbalanced disables for VIN_SYS_5V0\n\nTo fix this, we move the regulator control logic into\ntegra186_xusb_padctl_id_override() function since it's directly related\nto the ID override state. The regulator is now only disabled when the role\ntransitions from USB_ROLE_HOST to USB_ROLE_NONE, by checking the VBUS_ID\nregister. This ensures that regulator enable/disable operations are\nproperly balanced and only occur when actually transitioning to/from host\nmode.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38556",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: HID: core: Harden s32ton() against conversion to 0 bits",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: core: Harden s32ton() against conversion to 0 bits\n\nTesting by the syzbot fuzzer showed that the HID core gets a\nshift-out-of-bounds exception when it tries to convert a 32-bit\nquantity to a 0-bit quantity.  Ideally this should never occur, but\nthere are buggy devices and some might have a report field with size\nset to zero; we shouldn't reject the report or the device just because\nof that.\n\nInstead, harden the s32ton() routine so that it returns a reasonable\nresult instead of crashing when it is called with the number of bits\nset to 0 -- the same as what snto32() does.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38569",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: benet: fix BUG when creating VFs",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbenet: fix BUG when creating VFs\n\nbenet crashes as soon as SRIOV VFs are created:\n\n kernel BUG at mm/vmalloc.c:3457!\n Oops: invalid opcode: 0000 [#1] SMP KASAN NOPTI\n CPU: 4 UID: 0 PID: 7408 Comm: test.sh Kdump: loaded Not tainted 6.16.0+ #1 PREEMPT(voluntary)\n [...]\n RIP: 0010:vunmap+0x5f/0x70\n [...]\n Call Trace:\n  <TASK>\n  __iommu_dma_free+0xe8/0x1c0\n  be_cmd_set_mac_list+0x3fe/0x640 [be2net]\n  be_cmd_set_mac+0xaf/0x110 [be2net]\n  be_vf_eth_addr_config+0x19f/0x330 [be2net]\n  be_vf_setup+0x4f7/0x990 [be2net]\n  be_pci_sriov_configure+0x3a1/0x470 [be2net]\n  sriov_numvfs_store+0x20b/0x380\n  kernfs_fop_write_iter+0x354/0x530\n  vfs_write+0x9b9/0xf60\n  ksys_write+0xf3/0x1d0\n  do_syscall_64+0x8c/0x3d0\n\nbe_cmd_set_mac_list() calls dma_free_coherent() under a spin_lock_bh.\nFix it by freeing only after the lock has been released.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38572",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv6: reject malicious packets in ipv6_gso_segment()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: reject malicious packets in ipv6_gso_segment()\n\nsyzbot was able to craft a packet with very long IPv6 extension headers\nleading to an overflow of skb->transport_header.\n\nThis 16bit field has a limited range.\n\nAdd skb_reset_transport_header_careful() helper and use it\nfrom ipv6_gso_segment()\n\nWARNING: CPU: 0 PID: 5871 at ./include/linux/skbuff.h:3032 skb_reset_transport_header include/linux/skbuff.h:3032 [inline]\nWARNING: CPU: 0 PID: 5871 at ./include/linux/skbuff.h:3032 ipv6_gso_segment+0x15e2/0x21e0 net/ipv6/ip6_offload.c:151\nModules linked in:\nCPU: 0 UID: 0 PID: 5871 Comm: syz-executor211 Not tainted 6.16.0-rc6-syzkaller-g7abc678e3084 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/12/2025\n RIP: 0010:skb_reset_transport_header include/linux/skbuff.h:3032 [inline]\n RIP: 0010:ipv6_gso_segment+0x15e2/0x21e0 net/ipv6/ip6_offload.c:151\nCall Trace:\n <TASK>\n  skb_mac_gso_segment+0x31c/0x640 net/core/gso.c:53\n  nsh_gso_segment+0x54a/0xe10 net/nsh/nsh.c:110\n  skb_mac_gso_segment+0x31c/0x640 net/core/gso.c:53\n  __skb_gso_segment+0x342/0x510 net/core/gso.c:124\n  skb_gso_segment include/net/gso.h:83 [inline]\n  validate_xmit_skb+0x857/0x11b0 net/core/dev.c:3950\n  validate_xmit_skb_list+0x84/0x120 net/core/dev.c:4000\n  sch_direct_xmit+0xd3/0x4b0 net/sched/sch_generic.c:329\n  __dev_xmit_skb net/core/dev.c:4102 [inline]\n  __dev_queue_xmit+0x17b6/0x3a70 net/core/dev.c:4679",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38581",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: ccp - Fix crash when rebind ccp device for ccp.ko",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: ccp - Fix crash when rebind ccp device for ccp.ko\n\nWhen CONFIG_CRYPTO_DEV_CCP_DEBUGFS is enabled, rebinding\nthe ccp device causes the following crash:\n\n$ echo '0000:0a:00.2' > /sys/bus/pci/drivers/ccp/unbind\n$ echo '0000:0a:00.2' > /sys/bus/pci/drivers/ccp/bind\n\n[  204.976930] BUG: kernel NULL pointer dereference, address: 0000000000000098\n[  204.978026] #PF: supervisor write access in kernel mode\n[  204.979126] #PF: error_code(0x0002) - not-present page\n[  204.980226] PGD 0 P4D 0\n[  204.981317] Oops: Oops: 0002 [#1] SMP NOPTI\n...\n[  204.997852] Call Trace:\n[  204.999074]  <TASK>\n[  205.000297]  start_creating+0x9f/0x1c0\n[  205.001533]  debugfs_create_dir+0x1f/0x170\n[  205.002769]  ? srso_return_thunk+0x5/0x5f\n[  205.004000]  ccp5_debugfs_setup+0x87/0x170 [ccp]\n[  205.005241]  ccp5_init+0x8b2/0x960 [ccp]\n[  205.006469]  ccp_dev_init+0xd4/0x150 [ccp]\n[  205.007709]  sp_init+0x5f/0x80 [ccp]\n[  205.008942]  sp_pci_probe+0x283/0x2e0 [ccp]\n[  205.010165]  ? srso_return_thunk+0x5/0x5f\n[  205.011376]  local_pci_probe+0x4f/0xb0\n[  205.012584]  pci_device_probe+0xdb/0x230\n[  205.013810]  really_probe+0xed/0x380\n[  205.015024]  __driver_probe_device+0x7e/0x160\n[  205.016240]  device_driver_attach+0x2f/0x60\n[  205.017457]  bind_store+0x7c/0xb0\n[  205.018663]  drv_attr_store+0x28/0x40\n[  205.019868]  sysfs_kf_write+0x5f/0x70\n[  205.021065]  kernfs_fop_write_iter+0x145/0x1d0\n[  205.022267]  vfs_write+0x308/0x440\n[  205.023453]  ksys_write+0x6d/0xe0\n[  205.024616]  __x64_sys_write+0x1e/0x30\n[  205.025778]  x64_sys_call+0x16ba/0x2150\n[  205.026942]  do_syscall_64+0x56/0x1e0\n[  205.028108]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  205.029276] RIP: 0033:0x7fbc36f10104\n[  205.030420] Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 e1 08 2e 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 f3 c3 66 90 41 54 55 49 89 d4 53 48 89 f5\n\nThis patch sets ccp_debugfs_dir to NULL after destroying it in\nccp5_debugfs_destroy, allowing the directory dentry to be\nrecreated when rebinding the ccp device.\n\nTested on AMD Ryzen 7 1700X.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38590",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/mlx5e: Remove skb secpath if xfrm state is not found",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Remove skb secpath if xfrm state is not found\n\nHardware returns a unique identifier for a decrypted packet's xfrm\nstate, this state is looked up in an xarray. However, the state might\nhave been freed by the time of this lookup.\n\nCurrently, if the state is not found, only a counter is incremented.\nThe secpath (sp) extension on the skb is not removed, resulting in\nsp->len becoming 0.\n\nSubsequently, functions like __xfrm_policy_check() attempt to access\nfields such as xfrm_input_state(skb)->xso.type (which dereferences\nsp->xvec[sp->len - 1]) without first validating sp->len. This leads to\na crash when dereferencing an invalid state pointer.\n\nThis patch prevents the crash by explicitly removing the secpath\nextension from the skb if the xfrm state is not found after hardware\ndecryption. This ensures downstream functions do not operate on a\nzero-length secpath.\n\n BUG: unable to handle page fault for address: ffffffff000002c8\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 282e067 P4D 282e067 PUD 0\n Oops: Oops: 0000 [#1] SMP\n CPU: 12 UID: 0 PID: 0 Comm: swapper/12 Not tainted 6.15.0-rc7_for_upstream_min_debug_2025_05_27_22_44 #1 NONE\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n RIP: 0010:__xfrm_policy_check+0x61a/0xa30\n Code: b6 77 7f 83 e6 02 74 14 4d 8b af d8 00 00 00 41 0f b6 45 05 c1 e0 03 48 98 49 01 c5 41 8b 45 00 83 e8 01 48 98 49 8b 44 c5 10 <0f> b6 80 c8 02 00 00 83 e0 0c 3c 04 0f 84 0c 02 00 00 31 ff 80 fa\n RSP: 0018:ffff88885fb04918 EFLAGS: 00010297\n RAX: ffffffff00000000 RBX: 0000000000000002 RCX: 0000000000000000\n RDX: 0000000000000002 RSI: 0000000000000002 RDI: 0000000000000000\n RBP: ffffffff8311af80 R08: 0000000000000020 R09: 00000000c2eda353\n R10: ffff88812be2bbc8 R11: 000000001faab533 R12: ffff88885fb049c8\n R13: ffff88812be2bbc8 R14: 0000000000000000 R15: ffff88811896ae00\n FS:  0000000000000000(0000) GS:ffff8888dca82000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: ffffffff000002c8 CR3: 0000000243050002 CR4: 0000000000372eb0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <IRQ>\n  ? try_to_wake_up+0x108/0x4c0\n  ? udp4_lib_lookup2+0xbe/0x150\n  ? udp_lib_lport_inuse+0x100/0x100\n  ? __udp4_lib_lookup+0x2b0/0x410\n  __xfrm_policy_check2.constprop.0+0x11e/0x130\n  udp_queue_rcv_one_skb+0x1d/0x530\n  udp_unicast_rcv_skb+0x76/0x90\n  __udp4_lib_rcv+0xa64/0xe90\n  ip_protocol_deliver_rcu+0x20/0x130\n  ip_local_deliver_finish+0x75/0xa0\n  ip_local_deliver+0xc1/0xd0\n  ? ip_protocol_deliver_rcu+0x130/0x130\n  ip_sublist_rcv+0x1f9/0x240\n  ? ip_rcv_finish_core+0x430/0x430\n  ip_list_rcv+0xfc/0x130\n  __netif_receive_skb_list_core+0x181/0x1e0\n  netif_receive_skb_list_internal+0x200/0x360\n  ? mlx5e_build_rx_skb+0x1bc/0xda0 [mlx5_core]\n  gro_receive_skb+0xfd/0x210\n  mlx5e_handle_rx_cqe_mpwrq+0x141/0x280 [mlx5_core]\n  mlx5e_poll_rx_cq+0xcc/0x8e0 [mlx5_core]\n  ? mlx5e_handle_rx_dim+0x91/0xd0 [mlx5_core]\n  mlx5e_napi_poll+0x114/0xab0 [mlx5_core]\n  __napi_poll+0x25/0x170\n  net_rx_action+0x32d/0x3a0\n  ? mlx5_eq_comp_int+0x8d/0x280 [mlx5_core]\n  ? notifier_call_chain+0x33/0xa0\n  handle_softirqs+0xda/0x250\n  irq_exit_rcu+0x6d/0xc0\n  common_interrupt+0x81/0xa0\n  </IRQ>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38601",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: ath11k: clear initialized flag for deinit-ed srng lists",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: clear initialized flag for deinit-ed srng lists\n\nIn a number of cases we see kernel panics on resume due\nto ath11k kernel page fault, which happens under the\nfollowing circumstances:\n\n1) First ath11k_hal_dump_srng_stats() call\n\n Last interrupt received for each group:\n ath11k_pci 0000:01:00.0: group_id 0 22511ms before\n ath11k_pci 0000:01:00.0: group_id 1 14440788ms before\n [..]\n ath11k_pci 0000:01:00.0: failed to receive control response completion, polling..\n ath11k_pci 0000:01:00.0: Service connect timeout\n ath11k_pci 0000:01:00.0: failed to connect to HTT: -110\n ath11k_pci 0000:01:00.0: failed to start core: -110\n ath11k_pci 0000:01:00.0: firmware crashed: MHI_CB_EE_RDDM\n ath11k_pci 0000:01:00.0: already resetting count 2\n ath11k_pci 0000:01:00.0: failed to wait wlan mode request (mode 4): -110\n ath11k_pci 0000:01:00.0: qmi failed to send wlan mode off: -110\n ath11k_pci 0000:01:00.0: failed to reconfigure driver on crash recovery\n [..]\n\n2) At this point reconfiguration fails (we have 2 resets) and\n  ath11k_core_reconfigure_on_crash() calls ath11k_hal_srng_deinit()\n  which destroys srng lists.  However, it does not reset per-list\n  ->initialized flag.\n\n3) Second ath11k_hal_dump_srng_stats() call sees stale ->initialized\n  flag and attempts to dump srng stats:\n\n Last interrupt received for each group:\n ath11k_pci 0000:01:00.0: group_id 0 66785ms before\n ath11k_pci 0000:01:00.0: group_id 1 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 2 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 3 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 4 14780845ms before\n ath11k_pci 0000:01:00.0: group_id 5 14780845ms before\n ath11k_pci 0000:01:00.0: group_id 6 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 7 66814ms before\n ath11k_pci 0000:01:00.0: group_id 8 68997ms before\n ath11k_pci 0000:01:00.0: group_id 9 67588ms before\n ath11k_pci 0000:01:00.0: group_id 10 69511ms before\n BUG: unable to handle page fault for address: ffffa007404eb010\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 100000067 P4D 100000067 PUD 10022d067 PMD 100b01067 PTE 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n RIP: 0010:ath11k_hal_dump_srng_stats+0x2b4/0x3b0 [ath11k]\n Call Trace:\n <TASK>\n ? __die_body+0xae/0xb0\n ? page_fault_oops+0x381/0x3e0\n ? exc_page_fault+0x69/0xa0\n ? asm_exc_page_fault+0x22/0x30\n ? ath11k_hal_dump_srng_stats+0x2b4/0x3b0 [ath11k (HASH:6cea 4)]\n ath11k_qmi_driver_event_work+0xbd/0x1050 [ath11k (HASH:6cea 4)]\n worker_thread+0x389/0x930\n kthread+0x149/0x170\n\nClear per-list ->initialized flag in ath11k_hal_srng_deinit().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38666",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: appletalk: Fix use-after-free in AARP proxy probe",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: appletalk: Fix use-after-free in AARP proxy probe\n\nThe AARP proxy\u2010probe routine (aarp_proxy_probe_network) sends a probe,\nreleases the aarp_lock, sleeps, then re-acquires the lock.  During that\nwindow an expire timer thread (__aarp_expire_timer) can remove and\nkfree() the same entry, leading to a use-after-free.\n\nrace condition:\n\n         cpu 0                          |            cpu 1\n    atalk_sendmsg()                     |   atif_proxy_probe_device()\n    aarp_send_ddp()                     |   aarp_proxy_probe_network()\n    mod_timer()                         |   lock(aarp_lock) // LOCK!!\n    timeout around 200ms                |   alloc(aarp_entry)\n    and then call                       |   proxies[hash] = aarp_entry\n    aarp_expire_timeout()               |   aarp_send_probe()\n                                        |   unlock(aarp_lock) // UNLOCK!!\n    lock(aarp_lock) // LOCK!!           |   msleep(100);\n    __aarp_expire_timer(&proxies[ct])   |\n    free(aarp_entry)                    |\n    unlock(aarp_lock) // UNLOCK!!       |\n                                        |   lock(aarp_lock) // LOCK!!\n                                        |   UAF aarp_entry !!\n\n==================================================================\nBUG: KASAN: slab-use-after-free in aarp_proxy_probe_network+0x560/0x630 net/appletalk/aarp.c:493\nRead of size 4 at addr ffff8880123aa360 by task repro/13278\n\nCPU: 3 UID: 0 PID: 13278 Comm: repro Not tainted 6.15.2 #3 PREEMPT(full)\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1b0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xc1/0x630 mm/kasan/report.c:521\n kasan_report+0xca/0x100 mm/kasan/report.c:634\n aarp_proxy_probe_network+0x560/0x630 net/appletalk/aarp.c:493\n atif_proxy_probe_device net/appletalk/ddp.c:332 [inline]\n atif_ioctl+0xb58/0x16c0 net/appletalk/ddp.c:857\n atalk_ioctl+0x198/0x2f0 net/appletalk/ddp.c:1818\n sock_do_ioctl+0xdc/0x260 net/socket.c:1190\n sock_ioctl+0x239/0x6a0 net/socket.c:1311\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:906 [inline]\n __se_sys_ioctl fs/ioctl.c:892 [inline]\n __x64_sys_ioctl+0x194/0x200 fs/ioctl.c:892\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcb/0x250 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n </TASK>\n\nAllocated:\n aarp_alloc net/appletalk/aarp.c:382 [inline]\n aarp_proxy_probe_network+0xd8/0x630 net/appletalk/aarp.c:468\n atif_proxy_probe_device net/appletalk/ddp.c:332 [inline]\n atif_ioctl+0xb58/0x16c0 net/appletalk/ddp.c:857\n atalk_ioctl+0x198/0x2f0 net/appletalk/ddp.c:1818\n\nFreed:\n kfree+0x148/0x4d0 mm/slub.c:4841\n __aarp_expire net/appletalk/aarp.c:90 [inline]\n __aarp_expire_timer net/appletalk/aarp.c:261 [inline]\n aarp_expire_timeout+0x480/0x6e0 net/appletalk/aarp.c:317\n\nThe buggy address belongs to the object at ffff8880123aa300\n which belongs to the cache kmalloc-192 of size 192\nThe buggy address is located 96 bytes inside of\n freed 192-byte region [ffff8880123aa300, ffff8880123aa3c0)\n\nMemory state around the buggy address:\n ffff8880123aa200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff8880123aa280: 00 00 00 00 fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8880123aa300: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                       ^\n ffff8880123aa380: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc\n ffff8880123aa400: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n==================================================================",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38718",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: sctp: linearize cloned gso packets in sctp_rcv",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: linearize cloned gso packets in sctp_rcv\n\nA cloned head skb still shares these frag skbs in fraglist with the\noriginal head skb. It's not safe to access these frag skbs.\n\nsyzbot reported two use-of-uninitialized-memory bugs caused by this:\n\n  BUG: KMSAN: uninit-value in sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_inq_pop+0x15b7/0x1920 net/sctp/inqueue.c:211\n   sctp_assoc_bh_rcv+0x1a7/0xc50 net/sctp/associola.c:998\n   sctp_inq_push+0x2ef/0x380 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x397/0xdb0 net/sctp/input.c:331\n   sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1122\n   __release_sock+0x1da/0x330 net/core/sock.c:3106\n   release_sock+0x6b/0x250 net/core/sock.c:3660\n   sctp_wait_for_connect+0x487/0x820 net/sctp/socket.c:9360\n   sctp_sendmsg_to_asoc+0x1ec1/0x1f00 net/sctp/socket.c:1885\n   sctp_sendmsg+0x32b9/0x4a80 net/sctp/socket.c:2031\n   inet_sendmsg+0x25a/0x280 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:718 [inline]\n\nand\n\n  BUG: KMSAN: uninit-value in sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_assoc_bh_rcv+0x34e/0xbc0 net/sctp/associola.c:987\n   sctp_inq_push+0x2a3/0x350 net/sctp/inqueue.c:88\n   sctp_backlog_rcv+0x3c7/0xda0 net/sctp/input.c:331\n   sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148\n   __release_sock+0x1d3/0x330 net/core/sock.c:3213\n   release_sock+0x6b/0x270 net/core/sock.c:3767\n   sctp_wait_for_connect+0x458/0x820 net/sctp/socket.c:9367\n   sctp_sendmsg_to_asoc+0x223a/0x2260 net/sctp/socket.c:1886\n   sctp_sendmsg+0x3910/0x49f0 net/sctp/socket.c:2032\n   inet_sendmsg+0x269/0x2a0 net/ipv4/af_inet.c:851\n   sock_sendmsg_nosec net/socket.c:712 [inline]\n\nThis patch fixes it by linearizing cloned gso packets in sctp_rcv().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38724",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nfsd: handle get_client_locked() failure in nfsd4_setclientid_confirm()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: handle get_client_locked() failure in nfsd4_setclientid_confirm()\n\nLei Lu recently reported that nfsd4_setclientid_confirm() did not check\nthe return value from get_client_locked(). a SETCLIENTID_CONFIRM could\nrace with a confirmed client expiring and fail to get a reference. That\ncould later lead to a UAF.\n\nFix this by getting a reference early in the case where there is an\nextant confirmed client. If that fails then treat it as if there were no\nconfirmed client found at all.\n\nIn the case where the unconfirmed client is expiring, just fail and\nreturn the result from get_client_locked().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-38729",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: usb-audio: Validate UAC3 power domain descriptors, too",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 power domain descriptors, too\n\nUAC3 power domain descriptors need to be verified with its variable\nbLength for avoiding the unexpected OOB accesses by malicious\nfirmware, too.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39677",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net/sched: Fix backlog accounting in qdisc_dequeue_internal",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Fix backlog accounting in qdisc_dequeue_internal\n\nThis issue applies for the following qdiscs: hhf, fq, fq_codel, and\nfq_pie, and occurs in their change handlers when adjusting to the new\nlimit. The problem is the following in the values passed to the\nsubsequent qdisc_tree_reduce_backlog call given a tbf parent:\n\n   When the tbf parent runs out of tokens, skbs of these qdiscs will\n   be placed in gso_skb. Their peek handlers are qdisc_peek_dequeued,\n   which accounts for both qlen and backlog. However, in the case of\n   qdisc_dequeue_internal, ONLY qlen is accounted for when pulling\n   from gso_skb. This means that these qdiscs are missing a\n   qdisc_qstats_backlog_dec when dropping packets to satisfy the\n   new limit in their change handlers.\n\n   One can observe this issue with the following (with tc patched to\n   support a limit of 0):\n\n   export TARGET=fq\n   tc qdisc del dev lo root\n   tc qdisc add dev lo root handle 1: tbf rate 8bit burst 100b latency 1ms\n   tc qdisc replace dev lo handle 3: parent 1:1 $TARGET limit 1000\n   echo ''; echo 'add child'; tc -s -d qdisc show dev lo\n   ping -I lo -f -c2 -s32 -W0.001 127.0.0.1 2>&1 >/dev/null\n   echo ''; echo 'after ping'; tc -s -d qdisc show dev lo\n   tc qdisc change dev lo handle 3: parent 1:1 $TARGET limit 0\n   echo ''; echo 'after limit drop'; tc -s -d qdisc show dev lo\n   tc qdisc replace dev lo handle 2: parent 1:1 sfq\n   echo ''; echo 'post graft'; tc -s -d qdisc show dev lo\n\n   The second to last show command shows 0 packets but a positive\n   number (74) of backlog bytes. The problem becomes clearer in the\n   last show command, where qdisc_purge_queue triggers\n   qdisc_tree_reduce_backlog with the positive backlog and causes an\n   underflow in the tbf parent's backlog (4096 Mb instead of 0).\n\nTo fix this issue, the codepath for all clients of qdisc_dequeue_internal\nhas been simplified: codel, pie, hhf, fq, fq_pie, and fq_codel.\nqdisc_dequeue_internal handles the backlog adjustments for all cases that\ndo not directly use the dequeue handler.\n\nThe old fq_codel_change limit adjustment loop accumulated the arguments to\nthe subsequent qdisc_tree_reduce_backlog call through the cstats field.\nHowever, this is confusing and error prone as fq_codel_dequeue could also\npotentially mutate this field (which qdisc_dequeue_internal calls in the\nnon gso_skb case), so we have unified the code here with other qdiscs.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39697",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFS: Fix a race when updating an existing write",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix a race when updating an existing write\n\nAfter nfs_lock_and_join_requests() tests for whether the request is\nstill attached to the mapping, nothing prevents a call to\nnfs_inode_remove_request() from succeeding until we actually lock the\npage group.\nThe reason is that whoever called nfs_inode_remove_request() doesn't\nnecessarily have a lock on the page group head.\n\nSo in order to avoid races, let's take the page group lock earlier in\nnfs_lock_and_join_requests(), and hold it across the removal of the\nrequest in nfs_inode_remove_request().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39702",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv6: sr: Fix MAC comparison to be constant-time",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: sr: Fix MAC comparison to be constant-time\n\nTo prevent timing attacks, MACs need to be compared in constant time.\nUse the appropriate helper function for this.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39730",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFS: Fix filehandle bounds checking in nfs_fh_to_dentry()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix filehandle bounds checking in nfs_fh_to_dentry()\n\nThe function needs to check the minimal filehandle length before it can\naccess the embedded filehandle.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39735",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.237-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: fix slab-out-of-bounds read in ea_get()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix slab-out-of-bounds read in ea_get()\n\nDuring the \"size_check\" label in ea_get(), the code checks if the extended\nattribute list (xattr) size matches ea_size. If not, it logs\n\"ea_get: invalid extended attribute\" and calls print_hex_dump().\n\nHere, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds\nINT_MAX (2,147,483,647). Then ea_size is clamped:\n\n\tint size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));\n\nAlthough clamp_t aims to bound ea_size between 0 and 4110417968, the upper\nlimit is treated as an int, causing an overflow above 2^31 - 1. This leads\n\"size\" to wrap around and become negative (-184549328).\n\nThe \"size\" is then passed to print_hex_dump() (called \"len\" in\nprint_hex_dump()), it is passed as type size_t (an unsigned\ntype), this is then stored inside a variable called\n\"int remaining\", which is then assigned to \"int linelen\" which\nis then passed to hex_dump_to_buffer(). In print_hex_dump()\nthe for loop, iterates through 0 to len-1, where len is\n18446744073525002176, calling hex_dump_to_buffer()\non each iteration:\n\n\tfor (i = 0; i < len; i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf, sizeof(linebuf), ascii);\n\n\t\t...\n\t}\n\nThe expected stopping condition (i < len) is effectively broken\nsince len is corrupted and very large. This eventually leads to\nthe \"ptr+i\" being passed to hex_dump_to_buffer() to get closer\nto the end of the actual bounds of \"ptr\", eventually an out of\nbounds access is done in hex_dump_to_buffer() in the following\nfor loop:\n\n\tfor (j = 0; j < len; j++) {\n\t\t\tif (linebuflen < lx + 2)\n\t\t\t\tgoto overflow2;\n\t\t\tch = ptr[j];\n\t\t...\n\t}\n\nTo fix this we should validate \"EALIST_SIZE(ea_buf->xattr)\"\nbefore it is utilised.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39743",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: jfs: truncate good inode pages when hard link is 0",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: truncate good inode pages when hard link is 0\n\nThe fileset value of the inode copy from the disk by the reproducer is\nAGGR_RESERVED_I. When executing evict, its hard link number is 0, so its\ninode pages are not truncated. This causes the bugon to be triggered when\nexecuting clear_inode() because nrpages is greater than 0.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39757",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ALSA: usb-audio: Validate UAC3 cluster segment descriptors",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 cluster segment descriptors\n\nUAC3 class segment descriptors need to be verified whether their sizes\nmatch with the declared lengths and whether they fit with the\nallocated buffer sizes, too.  Otherwise malicious firmware may lead to\nthe unexpected OOB accesses.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39773",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: bridge: fix soft lockup in br_multicast_query_expired()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix soft lockup in br_multicast_query_expired()\n\nWhen set multicast_query_interval to a large value, the local variable\n'time' in br_multicast_send_query() may overflow. If the time is smaller\nthan jiffies, the timer will expire immediately, and then call mod_timer()\nagain, which creates a loop and may trigger the following soft lockup\nissue.\n\n  watchdog: BUG: soft lockup - CPU#1 stuck for 221s! [rb_consumer:66]\n  CPU: 1 UID: 0 PID: 66 Comm: rb_consumer Not tainted 6.16.0+ #259 PREEMPT(none)\n  Call Trace:\n   <IRQ>\n   __netdev_alloc_skb+0x2e/0x3a0\n   br_ip6_multicast_alloc_query+0x212/0x1b70\n   __br_multicast_send_query+0x376/0xac0\n   br_multicast_send_query+0x299/0x510\n   br_multicast_query_expired.constprop.0+0x16d/0x1b0\n   call_timer_fn+0x3b/0x2a0\n   __run_timers+0x619/0x950\n   run_timer_softirq+0x11c/0x220\n   handle_softirqs+0x18e/0x560\n   __irq_exit_rcu+0x158/0x1a0\n   sysvec_apic_timer_interrupt+0x76/0x90\n   </IRQ>\n\nThis issue can be reproduced with:\n  ip link add br0 type bridge\n  echo 1 > /sys/class/net/br0/bridge/multicast_querier\n  echo 0xffffffffffffffff >\n  \t/sys/class/net/br0/bridge/multicast_query_interval\n  ip link set dev br0 up\n\nThe multicast_startup_query_interval can also cause this issue. Similar to\nthe commit 99b40610956a (\"net: bridge: mcast: add and enforce query\ninterval minimum\"), add check for the query interval maximum to fix this\nissue.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39798",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: NFS: Fix the setting of capabilities when automounting a new filesystem",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix the setting of capabilities when automounting a new filesystem\n\nCapabilities cannot be inherited when we cross into a new filesystem.\nThey need to be reset to the minimal defaults, and then probed for\nagain.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39810",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bnxt_en: Fix memory corruption when FW resources change during ifdown",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt_en: Fix memory corruption when FW resources change during ifdown\n\nbnxt_set_dflt_rings() assumes that it is always called before any TC has\nbeen created.  So it doesn't take bp->num_tc into account and assumes\nthat it is always 0 or 1.\n\nIn the FW resource or capability change scenario, the FW will return\nflags in bnxt_hwrm_if_change() that will cause the driver to\nreinitialize and call bnxt_cancel_reservations().  This will lead to\nbnxt_init_dflt_ring_mode() calling bnxt_set_dflt_rings() and bp->num_tc\nmay be greater than 1.  This will cause bp->tx_ring[] to be sized too\nsmall and cause memory corruption in bnxt_alloc_cp_rings().\n\nFix it by properly scaling the TX rings by bp->num_tc in the code\npaths mentioned above.  Add 2 helper functions to determine\nbp->tx_nr_rings and bp->tx_nr_rings_per_tc.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39817",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: efivarfs: Fix slab-out-of-bounds in efivarfs_d_compare",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nefivarfs: Fix slab-out-of-bounds in efivarfs_d_compare\n\nObserved on kernel 6.6 (present on master as well):\n\n  BUG: KASAN: slab-out-of-bounds in memcmp+0x98/0xd0\n  Call trace:\n   kasan_check_range+0xe8/0x190\n   __asan_loadN+0x1c/0x28\n   memcmp+0x98/0xd0\n   efivarfs_d_compare+0x68/0xd8\n   __d_lookup_rcu_op_compare+0x178/0x218\n   __d_lookup_rcu+0x1f8/0x228\n   d_alloc_parallel+0x150/0x648\n   lookup_open.isra.0+0x5f0/0x8d0\n   open_last_lookups+0x264/0x828\n   path_openat+0x130/0x3f8\n   do_filp_open+0x114/0x248\n   do_sys_openat2+0x340/0x3c0\n   __arm64_sys_openat+0x120/0x1a0\n\nIf dentry->d_name.len < EFI_VARIABLE_GUID_LEN , 'guid' can become\nnegative, leadings to oob. The issue can be triggered by parallel\nlookups using invalid filename:\n\n  T1\t\t\tT2\n  lookup_open\n   ->lookup\n    simple_lookup\n     d_add\n     // invalid dentry is added to hash list\n\n\t\t\tlookup_open\n\t\t\t d_alloc_parallel\n\t\t\t  __d_lookup_rcu\n\t\t\t   __d_lookup_rcu_op_compare\n\t\t\t    hlist_bl_for_each_entry_rcu\n\t\t\t    // invalid dentry can be retrieved\n\t\t\t     ->d_compare\n\t\t\t      efivarfs_d_compare\n\t\t\t      // oob\n\nFix it by checking 'guid' before cmp.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39823",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: x86: use array_index_nospec with indices that come from guest",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: use array_index_nospec with indices that come from guest\n\nmin and dest_id are guest-controlled indices. Using array_index_nospec()\nafter the bounds checks clamps these values to mitigate speculative execution\nside-channels.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39824",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: HID: asus: fix UAF via HID_CLAIMED_INPUT validation",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: asus: fix UAF via HID_CLAIMED_INPUT validation\n\nAfter hid_hw_start() is called hidinput_connect() will eventually be\ncalled to set up the device with the input layer since the\nHID_CONNECT_DEFAULT connect mask is used. During hidinput_connect()\nall input and output reports are processed and corresponding hid_inputs\nare allocated and configured via hidinput_configure_usages(). This\nprocess involves slot tagging report fields and configuring usages\nby setting relevant bits in the capability bitmaps. However it is possible\nthat the capability bitmaps are not set at all leading to the subsequent\nhidinput_has_been_populated() check to fail leading to the freeing of the\nhid_input and the underlying input device.\n\nThis becomes problematic because a malicious HID device like a\nASUS ROG N-Key keyboard can trigger the above scenario via a\nspecially crafted descriptor which then leads to a user-after-free\nwhen the name of the freed input device is written to later on after\nhid_hw_start(). Below, report 93 intentionally utilises the\nHID_UP_UNDEFINED Usage Page which is skipped during usage\nconfiguration, leading to the frees.\n\n0x05, 0x0D,        // Usage Page (Digitizer)\n0x09, 0x05,        // Usage (Touch Pad)\n0xA1, 0x01,        // Collection (Application)\n0x85, 0x0D,        //   Report ID (13)\n0x06, 0x00, 0xFF,  //   Usage Page (Vendor Defined 0xFF00)\n0x09, 0xC5,        //   Usage (0xC5)\n0x15, 0x00,        //   Logical Minimum (0)\n0x26, 0xFF, 0x00,  //   Logical Maximum (255)\n0x75, 0x08,        //   Report Size (8)\n0x95, 0x04,        //   Report Count (4)\n0xB1, 0x02,        //   Feature (Data,Var,Abs)\n0x85, 0x5D,        //   Report ID (93)\n0x06, 0x00, 0x00,  //   Usage Page (Undefined)\n0x09, 0x01,        //   Usage (0x01)\n0x15, 0x00,        //   Logical Minimum (0)\n0x26, 0xFF, 0x00,  //   Logical Maximum (255)\n0x75, 0x08,        //   Report Size (8)\n0x95, 0x1B,        //   Report Count (27)\n0x81, 0x02,        //   Input (Data,Var,Abs)\n0xC0,              // End Collection\n\nBelow is the KASAN splat after triggering the UAF:\n\n[   21.672709] ==================================================================\n[   21.673700] BUG: KASAN: slab-use-after-free in asus_probe+0xeeb/0xf80\n[   21.673700] Write of size 8 at addr ffff88810a0ac000 by task kworker/1:2/54\n[   21.673700]\n[   21.673700] CPU: 1 UID: 0 PID: 54 Comm: kworker/1:2 Not tainted 6.16.0-rc4-g9773391cf4dd-dirty #36 PREEMPT(voluntary)\n[   21.673700] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n[   21.673700] Call Trace:\n[   21.673700]  <TASK>\n[   21.673700]  dump_stack_lvl+0x5f/0x80\n[   21.673700]  print_report+0xd1/0x660\n[   21.673700]  kasan_report+0xe5/0x120\n[   21.673700]  __asan_report_store8_noabort+0x1b/0x30\n[   21.673700]  asus_probe+0xeeb/0xf80\n[   21.673700]  hid_device_probe+0x2ee/0x700\n[   21.673700]  really_probe+0x1c6/0x6b0\n[   21.673700]  __driver_probe_device+0x24f/0x310\n[   21.673700]  driver_probe_device+0x4e/0x220\n[...]\n[   21.673700]\n[   21.673700] Allocated by task 54:\n[   21.673700]  kasan_save_stack+0x3d/0x60\n[   21.673700]  kasan_save_track+0x18/0x40\n[   21.673700]  kasan_save_alloc_info+0x3b/0x50\n[   21.673700]  __kasan_kmalloc+0x9c/0xa0\n[   21.673700]  __kmalloc_cache_noprof+0x139/0x340\n[   21.673700]  input_allocate_device+0x44/0x370\n[   21.673700]  hidinput_connect+0xcb6/0x2630\n[   21.673700]  hid_connect+0xf74/0x1d60\n[   21.673700]  hid_hw_start+0x8c/0x110\n[   21.673700]  asus_probe+0x5a3/0xf80\n[   21.673700]  hid_device_probe+0x2ee/0x700\n[   21.673700]  really_probe+0x1c6/0x6b0\n[   21.673700]  __driver_probe_device+0x24f/0x310\n[   21.673700]  driver_probe_device+0x4e/0x220\n[...]\n[   21.673700]\n[   21.673700] Freed by task 54:\n[   21.673700]  kasan_save_stack+0x3d/0x60\n[   21.673700]  kasan_save_track+0x18/0x40\n[   21.673700]  kasan_save_free_info+0x3f/0x60\n[   21.673700]  __kasan_slab_free+0x3c/0x50\n[   21.673700]  kfre\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39825",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: fix race with concurrent opens in rename(2)",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix race with concurrent opens in rename(2)\n\nBesides sending the rename request to the server, the rename process\nalso involves closing any deferred close, waiting for outstanding I/O\nto complete as well as marking all existing open handles as deleted to\nprevent them from deferring closes, which increases the race window\nfor potential concurrent opens on the target file.\n\nFix this by unhashing the dentry in advance to prevent any concurrent\nopens on the target.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39828",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: atm: atmtcp: Prevent arbitrary write in atmtcp_recv_control()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: atmtcp: Prevent arbitrary write in atmtcp_recv_control().\n\nsyzbot reported the splat below. [0]\n\nWhen atmtcp_v_open() or atmtcp_v_close() is called via connect()\nor close(), atmtcp_send_control() is called to send an in-kernel\nspecial message.\n\nThe message has ATMTCP_HDR_MAGIC in atmtcp_control.hdr.length.\nAlso, a pointer of struct atm_vcc is set to atmtcp_control.vcc.\n\nThe notable thing is struct atmtcp_control is uAPI but has a\nspace for an in-kernel pointer.\n\n  struct atmtcp_control {\n  \tstruct atmtcp_hdr hdr;\t/* must be first */\n  ...\n  \tatm_kptr_t vcc;\t\t/* both directions */\n  ...\n  } __ATM_API_ALIGN;\n\n  typedef struct { unsigned char _[8]; } __ATM_API_ALIGN atm_kptr_t;\n\nThe special message is processed in atmtcp_recv_control() called\nfrom atmtcp_c_send().\n\natmtcp_c_send() is vcc->dev->ops->send() and called from 2 paths:\n\n  1. .ndo_start_xmit() (vcc->send() == atm_send_aal0())\n  2. vcc_sendmsg()\n\nThe problem is sendmsg() does not validate the message length and\nuserspace can abuse atmtcp_recv_control() to overwrite any kptr\nby atmtcp_control.\n\nLet's add a new ->pre_send() hook to validate messages from sendmsg().\n\n[0]:\nOops: general protection fault, probably for non-canonical address 0xdffffc00200000ab: 0000 [#1] SMP KASAN PTI\nKASAN: probably user-memory-access in range [0x0000000100000558-0x000000010000055f]\nCPU: 0 UID: 0 PID: 5865 Comm: syz-executor331 Not tainted 6.17.0-rc1-syzkaller-00215-gbab3ce404553 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/12/2025\nRIP: 0010:atmtcp_recv_control drivers/atm/atmtcp.c:93 [inline]\nRIP: 0010:atmtcp_c_send+0x1da/0x950 drivers/atm/atmtcp.c:297\nCode: 4d 8d 75 1a 4c 89 f0 48 c1 e8 03 42 0f b6 04 20 84 c0 0f 85 15 06 00 00 41 0f b7 1e 4d 8d b7 60 05 00 00 4c 89 f0 48 c1 e8 03 <42> 0f b6 04 20 84 c0 0f 85 13 06 00 00 66 41 89 1e 4d 8d 75 1c 4c\nRSP: 0018:ffffc90003f5f810 EFLAGS: 00010203\nRAX: 00000000200000ab RBX: 0000000000000000 RCX: 0000000000000000\nRDX: ffff88802a510000 RSI: 00000000ffffffff RDI: ffff888030a6068c\nRBP: ffff88802699fb40 R08: ffff888030a606eb R09: 1ffff1100614c0dd\nR10: dffffc0000000000 R11: ffffffff8718fc40 R12: dffffc0000000000\nR13: ffff888030a60680 R14: 000000010000055f R15: 00000000ffffffff\nFS:  00007f8d7e9236c0(0000) GS:ffff888125c1c000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000000045ad50 CR3: 0000000075bde000 CR4: 00000000003526f0\nCall Trace:\n <TASK>\n vcc_sendmsg+0xa10/0xc60 net/atm/common.c:645\n sock_sendmsg_nosec net/socket.c:714 [inline]\n __sock_sendmsg+0x219/0x270 net/socket.c:729\n ____sys_sendmsg+0x505/0x830 net/socket.c:2614\n ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2668\n __sys_sendmsg net/socket.c:2700 [inline]\n __do_sys_sendmsg net/socket.c:2705 [inline]\n __se_sys_sendmsg net/socket.c:2703 [inline]\n __x64_sys_sendmsg+0x19b/0x260 net/socket.c:2703\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f8d7e96a4a9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f8d7e923198 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f8d7e9f4308 RCX: 00007f8d7e96a4a9\nRDX: 0000000000000000 RSI: 0000200000000240 RDI: 0000000000000005\nRBP: 00007f8d7e9f4300 R08: 65732f636f72702f R09: 65732f636f72702f\nR10: 65732f636f72702f R11: 0000000000000246 R12: 00007f8d7e9c10ac\nR13: 00007f8d7e9231a0 R14: 0000200000000200 R15: 0000200000000250\n </TASK>\nModules linked in:",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39841",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: lpfc: Fix buffer free/clear order in deferred receive path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix buffer free/clear order in deferred receive path\n\nFix a use-after-free window by correcting the buffer release sequence in\nthe deferred receive path. The code freed the RQ buffer first and only\nthen cleared the context pointer under the lock. Concurrent paths (e.g.,\nABTS and the repost path) also inspect and release the same pointer under\nthe lock, so the old order could lead to double-free/UAF.\n\nNote that the repost path already uses the correct pattern: detach the\npointer under the lock, then free it after dropping the lock. The\ndeferred path should do the same.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39864",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: wifi: cfg80211: fix use-after-free in cmp_bss()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: fix use-after-free in cmp_bss()\n\nFollowing bss_free() quirk introduced in commit 776b3580178f\n(\"cfg80211: track hidden SSID networks properly\"), adjust\ncfg80211_update_known_bss() to free the last beacon frame\nelements only if they're not shared via the corresponding\n'hidden_beacon_bss' pointer.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39883",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm/memory-failure: fix VM_BUG_ON_PAGE(PagePoisoned(page)) when unpoison memory",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/memory-failure: fix VM_BUG_ON_PAGE(PagePoisoned(page)) when unpoison memory\n\nWhen I did memory failure tests, below panic occurs:\n\npage dumped because: VM_BUG_ON_PAGE(PagePoisoned(page))\nkernel BUG at include/linux/page-flags.h:616!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 3 PID: 720 Comm: bash Not tainted 6.10.0-rc1-00195-g148743902568 #40\nRIP: 0010:unpoison_memory+0x2f3/0x590\nRSP: 0018:ffffa57fc8787d60 EFLAGS: 00000246\nRAX: 0000000000000037 RBX: 0000000000000009 RCX: ffff9be25fcdc9c8\nRDX: 0000000000000000 RSI: 0000000000000027 RDI: ffff9be25fcdc9c0\nRBP: 0000000000300000 R08: ffffffffb4956f88 R09: 0000000000009ffb\nR10: 0000000000000284 R11: ffffffffb4926fa0 R12: ffffe6b00c000000\nR13: ffff9bdb453dfd00 R14: 0000000000000000 R15: fffffffffffffffe\nFS:  00007f08f04e4740(0000) GS:ffff9be25fcc0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000564787a30410 CR3: 000000010d4e2000 CR4: 00000000000006f0\nCall Trace:\n <TASK>\n unpoison_memory+0x2f3/0x590\n simple_attr_write_xsigned.constprop.0.isra.0+0xb3/0x110\n debugfs_attr_write+0x42/0x60\n full_proxy_write+0x5b/0x80\n vfs_write+0xd5/0x540\n ksys_write+0x64/0xe0\n do_syscall_64+0xb9/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f08f0314887\nRSP: 002b:00007ffece710078 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 0000000000000009 RCX: 00007f08f0314887\nRDX: 0000000000000009 RSI: 0000564787a30410 RDI: 0000000000000001\nRBP: 0000564787a30410 R08: 000000000000fefe R09: 000000007fffffff\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000009\nR13: 00007f08f041b780 R14: 00007f08f0417600 R15: 00007f08f0416a00\n </TASK>\nModules linked in: hwpoison_inject\n---[ end trace 0000000000000000 ]---\nRIP: 0010:unpoison_memory+0x2f3/0x590\nRSP: 0018:ffffa57fc8787d60 EFLAGS: 00000246\nRAX: 0000000000000037 RBX: 0000000000000009 RCX: ffff9be25fcdc9c8\nRDX: 0000000000000000 RSI: 0000000000000027 RDI: ffff9be25fcdc9c0\nRBP: 0000000000300000 R08: ffffffffb4956f88 R09: 0000000000009ffb\nR10: 0000000000000284 R11: ffffffffb4926fa0 R12: ffffe6b00c000000\nR13: ffff9bdb453dfd00 R14: 0000000000000000 R15: fffffffffffffffe\nFS:  00007f08f04e4740(0000) GS:ffff9be25fcc0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000564787a30410 CR3: 000000010d4e2000 CR4: 00000000000006f0\nKernel panic - not syncing: Fatal exception\nKernel Offset: 0x31c00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n---[ end Kernel panic - not syncing: Fatal exception ]---\n\nThe root cause is that unpoison_memory() tries to check the PG_HWPoison\nflags of an uninitialized page.  So VM_BUG_ON_PAGE(PagePoisoned(page)) is\ntriggered.  This can be reproduced by below steps:\n\n1.Offline memory block:\n\n echo offline > /sys/devices/system/memory/memory12/state\n\n2.Get offlined memory pfn:\n\n page-types -b n -rlN\n\n3.Write pfn to unpoison-pfn\n\n echo <pfn> > /sys/kernel/debug/hwpoison/unpoison-pfn\n\nThis scenario can be identified by pfn_to_online_page() returning NULL. \nAnd ZONE_DEVICE pages are never expected, so we can simply fail if\npfn_to_online_page() == NULL to fix the bug.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39902",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "5.10.244-1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: mm/slub: avoid accessing metadata when pointer is invalid in object_err()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: avoid accessing metadata when pointer is invalid in object_err()\n\nobject_err() reports details of an object for further debugging, such as\nthe freelist pointer, redzone, etc. However, if the pointer is invalid,\nattempting to access object metadata can lead to a crash since it does\nnot point to a valid object.\n\nOne known path to the crash is when alloc_consistency_checks()\ndetermines the pointer to the allocated object is invalid because of a\nfreelist corruption, and calls object_err() to report it. The debug code\nshould report and handle the corruption gracefully and not crash in the\nprocess.\n\nIn case the pointer is NULL or check_valid_pointer() returns false for\nthe pointer, only print the pointer value and skip accessing metadata.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39905",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: phylink: add lock for serializing concurrent pl->phydev writes with resolver",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phylink: add lock for serializing concurrent pl->phydev writes with resolver\n\nCurrently phylink_resolve() protects itself against concurrent\nphylink_bringup_phy() or phylink_disconnect_phy() calls which modify\npl->phydev by relying on pl->state_mutex.\n\nThe problem is that in phylink_resolve(), pl->state_mutex is in a lock\ninversion state with pl->phydev->lock. So pl->phydev->lock needs to be\nacquired prior to pl->state_mutex. But that requires dereferencing\npl->phydev in the first place, and without pl->state_mutex, that is\nracy.\n\nHence the reason for the extra lock. Currently it is redundant, but it\nwill serve a functional purpose once mutex_lock(&phy->lock) will be\nmoved outside of the mutex_lock(&pl->state_mutex) section.\n\nAnother alternative considered would have been to let phylink_resolve()\nacquire the rtnl_mutex, which is also held when phylink_bringup_phy()\nand phylink_disconnect_phy() are called. But since phylink_disconnect_phy()\nruns under rtnl_lock(), it would deadlock with phylink_resolve() when\ncalling flush_work(&pl->resolve). Additionally, it would have been\nundesirable because it would have unnecessarily blocked many other call\npaths as well in the entire kernel, so the smaller-scoped lock was\npreferred.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39911",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: fix IRQ freeing in i40e_vsi_request_irq_msix error path",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix IRQ freeing in i40e_vsi_request_irq_msix error path\n\nIf request_irq() in i40e_vsi_request_irq_msix() fails in an iteration\nlater than the first, the error path wants to free the IRQs requested\nso far. However, it uses the wrong dev_id argument for free_irq(), so\nit does not free the IRQs correctly and instead triggers the warning:\n\n Trying to free already-free IRQ 173\n WARNING: CPU: 25 PID: 1091 at kernel/irq/manage.c:1829 __free_irq+0x192/0x2c0\n Modules linked in: i40e(+) [...]\n CPU: 25 UID: 0 PID: 1091 Comm: NetworkManager Not tainted 6.17.0-rc1+ #1 PREEMPT(lazy)\n Hardware name: [...]\n RIP: 0010:__free_irq+0x192/0x2c0\n [...]\n Call Trace:\n  <TASK>\n  free_irq+0x32/0x70\n  i40e_vsi_request_irq_msix.cold+0x63/0x8b [i40e]\n  i40e_vsi_request_irq+0x79/0x80 [i40e]\n  i40e_vsi_open+0x21f/0x2f0 [i40e]\n  i40e_open+0x63/0x130 [i40e]\n  __dev_open+0xfc/0x210\n  __dev_change_flags+0x1fc/0x240\n  netif_change_flags+0x27/0x70\n  do_setlink.isra.0+0x341/0xc70\n  rtnl_newlink+0x468/0x860\n  rtnetlink_rcv_msg+0x375/0x450\n  netlink_rcv_skb+0x5c/0x110\n  netlink_unicast+0x288/0x3c0\n  netlink_sendmsg+0x20d/0x430\n  ____sys_sendmsg+0x3a2/0x3d0\n  ___sys_sendmsg+0x99/0xe0\n  __sys_sendmsg+0x8a/0xf0\n  do_syscall_64+0x82/0x2c0\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  [...]\n  </TASK>\n ---[ end trace 0000000000000000 ]---\n\nUse the same dev_id for free_irq() as for request_irq().\n\nI tested this with inserting code to fail intentionally.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39923",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: dmaengine: qcom: bam_dma: Fix DT error handling for num-channels/ees",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: qcom: bam_dma: Fix DT error handling for num-channels/ees\n\nWhen we don't have a clock specified in the device tree, we have no way to\nensure the BAM is on. This is often the case for remotely-controlled or\nremotely-powered BAM instances. In this case, we need to read num-channels\nfrom the DT to have all the necessary information to complete probing.\n\nHowever, at the moment invalid device trees without clock and without\nnum-channels still continue probing, because the error handling is missing\nreturn statements. The driver will then later try to read the number of\nchannels from the registers. This is unsafe, because it relies on boot\nfirmware and lucky timing to succeed. Unfortunately, the lack of proper\nerror handling here has been abused for several Qualcomm SoCs upstream,\ncausing early boot crashes in several situations [1, 2].\n\nAvoid these early crashes by erroring out when any of the required DT\nproperties are missing. Note that this will break some of the existing DTs\nupstream (mainly BAM instances related to the crypto engine). However,\nclearly these DTs have never been tested properly, since the error in the\nkernel log was just ignored. It's safer to disable the crypto engine for\nthese broken DTBs.\n\n[1]: https://lore.kernel.org/r/CY01EKQVWE36.B9X5TDXAREPF@fairphone.com/\n[2]: https://lore.kernel.org/r/20230626145959.646747-1-krzysztof.kozlowski@linaro.org/",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39931",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: crypto: af_alg - Set merge to zero early in af_alg_sendmsg",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: af_alg - Set merge to zero early in af_alg_sendmsg\n\nIf an error causes af_alg_sendmsg to abort, ctx->merge may contain\na garbage value from the previous loop.  This may then trigger a\ncrash on the next entry into af_alg_sendmsg when it attempts to do\na merge that can't be done.\n\nFix this by setting ctx->merge to zero near the start of the loop.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39932",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: let smbd_destroy() call disable_work_sync(&#38;info->post_send_credits_work)",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: let smbd_destroy() call disable_work_sync(&info->post_send_credits_work)\n\nIn smbd_destroy() we may destroy the memory so we better\nwait until post_send_credits_work is no longer pending\nand will never be started again.\n\nI actually just hit the case using rxe:\n\nWARNING: CPU: 0 PID: 138 at drivers/infiniband/sw/rxe/rxe_verbs.c:1032 rxe_post_recv+0x1ee/0x480 [rdma_rxe]\n...\n[ 5305.686979] [    T138]  smbd_post_recv+0x445/0xc10 [cifs]\n[ 5305.687135] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687149] [    T138]  ? __kasan_check_write+0x14/0x30\n[ 5305.687185] [    T138]  ? __pfx_smbd_post_recv+0x10/0x10 [cifs]\n[ 5305.687329] [    T138]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[ 5305.687356] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687368] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687378] [    T138]  ? _raw_spin_unlock_irqrestore+0x11/0x60\n[ 5305.687389] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687399] [    T138]  ? get_receive_buffer+0x168/0x210 [cifs]\n[ 5305.687555] [    T138]  smbd_post_send_credits+0x382/0x4b0 [cifs]\n[ 5305.687701] [    T138]  ? __pfx_smbd_post_send_credits+0x10/0x10 [cifs]\n[ 5305.687855] [    T138]  ? __pfx___schedule+0x10/0x10\n[ 5305.687865] [    T138]  ? __pfx__raw_spin_lock_irq+0x10/0x10\n[ 5305.687875] [    T138]  ? queue_delayed_work_on+0x8e/0xa0\n[ 5305.687889] [    T138]  process_one_work+0x629/0xf80\n[ 5305.687908] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687917] [    T138]  ? __kasan_check_write+0x14/0x30\n[ 5305.687933] [    T138]  worker_thread+0x87f/0x1570\n...\n\nIt means rxe_post_recv was called after rdma_destroy_qp().\nThis happened because put_receive_buffer() was triggered\nby ib_drain_qp() and called:\nqueue_work(info->workqueue, &info->post_send_credits_work);",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39933",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smb: client: let recv_done verify data_offset, data_length and remaining_data_length",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: let recv_done verify data_offset, data_length and remaining_data_length\n\nThis is inspired by the related server fixes.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39949",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: qed: Don't collect too many protection override GRC elements",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nqed: Don't collect too many protection override GRC elements\n\nIn the protection override dump path, the firmware can return far too\nmany GRC elements, resulting in attempting to write past the end of the\npreviously-kmalloc'ed dump buffer.\n\nThis will result in a kernel panic with reason:\n\n BUG: unable to handle kernel paging request at ADDRESS\n\nwhere \"ADDRESS\" is just past the end of the protection override dump\nbuffer. The start address of the buffer is:\n p_hwfn->cdev->dbg_features[DBG_FEATURE_PROTECTION_OVERRIDE].dump_buf\nand the size of the buffer is buf_size in the same data structure.\n\nThe panic can be arrived at from either the qede Ethernet driver path:\n\n    [exception RIP: qed_grc_dump_addr_range+0x108]\n qed_protection_override_dump at ffffffffc02662ed [qed]\n qed_dbg_protection_override_dump at ffffffffc0267792 [qed]\n qed_dbg_feature at ffffffffc026aa8f [qed]\n qed_dbg_all_data at ffffffffc026b211 [qed]\n qed_fw_fatal_reporter_dump at ffffffffc027298a [qed]\n devlink_health_do_dump at ffffffff82497f61\n devlink_health_report at ffffffff8249cf29\n qed_report_fatal_error at ffffffffc0272baf [qed]\n qede_sp_task at ffffffffc045ed32 [qede]\n process_one_work at ffffffff81d19783\n\nor the qedf storage driver path:\n\n    [exception RIP: qed_grc_dump_addr_range+0x108]\n qed_protection_override_dump at ffffffffc068b2ed [qed]\n qed_dbg_protection_override_dump at ffffffffc068c792 [qed]\n qed_dbg_feature at ffffffffc068fa8f [qed]\n qed_dbg_all_data at ffffffffc0690211 [qed]\n qed_fw_fatal_reporter_dump at ffffffffc069798a [qed]\n devlink_health_do_dump at ffffffff8aa95e51\n devlink_health_report at ffffffff8aa9ae19\n qed_report_fatal_error at ffffffffc0697baf [qed]\n qed_hw_err_notify at ffffffffc06d32d7 [qed]\n qed_spq_post at ffffffffc06b1011 [qed]\n qed_fcoe_destroy_conn at ffffffffc06b2e91 [qed]\n qedf_cleanup_fcport at ffffffffc05e7597 [qedf]\n qedf_rport_event_handler at ffffffffc05e7bf7 [qedf]\n fc_rport_work at ffffffffc02da715 [libfc]\n process_one_work at ffffffff8a319663\n\nResolve this by clamping the firmware's return value to the maximum\nnumber of legal elements the firmware should return.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39955",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcp: Clear tcp_sk(sk)->fastopen_rsk in tcp_disconnect()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: Clear tcp_sk(sk)->fastopen_rsk in tcp_disconnect().\n\nsyzbot reported the splat below where a socket had tcp_sk(sk)->fastopen_rsk\nin the TCP_ESTABLISHED state. [0]\n\nsyzbot reused the server-side TCP Fast Open socket as a new client before\nthe TFO socket completes 3WHS:\n\n  1. accept()\n  2. connect(AF_UNSPEC)\n  3. connect() to another destination\n\nAs of accept(), sk->sk_state is TCP_SYN_RECV, and tcp_disconnect() changes\nit to TCP_CLOSE and makes connect() possible, which restarts timers.\n\nSince tcp_disconnect() forgot to clear tcp_sk(sk)->fastopen_rsk, the\nretransmit timer triggered the warning and the intended packet was not\nretransmitted.\n\nLet's call reqsk_fastopen_remove() in tcp_disconnect().\n\n[0]:\nWARNING: CPU: 2 PID: 0 at net/ipv4/tcp_timer.c:542 tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))\nModules linked in:\nCPU: 2 UID: 0 PID: 0 Comm: swapper/2 Not tainted 6.17.0-rc5-g201825fb4278 #62 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\nRIP: 0010:tcp_retransmit_timer (net/ipv4/tcp_timer.c:542 (discriminator 7))\nCode: 41 55 41 54 55 53 48 8b af b8 08 00 00 48 89 fb 48 85 ed 0f 84 55 01 00 00 0f b6 47 12 3c 03 74 0c 0f b6 47 12 3c 04 74 04 90 <0f> 0b 90 48 8b 85 c0 00 00 00 48 89 ef 48 8b 40 30 e8 6a 4f 06 3e\nRSP: 0018:ffffc900002f8d40 EFLAGS: 00010293\nRAX: 0000000000000002 RBX: ffff888106911400 RCX: 0000000000000017\nRDX: 0000000002517619 RSI: ffffffff83764080 RDI: ffff888106911400\nRBP: ffff888106d5c000 R08: 0000000000000001 R09: ffffc900002f8de8\nR10: 00000000000000c2 R11: ffffc900002f8ff8 R12: ffff888106911540\nR13: ffff888106911480 R14: ffff888106911840 R15: ffffc900002f8de0\nFS:  0000000000000000(0000) GS:ffff88907b768000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f8044d69d90 CR3: 0000000002c30003 CR4: 0000000000370ef0\nCall Trace:\n <IRQ>\n tcp_write_timer (net/ipv4/tcp_timer.c:738)\n call_timer_fn (kernel/time/timer.c:1747)\n __run_timers (kernel/time/timer.c:1799 kernel/time/timer.c:2372)\n timer_expire_remote (kernel/time/timer.c:2385 kernel/time/timer.c:2376 kernel/time/timer.c:2135)\n tmigr_handle_remote_up (kernel/time/timer_migration.c:944 kernel/time/timer_migration.c:1035)\n __walk_groups.isra.0 (kernel/time/timer_migration.c:533 (discriminator 1))\n tmigr_handle_remote (kernel/time/timer_migration.c:1096)\n handle_softirqs (./arch/x86/include/asm/jump_label.h:36 ./include/trace/events/irq.h:142 kernel/softirq.c:580)\n irq_exit_rcu (kernel/softirq.c:614 kernel/softirq.c:453 kernel/softirq.c:680 kernel/softirq.c:696)\n sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1050 (discriminator 35) arch/x86/kernel/apic/apic.c:1050 (discriminator 35))\n </IRQ>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39968",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: add max boundary check for VF filters",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: add max boundary check for VF filters\n\nThere is no check for max filters that VF can request. Add it.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39969",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: fix validation of VF state in get resources",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix validation of VF state in get resources\n\nVF state I40E_VF_STATE_ACTIVE is not the only state in which\nVF is actually active so it should not be used to determine\nif a VF is allowed to obtain resources.\n\nUse I40E_VF_STATE_RESOURCES_LOADED that is set only in\ni40e_vc_get_vf_resources_msg() and cleared during reset.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39970",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: fix input validation logic for action_meta",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix input validation logic for action_meta\n\nFix condition to check 'greater or equal' to prevent OOB dereference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39971",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: fix idx validation in config queues msg",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix idx validation in config queues msg\n\nEnsure idx is within range of active/initialized TCs when iterating over\nvf->ch[idx] in i40e_vc_config_queues_msg().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39972",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: fix idx validation in i40e_validate_queue_map",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix idx validation in i40e_validate_queue_map\n\nEnsure idx is within range of active/initialized TCs when iterating over\nvf->ch[idx] in i40e_validate_queue_map().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39973",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: i40e: add validation for ring_len param",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: add validation for ring_len param\n\nThe `ring_len` parameter provided by the virtual function (VF)\nis assigned directly to the hardware memory context (HMC) without\nany validation.\n\nTo address this, introduce an upper boundary check for both Tx and Rx\nqueue lengths. The maximum number of descriptors supported by the\nhardware is 8k-32.\nAdditionally, enforce alignment constraints: Tx rings must be a multiple\nof 8, and Rx rings must be a multiple of 32.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39980",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nexthop: Forbid FDB status change while nexthop is in a group",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnexthop: Forbid FDB status change while nexthop is in a group\n\nThe kernel forbids the creation of non-FDB nexthop groups with FDB\nnexthops:\n\n # ip nexthop add id 1 via 192.0.2.1 fdb\n # ip nexthop add id 2 group 1\n Error: Non FDB nexthop group cannot have fdb nexthops.\n\nAnd vice versa:\n\n # ip nexthop add id 3 via 192.0.2.2 dev dummy1\n # ip nexthop add id 4 group 3 fdb\n Error: FDB nexthop group can only have fdb nexthops.\n\nHowever, as long as no routes are pointing to a non-FDB nexthop group,\nthe kernel allows changing the type of a nexthop from FDB to non-FDB and\nvice versa:\n\n # ip nexthop add id 5 via 192.0.2.2 dev dummy1\n # ip nexthop add id 6 group 5\n # ip nexthop replace id 5 via 192.0.2.2 fdb\n # echo $?\n 0\n\nThis configuration is invalid and can result in a NPD [1] since FDB\nnexthops are not associated with a nexthop device:\n\n # ip route add 198.51.100.1/32 nhid 6\n # ping 198.51.100.1\n\nFix by preventing nexthop FDB status change while the nexthop is in a\ngroup:\n\n # ip nexthop add id 7 via 192.0.2.2 dev dummy1\n # ip nexthop add id 8 group 7\n # ip nexthop replace id 7 via 192.0.2.2 fdb\n Error: Cannot change nexthop FDB status while in a group.\n\n[1]\nBUG: kernel NULL pointer dereference, address: 00000000000003c0\n[...]\nOops: Oops: 0000 [#1] SMP\nCPU: 6 UID: 0 PID: 367 Comm: ping Not tainted 6.17.0-rc6-virtme-gb65678cacc03 #1 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014\nRIP: 0010:fib_lookup_good_nhc+0x1e/0x80\n[...]\nCall Trace:\n <TASK>\n fib_table_lookup+0x541/0x650\n ip_route_output_key_hash_rcu+0x2ea/0x970\n ip_route_output_key_hash+0x55/0x80\n __ip4_datagram_connect+0x250/0x330\n udp_connect+0x2b/0x60\n __sys_connect+0x9c/0xd0\n __x64_sys_connect+0x18/0x20\n do_syscall_64+0xa4/0x2a0\n entry_SYSCALL_64_after_hwframe+0x4b/0x53",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39993",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: rc: fix races with imon_disconnect()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: rc: fix races with imon_disconnect()\n\nSyzbot reports a KASAN issue as below:\nBUG: KASAN: use-after-free in __create_pipe include/linux/usb.h:1945 [inline]\nBUG: KASAN: use-after-free in send_packet+0xa2d/0xbc0 drivers/media/rc/imon.c:627\nRead of size 4 at addr ffff8880256fb000 by task syz-executor314/4465\n\nCPU: 2 PID: 4465 Comm: syz-executor314 Not tainted 6.0.0-rc1-syzkaller #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014\nCall Trace:\n <TASK>\n__dump_stack lib/dump_stack.c:88 [inline]\ndump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\nprint_address_description mm/kasan/report.c:317 [inline]\nprint_report.cold+0x2ba/0x6e9 mm/kasan/report.c:433\nkasan_report+0xb1/0x1e0 mm/kasan/report.c:495\n__create_pipe include/linux/usb.h:1945 [inline]\nsend_packet+0xa2d/0xbc0 drivers/media/rc/imon.c:627\nvfd_write+0x2d9/0x550 drivers/media/rc/imon.c:991\nvfs_write+0x2d7/0xdd0 fs/read_write.c:576\nksys_write+0x127/0x250 fs/read_write.c:631\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe iMON driver improperly releases the usb_device reference in\nimon_disconnect without coordinating with active users of the\ndevice.\n\nSpecifically, the fields usbdev_intf0 and usbdev_intf1 are not\nprotected by the users counter (ictx->users). During probe,\nimon_init_intf0 or imon_init_intf1 increments the usb_device\nreference count depending on the interface. However, during\ndisconnect, usb_put_dev is called unconditionally, regardless of\nactual usage.\n\nAs a result, if vfd_write or other operations are still in\nprogress after disconnect, this can lead to a use-after-free of\nthe usb_device pointer.\n\nThread 1 vfd_write                      Thread 2 imon_disconnect\n                                        ...\n                                        if\n                                          usb_put_dev(ictx->usbdev_intf0)\n                                        else\n                                          usb_put_dev(ictx->usbdev_intf1)\n...\nwhile\n  send_packet\n    if\n      pipe = usb_sndintpipe(\n        ictx->usbdev_intf0) UAF\n    else\n      pipe = usb_sndctrlpipe(\n        ictx->usbdev_intf0, 0) UAF\n\nGuard access to usbdev_intf0 and usbdev_intf1 after disconnect by\nchecking ictx->disconnected in all writer paths. Add early return\nwith -ENODEV in send_packet(), vfd_write(), lcd_write() and\ndisplay_open() if the device is no longer present.\n\nSet and read ictx->disconnected under ictx->lock to ensure memory\nsynchronization. Acquire the lock in imon_disconnect() before setting\nthe flag to synchronize with any ongoing operations.\n\nEnsure writers exit early and safely after disconnect before the USB\ncore proceeds with cleanup.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39994",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: tuner: xc5000: Fix use-after-free in xc5000_release",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: tuner: xc5000: Fix use-after-free in xc5000_release\n\nThe original code uses cancel_delayed_work() in xc5000_release(), which\ndoes not guarantee that the delayed work item timer_sleep has fully\ncompleted if it was already running. This leads to use-after-free scenarios\nwhere xc5000_release() may free the xc5000_priv while timer_sleep is still\nactive and attempts to dereference the xc5000_priv.\n\nA typical race condition is illustrated below:\n\nCPU 0 (release thread)                 | CPU 1 (delayed work callback)\nxc5000_release()                       | xc5000_do_timer_sleep()\n  cancel_delayed_work()                |\n  hybrid_tuner_release_state(priv)     |\n    kfree(priv)                        |\n                                       |   priv = container_of() // UAF\n\nReplace cancel_delayed_work() with cancel_delayed_work_sync() to ensure\nthat the timer_sleep is properly canceled before the xc5000_priv memory\nis deallocated.\n\nA deadlock concern was considered: xc5000_release() is called in a process\ncontext and is not holding any locks that the timer_sleep work item might\nalso need. Therefore, the use of the _sync() variant is safe here.\n\nThis bug was initially identified through static analysis.\n\n[hverkuil: fix typo in Subject: tunner -> tuner]",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-39998",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: scsi: target: target_core_configfs: Add length check to avoid buffer overflow",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: target_core_configfs: Add length check to avoid buffer overflow\n\nA buffer overflow arises from the usage of snprintf to write into the\nbuffer \"buf\" in target_lu_gp_members_show function located in\n/drivers/target/target_core_configfs.c. This buffer is allocated with\nsize LU_GROUP_NAME_BUF (256 bytes).\n\nsnprintf(...) formats multiple strings into buf with the HBA name\n(hba->hba_group.cg_item), a slash character, a devicename (dev->\ndev_group.cg_item) and a newline character, the total formatted string\nlength may exceed the buffer size of 256 bytes.\n\nSince snprintf() returns the total number of bytes that would have been\nwritten (the length of %s/%sn ), this value may exceed the buffer length\n(256 bytes) passed to memcpy(), this will ultimately cause function\nmemcpy reporting a buffer overflow error.\n\nAn additional check of the return value of snprintf() can avoid this\nbuffer overflow.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40005",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: spi: cadence-quadspi: Implement refcount to handle unbind during busy",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: cadence-quadspi: Implement refcount to handle unbind during busy\n\ndriver support indirect read and indirect write operation with\nassumption no force device removal(unbind) operation. However\nforce device removal(removal) is still available to root superuser.\n\nUnbinding driver during operation causes kernel crash. This changes\nensure driver able to handle such operation for indirect read and\nindirect write by implementing refcount to track attached devices\nto the controller and gracefully wait and until attached devices\nremove operation completed before proceed with removal operation.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40016",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: media: uvcvideo: Mark invalid entities with id UVC_INVALID_ENTITY_ID",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Mark invalid entities with id UVC_INVALID_ENTITY_ID\n\nPer UVC 1.1+ specification 3.7.2, units and terminals must have a non-zero\nunique ID.\n\n```\nEach Unit and Terminal within the video function is assigned a unique\nidentification number, the Unit ID (UID) or Terminal ID (TID), contained in\nthe bUnitID or bTerminalID field of the descriptor. The value 0x00 is\nreserved for undefined ID,\n```\n\nIf we add a new entity with id 0 or a duplicated ID, it will be marked\nas UVC_INVALID_ENTITY_ID.\n\nIn a previous attempt commit 3dd075fe8ebb (\"media: uvcvideo: Require\nentities to have a non-zero unique ID\"), we ignored all the invalid units,\nthis broke a lot of non-compatible cameras. Hopefully we are more lucky\nthis time.\n\nThis also prevents some syzkaller reproducers from triggering warnings due\nto a chain of entities referring to themselves. In one particular case, an\nOutput Unit is connected to an Input Unit, both with the same ID of 1. But\nwhen looking up for the source ID of the Output Unit, that same entity is\nfound instead of the input entity, which leads to such warnings.\n\nIn another case, a backward chain was considered finished as the source ID\nwas 0. Later on, that entity was found, but its pads were not valid.\n\nHere is a sample stack trace for one of those cases.\n\n[   20.650953] usb 1-1: new high-speed USB device number 2 using dummy_hcd\n[   20.830206] usb 1-1: Using ep0 maxpacket: 8\n[   20.833501] usb 1-1: config 0 descriptor??\n[   21.038518] usb 1-1: string descriptor 0 read error: -71\n[   21.038893] usb 1-1: Found UVC 0.00 device <unnamed> (2833:0201)\n[   21.039299] uvcvideo 1-1:0.0: Entity type for entity Output 1 was not initialized!\n[   21.041583] uvcvideo 1-1:0.0: Entity type for entity Input 1 was not initialized!\n[   21.042218] ------------[ cut here ]------------\n[   21.042536] WARNING: CPU: 0 PID: 9 at drivers/media/mc/mc-entity.c:1147 media_create_pad_link+0x2c4/0x2e0\n[   21.043195] Modules linked in:\n[   21.043535] CPU: 0 UID: 0 PID: 9 Comm: kworker/0:1 Not tainted 6.11.0-rc7-00030-g3480e43aeccf #444\n[   21.044101] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014\n[   21.044639] Workqueue: usb_hub_wq hub_event\n[   21.045100] RIP: 0010:media_create_pad_link+0x2c4/0x2e0\n[   21.045508] Code: fe e8 20 01 00 00 b8 f4 ff ff ff 48 83 c4 30 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 0f 0b eb e9 0f 0b eb 0a 0f 0b eb 06 <0f> 0b eb 02 0f 0b b8 ea ff ff ff eb d4 66 2e 0f 1f 84 00 00 00 00\n[   21.046801] RSP: 0018:ffffc9000004b318 EFLAGS: 00010246\n[   21.047227] RAX: ffff888004e5d458 RBX: 0000000000000000 RCX: ffffffff818fccf1\n[   21.047719] RDX: 000000000000007b RSI: 0000000000000000 RDI: ffff888004313290\n[   21.048241] RBP: ffff888004313290 R08: 0001ffffffffffff R09: 0000000000000000\n[   21.048701] R10: 0000000000000013 R11: 0001888004313290 R12: 0000000000000003\n[   21.049138] R13: ffff888004313080 R14: ffff888004313080 R15: 0000000000000000\n[   21.049648] FS:  0000000000000000(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000\n[   21.050271] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   21.050688] CR2: 0000592cc27635b0 CR3: 000000000431c000 CR4: 0000000000750ef0\n[   21.051136] PKRU: 55555554\n[   21.051331] Call Trace:\n[   21.051480]  <TASK>\n[   21.051611]  ? __warn+0xc4/0x210\n[   21.051861]  ? media_create_pad_link+0x2c4/0x2e0\n[   21.052252]  ? report_bug+0x11b/0x1a0\n[   21.052540]  ? trace_hardirqs_on+0x31/0x40\n[   21.052901]  ? handle_bug+0x3d/0x70\n[   21.053197]  ? exc_invalid_op+0x1a/0x50\n[   21.053511]  ? asm_exc_invalid_op+0x1a/0x20\n[   21.053924]  ? media_create_pad_link+0x91/0x2e0\n[   21.054364]  ? media_create_pad_link+0x2c4/0x2e0\n[   21.054834]  ? media_create_pad_link+0x91/0x2e0\n[   21.055131]  ? _raw_spin_unlock+0x1e/0x40\n[   21.055441]  ? __v4l2_device_register_subdev+0x202/0x210\n[   21.055837]  uvc_mc_register_entities+0x358/0x400\n[   21.056144]  uvc_register_chains+0x1\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40026",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: KVM: x86: Don't (re)check L1 intercepts when completing userspace I/O",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Don't (re)check L1 intercepts when completing userspace I/O\n\nWhen completing emulation of instruction that generated a userspace exit\nfor I/O, don't recheck L1 intercepts as KVM has already finished that\nphase of instruction execution, i.e. has already committed to allowing L2\nto perform I/O.  If L1 (or host userspace) modifies the I/O permission\nbitmaps during the exit to userspace,  KVM will treat the access as being\nintercepted despite already having emulated the I/O access.\n\nPivot on EMULTYPE_NO_DECODE to detect that KVM is completing emulation.\nOf the three users of EMULTYPE_NO_DECODE, only complete_emulated_io() (the\nintended \"recipient\") can reach the code in question.  gp_interception()'s\nuse is mutually exclusive with is_guest_mode(), and\ncomplete_emulated_insn_gp() unconditionally pairs EMULTYPE_NO_DECODE with\nEMULTYPE_SKIP.\n\nThe bad behavior was detected by a syzkaller program that toggles port I/O\ninterception during the userspace I/O exit, ultimately resulting in a WARN\non vcpu->arch.pio.count being non-zero due to KVM no completing emulation\nof the I/O instruction.\n\n  WARNING: CPU: 23 PID: 1083 at arch/x86/kvm/x86.c:8039 emulator_pio_in_out+0x154/0x170 [kvm]\n  Modules linked in: kvm_intel kvm irqbypass\n  CPU: 23 UID: 1000 PID: 1083 Comm: repro Not tainted 6.16.0-rc5-c1610d2d66b1-next-vm #74 NONE\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:emulator_pio_in_out+0x154/0x170 [kvm]\n  PKRU: 55555554\n  Call Trace:\n   <TASK>\n   kvm_fast_pio+0xd6/0x1d0 [kvm]\n   vmx_handle_exit+0x149/0x610 [kvm_intel]\n   kvm_arch_vcpu_ioctl_run+0xda8/0x1ac0 [kvm]\n   kvm_vcpu_ioctl+0x244/0x8c0 [kvm]\n   __x64_sys_ioctl+0x8a/0xd0\n   do_syscall_64+0x5d/0xc60\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n   </TASK>",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40029",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: bus: fsl-mc: Check return value of platform_get_resource()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: fsl-mc: Check return value of platform_get_resource()\n\nplatform_get_resource() returns NULL in case of failure, so check its\nreturn value and propagate the error in order to prevent NULL pointer\ndereference.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40030",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pinctrl: check the return value of pinmux_ops::get_function_name()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: check the return value of pinmux_ops::get_function_name()\n\nWhile the API contract in docs doesn't specify it explicitly, the\ngeneric implementation of the get_function_name() callback from struct\npinmux_ops - pinmux_generic_get_function_name() - can fail and return\nNULL. This is already checked in pinmux_check_ops() so add a similar\ncheck in pinmux_func_name_to_selector() instead of passing the returned\npointer right down to strcmp() where the NULL can get dereferenced. This\nis normal operation when adding new pinfunctions.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40044",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: fs: udf: fix OOB read in lengthAllocDescs handling",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: udf: fix OOB read in lengthAllocDescs handling\n\nWhen parsing Allocation Extent Descriptor, lengthAllocDescs comes from\non-disk data and must be validated against the block size. Crafted or\ncorrupted images may set lengthAllocDescs so that the total descriptor\nlength (sizeof(allocExtDesc) + lengthAllocDescs) exceeds the buffer,\nleading udf_update_tag() to call crc_itu_t() on out-of-bounds memory and\ntrigger a KASAN use-after-free read.\n\nBUG: KASAN: use-after-free in crc_itu_t+0x1d5/0x2b0 lib/crc-itu-t.c:60\nRead of size 1 at addr ffff888041e7d000 by task syz-executor317/5309\n\nCPU: 0 UID: 0 PID: 5309 Comm: syz-executor317 Not tainted 6.12.0-rc4-syzkaller-00261-g850925a8133c #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n crc_itu_t+0x1d5/0x2b0 lib/crc-itu-t.c:60\n udf_update_tag+0x70/0x6a0 fs/udf/misc.c:261\n udf_write_aext+0x4d8/0x7b0 fs/udf/inode.c:2179\n extent_trunc+0x2f7/0x4a0 fs/udf/truncate.c:46\n udf_truncate_tail_extent+0x527/0x7e0 fs/udf/truncate.c:106\n udf_release_file+0xc1/0x120 fs/udf/file.c:185\n __fput+0x23f/0x880 fs/file_table.c:431\n task_work_run+0x24f/0x310 kernel/task_work.c:239\n exit_task_work include/linux/task_work.h:43 [inline]\n do_exit+0xa2f/0x28e0 kernel/exit.c:939\n do_group_exit+0x207/0x2c0 kernel/exit.c:1088\n __do_sys_exit_group kernel/exit.c:1099 [inline]\n __se_sys_exit_group kernel/exit.c:1097 [inline]\n __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1097\n x64_sys_call+0x2634/0x2640 arch/x86/include/generated/asm/syscalls_64.h:232\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n </TASK>\n\nValidate the computed total length against epos->bh->b_size.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40048",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: uio_hv_generic: Let userspace take care of interrupt mask",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuio_hv_generic: Let userspace take care of interrupt mask\n\nRemove the logic to set interrupt mask by default in uio_hv_generic\ndriver as the interrupt mask value is supposed to be controlled\ncompletely by the user space. If the mask bit gets changed\nby the driver, concurrently with user mode operating on the ring,\nthe mask bit may be set when it is supposed to be clear, and the\nuser-mode driver will miss an interrupt which will cause a hang.\n\nFor eg- when the driver sets inbound ring buffer interrupt mask to 1,\nthe host does not interrupt the guest on the UIO VMBus channel.\nHowever, setting the mask does not prevent the host from putting a\nmessage in the inbound ring buffer.\u00a0So let\u2019s assume that happens,\nthe host puts a message into the ring buffer but does not interrupt.\n\nSubsequently, the user space code in the guest sets the inbound ring\nbuffer interrupt mask to 0, saying \u201cHey, I\u2019m ready for interrupts\u201d.\nUser space code then calls pread() to wait for an interrupt.\nThen one of two things happens:\n\n* The host never sends another message. So the pread() waits forever.\n* The host does send another message. But because there\u2019s already a\n  message in the ring buffer, it doesn\u2019t generate an interrupt.\n  This is the correct behavior, because the host should only send an\n  interrupt when the inbound ring buffer transitions from empty to\n  not-empty. Adding an additional message to a ring buffer that is not\n  empty is not supposed to generate an interrupt on the guest.\n  Since the guest is waiting in pread() and not removing messages from\n  the ring buffer, the pread() waits forever.\n\nThis could be easily reproduced in hv_fcopy_uio_daemon if we delay\nsetting interrupt mask to 0.\n\nSimilarly if hv_uio_channel_cb() sets the interrupt_mask to 1,\nthere\u2019s a race condition. Once user space empties the inbound ring\nbuffer, but before user space sets interrupt_mask to 0, the host could\nput another message in the ring buffer but it wouldn\u2019t interrupt.\nThen the next pread() would hang.\n\nFix these by removing all instances where interrupt_mask is changed,\nwhile keeping the one in set_event() unchanged to enable userspace\ncontrol the interrupt mask by writing 0/1 to /dev/uioX.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40053",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: net: dlink: handle copy_thresh allocation failure",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dlink: handle copy_thresh allocation failure\n\nThe driver did not handle failure of `netdev_alloc_skb_ip_align()`.\nIf the allocation failed, dereferencing `skb->protocol` could lead to\na NULL pointer dereference.\n\nThis patch tries to allocate `skb`. If the allocation fails, it falls\nback to the normal path.\n\nTested-on: D-Link DGE-550T Rev-A3",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40064",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: smc: Fix use-after-free in __pnet_find_base_ndev()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmc: Fix use-after-free in __pnet_find_base_ndev().\n\nsyzbot reported use-after-free of net_device in __pnet_find_base_ndev(),\nwhich was called during connect(). [0]\n\nsmc_pnet_find_ism_resource() fetches sk_dst_get(sk)->dev and passes\ndown to pnet_find_base_ndev(), where RTNL is held.  Then, UAF happened\nat __pnet_find_base_ndev() when the dev is first used.\n\nThis means dev had already been freed before acquiring RTNL in\npnet_find_base_ndev().\n\nWhile dev is going away, dst->dev could be swapped with blackhole_netdev,\nand the dev's refcnt by dst will be released.\n\nWe must hold dev's refcnt before calling smc_pnet_find_ism_resource().\n\nAlso, smc_pnet_find_roce_resource() has the same problem.\n\nLet's use __sk_dst_get() and dst_dev_rcu() in the two functions.\n\n[0]:\nBUG: KASAN: use-after-free in __pnet_find_base_ndev+0x1b1/0x1c0 net/smc/smc_pnet.c:926\nRead of size 1 at addr ffff888036bac33a by task syz.0.3632/18609\n\nCPU: 1 UID: 0 PID: 18609 Comm: syz.0.3632 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x240 mm/kasan/report.c:482\n kasan_report+0x118/0x150 mm/kasan/report.c:595\n __pnet_find_base_ndev+0x1b1/0x1c0 net/smc/smc_pnet.c:926\n pnet_find_base_ndev net/smc/smc_pnet.c:946 [inline]\n smc_pnet_find_ism_by_pnetid net/smc/smc_pnet.c:1103 [inline]\n smc_pnet_find_ism_resource+0xef/0x390 net/smc/smc_pnet.c:1154\n smc_find_ism_device net/smc/af_smc.c:1030 [inline]\n smc_find_proposal_devices net/smc/af_smc.c:1115 [inline]\n __smc_connect+0x372/0x1890 net/smc/af_smc.c:1545\n smc_connect+0x877/0xd90 net/smc/af_smc.c:1715\n __sys_connect_file net/socket.c:2086 [inline]\n __sys_connect+0x313/0x440 net/socket.c:2105\n __do_sys_connect net/socket.c:2111 [inline]\n __se_sys_connect net/socket.c:2108 [inline]\n __x64_sys_connect+0x7a/0x90 net/socket.c:2108\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f47cbf8eba9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f47ccdb1038 EFLAGS: 00000246 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 00007f47cc1d5fa0 RCX: 00007f47cbf8eba9\nRDX: 0000000000000010 RSI: 0000200000000280 RDI: 000000000000000b\nRBP: 00007f47cc011e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007f47cc1d6038 R14: 00007f47cc1d5fa0 R15: 00007ffc512f8aa8\n </TASK>\n\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0xffff888036bacd00 pfn:0x36bac\nflags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000000000 ffffea0001243d08 ffff8880b863fdc0 0000000000000000\nraw: ffff888036bacd00 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as freed\npage last allocated via order 2, migratetype Unmovable, gfp_mask 0x446dc0(GFP_KERNEL_ACCOUNT|__GFP_ZERO|__GFP_NOWARN|__GFP_RETRY_MAYFAIL|__GFP_COMP), pid 16741, tgid 16741 (syz-executor), ts 343313197788, free_ts 380670750466\n set_page_owner include/linux/page_owner.h:32 [inline]\n post_alloc_hook+0x240/0x2a0 mm/page_alloc.c:1851\n prep_new_page mm/page_alloc.c:1859 [inline]\n get_page_from_freelist+0x21e4/0x22c0 mm/page_alloc.c:3858\n __alloc_frozen_pages_noprof+0x181/0x370 mm/page_alloc.c:5148\n alloc_pages_mpol+0x232/0x4a0 mm/mempolicy.c:2416\n ___kmalloc_large_node+0x5f/0x1b0 mm/slub.c:4317\n __kmalloc_large_node_noprof+0x18/0x90 mm/slub.c:4348\n __do_kmalloc_node mm/slub.c:4364 [inline]\n __kvmalloc_node\n---truncated---",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40070",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: pps: fix warning in pps_register_cdev when register device fail",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npps: fix warning in pps_register_cdev when register device fail\n\nSimilar to previous commit 2a934fdb01db (\"media: v4l2-dev: fix error\nhandling in __video_register_device()\"), the release hook should be set\nbefore device_register(). Otherwise, when device_register() return error\nand put_device() try to callback the release function, the below warning\nmay happen.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 1 PID: 4760 at drivers/base/core.c:2567 device_release+0x1bd/0x240 drivers/base/core.c:2567\n  Modules linked in:\n  CPU: 1 UID: 0 PID: 4760 Comm: syz.4.914 Not tainted 6.17.0-rc3+ #1 NONE\n  RIP: 0010:device_release+0x1bd/0x240 drivers/base/core.c:2567\n  Call Trace:\n   <TASK>\n   kobject_cleanup+0x136/0x410 lib/kobject.c:689\n   kobject_release lib/kobject.c:720 [inline]\n   kref_put include/linux/kref.h:65 [inline]\n   kobject_put+0xe9/0x130 lib/kobject.c:737\n   put_device+0x24/0x30 drivers/base/core.c:3797\n   pps_register_cdev+0x2da/0x370 drivers/pps/pps.c:402\n   pps_register_source+0x2f6/0x480 drivers/pps/kapi.c:108\n   pps_tty_open+0x190/0x310 drivers/pps/clients/pps-ldisc.c:57\n   tty_ldisc_open+0xa7/0x120 drivers/tty/tty_ldisc.c:432\n   tty_set_ldisc+0x333/0x780 drivers/tty/tty_ldisc.c:563\n   tiocsetd drivers/tty/tty_io.c:2429 [inline]\n   tty_ioctl+0x5d1/0x1700 drivers/tty/tty_io.c:2728\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:598 [inline]\n   __se_sys_ioctl fs/ioctl.c:584 [inline]\n   __x64_sys_ioctl+0x194/0x210 fs/ioctl.c:584\n   do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n   do_syscall_64+0x5f/0x2a0 arch/x86/entry/syscall_64.c:94\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n   </TASK>\n\nBefore commit c79a39dc8d06 (\"pps: Fix a use-after-free\"),\npps_register_cdev() call device_create() to create pps->dev, which will\ninit dev->release to device_create_release(). Now the comment is outdated,\njust remove it.\n\nThanks for the reminder from Calvin Owens, 'kfree_pps' should be removed\nin pps_register_source() to avoid a double free in the failure case.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40074",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: ipv4: start using dst_dev_rcu()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv4: start using dst_dev_rcu()\n\nChange icmpv4_xrlim_allow(), ip_defrag() to prevent possible UAF.\n\nChange ipmr_prepare_xmit(), ipmr_queue_fwd_xmit(), ip_mr_output(),\nipv4_neigh_lookup() to use lockdep enabled dst_dev_rcu().",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40075",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: tcp_metrics: use dst_dev_net_rcu()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_metrics: use dst_dev_net_rcu()\n\nReplace three dst_dev() with a lockdep enabled helper.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40080",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: nbd: restrict sockets to TCP and UDP",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: restrict sockets to TCP and UDP\n\nRecently, syzbot started to abuse NBD with all kinds of sockets.\n\nCommit cf1b2326b734 (\"nbd: verify socket is supported during setup\")\nmade sure the socket supported a shutdown() method.\n\nExplicitely accept TCP and UNIX stream sockets.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40081",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: perf: arm_spe: Prevent overflow in PERF_IDX2OFF()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: arm_spe: Prevent overflow in PERF_IDX2OFF()\n\nCast nr_pages to unsigned long to avoid overflow when handling large\nAUX buffer sizes (>= 2 GiB).",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2025-40082",
      "package_name": "linux-libc-dev",
      "installed_version": "5.10.149-2",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "kernel: hfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()",
      "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: fix slab-out-of-bounds read in hfsplus_uni2asc()\n\nBUG: KASAN: slab-out-of-bounds in hfsplus_uni2asc+0xa71/0xb90 fs/hfsplus/unicode.c:186\nRead of size 2 at addr ffff8880289ef218 by task syz.6.248/14290\n\nCPU: 0 UID: 0 PID: 14290 Comm: syz.6.248 Not tainted 6.16.4 #1 PREEMPT(full)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1b0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x5f0 mm/kasan/report.c:482\n kasan_report+0xca/0x100 mm/kasan/report.c:595\n hfsplus_uni2asc+0xa71/0xb90 fs/hfsplus/unicode.c:186\n hfsplus_listxattr+0x5b6/0xbd0 fs/hfsplus/xattr.c:738\n vfs_listxattr+0xbe/0x140 fs/xattr.c:493\n listxattr+0xee/0x190 fs/xattr.c:924\n filename_listxattr fs/xattr.c:958 [inline]\n path_listxattrat+0x143/0x360 fs/xattr.c:988\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcb/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fe0e9fae16d\nCode: 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fe0eae67f98 EFLAGS: 00000246 ORIG_RAX: 00000000000000c3\nRAX: ffffffffffffffda RBX: 00007fe0ea205fa0 RCX: 00007fe0e9fae16d\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000200000000000\nRBP: 00007fe0ea0480f0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fe0ea206038 R14: 00007fe0ea205fa0 R15: 00007fe0eae48000\n </TASK>\n\nAllocated by task 14290:\n kasan_save_stack+0x24/0x50 mm/kasan/common.c:47\n kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4333 [inline]\n __kmalloc_noprof+0x219/0x540 mm/slub.c:4345\n kmalloc_noprof include/linux/slab.h:909 [inline]\n hfsplus_find_init+0x95/0x1f0 fs/hfsplus/bfind.c:21\n hfsplus_listxattr+0x331/0xbd0 fs/hfsplus/xattr.c:697\n vfs_listxattr+0xbe/0x140 fs/xattr.c:493\n listxattr+0xee/0x190 fs/xattr.c:924\n filename_listxattr fs/xattr.c:958 [inline]\n path_listxattrat+0x143/0x360 fs/xattr.c:988\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcb/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nWhen hfsplus_uni2asc is called from hfsplus_listxattr,\nit actually passes in a struct hfsplus_attr_unistr*.\nThe size of the corresponding structure is different from that of hfsplus_unistr,\nso the previous fix (94458781aee6) is insufficient.\nThe pointer on the unicode buffer is still going beyond the allocated memory.\n\nThis patch introduces two warpper functions hfsplus_uni2asc_xattr_str and\nhfsplus_uni2asc_str to process two unicode buffers,\nstruct hfsplus_attr_unistr* and struct hfsplus_unistr* respectively.\nWhen ustrlen value is bigger than the allocated memory size,\nthe ustrlen value is limited to an safe size.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2022-1304",
      "package_name": "logsave",
      "installed_version": "1.46.2-2",
      "fixed_version": "1.46.2-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "e2fsprogs: out-of-bounds read/write via crafted filesystem",
      "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-29458",
      "package_name": "ncurses-base",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: segfaulting OOB read",
      "description": "ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29491",
      "package_name": "ncurses-base",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: Local users can trigger security-relevant memory corruption via malformed data",
      "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-29458",
      "package_name": "ncurses-bin",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u1",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: segfaulting OOB read",
      "description": "ncurses 6.3 before patch 20220416 has an out-of-bounds read and segmentation violation in convert_strings in tinfo/read_entry.c in the terminfo library.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29491",
      "package_name": "ncurses-bin",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "6.2+20201114-2+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "ncurses: Local users can trigger security-relevant memory corruption via malformed data",
      "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-16156",
      "package_name": "perl-base",
      "installed_version": "5.32.1-4+deb11u2",
      "fixed_version": "5.32.1-4+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "perl-CPAN: Bypass of verification of signatures in CHECKSUMS files",
      "description": "CPAN 2.28 allows Signature Verification Bypass.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31484",
      "package_name": "perl-base",
      "installed_version": "5.32.1-4+deb11u2",
      "fixed_version": "5.32.1-4+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "perl: CPAN.pm does not verify TLS certificates when downloading distributions over HTTPS",
      "description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-47038",
      "package_name": "perl-base",
      "installed_version": "5.32.1-4+deb11u2",
      "fixed_version": "5.32.1-4+deb11u3",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "perl: Write past buffer end via illegal user-defined Unicode property",
      "description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50387",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator",
      "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50868",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources",
      "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50387",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: KeyTrap - Extreme CPU consumption in DNSSEC validator",
      "description": "Certain DNSSEC aspects of the DNS protocol (in RFC 4033, 4034, 4035, 6840, and related RFCs) allow remote attackers to cause a denial of service (CPU consumption) via one or more DNSSEC responses, aka the \"KeyTrap\" issue. One of the concerns is that, when there is a zone with many DNSKEY and RRSIG records, the protocol specification implies that an algorithm must evaluate all combinations of DNSKEY and RRSIG records.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50868",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "bind9: Preparing an NSEC3 closest encloser proof can exhaust CPU resources",
      "description": "The Closest Encloser Proof aspect of the DNS protocol (in RFC 5155 when RFC 9276 guidance is skipped) allows remote attackers to cause a denial of service (CPU consumption for SHA-1 computations) via DNSSEC responses in a random subdomain attack, aka the \"NSEC3\" issue. The RFC 5155 specification implies that an algorithm must perform thousands of iterations of a hash function in certain situations.",
      "detected_by": [
        "trivy",
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45853",
      "package_name": "zlib1g",
      "installed_version": "1:1.2.11.dfsg-2+deb11u2",
      "fixed_version": "No fix available",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "trivy",
      "title": "zlib: integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_6",
      "description": "MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version, and exposes the applicable MiniZip code through its compress API.",
      "detected_by": [
        "trivy"
      ]
    },
    {
      "cve_id": "CVE-2023-2650",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Processing some specially crafted ASN.1 object identifiers or data containing them may be very slow.  Impact summary: Applications that use OBJ_obj2txt() directly, or use any of the OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message size limit may experience notable to very long delays when processing those messages, which may lead to a Denial of Service.  An OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers - most of which have no size limit.  OBJ_obj2txt() may be used to translate an ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL type ASN1_OBJECT) to its canonical numeric text form, which are the sub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by periods.  When one of the sub-identifiers in the OBJECT IDENTIFIER is very large (these are sizes that are seen as absurdly large, taking up tens or hundreds of KiBs), the translation to a decimal number in text may take a very long time.  The time complexity is O(n^2) with 'n' being the size of the sub-identifiers in bytes (*).  With OpenSSL 3.0, support to fetch cryptographic algorithms using names / identifiers in string form was introduced.  This includes using OBJECT IDENTIFIERs in canonical numeric text form as identifiers for fetching algorithms.  Such OBJECT IDENTIFIERs may be received through the ASN.1 structure AlgorithmIdentifier, which is commonly used in multiple protocols to specify what cryptographic algorithm should be used to sign or verify, encrypt or decrypt, or digest passed data.  Applications that call OBJ_obj2txt() directly with untrusted data are affected, with any version of OpenSSL.  If the use is for the mere purpose of display, the severity is considered low.  In OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS.  It also impacts anything that processes X.509 certificates, including simple things like verifying its signature.  The impact on TLS is relatively low, because all versions of OpenSSL have a 100KiB limit on the peer's certificate chain.  Additionally, this only impacts clients, or servers that have explicitly enabled client authentication.  In OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects, such as X.509 certificates.  This is assumed to not happen in such a way that it would cause a Denial of Service, so these versions are considered not affected by this issue in such a way that it would be cause for concern, and the severity is therefore considered low.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28182",
      "package_name": "libnghttp2-14",
      "installed_version": "1.43.0-1",
      "fixed_version": "1.43.0-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nghttp2 is an implementation of the Hypertext Transfer Protocol version 2 in C. The nghttp2 library prior to version 1.61.0 keeps reading the unbounded number of HTTP/2 CONTINUATION frames even after a stream is reset to keep HPACK context in sync.  This causes excessive CPU usage to decode HPACK stream. nghttp2 v1.61.0 mitigates this vulnerability by limiting the number of CONTINUATION frames it accepts per stream. There is no workaround for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-5535",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u2",
      "severity": "CRITICAL",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Calling the OpenSSL API function SSL_select_next_proto with an empty supported client protocols buffer may cause a crash or memory contents to be sent to the peer.  Impact summary: A buffer overread can have a range of potential consequences such as unexpected application beahviour or a crash. In particular this issue could result in up to 255 bytes of arbitrary private data from memory being sent to the peer leading to a loss of confidentiality. However, only applications that directly call the SSL_select_next_proto function with a 0 length list of supported client protocols are affected by this issue. This would normally never be a valid scenario and is typically not under attacker control but may occur by accident in the case of a configuration or programming error in the calling application.  The OpenSSL API function SSL_select_next_proto is typically used by TLS applications that support ALPN (Application Layer Protocol Negotiation) or NPN (Next Protocol Negotiation). NPN is older, was never standardised and is deprecated in favour of ALPN. We believe that ALPN is significantly more widely deployed than NPN. The SSL_select_next_proto function accepts a list of protocols from the server and a list of protocols from the client and returns the first protocol that appears in the server list that also appears in the client list. In the case of no overlap between the two lists it returns the first item in the client list. In either case it will signal whether an overlap between the two lists was found. In the case where SSL_select_next_proto is called with a zero length client list it fails to notice this condition and returns the memory immediately following the client list pointer (and reports that there was no overlap in the lists).  This function is typically called from a server side application callback for ALPN or a client side application callback for NPN. In the case of ALPN the list of protocols supplied by the client is guaranteed by libssl to never be zero in length. The list of server protocols comes from the application and should never normally be expected to be of zero length. In this case if the SSL_select_next_proto function has been called as expected (with the list supplied by the client passed in the client/client_len parameters), then the application will not be vulnerable to this issue. If the application has accidentally been configured with a zero length server list, and has accidentally passed that zero length server list in the client/client_len parameters, and has additionally failed to correctly handle a \"no overlap\" response (which would normally result in a handshake failure in ALPN) then it will be vulnerable to this problem.  In the case of NPN, the protocol permits the client to opportunistically select a protocol when there is no overlap. OpenSSL returns the first client protocol in the no overlap case in support of this. The list of client protocols comes from the application and should never normally be expected to be of zero length. However if the SSL_select_next_proto function is accidentally called with a client_len of 0 then an invalid memory pointer will be returned instead. If the application uses this output as the opportunistic protocol then the loss of confidentiality will occur.  This issue has been assessed as Low severity because applications are most likely to be vulnerable if they are using NPN instead of ALPN - but NPN is not widely used. It also requires an application configuration or programming error. Finally, this issue would not typically be under attacker control making active exploitation unlikely.  The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.  Due to the low severity of this issue we are not issuing new releases of OpenSSL at this time. The fix will be included in the next releases when they become available.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-7264",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u13",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libcurl's ASN1 parser code has the `GTime2str()` function, used for parsing an ASN.1 Generalized Time field. If given an syntactically incorrect field, the parser might end up using -1 for the length of the *time fraction*, leading to a `strlen()` getting performed on a pointer to a heap buffer area that is not (purposely) null terminated.  This flaw most likely leads to a crash, but can also lead to heap contents getting returned to the application when [CURLINFO_CERTINFO](https://curl.se/libcurl/c/CURLINFO_CERTINFO.html) is used.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-7264",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u13",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libcurl's ASN1 parser code has the `GTime2str()` function, used for parsing an ASN.1 Generalized Time field. If given an syntactically incorrect field, the parser might end up using -1 for the length of the *time fraction*, leading to a `strlen()` getting performed on a pointer to a heap buffer area that is not (purposely) null terminated.  This flaw most likely leads to a crash, but can also lead to heap contents getting returned to the application when [CURLINFO_CERTINFO](https://curl.se/libcurl/c/CURLINFO_CERTINFO.html) is used.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "bsdutils",
      "installed_version": "1:2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "libblkid1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "libmount1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "libsmartcols1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "libuuid1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "mount",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28085",
      "package_name": "util-linux",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "2.36.1-8+deb11u2",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-48795",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-35737",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "SQLite 1.0.12 through 3.39.x before 3.39.2 sometimes allows an array-bounds overflow if billions of bytes are used in a string argument to a C API.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2511",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Some non-default TLS server configurations can cause unbounded memory growth when processing TLSv1.3 sessions  Impact summary: An attacker may exploit certain server configurations to trigger unbounded memory growth that would lead to a Denial of Service  This problem can occur in TLSv1.3 if the non-default SSL_OP_NO_TICKET option is being used (but not if early_data support is also configured and the default anti-replay protection is in use). In this case, under certain conditions, the session cache can get into an incorrect state and it will fail to flush properly as it fills. The session cache will continue to grow in an unbounded manner. A malicious client could deliberately create the scenario for this failure to force a Denial of Service. It may also happen by accident in normal operation.  This issue only affects TLS servers supporting TLSv1.3. It does not affect TLS clients.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue. OpenSSL 1.0.2 is also not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-35235",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. In versions 2.4.8 and earlier, when starting the cupsd server with a Listen configuration item pointing to a symbolic link, the cupsd process can be caused to perform an arbitrary chmod of the provided argument, providing world-writable access to the target. Given that cupsd is often running as root, this can result in the change of permission of any user or system files to be world writable. Given the aforementioned Ubuntu AppArmor context, on such systems this vulnerability is limited to those files modifiable by the cupsd process. In that specific case it was found to be possible to turn the configuration of the Listen argument into full control over the cupsd.conf and cups-files.conf configuration files. By later setting the User and Group arguments in cups-files.conf, and printing with a printer configured by PPD with a `FoomaticRIPCommandLine` argument, arbitrary user and group (not root) command execution could be achieved, which can further be used on Ubuntu systems to achieve full root command execution. Commit ff1f8a623e090dee8a8aadf12a6a4b25efac143d contains a patch for the issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-56433",
      "package_name": "login",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g., uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks, potentially leading to account takeover, e.g., by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids, within local networks, that are within the range that can occur in /etc/subuid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-56433",
      "package_name": "passwd",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g., uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks, potentially leading to account takeover, e.g., by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids, within local networks, that are within the range that can occur in /etc/subuid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4806",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4806",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4806",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4806",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an extremely rare situation, the getaddrinfo function may access memory that has been freed, resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4, and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME, AI_ALL and AI_V4MAPPED as flags.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28834",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GnuTLS. The Minerva attack is a cryptographic vulnerability that exploits deterministic behavior in systems like GnuTLS, leading to side-channel leaks. In specific scenarios, such as when using the GNUTLS_PRIVKEY_FLAG_REPRODUCIBLE flag, it can result in a noticeable step in nonce size from 513 to 512 bits, exposing a potential timing side-channel.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-12243",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GnuTLS, which relies on libtasn1 for ASN.1 data processing. Due to an inefficient algorithm in libtasn1, decoding certain DER-encoded certificate data can take excessive time, leading to increased resource consumption. This flaw allows a remote attacker to send a specially crafted certificate, causing GnuTLS to become unresponsive or slow, resulting in a denial-of-service condition.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-2784",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. The package is vulnerable to a heap buffer over-read when sniffing content via the skip_insight_whitespace() function. Libsoup clients may read one byte out-of-bounds in response to a crafted HTTP response by an HTTP server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-2784",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. The package is vulnerable to a heap buffer over-read when sniffing content via the skip_insight_whitespace() function. Libsoup clients may read one byte out-of-bounds in response to a crafted HTTP response by an HTTP server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3446",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1v-0~deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_check(), DH_check_ex() or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  The function DH_check() performs various checks on DH parameters. One of those checks confirms that the modulus ('p' parameter) is not too large. Trying to use a very large modulus is slow and OpenSSL will not normally use a modulus which is over 10,000 bits in length.  However the DH_check() function checks numerous aspects of the key or parameters that have been supplied. Some of those checks use the supplied modulus value even if it has already been found to be too large.  An application that calls DH_check() and supplies a key or parameters obtained from an untrusted source could be vulernable to a Denial of Service attack.  The function DH_check() is itself called by a number of other OpenSSL functions. An application calling any of those other functions may similarly be affected. The other functions affected by this are DH_check_ex() and EVP_PKEY_param_check().  Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications when using the '-check' option.  The OpenSSL SSL/TLS implementation is not affected by this issue. The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-0395",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u12",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When the assert() function in the GNU C Library versions 2.13 to 2.40 fails, it does not allocate enough space for the assertion failure message string and size information, which may lead to a buffer overflow if the message string size aligns to page size.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-0395",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u12",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When the assert() function in the GNU C Library versions 2.13 to 2.40 fails, it does not allocate enough space for the assertion failure message string and size information, which may lead to a buffer overflow if the message string size aligns to page size.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-0395",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u12",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When the assert() function in the GNU C Library versions 2.13 to 2.40 fails, it does not allocate enough space for the assertion failure message string and size information, which may lead to a buffer overflow if the message string size aligns to page size.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-0395",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u12",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When the assert() function in the GNU C Library versions 2.13 to 2.40 fails, it does not allocate enough space for the assertion failure message string and size information, which may lead to a buffer overflow if the message string size aligns to page size.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-36054",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-36054",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-36054",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-36054",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-34969",
      "package_name": "dbus",
      "installed_version": "1.12.24-0+deb11u1",
      "fixed_version": "1.12.28-0+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "D-Bus before 1.15.6 sometimes allows unprivileged users to crash dbus-daemon. If a privileged user with control over the dbus-daemon is using the org.freedesktop.DBus.Monitoring interface to monitor message bus traffic, then an unprivileged user with the ability to connect to the same dbus-daemon can cause a dbus-daemon crash under some circumstances via an unreplyable message. When done on the well-known system bus, this is a denial-of-service vulnerability. The fixed versions are 1.12.28, 1.14.8, and 1.15.6.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-34969",
      "package_name": "dbus-user-session",
      "installed_version": "1.12.24-0+deb11u1",
      "fixed_version": "1.12.28-0+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "D-Bus before 1.15.6 sometimes allows unprivileged users to crash dbus-daemon. If a privileged user with control over the dbus-daemon is using the org.freedesktop.DBus.Monitoring interface to monitor message bus traffic, then an unprivileged user with the ability to connect to the same dbus-daemon can cause a dbus-daemon crash under some circumstances via an unreplyable message. When done on the well-known system bus, this is a denial-of-service vulnerability. The fixed versions are 1.12.28, 1.14.8, and 1.15.6.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-34969",
      "package_name": "libdbus-1-3",
      "installed_version": "1.12.24-0+deb11u1",
      "fixed_version": "1.12.28-0+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "D-Bus before 1.15.6 sometimes allows unprivileged users to crash dbus-daemon. If a privileged user with control over the dbus-daemon is using the org.freedesktop.DBus.Monitoring interface to monitor message bus traffic, then an unprivileged user with the ability to connect to the same dbus-daemon can cause a dbus-daemon crash under some circumstances via an unreplyable message. When done on the well-known system bus, this is a denial-of-service vulnerability. The fixed versions are 1.12.28, 1.14.8, and 1.15.6.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0466",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The function X509_VERIFY_PARAM_add0_policy() is documented to implicitly enable the certificate policy check when doing certificate verification. However the implementation of the function does not enable the check which allows certificates with invalid or incorrect policies to pass the certificate verification.  As suddenly enabling the policy check could break existing deployments it was decided to keep the existing behavior of the X509_VERIFY_PARAM_add0_policy() function.  Instead the applications that require OpenSSL to perform certificate policy check need to use X509_VERIFY_PARAM_set1_policies() or explicitly enable the policy check by calling X509_VERIFY_PARAM_set_flags() with the X509_V_FLAG_POLICY_CHECK flag argument.  Certificate policy checks are disabled by default in OpenSSL and are not commonly used by applications.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-9681",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is asked to use HSTS, the expiry time for a subdomain might overwrite a parent domain's cache entry, making it end sooner or later than otherwise intended.  This affects curl using applications that enable HSTS and use URLs with the insecure `HTTP://` scheme and perform transfers with hosts like `x.example.com` as well as `example.com` where the first host is a subdomain of the second host.  (The HSTS cache either needs to have been populated manually or there needs to have been previous HTTPS accesses done as the cache needs to have entries for the domains involved to trigger this problem.)  When `x.example.com` responds with `Strict-Transport-Security:` headers, this bug can make the subdomain's expiry timeout *bleed over* and get set for the parent domain `example.com` in curl's HSTS cache.  The result of a triggered bug is that HTTP accesses to `example.com` get converted to HTTPS for a different period of time than what was asked for by the origin server. If `example.com` for example stops supporting HTTPS at its expiry time, curl might then fail to access `http://example.com` until the (wrongly set) timeout expires. This bug can also expire the parent's entry *earlier*, thus making curl inadvertently switch back to insecure HTTP earlier than otherwise intended.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-9681",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is asked to use HSTS, the expiry time for a subdomain might overwrite a parent domain's cache entry, making it end sooner or later than otherwise intended.  This affects curl using applications that enable HSTS and use URLs with the insecure `HTTP://` scheme and perform transfers with hosts like `x.example.com` as well as `example.com` where the first host is a subdomain of the second host.  (The HSTS cache either needs to have been populated manually or there needs to have been previous HTTPS accesses done as the cache needs to have entries for the domains involved to trigger this problem.)  When `x.example.com` responds with `Strict-Transport-Security:` headers, this bug can make the subdomain's expiry timeout *bleed over* and get set for the parent domain `example.com` in curl's HSTS cache.  The result of a triggered bug is that HTTP accesses to `example.com` get converted to HTTPS for a different period of time than what was asked for by the origin server. If `example.com` for example stops supporting HTTPS at its expiry time, curl might then fail to access `http://example.com` until the (wrongly set) timeout expires. This bug can also expire the parent's entry *earlier*, thus making curl inadvertently switch back to insecure HTTP earlier than otherwise intended.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-5981",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found that the response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from response times of ciphertexts with correct PKCS#1 v1.5 padding.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-9143",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Use of the low-level GF(2^m) elliptic curve APIs with untrusted explicit values for the field polynomial can lead to out-of-bounds memory reads or writes.  Impact summary: Out of bound memory writes can lead to an application crash or even a possibility of a remote code execution, however, in all the protocols involving Elliptic Curve Cryptography that we're aware of, either only \"named curves\" are supported, or, if explicit curve parameters are supported, they specify an X9.62 encoding of binary (GF(2^m)) curves that can't represent problematic input values. Thus the likelihood of existence of a vulnerable application is low.  In particular, the X9.62 encoding is used for ECC keys in X.509 certificates, so problematic inputs cannot occur in the context of processing X.509 certificates.  Any problematic use-cases would have to be using an \"exotic\" curve encoding.  The affected APIs include: EC_GROUP_new_curve_GF2m(), EC_GROUP_new_from_params(), and various supporting BN_GF2m_*() functions.  Applications working with \"exotic\" explicit binary (GF(2^m)) curve parameters, that make it possible to represent invalid field polynomials with a zero constant term, via the above or similar APIs, may terminate abruptly as a result of reading or writing outside of array bounds.  Remote code execution cannot easily be ruled out.  The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-34459",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u8",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in xmllint (from libxml2) before 2.11.8 and 2.12.x before 2.12.7. Formatting error messages with xmllint --htmlout can result in a buffer over-read in xmlHTMLPrintFileContext in xmllint.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-12133",
      "package_name": "libtasn1-6",
      "installed_version": "4.16.0-2",
      "fixed_version": "4.16.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw in libtasn1 causes inefficient handling of specific certificate data. When processing a large number of elements in a certificate, libtasn1 takes much longer than expected, which can slow down or even crash the system. This flaw allows an attacker to send a specially crafted certificate, causing a denial of service attack.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-46218",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u11",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "This flaw allows a malicious HTTP server to set \"super cookies\" in curl that are then passed back to more origins than what is otherwise allowed or possible. This allows a site to set cookies that then would get sent to different and unrelated sites and domains.  It could do this by exploiting a mixed case flaw in curl's function that verifies a given cookie domain against the Public Suffix List (PSL). For example a cookie could be set with `domain=co.UK` when the URL used a lower case hostname `curl.co.uk`, even though `co.uk` is listed as a PSL domain.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-46218",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u11",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "This flaw allows a malicious HTTP server to set \"super cookies\" in curl that are then passed back to more origins than what is otherwise allowed or possible. This allows a site to set cookies that then would get sent to different and unrelated sites and domains.  It could do this by exploiting a mixed case flaw in curl's function that verifies a given cookie domain against the Public Suffix List (PSL). For example a cookie could be set with `domain=co.UK` when the URL used a lower case hostname `curl.co.uk`, even though `co.uk` is listed as a PSL domain.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-6277",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-8096",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u14",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is told to use the Certificate Status Request TLS extension, often referred to as OCSP stapling, to verify that the server certificate is valid, it might fail to detect some OCSP problems and instead wrongly consider the response as fine.  If the returned status reports another error than 'revoked' (like for example 'unauthorized') it is not treated as a bad certficate.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-8096",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u14",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is told to use the Certificate Status Request TLS extension, often referred to as OCSP stapling, to verify that the server certificate is valid, it might fail to detect some OCSP problems and instead wrongly consider the response as fine.  If the returned status reports another error than 'revoked' (like for example 'unauthorized') it is not treated as a bad certficate.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33602",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings  The Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory when the NSS callback does not store all strings in the provided buffer. The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33602",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings  The Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory when the NSS callback does not store all strings in the provided buffer. The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33602",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings  The Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory when the NSS callback does not store all strings in the provided buffer. The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33602",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings  The Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory when the NSS callback does not store all strings in the provided buffer. The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2011-3389",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a \"BEAST\" attack.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2097",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised implementation will not encrypt the entirety of the data under some circumstances. This could reveal sixteen bytes of data that was preexisting in the memory that wasn't written. In the special case of \"in place\" encryption, sixteen bytes of the plaintext would be revealed. Since OpenSSL does not support OCB based cipher suites for TLS and DTLS, they are both unaffected. Fixed in OpenSSL 3.0.5 (Affected 3.0.0-3.0.4). Fixed in OpenSSL 1.1.1q (Affected 1.1.1-1.1.1p).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0465",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Applications that use a non-default option when verifying certificates may be vulnerable to an attack from a malicious CA to circumvent certain checks.  Invalid certificate policies in leaf certificates are silently ignored by OpenSSL and other certificate policy checks are skipped for that certificate. A malicious CA could use this to deliberately assert invalid certificate policies in order to circumvent policy checking on the certificate altogether.  Policy processing is disabled by default but can be enabled by passing the `-policy' argument to the command line utilities or by calling the `X509_VERIFY_PARAM_set1_policies()' function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28322",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u9",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An information disclosure vulnerability exists in curl <v8.1.0 when doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously wasused to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the second transfer. The problem exists in the logic for a reused handle when it is (expected to be) changed from a PUT to a POST.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28322",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u9",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An information disclosure vulnerability exists in curl <v8.1.0 when doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously wasused to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the second transfer. The problem exists in the logic for a reused handle when it is (expected to be) changed from a PUT to a POST.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4813",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4813",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4813",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4813",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been identified in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3817",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1v-0~deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_check(), DH_check_ex() or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  The function DH_check() performs various checks on DH parameters. After fixing CVE-2023-3446 it was discovered that a large q parameter value can also trigger an overly long computation during some of these checks. A correct q value, if present, cannot be larger than the modulus p parameter, thus it is unnecessary to perform these checks if q is larger than p.  An application that calls DH_check() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  The function DH_check() is itself called by a number of other OpenSSL functions. An application calling any of those other functions may similarly be affected. The other functions affected by this are DH_check_ex() and EVP_PKEY_param_check().  Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications when using the \"-check\" option.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28321",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u9",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An improper certificate validation vulnerability exists in curl <v8.1.0 in the way it supports matching of wildcard patterns when listed as \"Subject Alternative Name\" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28321",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u9",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An improper certificate validation vulnerability exists in curl <v8.1.0 in the way it supports matching of wildcard patterns when listed as \"Subject Alternative Name\" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-40745",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF is vulnerable to an integer overflow. This flaw allows remote attackers to cause a denial of service (application crash) or possibly execute an arbitrary code via a crafted tiff image, which triggers a heap-based buffer overflow.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-41175",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libtiff due to multiple potential integer overflows in raw2tiff.c. This flaw allows remote attackers to cause a denial of service or possibly execute an arbitrary code via a crafted tiff image, which triggers a heap-based buffer overflow.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-32324",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "OpenPrinting CUPS is an open source printing system. In versions 2.4.2 and prior, a heap buffer overflow vulnerability would allow a remote attacker to launch a denial of service (DoS) attack. A buffer overflow vulnerability in the function `format_log_line` could allow remote attackers to cause a DoS on the affected system. Exploitation of the vulnerability can be triggered when the configuration file `cupsd.conf` sets the value of `loglevel `to `DEBUG`. No known patches or workarounds exist at time of publication.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-7008",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-7008",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-7008",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-7008",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-7008",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-17740",
      "package_name": "libldap-2.4-2",
      "installed_version": "2.4.57+dfsg-3+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45, when both the nops module and the memberof overlay are enabled, attempts to free a buffer that was allocated on the stack, which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28484",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In libxml2 before 2.10.4, parsing of certain invalid XSD schemas can lead to a NULL pointer dereference and subsequently a segfault. This occurs in xmlSchemaFixupComplexType in xmlschemas.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4304",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1n-0+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A timing based side channel exists in the OpenSSL RSA Decryption implementation which could be sufficient to recover a plaintext across a network in a Bleichenbacher style attack. To achieve a successful decryption an attacker would have to be able to send a very large number of trial messages for decryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5, RSA-OEAP and RSASVE.  For example, in a TLS connection, RSA is commonly used by a client to send an encrypted pre-master secret to the server. An attacker that had observed a genuine connection between a client and a server could use this flaw to send trial messages to the server and record the time taken to process them. After a sufficiently large number of messages the attacker could recover the pre-master secret used for the original connection and thus be able to decrypt the application data sent over that connection.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-34526",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A stack overflow was discovered in the _TIFFVGetField function of Tiffsplit v4.4.0. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted TIFF file parsed by the \"tiffsplit\" or \"tiffcrop\" utilities.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32907",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. The implementation of HTTP range requests is vulnerable to a resource consumption attack. This flaw allows a malicious client to request the same range many times in a single HTTP request, causing the server to use large amounts of memory. This does not allow for a full denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32907",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. The implementation of HTTP range requests is vulnerable to a resource consumption attack. This flaw allows a malicious client to request the same range many times in a single HTTP request, causing the server to use large amounts of memory. This does not allow for a full denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-0727",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL to crash leading to a potential Denial of Service attack  Impact summary: Applications loading files in the PKCS12 format from untrusted sources might terminate abruptly.  A file in PKCS12 format can contain certificates and keys and may come from an untrusted source. The PKCS12 specification allows certain fields to be NULL, but OpenSSL does not correctly check for this case. This can lead to a NULL pointer dereference that results in OpenSSL crashing. If an application processes PKCS12 files from an untrusted source using the OpenSSL APIs then that application will be vulnerable to this issue.  OpenSSL APIs that are vulnerable to this are: PKCS12_parse(), PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes() and PKCS12_newpass().  We have also fixed a similar issue in SMIME_write_PKCS7(). However since this function is related to writing data we do not consider it security significant.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3618",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libtiff. A specially crafted tiff file can lead to a segmentation fault due to a buffer overflow in the Fax3Encode function in libtiff/tif_fax3.c, resulting in a denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33600",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: Null pointer crashes after notfound response  If the Name Service Cache Daemon's (nscd) cache fails to add a not-found netgroup response to the cache, the client request can result in a null pointer dereference.  This flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33600",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: Null pointer crashes after notfound response  If the Name Service Cache Daemon's (nscd) cache fails to add a not-found netgroup response to the cache, the client request can result in a null pointer dereference.  This flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33600",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: Null pointer crashes after notfound response  If the Name Service Cache Daemon's (nscd) cache fails to add a not-found netgroup response to the cache, the client request can result in a null pointer dereference.  This flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33600",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: Null pointer crashes after notfound response  If the Name Service Cache Daemon's (nscd) cache fails to add a not-found netgroup response to the cache, the client request can result in a null pointer dereference.  This flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52616",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the Avahi-daemon, where it initializes DNS transaction IDs randomly only once at startup, incrementing them sequentially after that. This predictable behavior facilitates DNS spoofing attacks, allowing attackers to guess transaction IDs.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52616",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the Avahi-daemon, where it initializes DNS transaction IDs randomly only once at startup, incrementing them sequentially after that. This predictable behavior facilitates DNS spoofing attacks, allowing attackers to guess transaction IDs.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52616",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the Avahi-daemon, where it initializes DNS transaction IDs randomly only once at startup, incrementing them sequentially after that. This predictable behavior facilitates DNS spoofing attacks, allowing attackers to guess transaction IDs.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52615",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in Avahi-daemon, which relies on fixed source ports for wide-area DNS queries. This issue simplifies attacks where malicious DNS responses are injected.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52615",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in Avahi-daemon, which relies on fixed source ports for wide-area DNS queries. This issue simplifies attacks where malicious DNS responses are injected.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-52615",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in Avahi-daemon, which relies on fixed source ports for wide-area DNS queries. This issue simplifies attacks where malicious DNS responses are injected.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-7475",
      "package_name": "libcairo-gobject2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-7475",
      "package_name": "libcairo2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-4741",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Calling the OpenSSL API function SSL_free_buffers may cause memory to be accessed that was previously freed in some situations  Impact summary: A use after free can have a range of potential consequences such as the corruption of valid data, crashes or execution of arbitrary code. However, only applications that directly call the SSL_free_buffers function are affected by this issue. Applications that do not call this function are not vulnerable. Our investigations indicate that this function is rarely used by applications.  The SSL_free_buffers function is used to free the internal OpenSSL buffer used when processing an incoming record from the network. The call is only expected to succeed if the buffer is not currently in use. However, two scenarios have been identified where the buffer is freed even when still in use.  The first scenario occurs where a record header has been received from the network and processed by OpenSSL, but the full record body has not yet arrived. In this case calling SSL_free_buffers will succeed even though a record has only been partially processed and the buffer is still in use.  The second scenario occurs where a full record containing application data has been received and processed by OpenSSL but the application has only read part of this data. Again a call to SSL_free_buffers will succeed even though the buffer is still in use.  While these scenarios could occur accidentally during normal operation a malicious attacker could attempt to engineer a stituation where this occurs. We are not aware of this issue being actively exploited.  The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-46219",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When saving HSTS data to an excessively long file name, curl could end up removing all contents, making subsequent requests using that file unaware of the HSTS status they should otherwise use.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-46219",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When saving HSTS data to an excessively long file name, curl could end up removing all contents, making subsequent requests using that file unaware of the HSTS status they should otherwise use.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-26618",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "1:23.2.6+dfsg-1+deb11u2",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang is a programming language and runtime system for building massively scalable soft real-time systems with requirements on high availability. OTP is a set of Erlang libraries, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang. Packet size is not verified properly for SFTP packets. As a result when multiple SSH packets (conforming to max SSH packet size) are received by ssh, they might be combined into an SFTP packet which will exceed the max allowed packet size and potentially cause large amount of memory to be allocated. Note that situation described above can only happen for successfully authenticated users after completing the SSH handshake. This issue has been patched in OTP versions 27.2.4, 26.2.5.9, and 25.3.2.18. There are no known workarounds for this vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2520",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libtiff 4.4.0rc1. There is a sysmalloc assertion fail in rotateImage() at tiffcrop.c:8621 that can cause program crash when reading a crafted input.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46420",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. It is vulnerable to memory leaks in the soup_header_parse_quality_list() function when parsing a quality list that contains elements with all zeroes.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46420",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. It is vulnerable to memory leaks in the soup_header_parse_quality_list() function when parsing a quality list that contains elements with all zeroes.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-20796",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-20796",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-20796",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-20796",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\\227|)(\\\\1\\\\1|t1|\\\\\\2537)+' in grep.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2015-3276",
      "package_name": "libldap-2.4-2",
      "installed_version": "2.4.57+dfsg-3+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings, which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-16232",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-59375",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libexpat in Expat before 2.7.2 allows attackers to trigger large dynamic memory allocations via a small document that is submitted for parsing.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2005-2541",
      "package_name": "tar",
      "installed_version": "1.34+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2011-3374",
      "package_name": "apt",
      "installed_version": "2.2.4",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2011-3374",
      "package_name": "libapt-pkg6.0",
      "installed_version": "2.2.4",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2056",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Divide By Zero error in tiffcrop in libtiff 4.4.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit f3a5e010.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2057",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Divide By Zero error in tiffcrop in libtiff 4.4.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit f3a5e010.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2058",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Divide By Zero error in tiffcrop in libtiff 4.4.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit f3a5e010.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32052",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. A vulnerability in the sniff_unknown() function may lead to heap buffer over-read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32053",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. A vulnerability in sniff_feed_or_html() and skip_insignificant_space() functions may lead to a heap buffer over-read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32052",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. A vulnerability in the sniff_unknown() function may lead to heap buffer over-read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32053",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. A vulnerability in sniff_feed_or_html() and skip_insignificant_space() functions may lead to a heap buffer over-read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38546",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u10",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "This flaw allows an attacker to insert cookies at will into a running program using libcurl, if the specific series of conditions are met.  libcurl performs transfers. In its API, an application creates \"easy handles\" that are the individual handles for single transfers.  libcurl provides a function call that duplicates en easy handle called [curl_easy_duphandle](https://curl.se/libcurl/c/curl_easy_duphandle.html).  If a transfer has cookies enabled when the handle is duplicated, the cookie-enable state is also cloned - but without cloning the actual cookies. If the source handle did not read any cookies from a specific file on disk, the cloned version of the handle would instead store the file name as `none` (using the four ASCII letters, no quotes).  Subsequent use of the cloned handle that does not explicitly set a source to load cookies from would then inadvertently load cookies from a file named `none` - if such a file exists and is readable in the current directory of the program using libcurl. And if using the correct file format of course.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38546",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u10",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "This flaw allows an attacker to insert cookies at will into a running program using libcurl, if the specific series of conditions are met.  libcurl performs transfers. In its API, an application creates \"easy handles\" that are the individual handles for single transfers.  libcurl provides a function call that duplicates en easy handle called [curl_easy_duphandle](https://curl.se/libcurl/c/curl_easy_duphandle.html).  If a transfer has cookies enabled when the handle is duplicated, the cookie-enable state is also cloned - but without cloning the actual cookies. If the source handle did not read any cookies from a specific file on disk, the cloned version of the handle would instead store the file name as `none` (using the four ASCII letters, no quotes).  Subsequent use of the cloned handle that does not explicitly set a source to load cookies from would then inadvertently load cookies from a file named `none` - if such a file exists and is readable in the current directory of the program using libcurl. And if using the correct file format of course.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2519",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "There is a double free or corruption in rotateImage() at tiffcrop.c:8839 found in libtiff 4.4.0rc1",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2521",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "It was found in libtiff 4.4.0rc1 that there is an invalid pointer free operation in TIFFClose() at tif_close.c:131 called by tiffcrop.c:2522 that can cause a program crash and denial of service while processing crafted input.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6297",
      "package_name": "dpkg",
      "installed_version": "1.20.12",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "It was discovered that dpkg-deb does not properly sanitize directory permissions when extracting a control member into a temporary directory, which is documented as being a safe operation even on untrusted data. This may result in leaving temporary files behind on cleanup. Given automated and repeated execution of dpkg-deb commands on adversarial .deb packages or with well compressible files, placed inside a directory with permissions not allowing removal by a non-root user, this can end up in a DoS scenario due to causing disk quota exhaustion or disk full conditions.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-3709",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Possible cross-site scripting vulnerability in libxml after commit 960f0e2.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-5678",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: Generating excessively long X9.42 DH keys or checking excessively long X9.42 DH keys or parameters may be very slow.  Impact summary: Applications that use the functions DH_generate_key() to generate an X9.42 DH key may experience long delays.  Likewise, applications that use DH_check_pub_key(), DH_check_pub_key_ex() or EVP_PKEY_public_check() to check an X9.42 DH key or X9.42 DH parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service.  While DH_check() performs all the necessary checks (as of CVE-2023-3817), DH_check_pub_key() doesn't make any of these checks, and is therefore vulnerable for excessively large P and Q parameters.  Likewise, while DH_generate_key() performs a check for an excessively large P, it doesn't check for an excessively large Q.  An application that calls DH_generate_key() or DH_check_pub_key() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack.  DH_generate_key() and DH_check_pub_key() are also called by a number of other OpenSSL functions.  An application calling any of those other functions may similarly be affected.  The other functions affected by this are DH_check_pub_key_ex(), EVP_PKEY_public_check(), and EVP_PKEY_generate().  Also vulnerable are the OpenSSL pkey command line application when using the \"-pubcheck\" option, as well as the OpenSSL genpkey command line application.  The OpenSSL SSL/TLS implementation is not affected by this issue.  The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32050",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. The libsoup append_param_quoted() function may contain an overflow bug resulting in a buffer under-read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32050",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. The libsoup append_param_quoted() function may contain an overflow bug resulting in a buffer under-read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-50602",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "2.2.10-2+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in libexpat before 2.6.4. There is a crash within the XML_ResumeParser function because XML_StopParser can stop/suspend an unstarted parser.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9086",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "1. A cookie is set using the `secure` keyword for `https://target` 2. curl is redirected to or otherwise made to speak with `http://target` (same    hostname, but using clear text HTTP) using the same cookie set 3. The same cookie name is set - but with just a slash as path (`path='/'`).    Since this site is not secure, the cookie *should* just be ignored. 4. A bug in the path comparison logic makes curl read outside a heap buffer    boundary  The bug either causes a crash or it potentially makes the comparison come to the wrong conclusion and lets the clear-text site override the contents of the secure cookie, contrary to expectations and depending on the memory contents immediately following the single-byte allocation that holds the path.  The presumed and correct behavior would be to plainly ignore the second set of the cookie since it was already set as secure on a secure host so overriding it on an insecure host should not be okay.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9086",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "1. A cookie is set using the `secure` keyword for `https://target` 2. curl is redirected to or otherwise made to speak with `http://target` (same    hostname, but using clear text HTTP) using the same cookie set 3. The same cookie name is set - but with just a slash as path (`path='/'`).    Since this site is not secure, the cookie *should* just be ignored. 4. A bug in the path comparison logic makes curl read outside a heap buffer    boundary  The bug either causes a crash or it potentially makes the comparison come to the wrong conclusion and lets the clear-text site override the contents of the secure cookie, contrary to expectations and depending on the memory contents immediately following the single-byte allocation that holds the path.  The presumed and correct behavior would be to plainly ignore the second set of the cookie since it was already set as secure on a secure host so overriding it on an insecure host should not be okay.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4969",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the libsoup package. This flaw stems from its failure to correctly verify the termination of multipart HTTP messages. This can allow a remote attacker to send a specially crafted multipart HTTP body, causing the libsoup-consuming server to read beyond its allocated memory boundaries (out-of-bounds read).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4969",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the libsoup package. This flaw stems from its failure to correctly verify the termination of multipart HTTP messages. This can allow a remote attacker to send a specially crafted multipart HTTP body, causing the libsoup-consuming server to read beyond its allocated memory boundaries (out-of-bounds read).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-39615",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Xmlsoft Libxml2 v2.11.0 was discovered to contain an out-of-bounds read via the xmlSAX2StartElement() function at /libxml2/SAX2.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via supplying a crafted XML file. NOTE: the vendor's position is that the product does not support the legacy SAX1 interface with custom callbacks; there is a crash even without crafted input.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-43552",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A use after free vulnerability exists in curl <7.87.0. Curl can be asked to *tunnel* virtually all protocols it supports through an HTTP proxy. HTTP proxies can (and often do) deny such tunnel operations. When getting denied to tunnel the specific protocols SMB or TELNET, curl would use a heap-allocated struct after it had been freed, in its transfer shutdown code path.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-43552",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A use after free vulnerability exists in curl <7.87.0. Curl can be asked to *tunnel* virtually all protocols it supports through an HTTP proxy. HTTP proxies can (and often do) deny such tunnel operations. When getting denied to tunnel the specific protocols SMB or TELNET, curl would use a heap-allocated struct after it had been freed, in its transfer shutdown code path.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33601",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache may terminate daemon on memory allocation failure  The Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or xrealloc and these functions may terminate the process due to a memory allocation failure resulting in a denial of service to the clients.  The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33601",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache may terminate daemon on memory allocation failure  The Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or xrealloc and these functions may terminate the process due to a memory allocation failure resulting in a denial of service to the clients.  The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33601",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache may terminate daemon on memory allocation failure  The Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or xrealloc and these functions may terminate the process due to a memory allocation failure resulting in a denial of service to the clients.  The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-33601",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "2.31-13+deb11u10",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "nscd: netgroup cache may terminate daemon on memory allocation failure  The Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or xrealloc and these functions may terminate the process due to a memory allocation failure resulting in a denial of service to the clients.  The flaw was introduced in glibc 2.15 when the cache was added to nscd.  This vulnerability is only present in the nscd binary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-13176",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: A timing side-channel which could potentially allow recovering the private key exists in the ECDSA signature computation.  Impact summary: A timing side-channel in ECDSA signature computations could allow recovering the private key by an attacker. However, measuring the timing would require either local access to the signing application or a very fast network connection with low latency.  There is a timing signal of around 300 nanoseconds when the top word of the inverted ECDSA nonce value is zero. This can happen with significant probability only for some of the supported elliptic curves. In particular the NIST P-521 curve is affected. To be able to measure this leak, the attacker process must either be located in the same physical computer or must have a very fast network connection with low latency. For that reason the severity of this vulnerability is Low.  The FIPS modules in 3.4, 3.3, 3.2, 3.1 and 3.0 are affected by this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4373",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GLib, which is vulnerable to an integer overflow in the g_string_insert_unichar() function. When the position at which to insert the character is large, the position will overflow, leading to a buffer underwrite.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43785",
      "package_name": "libx11-6",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libX11 due to a boundary condition within the _XkbReadKeySyms() function. This flaw allows a local user to trigger an out-of-bounds read error and read the contents of memory on the system.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43785",
      "package_name": "libx11-data",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libX11 due to a boundary condition within the _XkbReadKeySyms() function. This flaw allows a local user to trigger an out-of-bounds read error and read the contents of memory on the system.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43785",
      "package_name": "libx11-xcb1",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libX11 due to a boundary condition within the _XkbReadKeySyms() function. This flaw allows a local user to trigger an out-of-bounds read error and read the contents of memory on the system.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-46822",
      "package_name": "libjpeg62-turbo",
      "installed_version": "1:2.0.6-4",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow in the get_word_rgb_row function in rdppm.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1622",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF master branch has an out-of-bounds read in LZWDecode in libtiff/tif_lzw.c:619, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit b4e79bfa.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-34397",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "2.66.8-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in GNOME GLib before 2.78.5, and 2.79.x and 2.80.x before 2.80.1. When a GDBus-based client subscribes to signals from a trusted system service such as NetworkManager on a shared computer, other users of the same computer can send spoofed D-Bus signals that the GDBus-based client will wrongly interpret as having been sent by the trusted system service. This could lead to the GDBus-based client behaving incorrectly, with an application-dependent impact.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1623",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF master branch has an out-of-bounds read in LZWDecode in libtiff/tif_lzw.c:624, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit b4e79bfa.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2014-8166",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The browsing feature in the server in CUPS does not filter ANSI escape sequences from shared printer names, which might allow remote attackers to execute arbitrary code via a crafted printer name.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-58364",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u10",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "OpenPrinting CUPS is an open source printing system for Linux and other Unix-like operating systems. In versions 2.4.12 and earlier, an unsafe deserialization and validation of printer attributes causes null dereference in the libcups library. This is a remote DoS vulnerability available in local subnet in default configurations. It can cause the cups & cups-browsed to crash, on all the machines in local network who are listening for printers (so by default for all regular linux machines). On systems where the vulnerability CVE-2024-47176 (cups-filters 1.x/cups-browsed 2.x vulnerability) was not fixed, and the firewall on the machine does not reject incoming communication to IPP port, and the machine is set to be available to public internet, attack vector \"Network\" is possible. The current versions of CUPS and cups-browsed projects have the attack vector \"Adjacent\" in their default configurations. Version 2.4.13 contains a patch for CVE-2025-58364.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43786",
      "package_name": "libx11-6",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libX11 due to an infinite loop within the PutSubImage() function. This flaw allows a local user to consume all available system resources and cause a denial of service condition.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43786",
      "package_name": "libx11-data",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libX11 due to an infinite loop within the PutSubImage() function. This flaw allows a local user to consume all available system resources and cause a denial of service condition.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-43786",
      "package_name": "libx11-xcb1",
      "installed_version": "2:1.7.2-1",
      "fixed_version": "2:1.7.2-1+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libX11 due to an infinite loop within the PutSubImage() function. This flaw allows a local user to consume all available system resources and cause a denial of service condition.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6395",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A NULL pointer dereference flaw was found in the GnuTLS software in _gnutls_figure_common_ciphersuite().",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45322",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor's position is \"I don't think these issues are critical enough to warrant a CVE ID ... because an attacker typically can't control when memory allocations fail.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46421",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. When libsoup clients encounter an HTTP redirect, they mistakenly send the HTTP Authorization header to the new host that the redirection points to. This allows the new host to impersonate the user to the original host that issued the redirect.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46421",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. When libsoup clients encounter an HTTP redirect, they mistakenly send the HTTP Authorization header to the new host that the redirection points to. This allows the new host to impersonate the user to the original host that issued the redirect.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48041",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-33068",
      "package_name": "libharfbuzz0b",
      "installed_version": "2.7.4-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An integer overflow in the component hb-ot-shape-fallback.cc of Harfbuzz v4.3.0 allows attackers to cause a Denial of Service (DoS) via unspecified vectors.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27535",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication bypass vulnerability exists in libcurl <8.0.0 in the FTP connection reuse feature that can result in wrong credentials being used during subsequent transfers. Previously created connections are kept in a connection pool for reuse if they match the current setup. However, certain FTP settings such as CURLOPT_FTP_ACCOUNT, CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPT_FTP_SSL_CCC, and CURLOPT_USE_SSL were not included in the configuration match checks, causing them to match too easily. This could lead to libcurl using the wrong credentials when performing a transfer, potentially allowing unauthorized access to sensitive information.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27535",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication bypass vulnerability exists in libcurl <8.0.0 in the FTP connection reuse feature that can result in wrong credentials being used during subsequent transfers. Previously created connections are kept in a connection pool for reuse if they match the current setup. However, certain FTP settings such as CURLOPT_FTP_ACCOUNT, CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPT_FTP_SSL_CCC, and CURLOPT_USE_SSL were not included in the configuration match checks, causing them to match too easily. This could lead to libcurl using the wrong credentials when performing a transfer, potentially allowing unauthorized access to sensitive information.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-6461",
      "package_name": "libcairo-gobject2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-6462",
      "package_name": "libcairo-gobject2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-6461",
      "package_name": "libcairo2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-6462",
      "package_name": "libcairo2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48040",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled Resource Consumption vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Flooding. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-22365",
      "package_name": "libpam-modules",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-22365",
      "package_name": "libpam-modules-bin",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-22365",
      "package_name": "libpam-runtime",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-22365",
      "package_name": "libpam0g",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "1.4.0-9+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-39804",
      "package_name": "tar",
      "installed_version": "1.34+dfsg-1",
      "fixed_version": "1.34+dfsg-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In GNU tar before 1.35, mishandled extension attributes in a PAX archive can lead to an application crash in xheader.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28757",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9901",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup\u2019s caching mechanism, SoupCache, where the HTTP Vary header is ignored when evaluating cached responses. This header ensures that responses vary appropriately based on request headers such as language or authentication. Without this check, cached content can be incorrectly reused across different requests, potentially exposing sensitive user information. While the issue is unlikely to affect everyday desktop use, it could result in confidentiality breaches in proxy or multi-user environments.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9901",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup\u2019s caching mechanism, SoupCache, where the HTTP Vary header is ignored when evaluating cached responses. This header ensures that responses vary appropriately based on request headers such as language or authentication. Without this check, cached content can be incorrectly reused across different requests, potentially exposing sensitive user information. While the issue is unlikely to affect everyday desktop use, it could result in confidentiality breaches in proxy or multi-user environments.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010023",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010023",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010023",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010023",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-23916",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An allocation of resources without limits or throttling vulnerability exists in curl <v7.88.0 based on the \"chained\" HTTP compression algorithms, meaning that a server response can be compressed multiple times and potentially with differentalgorithms. The number of acceptable \"links\" in this \"decompression chain\" wascapped, but the cap was implemented on a per-header basis allowing a maliciousserver to insert a virtually unlimited number of compression steps simply byusing many headers. The use of such a decompression chain could result in a \"malloc bomb\", making curl end up spending enormous amounts of allocated heap memory, or trying to and returning out of memory errors.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-23916",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An allocation of resources without limits or throttling vulnerability exists in curl <v7.88.0 based on the \"chained\" HTTP compression algorithms, meaning that a server response can be compressed multiple times and potentially with differentalgorithms. The number of acceptable \"links\" in this \"decompression chain\" wascapped, but the cap was implemented on a per-header basis allowing a maliciousserver to insert a virtually unlimited number of compression steps simply byusing many headers. The use of such a decompression chain could result in a \"malloc bomb\", making curl end up spending enormous amounts of allocated heap memory, or trying to and returning out of memory errors.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32909",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. SoupContentSniffer may be vulnerable to a NULL pointer dereference in the sniff_mp4 function. The HTTP server may cause the libsoup client to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32909",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. SoupContentSniffer may be vulnerable to a NULL pointer dereference in the sniff_mp4 function. The HTTP server may cause the libsoup client to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28320",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A denial of service vulnerability exists in curl <v8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-28320",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A denial of service vulnerability exists in curl <v8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29469",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in libxml2 before 2.10.4. When hashing empty dict strings in a crafted XML document, xmlDictComputeFastKey in dict.c can produce non-deterministic values, leading to various logic and memory errors, such as a double free. This behavior occurs because there is an attempt to use the first byte of an empty string, and any value is possible (not solely the '\\0' value).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-23915",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality to behave incorrectly when multiple URLs are requested in parallel. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. This HSTS mechanism would however surprisingly fail when multiple transfers are done in parallel as the HSTS cache file gets overwritten by the most recentlycompleted transfer. A later HTTP-only transfer to the earlier host name would then *not* get upgraded properly to HSTS.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-23915",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality to behave incorrectly when multiple URLs are requested in parallel. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. This HSTS mechanism would however surprisingly fail when multiple transfers are done in parallel as the HSTS cache file gets overwritten by the most recentlycompleted transfer. A later HTTP-only transfer to the earlier host name would then *not* get upgraded properly to HSTS.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48038",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-48039",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Allocation of Resources Without Limits or Throttling vulnerability in Erlang OTP ssh (ssh_sftp modules) allows Excessive Allocation, Resource Leak Exposure. This vulnerability is associated with program files lib/ssh/src/ssh_sftpd.erl.  This issue affects OTP form OTP 17.0 until OTP 28.0.3, OTP 27.3.4.3 and 26.2.5.15 corresponding to ssh from 3.0.1 until 5.3.3, 5.2.11.3 and 5.1.4.12.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-7039",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in glib. An integer overflow during temporary file creation leads to an out-of-bounds memory access, allowing an attacker to potentially perform path traversal or access private temporary file content by creating symbolic links. This vulnerability allows a local attacker to manipulate file paths and access unauthorized data. The core issue stems from insufficient validation of file path lengths during temporary file operations.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-7246",
      "package_name": "libpcre3",
      "installed_version": "2:8.39-13",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-32665",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "2.66.8-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50495",
      "package_name": "libncurses6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50495",
      "package_name": "libncursesw6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50495",
      "package_name": "libtinfo6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50495",
      "package_name": "ncurses-base",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-50495",
      "package_name": "ncurses-bin",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31486",
      "package_name": "perl-base",
      "installed_version": "5.32.1-4+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3626",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemset in libtiff/tif_unix.c:340 when called from processCropSelections, tools/tiffcrop.c:7619, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 236b7191.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3599",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in writeSingleSection in tools/tiffcrop.c:7345, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit e8131125.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-0725",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When libcurl is asked to perform automatic gzip decompression of content-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` option, **using zlib 1.2.0.3 or older**, an attacker-controlled integer overflow would make libcurl perform a buffer overflow.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-0725",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When libcurl is asked to perform automatic gzip decompression of content-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` option, **using zlib 1.2.0.3 or older**, an attacker-controlled integer overflow would make libcurl perform a buffer overflow.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-6829",
      "package_name": "libgcrypt20",
      "installed_version": "1.8.7-6",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1000107",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "inets in Erlang possibly 22.1 and earlier follows RFC 3875 section 4.1.18 and therefore does not protect applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect an application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-18064",
      "package_name": "libcairo-gobject2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-18064",
      "package_name": "libcairo2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-30086",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Buffer Overflow vulnerability found in Libtiff V.4.0.7 allows a local attacker to cause a denial of service via the tiffcp function in tiffcp.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-3576",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types, an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-3576",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types, an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-3576",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types, an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-3576",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types, an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32910",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup, where soup_auth_digest_authenticate() is vulnerable to a NULL pointer dereference. This issue may cause the libsoup client to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32912",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup, where SoupAuthDigest is vulnerable to a NULL pointer dereference. The HTTP server may cause the libsoup client to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32910",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup, where soup_auth_digest_authenticate() is vulnerable to a NULL pointer dereference. This issue may cause the libsoup client to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-32912",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "2.72.0-2+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup, where SoupAuthDigest is vulnerable to a NULL pointer dereference. The HTTP server may cause the libsoup client to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2012-0039",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4748",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') vulnerability in Erlang OTP (stdlib modules) allows Absolute Path Traversal, File Manipulation. This vulnerability is associated with program files lib/stdlib/src/zip.erl and program routines zip:unzip/1, zip:unzip/2, zip:extract/1, zip:extract/2\u00a0unless the memory option is passed.  This issue affects OTP from OTP 17.0 until OTP\u00a028.0.1, OTP\u00a027.3.4.1 and OTP\u00a026.2.5.13, corresponding to stdlib from 2.0 until 7.0.1, 6.2.2.1 and 5.2.3.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2012-2663",
      "package_name": "libip4tc2",
      "installed_version": "1.8.7-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "extensions/libxt_tcp.c in iptables through 1.4.21 does not match TCP SYN+FIN packets in --syn rules, which might allow remote attackers to bypass intended firewall restrictions via crafted packets.  NOTE: the CVE-2012-6638 fix makes this issue less relevant.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-5709",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-5709",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-5709",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-5709",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3598",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in extractContigSamplesShifted24bits in tools/tiffcrop.c:3604, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit cfbb883b.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2018-10126",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "ijg-libjpeg before 9d, as used in tiff2pdf (from LibTIFF) and other products, does not check for a NULL pointer at a certain place in jpeg_fdct_16x16 in jfdctint.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1354",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A heap buffer overflow flaw was found in Libtiffs' tiffinfo.c in TIFFReadRawDataStriped() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffinfo tool, triggering a heap buffer overflow issue and causing a crash that leads to a denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1355",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-7245",
      "package_name": "libpcre3",
      "installed_version": "2:8.39-13",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-6129",
      "package_name": "libpng16-16",
      "installed_version": "1.6.37-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "png_create_info_struct in png.c in libpng 1.6.36 has a memory leak, as demonstrated by pngcp. NOTE: a third party has stated \"I don't think it is libpng's job to free this buffer.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-32360",
      "package_name": "libcups2",
      "installed_version": "2.3.3op2-3+deb11u2",
      "fixed_version": "2.3.3op2-3+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication issue was addressed with improved state management. This issue is fixed in macOS Big Sur 11.7.7, macOS Monterey 12.6.6, macOS Ventura 13.4. An unauthenticated user may be able to access recently printed documents.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-3360",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "2.66.8-1+deb11u6",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GLib. An integer overflow and buffer under-read occur when parsing a long invalid ISO 8601 timestamp with the g_date_time_new_from_iso8601() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3597",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346 when called from extractImageSection, tools/tiffcrop.c:6826, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 236b7191.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-2781",
      "package_name": "coreutils",
      "installed_version": "8.32-4+b1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9230",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "1.1.1w-0+deb11u4",
      "severity": "HIGH",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Issue summary: An application trying to decrypt CMS messages encrypted using password based encryption can trigger an out-of-bounds read and write.  Impact summary: This out-of-bounds read may trigger a crash which leads to Denial of Service for an application. The out-of-bounds write can cause a memory corruption which can have various consequences including a Denial of Service or Execution of attacker-supplied code.  Although the consequences of a successful exploit of this vulnerability could be severe, the probability that the attacker would be able to perform it is low. Besides, password based (PWRI) encryption support in CMS messages is very rarely used. For that reason the issue was assessed as Moderate severity according to our Security Policy.  The FIPS modules in 3.5, 3.4, 3.3, 3.2, 3.1 and 3.0 are not affected by this issue, as the CMS implementation is outside the OpenSSL FIPS module boundary.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010024",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010024",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010024",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010024",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2010-4756",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2010-4756",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2010-4756",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2010-4756",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-48303",
      "package_name": "tar",
      "installed_version": "1.34+dfsg-1",
      "fixed_version": "1.34+dfsg-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Tar through 1.34 has a one-byte out-of-bounds read that results in use of uninitialized memory for a conditional jump. Exploitation to change the flow of control has not been demonstrated. The issue occurs in from_header in list.c via a V7 archive in which mtime has approximately 11 whitespace characters.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-32611",
      "package_name": "libglib2.0-0",
      "installed_version": "2.66.8-1",
      "fixed_version": "2.66.8-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to a slowdown issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1390",
      "package_name": "libcap2",
      "installed_version": "1:2.44-1",
      "fixed_version": "1:2.44-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The PAM module pam_cap.so of libcap configuration supports group names starting with \u201c@\u201d, during actual parsing, configurations not starting with \u201c@\u201d are incorrectly recognized as group names. This may result in nonintended users being granted an inherited capability set, potentially leading to security risks. Attackers can exploit this vulnerability to achieve local privilege escalation on systems where /etc/security/capability.conf is used to configure user inherited privileges by constructing specific usernames.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-9937",
      "package_name": "libjbig0",
      "installed_version": "2.1-3.1+b2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In LibTIFF 4.0.8, there is a memory malloc failure in tif_jbig.c. A crafted TIFF document can lead to an abort resulting in a remote denial of service attack.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-9192",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-9192",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-9192",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-9192",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\\\1\\\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-25435",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libtiff 4.5.0 is vulnerable to Buffer Overflow via extractContigSamplesShifted8bits() at /libtiff/tools/tiffcrop.c:3753.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-10041",
      "package_name": "libpam-modules",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-10041",
      "package_name": "libpam-modules-bin",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-10041",
      "package_name": "libpam-runtime",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-10041",
      "package_name": "libpam0g",
      "installed_version": "1.4.0-9+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-31782",
      "package_name": "libfreetype6",
      "installed_version": "2.10.4+dfsg-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "ftbench.c in FreeType Demo Programs through 2.12.1 has a heap-based buffer overflow.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4476",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A denial-of-service vulnerability has been identified in the libsoup HTTP client library. This flaw can be triggered when a libsoup client receives a 401 (Unauthorized) HTTP response containing a specifically crafted domain parameter within the WWW-Authenticate header. Processing this malformed header can lead to a crash of the client application using libsoup. An attacker could exploit this by setting up a malicious HTTP server. If a user's application using the vulnerable libsoup library connects to this malicious server, it could result in a denial-of-service. Successful exploitation requires tricking a user's client application into connecting to the attacker's malicious server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4476",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A denial-of-service vulnerability has been identified in the libsoup HTTP client library. This flaw can be triggered when a libsoup client receives a 401 (Unauthorized) HTTP response containing a specifically crafted domain parameter within the WWW-Authenticate header. Processing this malformed header can lead to a crash of the client application using libsoup. An attacker could exploit this by setting up a malicious HTTP server. If a user's application using the vulnerable libsoup library connects to this malicious server, it could result in a denial-of-service. Successful exploitation requires tricking a user's client application into connecting to the attacker's malicious server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-20838",
      "package_name": "libpcre3",
      "installed_version": "2:8.39-13",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4415",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4415",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4415",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4415",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4415",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3821",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3821",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3821",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3821",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3821",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-11164",
      "package_name": "libpcre3",
      "installed_version": "2:8.39-13",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-25433",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-26966",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libtiff 4.5.0 is vulnerable to Buffer Overflow in uv_encode() when libtiff reads a corrupted little-endian TIFF file and specifies the output to be big-endian.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3576",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u5",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A memory leak flaw was found in Libtiff's tiffcrop utility. This issue occurs when tiffcrop operates on a TIFF image file, allowing an attacker to pass a crafted TIFF image file to tiffcrop utility, which causes this memory leak issue, resulting an application crash, eventually leading to a denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-3782",
      "package_name": "libwayland-client0",
      "installed_version": "1.18.0-2~exp1.1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-3782",
      "package_name": "libwayland-cursor0",
      "installed_version": "1.18.0-2~exp1.1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-3782",
      "package_name": "libwayland-egl1",
      "installed_version": "1.18.0-2~exp1.1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2867",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libtiff's tiffcrop utility has a uint32_t underflow that can lead to out of bounds read and write. An attacker who supplies a crafted file to tiffcrop (likely via tricking a user to run tiffcrop on it with certain parameters) could cause a crash or in some cases, further exploitation.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2869",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libtiff's tiffcrop tool has a uint32_t underflow which leads to out of bounds read and write in the extractContigSamples8bits routine. An attacker who supplies a crafted file to tiffcrop could trigger this flaw, most likely by tricking a user into opening the crafted file with tiffcrop. Triggering this flaw could cause a crash or potentially further exploitation.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4598",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-coredump. This flaw allows an attacker to force a SUID process to crash and replace it with a non-SUID binary to access the original's privileged process coredump, allowing the attacker to read sensitive data, such as /etc/shadow content, loaded by the original process.  A SUID binary or process has a special type of permission, which allows the process to run with the file owner's permissions, regardless of the user executing the binary. This allows the process to access more restricted data than unprivileged users or processes would be able to. An attacker can leverage this flaw by forcing a SUID process to crash and force the Linux kernel to recycle the process PID before systemd-coredump can analyze the /proc/pid/auxv file. If the attacker wins the race condition, they gain access to the original's SUID process coredump file. They can read sensitive content loaded into memory by the original binary, affecting data confidentiality.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4598",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-coredump. This flaw allows an attacker to force a SUID process to crash and replace it with a non-SUID binary to access the original's privileged process coredump, allowing the attacker to read sensitive data, such as /etc/shadow content, loaded by the original process.  A SUID binary or process has a special type of permission, which allows the process to run with the file owner's permissions, regardless of the user executing the binary. This allows the process to access more restricted data than unprivileged users or processes would be able to. An attacker can leverage this flaw by forcing a SUID process to crash and force the Linux kernel to recycle the process PID before systemd-coredump can analyze the /proc/pid/auxv file. If the attacker wins the race condition, they gain access to the original's SUID process coredump file. They can read sensitive content loaded into memory by the original binary, affecting data confidentiality.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4598",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-coredump. This flaw allows an attacker to force a SUID process to crash and replace it with a non-SUID binary to access the original's privileged process coredump, allowing the attacker to read sensitive data, such as /etc/shadow content, loaded by the original process.  A SUID binary or process has a special type of permission, which allows the process to run with the file owner's permissions, regardless of the user executing the binary. This allows the process to access more restricted data than unprivileged users or processes would be able to. An attacker can leverage this flaw by forcing a SUID process to crash and force the Linux kernel to recycle the process PID before systemd-coredump can analyze the /proc/pid/auxv file. If the attacker wins the race condition, they gain access to the original's SUID process coredump file. They can read sensitive content loaded into memory by the original binary, affecting data confidentiality.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4598",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-coredump. This flaw allows an attacker to force a SUID process to crash and replace it with a non-SUID binary to access the original's privileged process coredump, allowing the attacker to read sensitive data, such as /etc/shadow content, loaded by the original process.  A SUID binary or process has a special type of permission, which allows the process to run with the file owner's permissions, regardless of the user executing the binary. This allows the process to access more restricted data than unprivileged users or processes would be able to. An attacker can leverage this flaw by forcing a SUID process to crash and force the Linux kernel to recycle the process PID before systemd-coredump can analyze the /proc/pid/auxv file. If the attacker wins the race condition, they gain access to the original's SUID process coredump file. They can read sensitive content loaded into memory by the original binary, affecting data confidentiality.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4598",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "247.3-7+deb11u7",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in systemd-coredump. This flaw allows an attacker to force a SUID process to crash and replace it with a non-SUID binary to access the original's privileged process coredump, allowing the attacker to read sensitive data, such as /etc/shadow content, loaded by the original process.  A SUID binary or process has a special type of permission, which allows the process to run with the file owner's permissions, regardless of the user executing the binary. This allows the process to access more restricted data than unprivileged users or processes would be able to. An attacker can leverage this flaw by forcing a SUID process to crash and force the Linux kernel to recycle the process PID before systemd-coredump can analyze the /proc/pid/auxv file. If the attacker wins the race condition, they gain access to the original's SUID process coredump file. They can read sensitive content loaded into memory by the original binary, affecting data confidentiality.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4035",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. When handling cookies, libsoup clients mistakenly allow cookies to be set for public suffix domains if the domain contains at least two components and includes an uppercase character. This bypasses public suffix protections and could allow a malicious website to set cookies for domains it does not own, potentially leading to integrity issues such as session fixation.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4035",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in libsoup. When handling cookies, libsoup clients mistakenly allow cookies to be set for public suffix domains if the domain contains at least two components and includes an uppercase character. This bypasses public suffix protections and could allow a malicious website to set cookies for domains it does not own, potentially leading to integrity issues such as session fixation.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3627",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346 when called from extractImageSection, tools/tiffcrop.c:6860, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 236b7191.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3316",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A NULL pointer dereference in TIFFClose() is caused by a failure to open an output file (non-existent path or a path that requires permissions like /dev/null) while specifying zones.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2868",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libtiff's tiffcrop utility has a improper input validation flaw that can lead to out of bounds read and ultimately cause a crash if an attacker is able to supply a crafted file to tiffcrop.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-2953",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-45346",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A Memory Leak vulnerability exists in SQLite Project SQLite3 3.35.1 and 3.37.0 via maliciously crafted SQL Queries (made via editing the Database File), it is possible to query a record, and leak subsequent bytes of memory that extend beyond the record, which could let a malicious user obtain sensitive information. NOTE: The developer disputes this as a vulnerability stating that If you give SQLite a corrupted database file and submit a query against the database, it might read parts of the database that you did not intend or expect.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-46712",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Erlang/OTP is a set of libraries for the Erlang programming language. In versions prior to OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25), Erlang/OTP SSH fails to enforce strict KEX handshake hardening measures by allowing optional messages to be exchanged. This allows a Man-in-the-Middle attacker to inject these messages in a connection during the handshake. This issue has been patched in versions OTP-27.3.4 (for OTP-27), OTP-26.2.5.12 (for OTP-26), and OTP-25.3.2.21 (for OTP-25).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-4214",
      "package_name": "libpng16-16",
      "installed_version": "1.6.37-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0800",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3502, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 33aee127.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0801",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in libtiff/tif_unix.c:368, invoked by tools/tiffcrop.c:2903 and tools/tiffcrop.c:6778, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 33aee127.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0802",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3724, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 33aee127.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0803",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3516, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 33aee127.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-30774",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the libtiff library. This flaw causes a heap buffer overflow issue via the TIFFTAG_INKNAMES and TIFFTAG_NUMBEROFINKS values.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010025",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is \"ASLR bypass itself is not a vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010025",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is \"ASLR bypass itself is not a vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010025",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is \"ASLR bypass itself is not a vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010025",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is \"ASLR bypass itself is not a vulnerability.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2236",
      "package_name": "libgcrypt20",
      "installed_version": "1.8.7-6",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack, which can lead to the decryption of RSA ciphertexts.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9714",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u9",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Uncontrolled recursion in\u00a0XPath evaluation\u00a0in libxml2 up to and including version 2.9.14 allows a local attacker to cause a stack overflow via crafted expressions. XPath processing functions `xmlXPathRunEval`, `xmlXPathCtxtCompile`, and `xmlXPathEvalExpr` were resetting recursion depth to zero before making potentially recursive calls. When such functions were called recursively this could allow for uncontrolled recursion and lead to a stack overflow. These functions now preserve recursion depth across recursive calls, allowing recursion depth to be controlled.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-30258",
      "package_name": "gpgv",
      "installed_version": "2.2.27-2+deb11u2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In GnuPG before 2.5.5, if a user chooses to import a certificate with certain crafted subkey data that lacks a valid backsig or that has incorrect usage flags, the user loses the ability to verify signatures made from certain other signing keys, aka a \"verification DoS.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26458",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26458",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26458",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26458",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2007-5686",
      "package_name": "login",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2007-5686",
      "package_name": "passwd",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2379",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-2379",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2011-4116",
      "package_name": "perl-base",
      "installed_version": "5.32.1-4+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4945",
      "package_name": "libsoup-gnome2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the cookie parsing logic of the libsoup HTTP library, used in GNOME applications and other software. The vulnerability arises when processing the expiration date of cookies, where a specially crafted value can trigger an integer overflow. This may result in undefined behavior, allowing an attacker to bypass cookie expiration logic, causing persistent or unintended cookie behavior. The issue stems from improper validation of large integer inputs during date arithmetic operations within the cookie parsing routines.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-4945",
      "package_name": "libsoup2.4-1",
      "installed_version": "2.72.0-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the cookie parsing logic of the libsoup HTTP library, used in GNOME applications and other software. The vulnerability arises when processing the expiration date of cookies, where a specially crafted value can trigger an integer overflow. This may result in undefined behavior, allowing an attacker to bypass cookie expiration logic, causing persistent or unintended cookie behavior. The issue stems from improper validation of large integer inputs during date arithmetic operations within the cookie parsing routines.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-4645",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in tiffcp in tools/tiffcp.c:948, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit e8131125.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1352",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU elfutils 0.192 and classified as critical. This vulnerability affects the function __libdw_thread_tail in the library libdw_alloc.c of the component eu-readelf. The manipulation of the argument w leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 2636426a091bd6c6f7f02e49ab20d4cdc6bfc753. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-29070",
      "package_name": "liblcms2-2",
      "installed_version": "2.12~rc1-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A heap buffer overflow vulnerability has been identified in thesmooth2() in cmsgamma.c in lcms2-2.16 which allows a remote attacker to cause a denial of service. NOTE: the Supplier disputes this because \"this is not exploitable as this function is never called on normal color management, is there only as a helper for low-level programming and investigation.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4039",
      "package_name": "gcc-10-base",
      "installed_version": "10.2.1-6",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4039",
      "package_name": "gcc-9-base",
      "installed_version": "9.3.0-22",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4039",
      "package_name": "libgcc-s1",
      "installed_version": "10.2.1-6",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4039",
      "package_name": "libstdc++6",
      "installed_version": "10.2.1-6",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains  that target AArch64 allows an attacker to exploit an existing buffer  overflow in dynamically-sized local variables in your application  without this being detected. This stack-protector failure only applies  to C99-style dynamically-sized local variables or those created using  alloca(). The stack-protector operates as intended for statically-sized  local variables.  The default behavior when the stack-protector  detects an overflow is to terminate your application, resulting in  controlled loss of availability. An attacker who can exploit a buffer  overflow without triggering the stack-protector might be able to change  program flow control to cause an uncontrolled loss of availability or to  go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-22922",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is instructed to download content using the metalink feature, thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs, potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload, curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done, and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-22922",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is instructed to download content using the metalink feature, thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs, potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload, curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done, and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0799",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3701, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-1981",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the avahi library. This flaw allows an unprivileged user to make a dbus call, causing the avahi daemon to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-1981",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the avahi library. This flaw allows an unprivileged user to make a dbus call, causing the avahi daemon to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-1981",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the avahi library. This flaw allows an unprivileged user to make a dbus call, causing the avahi daemon to crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0804",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3609, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 33aee127.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45931",
      "package_name": "libgl1-mesa-dri",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa 23.0.4 was discovered to contain a NULL pointer dereference in check_xshm() for the has_error state. NOTE: this is disputed because there is no scenario in which the vulnerability was demonstrated.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45931",
      "package_name": "libglapi-mesa",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa 23.0.4 was discovered to contain a NULL pointer dereference in check_xshm() for the has_error state. NOTE: this is disputed because there is no scenario in which the vulnerability was demonstrated.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45931",
      "package_name": "libglx-mesa0",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa 23.0.4 was discovered to contain a NULL pointer dereference in check_xshm() for the has_error state. NOTE: this is disputed because there is no scenario in which the vulnerability was demonstrated.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6170",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "2.9.10+dfsg-6.7+deb11u8",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the interactive shell of the xmllint command-line tool, used for parsing XML files. When a user inputs an overly long command, the program does not check the input size properly, which can cause it to crash. This issue might allow attackers to run harmful code in rare configurations without modern protections.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4641",
      "package_name": "login",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "1:4.8.1-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in shadow-utils. When asking for a new password, shadow-utils asks the password twice. If the password fails on the second attempt, shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4641",
      "package_name": "passwd",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "1:4.8.1-1+deb11u1",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in shadow-utils. When asking for a new password, shadow-utils asks the password twice. If the password fails on the second attempt, shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0795",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0796",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3592, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0797",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in libtiff/tif_unix.c:368, invoked by tools/tiffcrop.c:2903 and tools/tiffcrop.c:6921, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-0798",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u4",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3400, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-2908",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A null pointer dereference issue was found in Libtiff's tif_dir.c file. This issue may allow an attacker to pass a crafted TIFF image file to the tiffcp utility which triggers a runtime error that causes undefined behavior. This will result in an application crash, eventually leading to a denial of service.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6199",
      "package_name": "libgdk-pixbuf-2.0-0",
      "installed_version": "2.42.2+dfsg-1+deb11u1",
      "fixed_version": "2.42.2+dfsg-1+deb11u3",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the GIF parser of GdkPixbuf\u2019s LZW decoder. When an invalid symbol is encountered during decompression, the decoder sets the reported output size to the full buffer length rather than the actual number of written bytes. This logic error results in uninitialized sections of the buffer being included in the output, potentially leaking arbitrary memory contents in the processed image.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6199",
      "package_name": "libgdk-pixbuf2.0-common",
      "installed_version": "2.42.2+dfsg-1+deb11u1",
      "fixed_version": "2.42.2+dfsg-1+deb11u3",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the GIF parser of GdkPixbuf\u2019s LZW decoder. When an invalid symbol is encountered during decompression, the decoder sets the reported output size to the full buffer length rather than the actual number of written bytes. This logic error results in uninitialized sections of the buffer being included in the output, potentially leaking arbitrary memory contents in the processed image.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6141",
      "package_name": "libncurses6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU ncurses up to 6.5-20250322 and classified as problematic. This vulnerability affects the function postprocess_termcap of the file tinfo/parse_entry.c. The manipulation leads to stack-based buffer overflow. The attack needs to be approached locally. Upgrading to version 6.5-20250329 is able to address this issue. It is recommended to upgrade the affected component.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6141",
      "package_name": "libncursesw6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU ncurses up to 6.5-20250322 and classified as problematic. This vulnerability affects the function postprocess_termcap of the file tinfo/parse_entry.c. The manipulation leads to stack-based buffer overflow. The attack needs to be approached locally. Upgrading to version 6.5-20250329 is able to address this issue. It is recommended to upgrade the affected component.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6141",
      "package_name": "libtinfo6",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU ncurses up to 6.5-20250322 and classified as problematic. This vulnerability affects the function postprocess_termcap of the file tinfo/parse_entry.c. The manipulation leads to stack-based buffer overflow. The attack needs to be approached locally. Upgrading to version 6.5-20250329 is able to address this issue. It is recommended to upgrade the affected component.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6141",
      "package_name": "ncurses-base",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU ncurses up to 6.5-20250322 and classified as problematic. This vulnerability affects the function postprocess_termcap of the file tinfo/parse_entry.c. The manipulation leads to stack-based buffer overflow. The attack needs to be approached locally. Upgrading to version 6.5-20250329 is able to address this issue. It is recommended to upgrade the affected component.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-6141",
      "package_name": "ncurses-bin",
      "installed_version": "6.2+20201114-2",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU ncurses up to 6.5-20250322 and classified as problematic. This vulnerability affects the function postprocess_termcap of the file tinfo/parse_entry.c. The manipulation leads to stack-based buffer overflow. The attack needs to be approached locally. Upgrading to version 6.5-20250329 is able to address this issue. It is recommended to upgrade the affected component.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29383",
      "package_name": "login",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "1:4.8.1-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that \"cat /etc/passwd\" shows a rogue user account.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-29383",
      "package_name": "passwd",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "1:4.8.1-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that \"cat /etc/passwd\" shows a rogue user account.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010022",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010022",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010022",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2019-1010022",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate \"this is being treated as a non-security bug and no real threat.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27536",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication bypass vulnerability exists libcurl <8.0.0 in the connection reuse feature which can reuse previously established connections with incorrect user permissions due to a failure to check for changes in the CURLOPT_GSSAPI_DELEGATION option. This vulnerability affects krb5/kerberos/negotiate/GSSAPI transfers and could potentially result in unauthorized access to sensitive information. The safest option is to not reuse connections if the CURLOPT_GSSAPI_DELEGATION option has been changed.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27536",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication bypass vulnerability exists libcurl <8.0.0 in the connection reuse feature which can reuse previously established connections with incorrect user permissions due to a failure to check for changes in the CURLOPT_GSSAPI_DELEGATION option. This vulnerability affects krb5/kerberos/negotiate/GSSAPI transfers and could potentially result in unauthorized access to sensitive information. The safest option is to not reuse connections if the CURLOPT_GSSAPI_DELEGATION option has been changed.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-28835",
      "package_name": "libgnutls30",
      "installed_version": "3.7.1-5+deb11u2",
      "fixed_version": "3.7.1-5+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been discovered in GnuTLS where an application crash can be induced when attempting to verify a specially crafted .pem bundle using the \"certtool --verify-chain\" command.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-36087",
      "package_name": "libsepol1",
      "installed_version": "3.1-1",
      "fixed_version": "3.1-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-40090",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in function TIFFReadDirectory libtiff before 4.4.0 allows attackers to cause a denial of service via crafted TIFF file.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-13978",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u7",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in LibTIFF up to 4.7.0. It has been declared as problematic. Affected by this vulnerability is the function t2p_read_tiff_init of the file tools/tiff2pdf.c of the component fax2ps. The manipulation leads to null pointer dereference. The attack needs to be approached locally. The complexity of an attack is rather high. The exploitation appears to be difficult. The patch is named 2ebfffb0e8836bfb1cd7d85c059cd285c59761a4. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-15719",
      "package_name": "libldap-2.4-2",
      "installed_version": "2.4.57+dfsg-3+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31437",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31437",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31437",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31437",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31437",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45924",
      "package_name": "libgl1",
      "installed_version": "1.3.2-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libglxproto.c in OpenGL libglvnd bb06db5a was discovered to contain a segmentation violation via the function glXGetDrawableScreen(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45924",
      "package_name": "libglvnd0",
      "installed_version": "1.3.2-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libglxproto.c in OpenGL libglvnd bb06db5a was discovered to contain a segmentation violation via the function glXGetDrawableScreen(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45924",
      "package_name": "libglx0",
      "installed_version": "1.3.2-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libglxproto.c in OpenGL libglvnd bb06db5a was discovered to contain a segmentation violation via the function glXGetDrawableScreen(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-22923",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-22923",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-3468",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-3468",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-3468",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u2",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-36085",
      "package_name": "libsepol1",
      "installed_version": "3.1-1",
      "fixed_version": "3.1-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __verify_map_perm_classperms and hashtab_map).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-36086",
      "package_name": "libsepol1",
      "installed_version": "3.1-1",
      "fixed_version": "3.1-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-36084",
      "package_name": "libsepol1",
      "installed_version": "3.1-1",
      "fixed_version": "3.1-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-14159",
      "package_name": "libldap-2.4-2",
      "installed_version": "2.4.57+dfsg-3+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a \"kill `cat /pathname`\" command, as demonstrated by openldap-initscript.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-50422",
      "package_name": "libcairo-gobject2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Cairo through 1.18.4, as used in Poppler through 25.08.0, has an \"unscaled->face == NULL\" assertion failure for _cairo_ft_unscaled_font_fini in cairo-ft-font.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-50422",
      "package_name": "libcairo2",
      "installed_version": "1.16.0-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Cairo through 1.18.4, as used in Poppler through 25.08.0, has an \"unscaled->face == NULL\" assertion failure for _cairo_ft_unscaled_font_fini in cairo-ft-font.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8058",
      "package_name": "libc-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The regcomp function in the GNU C library version from 2.4 to 2.41 is  subject to a double free if some previous allocation fails. It can be  accomplished either by a malloc failure or by using an interposed malloc  that injects random malloc failures. The double free can allow buffer  manipulation depending of how the regex is constructed. This issue  affects all architectures and ABIs supported by the GNU C library.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8058",
      "package_name": "libc-dev-bin",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The regcomp function in the GNU C library version from 2.4 to 2.41 is  subject to a double free if some previous allocation fails. It can be  accomplished either by a malloc failure or by using an interposed malloc  that injects random malloc failures. The double free can allow buffer  manipulation depending of how the regex is constructed. This issue  affects all architectures and ABIs supported by the GNU C library.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8058",
      "package_name": "libc6",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The regcomp function in the GNU C library version from 2.4 to 2.41 is  subject to a double free if some previous allocation fails. It can be  accomplished either by a malloc failure or by using an interposed malloc  that injects random malloc failures. The double free can allow buffer  manipulation depending of how the regex is constructed. This issue  affects all architectures and ABIs supported by the GNU C library.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8058",
      "package_name": "libc6-dev",
      "installed_version": "2.31-13+deb11u5",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "The regcomp function in the GNU C library version from 2.4 to 2.41 is  subject to a double free if some previous allocation fails. It can be  accomplished either by a malloc failure or by using an interposed malloc  that injects random malloc failures. The double free can allow buffer  manipulation depending of how the regex is constructed. This issue  affects all architectures and ABIs supported by the GNU C library.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-52099",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Integer Overflow vulnerability in SQLite SQLite3 v.3.50.0 allows a remote attacker to cause a denial of service via the setupLookaside function",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3570",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Multiple heap buffer overflows in tiffcrop.c utility in libtiff library Version 4.4.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27538",
      "package_name": "libcurl4",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication bypass vulnerability exists in libcurl prior to v8.0.0 where it reuses a previously established SSH connection despite the fact that an SSH option was modified, which should have prevented reuse. libcurl maintains a pool of previously used connections to reuse them for subsequent transfers if the configurations match. However, two SSH settings were omitted from the configuration check, allowing them to match easily, potentially leading to the reuse of an inappropriate connection.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-27538",
      "package_name": "libcurl4-openssl-dev",
      "installed_version": "7.74.0-1.3+deb11u3",
      "fixed_version": "7.74.0-1.3+deb11u8",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An authentication bypass vulnerability exists in libcurl prior to v8.0.0 where it reuses a previously established SSH connection despite the fact that an SSH option was modified, which should have prevented reuse. libcurl maintains a pool of previously used connections to reuse them for subsequent transfers if the configurations match. However, two SSH settings were omitted from the configuration check, allowing them to match easily, potentially leading to the reuse of an inappropriate connection.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31438",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31438",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31438",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31438",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31438",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-16231",
      "package_name": "libpcre3",
      "installed_version": "2:8.39-13",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In PCRE 8.41, after compiling, a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report, noting that there are options that can be used to limit the amount of stack that is used",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38469",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi, where a reachable assertion exists in avahi_dns_packet_append_record.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38470",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_escape_label() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38472",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_rdata_parse() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38473",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_alternative_host_name() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38469",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi, where a reachable assertion exists in avahi_dns_packet_append_record.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38470",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_escape_label() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38472",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_rdata_parse() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38473",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_alternative_host_name() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38469",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi, where a reachable assertion exists in avahi_dns_packet_append_record.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38470",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_escape_label() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38472",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_rdata_parse() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38473",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_alternative_host_name() function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-26965",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u6",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "loadImage() in tools/tiffcrop.c in LibTIFF through 4.5.0 has a heap-based use after free via a crafted TIFF image.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-2602",
      "package_name": "libcap2",
      "installed_version": "1:2.44-1",
      "fixed_version": "1:2.44-1+deb11u1",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the pthread_create() function in libcap. This issue may allow a malicious actor to use cause __real_pthread_create() to return an error, which can exhaust the process memory.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31439",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31439",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31439",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31439",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-31439",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-42523",
      "package_name": "libcolord2",
      "installed_version": "1.4.5-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "There are two Information Disclosure vulnerabilities in colord, and they lie in colord/src/cd-device-db.c and colord/src/cd-profile-db.c separately. They exist because the 'err_msg' of 'sqlite3_exec' is not releasing after use, while libxml2 emphasizes that the caller needs to release it.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1377",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability, which was classified as problematic, has been found in GNU elfutils 0.192. This issue affects the function gelf_getsymshndx of the file strip.c of the component eu-strip. The manipulation leads to denial of service. The attack needs to be approached locally. The exploit has been disclosed to the public and may be used. The identifier of the patch is fbf1df9ca286de3323ae541973b08449f8d03aba. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4016",
      "package_name": "libprocps8",
      "installed_version": "2:3.3.17-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-4016",
      "package_name": "procps",
      "installed_version": "2:3.3.17-5",
      "fixed_version": "No fix available",
      "severity": "LOW",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26461",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26461",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26461",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-26461",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2016-1585",
      "package_name": "libapparmor1",
      "installed_version": "2.13.6-10",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In all versions of AppArmor mount rules are accidentally widened when compiled.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-40909",
      "package_name": "perl-base",
      "installed_version": "5.32.1-4+deb11u2",
      "fixed_version": "No fix available",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Perl threads have a working directory race condition where file operations may target unintended paths.  If a directory handle is open at thread creation, the process-wide current working directory is temporarily changed in order to clone\u00a0that handle for the new thread, which is visible from any third (or\u00a0more) thread already running.   This may lead to unintended operations\u00a0such as loading code or accessing files from unexpected locations,\u00a0which a local attacker may be able to exploit.  The bug was introduced in commit\u00a011a11ecf4bea72b17d250cfb43c897be1341861e and released in Perl version 5.13.6",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1056",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Out-of-bounds Read error in tiffcrop in libtiff 4.3.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 46dc8fcd.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38471",
      "package_name": "libavahi-client3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the dbus_set_host_name function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38471",
      "package_name": "libavahi-common-data",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the dbus_set_host_name function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-38471",
      "package_name": "libavahi-common3",
      "installed_version": "0.8-5+deb11u1",
      "fixed_version": "0.8-5+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the dbus_set_host_name function.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-48281",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "4.2.0-1+deb11u3",
      "severity": "MEDIUM",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "processCropSelections in tools/tiffcrop.c in LibTIFF through 4.5.0 has a heap-based buffer overflow (e.g., \"WRITE of size 307203\") via a crafted TIFF image.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45919",
      "package_name": "libgl1-mesa-dri",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa 23.0.4 was discovered to contain a buffer over-read in glXQueryServerString(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45919",
      "package_name": "libglapi-mesa",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa 23.0.4 was discovered to contain a buffer over-read in glXQueryServerString(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45919",
      "package_name": "libglx-mesa0",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa 23.0.4 was discovered to contain a buffer over-read in glXQueryServerString(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4235",
      "package_name": "login",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4235",
      "package_name": "passwd",
      "installed_version": "1:4.8.1-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-13529",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-13529",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-13529",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-13529",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2020-13529",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1376",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability classified as problematic was found in GNU elfutils 0.192. This vulnerability affects the function elf_strptr in the library /libelf/elf_strptr.c of the component eu-strip. The manipulation leads to denial of service. It is possible to launch the attack on the local host. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is b16f441cca0a4841050e3215a9f120a6d8aea918. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-41409",
      "package_name": "libpcre2-8-0",
      "installed_version": "10.36-2+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45922",
      "package_name": "libgl1-mesa-dri",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glx_pbuffer.c in Mesa 23.0.4 was discovered to contain a segmentation violation when calling __glXGetDrawableAttribute(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45922",
      "package_name": "libglapi-mesa",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glx_pbuffer.c in Mesa 23.0.4 was discovered to contain a segmentation violation when calling __glXGetDrawableAttribute(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45922",
      "package_name": "libglx-mesa0",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glx_pbuffer.c in Mesa 23.0.4 was discovered to contain a segmentation violation when calling __glXGetDrawableAttribute(). NOTE: this is disputed because there are no common situations in which users require uninterrupted operation with an attacker-controller server.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-1013",
      "package_name": "libodbc1",
      "installed_version": "2.3.6-0.1+b1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An out-of-bounds stack write flaw was found in unixODBC on 64-bit architectures where the caller has 4 bytes and callee writes 8 bytes. This issue may go unnoticed on little-endian architectures, while big-endian architectures can be broken.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4392",
      "package_name": "libpam-systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4392",
      "package_name": "libsystemd0",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4392",
      "package_name": "libudev1",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4392",
      "package_name": "systemd",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-4392",
      "package_name": "systemd-sysv",
      "installed_version": "247.3-7+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-asn1",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-base",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-crypto",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-diameter",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-edoc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-eldap",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-erl-docgen",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-eunit",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-ftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-inets",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-mnesia",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-nox",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-odbc",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-os-mon",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-parsetools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-public-key",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-reltool",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-runtime-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-snmp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-ssh",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-ssl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-syntax-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-tftp",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-tools",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-wx",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2009-0130",
      "package_name": "erlang-xmerl",
      "installed_version": "1:23.2.6+dfsg-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "lib/crypto/c_src/crypto_drv.c in erlang does not properly check the return value from the OpenSSL DSA_do_verify function, which might allow remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature, a similar vulnerability to CVE-2008-5077.  NOTE: a package maintainer disputes this issue, reporting that there is a proper check within the only code that uses the applicable part of crypto_drv.c, and thus \"this report is invalid.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2017-18018",
      "package_name": "coreutils",
      "installed_version": "8.32-4+b1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX \"-R -L\" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-30775",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in the libtiff library. This security flaw causes a heap buffer overflow in extractContigSamples32bits, tiffcrop.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-60018",
      "package_name": "glib-networking",
      "installed_version": "2.66.0-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glib-networking's OpenSSL backend fails to properly check the return value of a call to BIO_write(), resulting in an out of bounds read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-60018",
      "package_name": "glib-networking-common",
      "installed_version": "2.66.0-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glib-networking's OpenSSL backend fails to properly check the return value of a call to BIO_write(), resulting in an out of bounds read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-60018",
      "package_name": "glib-networking-services",
      "installed_version": "2.66.0-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glib-networking's OpenSSL backend fails to properly check the return value of a call to BIO_write(), resulting in an out of bounds read.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-1210",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability classified as problematic was found in LibTIFF 4.3.0. Affected by this vulnerability is the TIFF File Handler of tiff2ps. Opening a malicious file leads to a denial of service. The attack can be launched remotely but requires user interaction. The exploit has been disclosed to the public and may be used.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-60019",
      "package_name": "glib-networking",
      "installed_version": "2.66.0-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glib-networking's OpenSSL backend fails to properly check the return value of memory allocation routines. An out of memory condition could potentially result in writing to an invalid memory location.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-60019",
      "package_name": "glib-networking-common",
      "installed_version": "2.66.0-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glib-networking's OpenSSL backend fails to properly check the return value of memory allocation routines. An out of memory condition could potentially result in writing to an invalid memory location.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-60019",
      "package_name": "glib-networking-services",
      "installed_version": "2.66.0-2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "glib-networking's OpenSSL backend fails to properly check the return value of memory allocation routines. An out of memory condition could potentially result in writing to an invalid memory location.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1372",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in GNU elfutils 0.192. It has been declared as critical. Affected by this vulnerability is the function dump_data_section/print_string_section of the file readelf.c of the component eu-readelf. The manipulation of the argument z/x leads to buffer overflow. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The identifier of the patch is 73db9d2021cab9e23fd734b0a76a612d52a6f1db. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2013-0340",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1371",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability has been found in GNU elfutils 0.192 and classified as problematic. This vulnerability affects the function handle_dynamic_symtab of the file readelf.c of the component eu-read. The manipulation leads to null pointer dereference. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used. The patch is identified as b38e562a4c907e08171c76b8b2def8464d5a104a. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-27587",
      "package_name": "libssl1.1",
      "installed_version": "1.1.1n-0+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "OpenSSL 3.0.0 through 3.3.2 on the PowerPC architecture is vulnerable to a Minerva attack, exploitable by measuring the time of signing of random messages using the EVP_DigestSign API, and then using the private key to extract the K value (nonce) from the signatures. Next, based on the bit size of the extracted nonce, one can compare the signing time of full-sized nonces to signatures that used smaller nonces, via statistical tests. There is a side-channel in the P-364 curve that allows private key extraction (also, there is a dependency between the bit size of K and the size of the side channel). NOTE: This CVE is disputed because the OpenSSL security policy explicitly notes that any side channels which require same physical system to be detected are outside of the threat model for the software. The timing signal is so small that it is infeasible to be detected without having the attacking process running on the same physical system.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8961",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A weakness has been identified in LibTIFF 4.7.0. This affects the function main of the file tiffcrop.c of the component tiffcrop. Executing manipulation can lead to memory corruption. The attack can only be executed locally. The exploit has been made available to the public and could be exploited.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-1365",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability, which was classified as critical, was found in GNU elfutils 0.192. This affects the function process_symtab of the file readelf.c of the component eu-readelf. The manipulation of the argument D/a leads to buffer overflow. Local access is required to approach this attack. The exploit has been disclosed to the public and may be used. The identifier of the patch is 5e5c0394d82c53e97750fe7b18023e6f84157b81. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8534",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability classified as problematic was found in libtiff 4.6.0. This vulnerability affects the function PS_Lvl2page of the file tools/tiff2ps.c of the component tiff2ps. The manipulation leads to null pointer dereference. It is possible to launch the attack on the local host. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 6ba36f159fd396ad11bf6b7874554197736ecc8b. It is recommended to apply a patch to fix this issue. One of the maintainers explains, that \"[t]his error only occurs if DEFER_STRILE_LOAD (defer-strile-load:BOOL=ON) or TIFFOpen( .. \"rD\") option is used.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-37769",
      "package_name": "libpixman-1-0",
      "installed_version": "0.40.0-1.1~deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "stress-test master commit e4c878 was discovered to contain a FPE vulnerability via the component combine_inner at /pixman-combine-float.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-9165",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw has been found in LibTIFF 4.7.0. This affects the function _TIFFmallocExt/_TIFFCheckRealloc/TIFFHashSetNew/InitCCITTFax3 of the file tools/tiffcmp.c of the component tiffcmp. Executing manipulation can lead to memory leak. The attack is restricted to local execution. This attack is characterized by high complexity. It is indicated that the exploitability is difficult. The exploit has been published and may be used. There is ongoing doubt regarding the real existence of this vulnerability. This patch is called ed141286a37f6e5ddafb5069347ff5d587e7a4e0. It is best practice to apply a patch to resolve this issue. A researcher disputes the security impact of this issue, because \"this is a memory leak on a command line tool that is about to exit anyway\". In the reply the project maintainer declares this issue as \"a simple 'bug' when leaving the command line tool and (...) not a security issue at all\".",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8851",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was determined in LibTIFF up to 4.5.1. Affected by this issue is the function readSeparateStripsetoBuffer of the file tools/tiffcrop.c of the component tiffcrop. The manipulation leads to stack-based buffer overflow. Local access is required to approach this attack. The patch is identified as 8a7a48d7a645992ca83062b3a1873c951661e2b3. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-1916",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in tiffcrop, a program distributed by the libtiff package. A specially crafted tiff file can lead to an out-of-bounds read in the extractImageSection function in tools/tiffcrop.c, resulting in a denial of service and limited information disclosure. This issue affects libtiff versions 4.x.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2021-33294",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In elfutils 0.183, an infinite loop was found in the function handle_symtab in readelf.c .Which allows attackers to cause a denial of service (infinite loop) via crafted file.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "bsdutils",
      "installed_version": "1:2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "libblkid1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "libmount1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "libsmartcols1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "libuuid1",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "mount",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-0563",
      "package_name": "util-linux",
      "installed_version": "2.36.1-8+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-29088",
      "package_name": "libsqlite3-0",
      "installed_version": "3.34.1-3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "In SQLite 3.49.0 before 3.49.1, certain argument values to sqlite3_db_config (in the C-language API) can cause a denial of service (application crash). An sz*nBig multiplication is not cast to a 64-bit integer, and consequently some memory allocations may be incorrect.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-52426",
      "package_name": "libexpat1",
      "installed_version": "2.2.10-2+deb11u5",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8176",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in LibTIFF up to 4.7.0. It has been declared as critical. This vulnerability affects the function get_histogram of the file tools/tiffmedian.c. The manipulation leads to use after free. The attack needs to be approached locally. The exploit has been disclosed to the public and may be used. The patch is identified as fe10872e53efba9cc36c66ac4ab3b41a839d5172. It is recommended to apply a patch to fix this issue.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8177",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in LibTIFF up to 4.7.0. It has been rated as critical. This issue affects the function setrow of the file tools/thumbnail.c. The manipulation leads to buffer overflow. An attack has to be approached locally. The patch is named e8c9d6c616b19438695fd829e58ae4fde5bfbc22. It is recommended to apply a patch to fix this issue. This vulnerability only affects products that are no longer supported by the maintainer.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45913",
      "package_name": "libgl1-mesa-dri",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa v23.0.4 was discovered to contain a NULL pointer dereference via the function dri2GetGlxDrawableFromXDrawableId(). This vulnerability is triggered when the X11 server sends an DRI2_BufferSwapComplete event unexpectedly when the application is using DRI3. NOTE: this is disputed because there is no scenario in which the vulnerability was demonstrated.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45913",
      "package_name": "libglapi-mesa",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa v23.0.4 was discovered to contain a NULL pointer dereference via the function dri2GetGlxDrawableFromXDrawableId(). This vulnerability is triggered when the X11 server sends an DRI2_BufferSwapComplete event unexpectedly when the application is using DRI3. NOTE: this is disputed because there is no scenario in which the vulnerability was demonstrated.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-45913",
      "package_name": "libglx-mesa0",
      "installed_version": "20.3.5-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "Mesa v23.0.4 was discovered to contain a NULL pointer dereference via the function dri2GetGlxDrawableFromXDrawableId(). This vulnerability is triggered when the X11 server sends an DRI2_BufferSwapComplete event unexpectedly when the application is using DRI3. NOTE: this is disputed because there is no scenario in which the vulnerability was demonstrated.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-6228",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "An issue was found in the tiffcp utility distributed by the libtiff package where a crafted TIFF file on processing may cause a heap-based buffer overflow leads to an application crash.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2024-25260",
      "package_name": "libelf1",
      "installed_version": "0.183-1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "elfutils v0.189 was discovered to contain a NULL pointer dereference via the handle_verdef() function at readelf.c.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2022-3219",
      "package_name": "gpgv",
      "installed_version": "2.2.27-2+deb11u2",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-5278",
      "package_name": "coreutils",
      "installed_version": "8.32-4+b1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A flaw was found in GNU Coreutils. The sort utility's begfield() function is vulnerable to a heap buffer under-read. The program may access memory outside the allocated buffer if a user runs a crafted command using the traditional key format. A malicious input could lead to a crash or leak sensitive data.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2023-3164",
      "package_name": "libtiff5",
      "installed_version": "4.2.0-1+deb11u1",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A heap-buffer-overflow vulnerability was found in LibTIFF, in extractImageSection() at tools/tiffcrop.c:7916 and tools/tiffcrop.c:7801. This flaw allows attackers to cause a denial of service via a crafted tiff file.",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-8732",
      "package_name": "libxml2",
      "installed_version": "2.9.10+dfsg-6.7+deb11u3",
      "fixed_version": "No fix available",
      "severity": "NEGLIGIBLE",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "A vulnerability was found in libxml2 up to 2.14.5. It has been declared as problematic. This vulnerability affects the function xmlParseSGMLCatalog of the component xmlcatalog. The manipulation leads to uncontrolled recursion. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used. The real existence of this vulnerability is still doubted at the moment. The code maintainer explains, that \"[t]he issue can only be triggered with untrusted SGML catalogs and it makes absolutely no sense to use untrusted catalogs. I also doubt that anyone is still using SGML catalogs at all.\"",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-24528",
      "package_name": "libgssapi-krb5-2",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u6",
      "severity": "UNKNOWN",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-24528",
      "package_name": "libk5crypto3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u6",
      "severity": "UNKNOWN",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-24528",
      "package_name": "libkrb5-3",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u6",
      "severity": "UNKNOWN",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "",
      "detected_by": [
        "grype"
      ]
    },
    {
      "cve_id": "CVE-2025-24528",
      "package_name": "libkrb5support0",
      "installed_version": "1.18.3-6+deb11u2",
      "fixed_version": "1.18.3-6+deb11u6",
      "severity": "UNKNOWN",
      "image": "vulhub/couchdb:3.2.1",
      "scanner": "grype",
      "title": "",
      "description": "",
      "detected_by": [
        "grype"
      ]
    }
  ]
}